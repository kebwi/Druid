#ifndef __B_SPLINE__#define __B_SPLINE__#include "FloatPoint.h"#include "MainWindow.h"#include "Colors.h"#include "Subboundaries.h"#include <vector.h>#include <utility.h>	//for pair#include <sstream>using namespace::std;class GenericIntersection;class BspBspIntersection;class Drawing;class BSplineToBSplineCut;class BSpline{	public:		static int sNumSegmentsPerCurve;		static bool sShadeWithArrows;	//If false, then shade with hashes		static int sShadeSize;		static double sArrowHeadAngle;		static int sBoundarySectionBspSpacing;				BSpline(Drawing* theDrawing);		BSpline(BSpline& bsp, Drawing* theDrawing, bool basicCopyOnly = false);		~BSpline();				void AddIntersection(int curve, int curveSegment, GenericIntersection* intersection, bool equalizeSections = true);		void RemoveIntersection(int curve, GenericIntersection* intersection, bool equalizeSections = true, int deleteDir = 0);		void MoveIntersection(GenericIntersection* intersection, int oldCurve, int oldSeg, int newCurve, int newSeg, int whichHalf);		bool MakeIntersectionList();		void CheckSegmentIntersectionOrder(GenericIntersection* intersection);				int GetBSplineIndex();		vector<FloatPoint> GetControlPoints();		FloatPoint GetControlPointPosition(int controlPointIndex);		int FindControlPoint(FloatPoint point);		int FindControlBoundarySegment(FloatPoint point);		int FindCurveSegment(FloatPoint point);		int GetNumControlPoints();		int GetNumIntersections();		int GetDegree();		int GetWindingNumber();		SurfaceTraits GetSurfaceTraits();		vector<GenericIntersection*> GetIntersections();		GenericIntersection* GetIntersectionFromIndex(int interIndex);		GenericIntersection* GetFirstIntersection();		GenericIntersection* GetFirstBspBspIntersection();		vector<vector<FloatPoint>*>* GetCurvePoints();		vector<vector<FloatPoint>*>* GetPrevCurvePoints();	//еее DEBUG		FloatPoint GetCurvePoint(int curve, int segment);		vector<bool> GetCurvesToRecalc();	//еее DEBUG		vector<bool> GetCurvesToReintersect();		int GetArbitraryCurvePointDepth(int curve, int segment, FloatPoint interLoc);		int GetArbitraryCurveSegCenterDepth(int curve, int segment);		int GetSectionDepthBeforeIntersection(GenericIntersection* intersection, int curve, int seg);		int GetSectionDepthAfterIntersection(GenericIntersection* intersection, int curve, int seg);		int GetMaxPossibleSectionDepthBeforeIntersection(GenericIntersection* intersection, int curve, int seg);		int GetMaxPossibleSectionDepthAfterIntersection(GenericIntersection* intersection, int curve, int seg);		int GetShallowestMaxPossibleSection();		int GetDeepestMaxPossibleSection();		int GetMaxPossibleSectionDepth(int section);		vector<int>* GetSectionDepths();		void GetSectionPoints(GenericIntersection* startInter, GenericIntersection* endInter, bool traverseFromTop, bool traverseToTop, bool stopAtFirstOccurrence,									int traverseDir, vector<FloatPoint>& intermediatePoints);		int GetSectionDepth(GenericIntersection* startInter, GenericIntersection* endInter, bool traverseFromTop, int traverseDir);		int FindSubboundaryForSection(UnorientedBoundarySection ubs);		void FindIntersectionsForSubboundary(int subboundary, GenericIntersection*& startInter, GenericIntersection*& endInter);		int GetMinIntersectionGap();		bool GetSectionDepthConstraintBeforeIntersection(GenericIntersection* intersection, int curve, int seg);		bool GetSectionDepthConstraintAfterIntersection(GenericIntersection* intersection, int curve, int seg);		int GetIntersectionIndex(GenericIntersection* intersection, bool takeFirstFound = true);		bool GetIfIntersectsBSpline(BSpline* bsp);		bool GetAllSectionsConstrained();		bool GetAllIntersectionsLegal(bool assertIt = false);		GenericIntersection* FindPrevIntersection(GenericIntersection* intersection, int curve, int segment);		GenericIntersection* FindNextIntersection(GenericIntersection* intersection, int curve, int segment);				FloatPoint FindCenter();		void FlipHorizontal(FloatPoint selectionCenter);		void FlipVertical(FloatPoint selectionCenter);		void Rotate90CW(FloatPoint selectionCenter);		void Rotate90CCW(FloatPoint selectionCenter);		void Rotate180(FloatPoint selectionCenter);		void RotateNumeric(double rotation, FloatPoint center);		void RotateFree();		void ScaleNumeric(double scaleAmount);		void ScaleFree();				void ConstrainMoveWithinCanvas(Point& delta, Point canvasSize);				void SetSurfaceTraits(SurfaceTraits st);		int AddControlPoint(FloatPoint newPoint);		void SplitControlBoundarySegment(int controlBoundarySegment, FloatPoint newPoint);		bool ChangeControlPoint(int controlPointIndex, FloatPoint newPoint, bool changeAllPoints, Point canvasSize);		void RemoveControlPoint(int controlPointIndex, bool removeAllPoints);		void PushPullBSpline(int depthChange);		void WrapSectionDepths(bool forward);		void SetSectionDepthBeforeIntersection(GenericIntersection* intersection, int curve, int seg, int depth);		void SetSectionDepthAfterIntersection(GenericIntersection* intersection, int curve, int seg, int depth);		void InitSectionMaxPossibleDepths();		void PickShallowestAndDeepestMaxPossibleSection();		bool IncrementMaxPossibleSectionDepthBeforeIntersection(GenericIntersection* intersection, int curve, int seg, int depth);		bool IncrementMaxPossibleSectionDepthAfterIntersection(GenericIntersection* intersection, int curve, int seg, int depth);		void PushDoublyInwardBoundSectionsDownOne();		bool IncrementMaxPossibleSectionDepthBeforeIntersectionV2(GenericIntersection* intersection, int curve, int seg, int depth, BSpline* stopCross);		bool IncrementMaxPossibleSectionDepthAfterIntersectionV2(GenericIntersection* intersection, int curve, int seg, int depth, BSpline* stopCross);		void InitSectionsIncrementedAlready();		void SetSectionIncrementedAlreadyBeforeIntersection(GenericIntersection* intersection, int curve, int seg);		void SetSectionIncrementedAlreadyAfterIntersection(GenericIntersection* intersection, int curve, int seg);		void IncrementMaxPossibleSectionDepthBeforeIntersectionV3(int recursionDepth /*DEBUG*/, GenericIntersection* intersection, int curve, int seg, BSpline* stopCross);		void IncrementMaxPossibleSectionDepthAfterIntersectionV3(int recursionDepth /*DEBUG*/, GenericIntersection* intersection, int curve, int seg, BSpline* stopCross);		void HalveSectionMaxPossibleDepths();		void MakeAllDepthsZero();		bool EqualizeNumberOfSections();		void VerifyNumSectionsMatchesNumInters();		void VerifyTotalIntersMatchesCurveInters();		void SetSectionDepthConstraintBeforeIntersection(GenericIntersection* intersection, int curve, int seg, bool value);		void SetSectionDepthConstraintAfterIntersection(GenericIntersection* intersection, int curve, int seg, bool value);		void SetAllSectionsNoHardConstraint();				void CalculateWindingNumber();				void VerifyBackupsMatchPresent();		void VerifyNothingDtored();		void BackupCurvePoints();		void RecalcBSpline();		void CleanUpIntersections(vector<BSpline*> bsplines, vector<BSplineToBSplineCut*> cuts);		bool ProjectIntersections(vector<GenericIntersection*>& alreadyProjectedInters, vector<BSpline*>& bsplineIntersDeleted, vector<BSplineToBSplineCut*>& cutIntersDeleted, bool dontProjectSelfInters, bool dontProjectAnyInters = false);		bool FindAndAddNewIntersections(vector<BSpline*> bsplines, vector<BSplineToBSplineCut*> cuts, vector<BSpline*> groupBSplines, bool forceToTop, bool cmdKey);				void DrawBSpline(MainWindow::ViewMode viewMode, Point scrollOffset, bool selected, bool hilighted, bool showDepths, bool exportingPict, bool debug = false);		void OutlineDepthZeroSections(Point scrollOffset);		void DrawControlPointBoundary(Point scrollOffset, bool selected, bool hilighted, bool debug = false);		void DrawPostscriptBSpline(short fRefNum, MainWindow::ViewMode viewMode, Point canvasSize, bool showDepths);		void OutlinePostscriptDepthZeroSections(short fRefNum, Point canvasSize);				void DumpFileData(short fRefNum);		void LoadFileData(istringstream& iss, double fileVersion);				void ChangeDegree(bool decrease);		void SetDegree(int newDegree);		void SetAllCurvesToRecalc();		void SetAllCurvesToNotRecalc();		void SetAllCurvesToReintersect();		void SetAllCurvesToNotReintersect();		void ReallocateCurvePoints();				void ReverseControlPointOrder();				bool VerifyLegalLabeling();				bool dtored;	//DEBUG only		private:		BSpline();	//Declare away				void Destroy();				void GetIntersectionSeg(GenericIntersection* intersection, int curve, int& seg);		void GetIntersectionCurveAndSeg(vector<GenericIntersection*>& intersectionsVisitedAlready, GenericIntersection* intersection, int& crv, int& seg);				bool IntersectionIsFirstOccurance(GenericIntersection* intersection, int curve, int seg);		int GetSectionBeforeIntersection(GenericIntersection* intersection, int curve, int seg);		int GetSectionAfterIntersection(GenericIntersection* intersection, int curve, int seg);				void CalcBSplinePoint(double& d, int cp, int numControlPoints, FloatPoint& fp);				void ProjectBspBspIntersection(GenericIntersection* intersection, vector<GenericIntersection*>& intersAlreadyProjected,										vector<BSpline*>& otherBSplines, vector<GenericIntersection*>& deleteIntersections,										vector<pair<GenericIntersection*, double> >& distIntersMoved);		bool GetIntersectionSegmentPoints(GenericIntersection* intersection, vector<vector<FloatPoint>*>& otherBSplineCurvePoints, vector<vector<FloatPoint>*>& otherBSplinePrevCurvePoints,											int& seg1, int& seg2, int& seg1old, int& seg2old,											FloatPoint& pA1post, FloatPoint& pA2post, FloatPoint& pA1pre, FloatPoint& pA2pre,											FloatPoint& pB1post, FloatPoint& pB2post, FloatPoint& pB1pre, FloatPoint& pB2pre);		bool DetermineSearchDirections(GenericIntersection* intersection, FloatPoint newLoc,										FloatPoint pA1pre, FloatPoint pA2pre, FloatPoint pB1pre, FloatPoint pB2pre,										FloatPoint pA1post, FloatPoint pA2post, FloatPoint pB1post, FloatPoint pB2post,										double lineSegInter1pre, double lineSegInter2pre,										int& movSearchDir, int& statSearchDir);		int SwitchMovingSegments(GenericIntersection* intersection, double lineSegInter1post,									int cv1bk, int sg1bk, int cv2bk, int sg2bk,									FloatPoint& pA1pre, FloatPoint& pA2pre, FloatPoint& pA1post, FloatPoint& pA2post,									int& seg1, int seg2, bool& noIntersectionFound, int& curveEndWrap1);		int SwitchStationarySegments(GenericIntersection* intersection, BSpline* otherBSpline, vector<vector<FloatPoint>*>* otherBSplineCurvePoints, double lineSegInter2post,									int cv1bk, int sg1bk, int cv2bk, int sg2bk,									FloatPoint& pB1pre, FloatPoint& pB2pre, FloatPoint& pB1post, FloatPoint& pB2post,									int seg1, int& seg2, bool& noIntersectionFound, int& curveEndWrap2);		void ChangeCurves(GenericIntersection* intersection, BSpline* otherBSpline,							int seg1, int seg2, int seg1old, int seg2old,							int curveEndWrap1, int curveEndWrap2);				void ProjectBspCutIntersection(GenericIntersection* intersection, vector<GenericIntersection*>& deleteIntersections,										vector<pair<GenericIntersection*, double> >& distIntersMoved);		void GetIntersectionSegmentPoints(GenericIntersection* intersection, int& seg, int& segOld,										FloatPoint& pA1post, FloatPoint& pA2post, FloatPoint& pA1pre, FloatPoint& pA2pre);		bool DetermineSearchDirection(GenericIntersection* intersection, FloatPoint newLoc,										FloatPoint pA1pre, FloatPoint pA2pre, FloatPoint pA1post, FloatPoint pA2post,										FloatPoint startLocPre, FloatPoint endLocPre, FloatPoint startLocPost, FloatPoint endLocPost,										double lineSegInter1pre, double lineSegInter2pre,										int& movSearchDir);		int SwitchMovingSegments(GenericIntersection* intersection, double lineSegInter1post,									int cv1bk, int sg1bk, int cv2bk, int sg2bk,									FloatPoint& pA1pre, FloatPoint& pA2pre, FloatPoint& pA1post, FloatPoint& pA2post,									int& seg, bool& noIntersectionFound, int& curveEndWrap);		void ChangeCurves(GenericIntersection* intersection,							int seg, int segOld,							int curveEndWrap);				void ProjectBspCutTIntersection(GenericIntersection* intersection);				void DestroyOldIntersections();		void FindNewIntersections(BSpline* bsp);		void FindNewIntersections(BSplineToBSplineCut* cut);				void DrawInterpolatedCurves(Point scrollOffset, MainWindow::ViewMode viewMode, bool showDepths, bool debug = false);		void DrawPostscriptInterpolatedCurves(short fRefNum, MainWindow::ViewMode viewMode, Point canvasSize, bool showDepths);		void DrawCurvesSplineMode(Point scrollOffset);		vector<vector<FloatPoint>*> GenerateSectionSegEndPoints();		void DrawCurvesKnotMode(Point scrollOffset, bool showDepths, bool drawOccludedSections = true, bool shadeSignOfOcclusion = true, bool debug = false);		void DrawSignOfOcclusionArrow(int curveIndex, Point scrollOffset);		void DrawPostscriptCurvesKnotMode(short fRefNum, Point canvasSize, bool showDepths, bool drawOccludedSections = true, bool shadeSignOfOcclusion = true);		void DrawPostscriptSignOfOcclusionArrow(short fRefNum, Point canvasSize, int curveIndex);				Drawing* drawing;				int degree;		int windingNumber;		SurfaceTraits surfaceTraits;				vector<FloatPoint> controlPoints;		vector<vector<FloatPoint>*> curvePoints;		vector<vector<GenericIntersection*>*> curveIntersections;		vector<GenericIntersection*> allIntersections;		vector<bool> intersectionCurveSegments;		vector<bool> curvesToRecalc;		vector<bool> curvesToReintersect;		vector<int> sectionDepths;		vector<int> maxPossibleSectionDepths;		vector<bool> sectionDepthConstraints;		int shallowestMaxPossibleSection, deepestMaxPossibleSection;				vector<vector<FloatPoint>*> prevCurvePoints;				//vector<vector<BSpline*>*> sectionsIncrementedAlready;};#endif