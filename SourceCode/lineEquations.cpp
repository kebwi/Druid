#include "FloatPoint.h"#include "trigConstants.h"#include <math.h>#include <algorithm.h>//******************************************************************************//Function Prototypes	//	In this filebool LineSegmentIntersection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2, FloatPoint &intersection);	//	In external files		//	main.cppvoid MyAssert(bool condition);#pragma mark -double LineSegmentLength(FloatPoint p1, FloatPoint p2){	return sqrt((p1.h - p2.h) * (p1.h - p2.h) + (p1.v - p2.v) * (p1.v - p2.v));}//Angle is from p1 to p2, as if p1 is at the center of a circle, in the range 0 to 2Pidouble LineSegmentAngle(FloatPoint p1, FloatPoint p2){	double sinAngle = (p2.v - p1.v) / LineSegmentLength(p1, p2);	double aSinAngle = asin(sinAngle);	double angle;	if (p2.v > p1.v)	{		if (p2.h < p1.h)			angle = Pi - aSinAngle;		else angle = aSinAngle;	}	else	{		if (p2.h < p1.h)			angle = Pi - aSinAngle;		else angle = PiTimes2 + aSinAngle;	}		return angle;}FloatPoint ProjectPointAtAngle(FloatPoint origin, double angle, double segLength){	FloatPoint newPos;	newPos.h = cos(angle) * segLength + origin.h;	newPos.v = sin(angle) * segLength + origin.v;		return newPos;}bool PointLineSegmentDistance(FloatPoint point, FloatPoint p1, FloatPoint p2, double &pointLineDist){    double segmentLength;    double u;    FloatPoint intersection;     segmentLength = LineSegmentLength(p1, p2);     u = (((point.h - p1.h) * (p2.h - p1.h)) +        ((point.v - p1.v) * (p2.v - p1.v))) /        	(segmentLength * segmentLength);     intersection.h = p1.h + u * (p2.h - p1.h);    intersection.v = p1.v + u * (p2.v - p1.v);     pointLineDist = LineSegmentLength(point, intersection);     if (u < 0.0 || u > 1.0)        return false;   // closest point on the line does not fall within the line segment     return true;}//One line with a direction crosses another line with a direction.//If the second line is directed left at the intersection, return 1.//If the second line is directed right at the intersection, return -1.//These values (1 for left, -1 for right), correspond to the resulting depth change that occurs on the first line as it crosses//the second line if the first line is below the second line and therefore is occluded either before or after the second line.int LineCrossLineDirection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2){	//Calculate the angle of the first line in its direction	double lineAangle = LineSegmentAngle(pA1, pA2);		//Determine the direction of the crossed edge by checking whether the angle to the start of the crossed edge is less or greater than the first line's direction angle	double lineAStartToLineBStartAngle = LineSegmentAngle(pA1, pB1) - lineAangle;	if (lineAStartToLineBStartAngle > Pi)		lineAStartToLineBStartAngle -= PiTimes2;	else if (lineAStartToLineBStartAngle < -Pi)		lineAStartToLineBStartAngle += PiTimes2;		//Only necessary for the test below	double lineAStartToLineBEndAngle = LineSegmentAngle(pA1, pB2) - lineAangle;	if (lineAStartToLineBEndAngle > Pi)		lineAStartToLineBEndAngle -= PiTimes2;	else if (lineAStartToLineBEndAngle < -Pi)		lineAStartToLineBEndAngle += PiTimes2;		//I believe this only occurs if the two line segments don't cross each other at all.	//Since the segments are of finite length, this does not necessarily imply parallel lines.	//Note that this function finds a line perfectly tangent to the endpoint of the crossing line as a noncross,	//but the other function, LineSegmentIntersection, considers such a situation a cross.	//Thus, the assertion in the following if block can fail.	if ((lineAStartToLineBStartAngle <= 0 && lineAStartToLineBEndAngle <= 0) ||		(lineAStartToLineBStartAngle >= 0 && lineAStartToLineBEndAngle >= 0))	{		FloatPoint intersectionLoc;		//MyAssert(!LineSegmentIntersection(pA1, pA2, pB1, pB2, intersectionLoc));		return 0;	}		//	1 for left, -1 for right	//These values perfectly reflect the delta depth that occurs while traversing the first line segment across the intersection	//in the direction specified if the first line segment is below the second line segment at this intersection	return ((lineAStartToLineBStartAngle < 0) ? -1 : 1);}bool LineSegmentIntersection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2, FloatPoint &intersection){	//http://www.delphiforfun.org/Programs/Math_Topics/intersecting_lines.htm	//http://www.cc.gatech.edu/gvu/multimedia/nsfmmedia/graphics/elabor/math/mathfaq_lines.html#Method:Intersecting%20Lines	/*	ForeColor(blueColor);	MoveTo(pA1.h, pA1.v);	LineTo(pA2.h, pA2.v);		//QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		ForeColor(greenColor);	MoveTo(pB1.h, pB1.v);	LineTo(pB2.h, pB2.v);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	*/	double mA, mB, bA, bB;		if (pA1.h == pA2.h && pB1.h == pB2.h) //Parallel vertical lines		return false;		if (pA1.h != pA2.h)	//If first line isn't vertical, calc slope and y-intercept	{		mA = (pA1.v - pA2.v) / (pA1.h - pA2.h);		bA = pA1.v - mA * pA1.h;	}		if (pB1.h != pB2.h)	//If second line isn't vertical, calc slope and y-intercept	{		mB = (pB1.v - pB2.v) / (pB1.h - pB2.h);		bB = pB1.v - mB * pB1.h;	}		if (pA1.h != pA2.h && pB1.h != pB2.h && mA == mB)	//Parallel lines		return false;		double intersectionX, intersectionY;		//No need to check for mA == mB, since it was checked in an earlier test	if (pA1.h != pA2.h && pB1.h != pB2.h)	//Neither line is vertical	{		intersectionX = (bB - bA) / (mA - mB);		intersectionY = mA * intersectionX + bA;	}	else if (pA1.h == pA2.h)	//First line is vertical (second line can't be due to earlier test)	{		intersectionX = pA1.h;		intersectionY = mB * intersectionX + bB;//intersectionY = mB * pB1.h + bB;	}	else if (pB1.h == pB2.h)	//Second line is vertical (first line can't be due to earlier test)	{		intersectionX = pB1.h;		intersectionY = mA * intersectionX + bA;//intersectionY = mA * pA1.h + bA;	}	/*	ForeColor(redColor);	Rect r;	SetRect(&r, (int)intersectionX - 2, (int)intersectionY - 2, (int)intersectionX + 2, (int)intersectionY + 2);	PaintOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	*/	intersection.h = intersectionX;	intersection.v = intersectionY;		double lineSegInter1, lineSegInter2;		if (pA2.h - pA1.h != 0)		lineSegInter1 = (intersectionX - pA1.h) / (pA2.h - pA1.h);	else lineSegInter1 = (intersectionY - pA1.v) / (pA2.v - pA1.v);		if (pB2.h - pB1.h != 0)		lineSegInter2 = (intersectionX - pB1.h) / (pB2.h - pB1.h);	else lineSegInter2 = (intersectionY - pB1.v) / (pB2.v - pB1.v);		if (lineSegInter1 >= 0.0 && lineSegInter1 <= 1.0 && lineSegInter2 >= 0.0 && lineSegInter2 <= 1.0)		return true;	return false;}bool LineSegmentIntersection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2,							FloatPoint &intersection, double& lineSegInter1, double& lineSegInter2){	double mA, mB, bA, bB;		if (pA1.h == pA2.h && pB1.h == pB2.h) //Parallel vertical lines		return false;		if (pA1.h != pA2.h)	//If first line isn't vertical, calc slope and y-intercept	{		mA = (pA1.v - pA2.v) / (pA1.h - pA2.h);		bA = pA1.v - mA * pA1.h;	}		if (pB1.h != pB2.h)	//If second line isn't vertical, calc slope and y-intercept	{		mB = (pB1.v - pB2.v) / (pB1.h - pB2.h);		bB = pB1.v - mB * pB1.h;	}		if (pA1.h != pA2.h && pB1.h != pB2.h && mA == mB)	//Parallel lines		return false;		double intersectionX, intersectionY;		//No need to check for mA == mB, since it was checked in an earlier test	if (pA1.h != pA2.h && pB1.h != pB2.h)	//Neither line is vertical	{		intersectionX = (bB - bA) / (mA - mB);		intersectionY = mA * intersectionX + bA;	}	else if (pA1.h == pA2.h)	//First line is vertical (second line can't be due to earlier test)	{		intersectionX = pA1.h;		intersectionY = mB * intersectionX + bB;//intersectionY = mB * pB1.h + bB;	}	else if (pB1.h == pB2.h)	//Second line is vertical (first line can't be due to earlier test)	{		intersectionX = pB1.h;		intersectionY = mA * intersectionX + bA;//intersectionY = mA * pA1.h + bA;	}		intersection.h = intersectionX;	intersection.v = intersectionY;		if (pA2.h - pA1.h != 0)		lineSegInter1 = (intersectionX - pA1.h) / (pA2.h - pA1.h);	else lineSegInter1 = (intersectionY - pA1.v) / (pA2.v - pA1.v);		if (pB2.h - pB1.h != 0)		lineSegInter2 = (intersectionX - pB1.h) / (pB2.h - pB1.h);	else lineSegInter2 = (intersectionY - pB1.v) / (pB2.v - pB1.v);		if (lineSegInter1 >= 0.0 && lineSegInter1 <= 1.0 && lineSegInter2 >= 0.0 && lineSegInter2 <= 1.0)		return true;	return false;}//The first line segment must be horizontalbool HorizontalLineSegmentIntersection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2,							FloatPoint &intersection, double& lineSegInter1, double& lineSegInter2){	MyAssert(pA1.v == pA2.v);		if (pB1.v > pA1.v && pB2.v > pA1.v)		return false;		if (pB1.v < pA1.v && pB2.v < pA1.v)		return false;		return LineSegmentIntersection(pA1, pA2, pB1, pB2, intersection, lineSegInter1, lineSegInter2);}