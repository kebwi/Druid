#include "BspCutIntersection.h"#include "BSpline.h"#include "BSplineToBSplineCut.h"#include "Drawing.h"#include "trigConstants.h"#include <math.h>#include <vector.h>#include <algorithm.h>#include <string>#include <sstream>using namespace::std;//******************************************************************************//Extern Globals//******************************************************************************//Global Declarationsint gB = 0;//******************************************************************************//Function Prototypes	//	In this file	//	In external files		//	main.cppvoid MyAssert(bool condition);		//lineEquations.cppdouble LineSegmentAngle(FloatPoint p1, FloatPoint p2);#pragma mark -BspCutIntersection::BspCutIntersection(Drawing* theDrawing) : GenericIntersection(GenericIntersection::BSP_CUT, theDrawing),	bsp(NULL), cut(NULL), bspIndex(-1), cutIndex(-1),	cv(-1), seg(-1), bspOnTop(true), edgeDirection(1),	cutIsSlice(false){}BspCutIntersection::BspCutIntersection(Drawing* theDrawing, FloatPoint locInit, BSpline *initBsp, BSplineToBSplineCut *initCut,										int initBspIndex, int initCutIndex, int initCv, int initSg, bool initBspOnTop, int initEdgeDirection,										bool initCutIsSlice) :	GenericIntersection(GenericIntersection::BSP_CUT, theDrawing, locInit),	bsp(initBsp), cut(initCut), bspIndex(initBspIndex), cutIndex(initCutIndex),	cv(initCv), seg(initSg), bspOnTop(initBspOnTop), edgeDirection(initEdgeDirection),	cutIsSlice(initCutIsSlice){	MyAssert(!dtored);	if (!cutIsSlice)	{		MyAssert(bsp);		MyAssert(cut);	}}BspCutIntersection::BspCutIntersection(BspCutIntersection& intersection, Drawing* d, BSpline *initBsp, BSplineToBSplineCut *initCut) :	GenericIntersection(intersection, d){	bspIndex = intersection.bspIndex;	cutIndex = intersection.cutIndex;	cv = intersection.cv;	seg = intersection.seg;	bspOnTop = intersection.bspOnTop;	edgeDirection = intersection.edgeDirection;	cutIsSlice = intersection.cutIsSlice;		bsp = initBsp;	cut = initCut;		MyAssert(bsp);	MyAssert(!dtored);}BspCutIntersection::~BspCutIntersection(){	gB++;	MyAssert(!dtored);		if (!cutIsSlice)	{		if (bsp)			bsp->RemoveIntersection(cv, (GenericIntersection*)this);		MyAssert(!dtored);				if (cut)			cut->RemoveIntersection((GenericIntersection*)this, true, false);		MyAssert(!dtored);	}		//dtored will be set true in the GenericIntersection dtor}BSpline* BspCutIntersection::GetBsp(){	MyAssert(!dtored);	return bsp;}BSplineToBSplineCut* BspCutIntersection::GetCut(){	MyAssert(!dtored && !cutIsSlice);	return cut;}int BspCutIntersection::GetBspIndex(){	MyAssert(!dtored);	MyAssert(bsp && !cutIsSlice);	return bspIndex;}int BspCutIntersection::GetCutIndex(){	MyAssert(!dtored);	MyAssert(cut && !cutIsSlice);	return cutIndex;}int BspCutIntersection::GetCv(){	MyAssert(!dtored);	return cv;}int BspCutIntersection::GetSg(){	MyAssert(!dtored);	return seg;}bool BspCutIntersection::GetBspOnTop(){	MyAssert(!dtored);	return bspOnTop;}int BspCutIntersection::GetEdgeDirection(){	MyAssert(!dtored);	return edgeDirection;}bool BspCutIntersection::GetCutIsSlice()	//DEBUG only{	MyAssert(!dtored);	return cutIsSlice;}bool BspCutIntersection::SelfIntersection(){	MyAssert(!dtored);	return false;}#pragma mark -void BspCutIntersection::FlipTopBottom(){	MyAssert(!dtored);		bspOnTop = !bspOnTop;}//-1:none, 1:cut_end1, 2:cut_end2int BspCutIntersection::DetermineOccludedEdge(){	MyAssert(!dtored && !cutIsSlice);		if (!bspOnTop)		return -1;		return DetermineOccludedEdgeIgnoreTopBottom();}int BspCutIntersection::DetermineOccludedEdgeIgnoreTopBottom(){	MyAssert(!dtored && !cutIsSlice);		//Get the endpoints of the segments	FloatPoint segEnd1 = bsp->GetCurvePoint(cv, seg);	FloatPoint segEnd2 = bsp->GetCurvePoint(cv, seg + 1);	FloatPoint cutEnd1 = cut->GetStart();	FloatPoint cutEnd2 = cut->GetEnd();		//Get the angle of the endpoints from the intersection	double segEnd1angle = LineSegmentAngle(location, segEnd1);	double segEnd2angle = LineSegmentAngle(location, segEnd2);	double cutEnd1angle = LineSegmentAngle(location, cutEnd1);	double cutEnd2angle = LineSegmentAngle(location, cutEnd2);		//It's possible an endpoint might be practically on top of the intersection	MyAssert(segEnd1 != location || segEnd2 != location);	MyAssert(cutEnd1 != location || cutEnd2 != location);	if (segEnd1 == location)	{		segEnd1angle = segEnd2angle + Pi;		if (segEnd1angle >= PiTimes2)			segEnd1angle -= PiTimes2;	}	else if (segEnd2 == location)	{		segEnd2angle = segEnd1angle + Pi;		if (segEnd2angle >= PiTimes2)			segEnd2angle -= PiTimes2;	}	if (cutEnd1 == location)	{		cutEnd1angle = cutEnd2angle + Pi;		if (cutEnd1angle >= PiTimes2)			cutEnd1angle -= PiTimes2;	}	else if (cutEnd2 == location)	{		cutEnd2angle = cutEnd1angle + Pi;		if (cutEnd2angle >= PiTimes2)			cutEnd2angle -= PiTimes2;	}		//Sanity check.  The corresponding angles should differ by Pi.	double angleDiff = fabs(segEnd1angle - segEnd2angle);	double piMinusAngleDiff = Pi - angleDiff;	MyAssert(fabs(Pi - angleDiff) < .1);		angleDiff = fabs(cutEnd1angle - cutEnd2angle);	piMinusAngleDiff = Pi - angleDiff;	MyAssert(fabs(Pi - angleDiff) < .1);		//Sanity check.  The angles for the two segments should alternate when ordered,	//meaning that when sorted, the angles should go seg1, seg2, seg1, seg2, or seg2, seg1, seg2, seg1	vector<double> angles;	angles.push_back(segEnd1angle);	angles.push_back(segEnd2angle);	angles.push_back(cutEnd1angle);	angles.push_back(cutEnd2angle);	sort(angles.begin(), angles.end());		bool anglesAreSane = false;	if (angles[0] == segEnd1angle && angles[2] == segEnd2angle)		anglesAreSane = true;	if (angles[0] == segEnd2angle && angles[2] == segEnd1angle)		anglesAreSane = true;	if (angles[0] == cutEnd1angle && angles[2] == cutEnd2angle)		anglesAreSane = true;	if (angles[0] == cutEnd2angle && angles[2] == cutEnd1angle)		anglesAreSane = true;	MyAssert(anglesAreSane);		//Find the occluded edge	int occludedAngleIndex;		if (angles[0] == segEnd1angle)		occludedAngleIndex = 3;	else if (angles[1] == segEnd1angle)		occludedAngleIndex = 0;	else if (angles[2] == segEnd1angle)		occludedAngleIndex = 1;	else if (angles[3] == segEnd1angle)		occludedAngleIndex = 2;		if (angles[occludedAngleIndex] == cutEnd1angle)		return 1;		MyAssert(angles[occludedAngleIndex] == cutEnd2angle);	return 2;}bool BspCutIntersection::IntersectionLegal(){	MyAssert(!dtored);		int occludedEdge = DetermineOccludedEdge();		//Get the four depths at the intersection	int bspEnd1D = bsp->GetSectionDepthBeforeIntersection(this, cv, seg);	int bspEnd2D = bsp->GetSectionDepthAfterIntersection(this, cv, seg);	int cutEnd1D = cut->GetSectionDepthBeforeIntersection(this);	int cutEnd2D = cut->GetSectionDepthAfterIntersection(this);		//Check the depths for legality	if (bspOnTop)	{		MyAssert(occludedEdge == 1 || occludedEdge == 2);				if (bspEnd1D != bspEnd2D)			return false;					if (occludedEdge == 1 && cutEnd1D != cutEnd2D + 1)			return false;		else if (occludedEdge == 2 && cutEnd2D != cutEnd1D + 1)			return false;				if (min(cutEnd1D, cutEnd2D) < bspEnd1D)			return false;				return true;	}	else	//Cut on top	{		MyAssert(occludedEdge == -1);				if (bspEnd1D != bspEnd2D)			return false;					if (cutEnd1D != cutEnd2D)			return false;				if (bspEnd1D <= cutEnd2D)			return false;				return true;	}}void BspCutIntersection::IncreaseCurve(){	MyAssert(!dtored);		cv++;}void BspCutIntersection::DecreaseCurve(){	MyAssert(!dtored);		cv--;}void BspCutIntersection::IncreaseSeg(int numCrvs){	MyAssert(!dtored);		seg++;	if (seg >= BSpline::BSpline::sNumSegmentsPerCurve)	{		seg = 0;		cv++;		if (cv >= numCrvs)			cv = 0;	}}void BspCutIntersection::DecreaseSeg(int numCrvs){	MyAssert(!dtored);		seg--;	if (seg < 0)	{		seg = BSpline::BSpline::sNumSegmentsPerCurve - 1;		cv--;		if (cv < 0)			cv = numCrvs - 1;	}}void BspCutIntersection::DecreaseBspIndex(){	MyAssert(!dtored);	bspIndex--;}void BspCutIntersection::DecreaseCutIndex(){	MyAssert(!dtored && !cutIsSlice);	cutIndex--;}void BspCutIntersection::SetCurveAndSeg(int newCv, int newSg){	MyAssert(!dtored);	cv = newCv;	seg = newSg;}void BspCutIntersection::SetNullBsp(){	MyAssert(!dtored);		bsp = NULL;	bspIndex = -1;	cv = -1;	seg = -1;}void BspCutIntersection::SetNullCut(){	MyAssert(!dtored && !cutIsSlice);		cut = NULL;}void BspCutIntersection::SetCut(BSplineToBSplineCut* theCut, int theCutIndex){	MyAssert(!cutIsSlice);	MyAssert(theCut && theCutIndex >= 0);	cut = theCut;	cutIndex = theCutIndex;}void BspCutIntersection::SetBspOnTop(bool theBspOnTop){	bspOnTop = theBspOnTop;}#pragma mark -		void BspCutIntersection::DumpFileData(short fRefNum, double fileVersion){	MyAssert(false);	//File version 1.2 only writes BspBsp inters to file	MyAssert(!dtored && !cutIsSlice);		string st;	ostringstream oss;		oss << "  " << GenericIntersection::BSP_CUT << "\n";		oss << "  " << location.h << " " << location.v << "\n";		oss << "  " << bspIndex << " " << cutIndex << "\n";	oss << "  " << cv << " " << seg << "\n";	oss << "  " << bspOnTop << " " << edgeDirection << "\n";		st += oss.str();	long strLen = st.length();	OSErr err = FSWrite(fRefNum, &strLen, st.c_str());}void BspCutIntersection::LoadFileData(istringstream& iss, double fileVersion){	MyAssert(fileVersion == 1.0 || fileVersion == 1.1);	//File version 1.2 only writes BspBsp inters to file		//The intersection was already read off the stream		iss >> location.h >> location.v;		iss >> bspIndex >> cutIndex;	vector<BSpline*> bsplines = drawing->GetBSplines();	MyAssert(bspIndex < bsplines.size());	bsp = bsplines[bspIndex];	vector<BSplineToBSplineCut*> cuts = drawing->GetCuts();	MyAssert(cutIndex < cuts.size());	cut = cuts[cutIndex];		iss >> cv >> seg;	iss >> bspOnTop >> edgeDirection;}