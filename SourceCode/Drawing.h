#ifndef __DRAWING__#define __DRAWING__class BSpline;class GenericIntersection;class BspBspIntersection;class BspCutIntersection;class BspCutTIntersection;class CutCutIntersection;class BSplineToBSplineCut;#include "MainWindow.h"#include "FloatPoint.h"#include "Subregion.h"#include "Subboundaries.h"#include "Colors.h"#include <time.h>#include <vector.h>#include <list.h>#include <map.h>#include <utility.h>	//for pair#include <string>#include <sstream>using namespace::std;//******************************************************************************//Extern Globalsextern Colors gColors;//******************************************************************************//Function Prototypes	//	In external files		//	main.cppvoid MyAssert(bool condition);struct WholeObject{	vector<int> bgDepths;	//	Depths of the associated surface at an infinitely distant boundary (or -999999 if there is a solid containing the object).							//	All but the strangest shapes have at most one unique infinite depth.  The "clover" can have two.	vector<BSpline*> bsplines;	vector<BspCutTIntersection*> bspCutTinters;		bool dtored;		WholeObject();	~WholeObject();};class PrevCut{	public:		BSpline *bsp1, *bsp2;		int cv1, cv2, sg1, sg2;		int numInters;};class Drawing{	public:		Drawing();		Drawing(Drawing& d);		const Drawing& operator=(Drawing& d);		~Drawing();				void ToggleShowCrossingStates();		bool SetShowCrossingStates(bool newVal);		bool GetShowCrossingStates();		void ToggleShowCuts();		bool SetShowCuts(bool newVal);		bool GetShowCuts();		void ToggleShowDepths();		bool SetShowDepths(bool newVal);		bool GetShowDepths();		void ToggleShowCompSets();		bool SetShowCompSets(bool newVal);		bool GetShowCompSets();				int GetNumBSplines();		int GetNumCuts();		int GetNumIntersections();		int GetNumInterCompanionSets();		vector<WholeObject*> GetWholeObjects();		int GetBSplineIndex(BSpline* object);		int GetCutIndex(BSplineToBSplineCut* object);		int GetWholeObjectIndex(WholeObject* wo);		vector<BSpline*> GetBSplines();		vector<BSplineToBSplineCut*> GetCuts();		void GetBSplinesInGroupFromBSpline(BSpline* bsp, vector<BSpline*>& groupBSplines);		vector<BSplineToBSplineCut*> GetCutsForOneBSpline(BSpline* bsp);		vector<BSplineToBSplineCut*> GetCutsTouchingOneBSpline(BSpline* bsp);		vector<GenericIntersection*> GetIntersections();		GenericIntersection* GetIntersection(int intersectionPoint);		int GetIntersectionIndex(GenericIntersection* intersection, bool assertIt = true);				void AddBSpline(BSpline* object);		void RemoveBSpline(BSpline* object);		bool TestBSplineForEnoughControlPoints(BSpline* bsp, vector<BSpline*>& affectedBSplines);		void RemoveCut(BSplineToBSplineCut* cut, bool splitGroup);		void RemoveBspFromWholeObject(BSpline* bsp);		void AddIntersection(GenericIntersection* intersection);		void RemoveIntersection(GenericIntersection* intersection);		void RemoveWholeObjectBspCutTInter(WholeObject* wholeObject, BspCutTIntersection* inter);		void RemoveCompanionPairsForIntersection(GenericIntersection* intersection);		void ClearBrandNewIntersections();		void DeleteAllIntersections();	//Doesn't remove the intersections after deleting them				void DuplicateCut(BSplineToBSplineCut* cut, BSpline* bsp1, BSpline* bsp2);		void CreateManualCut(BSpline* bsp, int curveSegment);		void ResetManualCut();		bool CreatingManualCut();				void RemoveAndRefindIntersections(BSpline* bsp);		void CleanUpSelfCrossingCuts(vector<BSplineToBSplineCut*> cuts);		void HalveAllBspCutTInterSegs();		void DoubleAllBspCutTInterSegs();				void FindInterCompSetsForBrandNewInters();		void FindInterCompSetsForAllInters();		void FindInterCompSetsForInters(vector<GenericIntersection*> intersToComp);		void DeleteAllCompSets();		void FindInterCompSetsForUnlabeledDrawing();				void FindInterCompSetsForAllInters2();				bool FindControlPoint(FloatPoint point, int& controlPoint, BSpline*& object);		bool FindIntersectionPoint(FloatPoint point, int& intersectionPoint);		bool FindControlBoundarySegment(FloatPoint point, int& controlBoundarySegment, BSpline*& object);		bool FindCurveSegment(FloatPoint point, int& curveSegment, BSpline*& object);				void InitAnalysisWindow();		void ClearAnalysisWindow();		void WriteSearchParameters();	private:		int IncrementTextV();		bool TestForMouseTermination();	public:		void FlipIntersection(int intersectionPoint);		void ToggleIntersectionPermanentContraint(int intersectionPoint);		void SetIntersectionPermanentContraint(int intersectionPoint, bool toggleCompSet, bool constraint);		void ReallocateCurvePoints();		void CleanUpIntersections();				void EqualizeNumberOfSections();				bool ChangeObjectRGB(BSpline* bsp, Point where);		bool ChangeObjectReflectance(BSpline* bsp, double newReflectance);		static pascal void ColorPickerColorChangedDrawing(SInt32 userData, PMColor *newColor);		static pascal void NColorPickerColorChangedDrawing(SInt32 userData, NPMColor *newColor);				void DrawDrawing(MainWindow::ViewMode viewMode, Point scrollOffset, Point canvasSize, vector<BSpline*> workingBSplines, BSpline* hilightedBSpline, int hilightCode, bool exportingPict = false);		void DrawIntersections(MainWindow::ViewMode viewMode, Point scrollOffset, bool exportingPict);		void DrawIntersectionInfo(Point scrollOffset);		void FlashIntersections(vector<GenericIntersection*> flashInters);		void HilightIntersection(GenericIntersection* intersection, Point scrollOffset, MainWindow::ViewMode viewMode);		void HilightOverlappingSubsurface(GenericIntersection* intersection, Point scrollOffset, MainWindow::ViewMode viewMode);		void DrawPostscriptDrawing(short fRefNum, MainWindow::ViewMode viewMode, Point canvasSize);		void DrawPostscriptIntersections(short fRefNum, MainWindow::ViewMode viewMode, Point canvasSize);				void DumpFileData(short fRefNum, double fileVersion);		void LoadFileData(istringstream& iss, double fileVersion);				void VerifyLegalIntersections();		bool VerifyLegalLabeling();		void VerifyWholeObjects();		void RandomizeCrossingStates();		void SortBSplineCrossingStates();		bool FlipAndLabel(int intersectionPoint);		bool CreateLegalLabeling(vector<BSpline*> testBSplines, bool initMouseSensitive);		void ClearLabeling();		void ClearDepths();		void ClearOneIntersectionLabeling(int intersectionPoint);				void SetAllIntersectionsNoHardConstraint();				void VerifyBackupsMatchPresent();		void VerifyIntersectionDrawingMatch();	//еее	DEBUG		void VerifyPrevCuts();		void VerifyNothingDtored();				//void FindWholeObjects(vector<BSpline*> testBSplines);		bool FindWholeObjects2(vector<BSpline*> testBSplines, bool dontGroupIllegalBSplines = true, bool refindCompanionSets = true, Drawing* backup = NULL);		void AttemptToFindBetterCuts();		void SortWholeObjectInfiniteInters(WholeObject* wholeObject = NULL);				bool dtored;		private:		void FindInterCompSetsForBspBspInter(BspBspIntersection* intersection, vector<BspCutIntersection*>* bspCutComps, int i /*DEBUG*/);		void FindInterCompSetsForBspCutInter(BspCutIntersection* intersection, int i /*DEBUG*/);		void FindOneBspBspInterCompanions(BspBspIntersection* intersection, BspBspIntersection*& compInter1, BspBspIntersection*& compInter2, vector<BspCutIntersection*>* bspCutComps);		BspBspIntersection* FindOneBspBspInterOneCompanion(BspBspIntersection* intersection, BSpline* bsp1, BSpline* bsp2, bool bsp1Forward, BspBspIntersection*& compInter1, BspBspIntersection*& compInter2);		BspBspIntersection* FindOneBspBspInterOneCompanion(BspBspIntersection* intersection, BSpline* traverseBsp, BSpline* crossBsp, bool forward);		BspBspIntersection* FindOneBspBspInterCompanionTraverseBottom(BspBspIntersection* intersection, vector<BspCutIntersection*>* bspCutComps);		BspBspIntersection* FindOneBspBspInterCompanionTraverseTop(BspBspIntersection* intersection, vector<BspCutIntersection*>* bspCutComps);		BspCutIntersection* FindBspCutInterCompanion(BspCutIntersection* intersection);		vector<GenericIntersection*> GetOneBSplineGroupIntersections(BSpline* bsp);				bool FindOneBspBspInterCompanion(BspBspIntersection* intersection, bool traverseFromTop, int occlusionCount, vector<BspCutIntersection*>* bspCutComps, BspBspIntersection* firstInter, vector<BspBspIntersection*>& accumCompSet, vector<GenericIntersection*> visitedInters);				void CollectAllSubregions(vector<Subregion*>& subregions, map<unsigned long, vector<Subregion*> >* boundarySectionMap, Point canvasSize, bool collectSubregionSurfaceDepths);		bool FindOneIntersectionOneSubregion(GenericIntersection* bspBspInter, int pass, Subregion* subregion, map<unsigned long, vector<Subregion*> >* boundarySectionMap,											vector<TraversedSection>& traversedSections, bool collectSubregionSurfaceDepths);		vector<CutIntersection> FindAllIntersectionsForOneSlice(FloatPoint sliceFromPoint, int sliceStartingDepth);		bool FindLegalSlice(Subregion* subregion);		bool FindLegalSlice2(Subregion* subregion);		BSpline* FindSliceBoundary(Subregion* subregion, int sliceStartingDepth, bool checkingForDeeperSurfaces, vector<pair<WholeObject*, int> >* ownerSurfaces);		void CalculateRequiredPredrawnSubregionsAndColor(vector<Subregion*>& subregions);		bool DetermineSubregionColor(Subregion* subregion, RGBColor& color);	//public:	//	static bool DetermineSubregionColor2(Subregion* subregion, RGBColor& color);	//private:		void ConnectAdjacentSubregions(vector<Subregion*> subregions);		void ConnectAdjacentSubregions(vector<Subregion*> subregions, map<unsigned long, vector<Subregion*> >* boundarySectionMap);		void BuildSurfaceToSubregionAssociations(vector<Subregion*> subregions);		void BuildOverlappingSubsurfaces(vector<Subregion*> subregions);		void BuildIntersectionCompanionSets(vector<Subregion*> subregions);		void BuildSurfaceSubregionGraphs(vector<Subregion*> subregions, vector<SurfaceSubregionGraph*>& surfaceSubregionGraphs);		SurfaceSubregionGraph* BuildSurfacePerimeterGraph(WholeObject* wholeObject, vector<Subregion*> subregions);		void PinchSurfaceSubregionGraphSingleNodes(SurfaceSubregionGraph*& surfaceSubregionGraph, WholeObject* wholeObject, vector<Subregion*> subregions);		void PinchSurfaceSubregionGraphSymmetries(SurfaceSubregionGraph*& surfaceSubregionGraph, WholeObject* wholeObject, vector<Subregion*> subregions);		void AddSurfaceSubregionGraphSpills(SurfaceSubregionGraph*& surfaceSubregionGraph, WholeObject* wholeObject, vector<Subregion*> subregions);		void AddSurfaceSubregionGraphSpillsForOneNode(SurfaceSubregionGraph::SurfaceSubregionGraphNode* surfaceSubregionGraphNode, SurfaceSubregionGraph*& surfaceSubregionGraph, WholeObject* wholeObject, vector<Subregion*> subregions, list<SurfaceSubregionGraph::SurfaceSubregionGraphNode*>& newNodes);		vector<OverlappingSubsurface> FindCommonSubgraphs(vector<SurfaceSubregionGraph*>& surfaceSubregionGraphs);		void BuildIntersectionCompanionSetsFromOverlappingSubsurfaces(vector<OverlappingSubsurface> overlappingSubsurfaces);		void InitializeCompanionSets();				void SetAllSectionsNoHardConstraint();				void CreateInspectionIntersectionList(list<GenericIntersection*>& inspectionIntersections);		void UpdateTouchedBSplines(int bspIndex, vector<int>& touchedBSplineIndexes);				vector<GenericIntersection*> FindInterNeighbors(GenericIntersection* inter);		void FindAllIntersectionContentionDistances(vector<GenericIntersection*> contentiousInters, vector<pair<GenericIntersection*, int> >& interDists);	//Find the smallest graph distance from every intersection in the drawing to any intersection in contention		void DrawContentionIntersectionDistances(vector<pair<GenericIntersection*, int> > interDists);				//bool FindBSplineSectionMaxPossibleDepths();		//bool FindBSplineSectionMaxPossibleDepthsV2();		bool FindBSplineSectionMaxPossibleDepthsV3();		bool FindBSplineSectionMaxPossibleDepthsV4();				BspCutTIntersection* FindNextInfiniteSolidCut(BspCutTIntersection* infiniteInter, bool useAllInfiniteObjects = false);		BspCutTIntersection* FindPrevInfiniteSolidCut(BspCutTIntersection* infiniteInter, bool useAllInfiniteObjects = false);		int FindInfiniteWOsectionForInter(BspCutTIntersection* infiniteInter, WholeObject* wholeObject = NULL);				bool FlipAndLabelUsingTreeSearch(int intersectionPoint);		bool FlipAndLabelUsingUniqueCompSet(int intersectionPoint);		bool CreateLegalLabelingUsingTreeSearch(vector<BSpline*> testBSplines, bool initMouseSensitive);		bool CreateLegalLabelingUsingUniqueCompSet(vector<BSpline*> testBSplines, bool initMouseSensitive);		bool FixIntersectionSegmentDepths(BspBspIntersection* intersection, list<GenericIntersection*>& cleanUpInters, int& segDepthsChanged);		bool FixIntersectionSegmentDepths(BspCutIntersection* intersection, list<GenericIntersection*>& cleanUpInters, int& segDepthsChanged);		bool FixIntersectionSegmentDepths(BspCutTIntersection* intersection, list<GenericIntersection*>& cleanUpInters, int& segDepthsChanged);		bool FixIntersectionSegmentDepths(CutCutIntersection* intersection, list<GenericIntersection*>& cleanUpInters, int& segDepthsChanged);				bool CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod0(int recursionDepth /*DEBUG*/, int depthAttempt, FloatPoint intersectionLoc, int traversalBSplineIndex,														vector<int> touchedBSplineIndexes, Drawing*& minDeltaLeaf,														int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,														bool& timeLimitReached);		bool CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod1(int recursionDepth /*DEBUG*/, int depthAttempt, FloatPoint intersectionLoc, int traversalBSplineIndex,														vector<int> touchedBSplineIndexes, Drawing*& minDeltaLeaf,														int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,														bool& timeLimitReached);		bool CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod2(int recursionDepth /*DEBUG*/, int depthAttempt, FloatPoint intersectionLoc, int traversalBSplineIndex,														vector<int> touchedBSplineIndexes, Drawing*& minDeltaLeaf,														int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,														bool& timeLimitReached);		bool HandleBSplinePropagation(int recursionDepth /*DEBUG*/, int child,										GenericIntersection* intersection, int traversalBSplineIndex,										vector<int>& touchedBSplineIndexes,										int cv, int sg, int beforeDepth,										Drawing*& minDeltaLeaf, int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,										bool& timeLimitReached);		bool HandleBSplinePropagationEnd(int recursionDepth /*DEBUG*/, int child,										GenericIntersection* intersection, int traversalBSplineIndex,										vector<int>& touchedBSplineIndexes,										int cv, int sg, int beforeDepth,										Drawing*& minDeltaLeaf, int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,										bool& timeLimitReached);		bool HandleBSplinePropagationTurnIntoCut(int recursionDepth /*DEBUG*/, GenericIntersection* intersection,										BSpline* traversalBSpline, vector<int>& touchedBSplineIndexes,										int cv, int sg, int beforeDepth,										Drawing*& minDeltaLeaf, int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,										bool& timeLimitReached);		bool CreateLegalLabelingUsingCutTraversalTreeCompSetMethod0(int recursionDepth /*DEBUG*/, FloatPoint intersectionLoc, int traversalCutIndex,														vector<int> touchedBSplineIndexes, Drawing*& minDeltaLeaf,														bool propagateForward,														int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,														bool& timeLimitReached);		bool CreateLegalLabelingUsingCutTraversalTreeCompSetMethod1(int recursionDepth /*DEBUG*/, FloatPoint intersectionLoc, int traversalCutIndex,														vector<int> touchedBSplineIndexes, Drawing*& minDeltaLeaf,														bool propagateForward,														int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,														bool& timeLimitReached);		bool CreateLegalLabelingUsingCutTraversalTreeCompSetMethod2(int recursionDepth /*DEBUG*/, FloatPoint intersectionLoc, int traversalCutIndex,														vector<int> touchedBSplineIndexes, Drawing*& minDeltaLeaf,														bool propagateForward,														int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,														bool& timeLimitReached);		bool HandleCutPropagation(int recursionDepth /*DEBUG*/, int child,										GenericIntersection* intersection, int traversalCutIndex,										vector<int>& touchedBSplineIndexes,										int beforeDepth, bool propagateForward,										Drawing*& minDeltaLeaf, int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,										bool& timeLimitReached);		bool HandleCutPropagationEnd(int recursionDepth, int child,										GenericIntersection* intersection, int traversalBSplineIndex,										vector<int>& touchedBSplineIndexes,										int beforeDepth, bool propagateForward,										Drawing*& minDeltaLeaf, int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,										bool& timeLimitReached);		bool HandleCutPropagationTurnOutOfCut(int recursionDepth /*DEBUG*/, GenericIntersection* intersection,										BSplineToBSplineCut* traversalCut, vector<int>& touchedBSplineIndexes,										int beforeDepth,										Drawing*& minDeltaLeaf, int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,										bool& timeLimitReached);				void NormalizeDepths();		void VerticallyCompactDrawing();		bool FindPreviousBSplineToSpecificBSplineCut(BSpline* bsp1, BSpline* bsp2, int& cv1, int& cv2, int& sg1, int& sg2, FloatPoint& lnPt1, FloatPoint& lnPt2);		bool FindPreviousBSplineToAnyBSplineCut(BSpline* bsp1, BSpline*& bsp2, int& cv1, int& cv2, int& sg1, int& sg2, FloatPoint& lnPt1, FloatPoint& lnPt2, PrevCut*& prevCut, int whichPrevCut);		void FindFurthestLeftInfiniteBSplineCut(BSpline* bsp, int& cv, int& sg, FloatPoint& lnPt);		bool CurveSegAlreadyCut(BSpline* bsp, int cv, int sg);		void FindRandomBSplineToBSplineCut(BSpline* bsp1, BSpline* bsp2, int& cv1, int& cv2, int& sg1, int& sg2, FloatPoint& lnPt1, FloatPoint& lnPt2);		void SaveBSplineToBSplineCut(BSplineToBSplineCut* cut);		void GroupBSplineAndSaveBSplineToBSplineCut(BSpline* bsp, BSplineToBSplineCut* cut, int infiniteCutEndingDepth);		//void RemoveBSplineToBSplineCut(BSpline* bsp1, BSpline* bsp2);		void DeleteBSplineToBSplineCut(BSplineToBSplineCut* cut);		vector<LineSegCurveIntersection> FindCutIntersections(double lineSegAngle, FloatPoint lnPt1, FloatPoint lnPt2, bool& success);		vector<CutIntersection> FindCutIntersections(BSplineToBSplineCut* cut, double lineSegAngle, FloatPoint lnPt1, FloatPoint lnPt2, bool& success);	public:		WholeObject* FindWholeObjectForBSpline(BSpline* bsp, int infiniteCutEndingDepth = -1);		WholeObject* FindWholeObjectForCut(BSplineToBSplineCut* cut);	private:		bool FindOrCreateWholeObjectForBSpline(BSpline* bsp, WholeObject*& wholeObject, int infiniteCutEndingDepth = -1);		bool TestCut(BSplineToBSplineCut* cut, int& cutEndingDepth);				void PrepareToFindWholeObjects(vector<BSpline*>& testBSplines, bool dontGroupIllegalBSplines, bool onlyPrepareTestBSplines);		BSplineToBSplineCut* CreateCutFromPrevCut(BSpline* bsp, int& cutEndingDepth, bool& alreadyCut);		BSplineToBSplineCut* AttemptToFindBetterCut(BSpline* bsp, BSplineToBSplineCut* prevCut, int& cutEndingDepth, bool mouseTerminable);		BSplineToBSplineCut* SearchForInfiniteCut(BSpline* bsp, int& cutEndingDepth, bool mouseTerminable);		vector<BSplineToBSplineCut*> SearchForInfiniteCuts(BSpline* bsp, bool mouseTerminable);		bool ConnectedHole(BSpline* bsp, vector<BSpline*> checkedBSplines, BSplineToBSplineCut* unusableCut);		BSplineToBSplineCut* SearchForBSplineToBSplineCut(BSpline* bsp, bool mouseTerminable, WholeObject* cutToWholeObject = NULL, BSplineToBSplineCut* skipCut = NULL);				BSplineToBSplineCut* CreateCutFromPrevCut(BSpline* bsp1, BSpline* bsp2, int& cutEndingDepth);		bool AttemptToConnectComponents(vector<BSpline*>& compOne, vector<BSpline*>& compTwo, double maxNumCutAttemptsScaler);		void IdentifyConnectedComponents(list<vector<BSpline*> >& connectedComponents);		void ConnectDisconnectedComponents();				void DoIntersectionGapError();		void DoIntersectionFlipConstraintError();				vector<BSpline*> bsplines;		vector<BSplineToBSplineCut*> bsplinePairCuts;		vector<PrevCut*> prevCuts;		vector<GenericIntersection*> intersections;		/*This is only left here to make depracated code compile.  It is no longer used.*/	vector<vector<pair<GenericIntersection*, GenericIntersection*> >*> interCompanionPairSets;	//vector of sets, each set a vector of pairs		vector<vector<GenericIntersection*>*> interCompanionSets;	//vector of sets, each set a vector of intersections, with no knowledge of companion pairs		vector<WholeObject*> wholeObjects;	//Equivalence relations governing multiple BSplines that belong to the same surface				vector<GenericIntersection*> brandNewIntersections;				bool showCrossingStates, showCuts, showDepths, showCompSets;		static unsigned long sTreeWalk, sTreeWalk2, sTreeWalk3;		clock_t labelingStartTime, labelAttemptWithSolutionTimeLimitSeconds, labelAttemptWithoutSolutionTimeLimitSeconds;				static SurfaceTraits sOldSurfaceTraits;		static ColorChangedUPP sColorChangedUPP;		static NColorChangedUPP sColorNChangedUPP;				bool mouseDownAtStartOfAttempt;		Point mouseLocAtStartOfAttempt;		bool mouseSensitive;				BSpline* manualCutStartBsp;		int manualCutStartSeg;};#endif