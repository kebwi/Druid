#include "CutCutIntersection.h"#include "BSpline.h"#include "BSplineToBSplineCut.h"#include "Drawing.h"#include "trigConstants.h"#include <math.h>#include <vector.h>#include <algorithm.h>#include <string>#include <sstream>using namespace::std;//******************************************************************************//Extern Globals//******************************************************************************//Function Prototypes	//	In this file	//	In external files		//	main.cppvoid MyAssert(bool condition);		//lineEquations.cppdouble LineSegmentAngle(FloatPoint p1, FloatPoint p2);#pragma mark -CutCutIntersection::CutCutIntersection(Drawing* theDrawing) : GenericIntersection(GenericIntersection::CUT_CUT, theDrawing), numNullCut1Assignments(0), numNullCut2Assignments(0), cut1old(NULL), cut2old(NULL){}CutCutIntersection::CutCutIntersection(Drawing* theDrawing, FloatPoint locInit, BSplineToBSplineCut *initCut1, BSplineToBSplineCut *initCut2,										int initCut1Index, int initCut2Index, bool initCut1IsSlice) :	GenericIntersection(GenericIntersection::CUT_CUT, theDrawing, locInit),	cut1(initCut1), cut2(initCut2), cut1Index(initCut1Index), cut2Index(initCut2Index),	cut1IsSlice(initCut1IsSlice),	numNullCut1Assignments(0), numNullCut2Assignments(0), cut1old(NULL), cut2old(NULL){	MyAssert(!dtored);	if (!cut1IsSlice)		MyAssert(cut1 && cut2);}CutCutIntersection::CutCutIntersection(CutCutIntersection& intersection, Drawing* d, BSplineToBSplineCut *initCut1, BSplineToBSplineCut *initCut2) :	GenericIntersection(intersection, d){	cut1Index = intersection.cut1Index;	cut2Index = intersection.cut2Index;	cut1IsSlice = intersection.cut1IsSlice;		cut1 = initCut1;	cut2 = initCut2;		numNullCut1Assignments = 1000 + intersection.numNullCut1Assignments;	numNullCut2Assignments = 1000 + intersection.numNullCut2Assignments;	cut1old = NULL;	cut2old = NULL;		MyAssert(cut1);	MyAssert(!dtored);}CutCutIntersection::~CutCutIntersection(){	MyAssert(!dtored);		bool cis = cut1IsSlice;	if (!cut1IsSlice)	{		bool cis2 = cut1IsSlice;				if (cut1)			cut1->RemoveIntersection((GenericIntersection*)this);		MyAssert(!dtored);				if (cut2)			cut2->RemoveIntersection((GenericIntersection*)this, true, false);		MyAssert(!dtored);	}		//dtored will be set true in the GenericIntersection dtor}int CutCutIntersection::GetCut1Index(){	MyAssert(!dtored && !cut1IsSlice);	MyAssert(cut1);	return cut1Index;}int CutCutIntersection::GetCut2Index(){	MyAssert(!dtored && !cut1IsSlice);	MyAssert(cut2);	return cut2Index;}BSplineToBSplineCut* CutCutIntersection::GetCut1(){	MyAssert(!dtored);	return cut1;}BSplineToBSplineCut* CutCutIntersection::GetCut2(){	MyAssert(!dtored && !cut1IsSlice);	return cut2;}BSplineToBSplineCut* CutCutIntersection::GetOtherCut(BSplineToBSplineCut* cut){	MyAssert(!dtored);	MyAssert(cut1 && cut2);	MyAssert(cut1 == cut || cut2 == cut);	return (cut1 == cut) ? cut2 : cut1;}bool CutCutIntersection::GetCut1IsSlice()	//DEBUG only{	MyAssert(!dtored);	return cut1IsSlice;}bool CutCutIntersection::SelfIntersection(){	MyAssert(!dtored);	MyAssert(cut1 != cut2);	return false;}#pragma mark -void CutCutIntersection::FlipTopBottom(){	MyAssert(!dtored);}//-1:none, no other responseint CutCutIntersection::DetermineOccludedEdge(){	MyAssert(!dtored && !cut1IsSlice);		return -1;}bool CutCutIntersection::IntersectionLegal(){	MyAssert(!dtored);		//Get the four depths at the intersection	int cut1End1D = cut1->GetSectionDepthBeforeIntersection(this);	int cut1End2D = cut1->GetSectionDepthAfterIntersection(this);	int cut2End1D = cut2->GetSectionDepthBeforeIntersection(this);	int cut2End2D = cut2->GetSectionDepthAfterIntersection(this);		//Check the depths for legality	if (cut1End1D != cut1End2D)		return false;		if (cut2End1D != cut2End2D)		return false;		return true;}void CutCutIntersection::DecreaseCut1Index(){	MyAssert(!dtored && !cut1IsSlice);	cut1Index--;}void CutCutIntersection::DecreaseCut2Index(){	MyAssert(!dtored && !cut1IsSlice);	cut2Index--;}void CutCutIntersection::SetNullCut(BSplineToBSplineCut *cut){	MyAssert(!dtored && !cut1IsSlice);		//Can legally fail	//MyAssert(numNullCut1Assignments == 0 || numNullCut2Assignments == 0);		bool foundIt = false;	if (cut1 == cut)	{		cut1old = cut1;		cut1 = NULL;		cut1Index = -1;		foundIt = true;		numNullCut1Assignments++;	}		if (cut2 == cut)	{		cut2old = cut2;		cut2 = NULL;		cut2Index = -1;		foundIt = true;		numNullCut2Assignments++;	}		//Can legally fail	//MyAssert(foundIt);}void CutCutIntersection::SetCut1(BSplineToBSplineCut* theCut, int theCutIndex){	MyAssert(!cut1IsSlice);	MyAssert(theCut || theCutIndex == -1);	cut1 = theCut;	cut1Index = theCutIndex;}void CutCutIntersection::SetCut2(BSplineToBSplineCut* theCut, int theCutIndex){	MyAssert(!cut1IsSlice);	MyAssert(theCut || theCutIndex == -1);	cut2 = theCut;	cut2Index = theCutIndex;}#pragma mark -		void CutCutIntersection::DumpFileData(short fRefNum, double fileVersion){	MyAssert(false);	//File version 1.2 only writes BspBsp inters to file	MyAssert(!dtored && !cut1IsSlice);		string st;	ostringstream oss;		oss << "  " << GenericIntersection::CUT_CUT << "\n";		oss << "  " << location.h << " " << location.v << "\n";		oss << "  " << cut1Index << " " << cut2Index << "\n";		st += oss.str();	long strLen = st.length();	OSErr err = FSWrite(fRefNum, &strLen, st.c_str());}void CutCutIntersection::LoadFileData(istringstream& iss, double fileVersion){	MyAssert(fileVersion == 1.0 || fileVersion == 1.1);	//File version 1.2 only writes BspBsp inters to file		//The intersection was already read off the stream		iss >> location.h >> location.v;		iss >> cut1Index >> cut2Index;	vector<BSplineToBSplineCut*> cuts = drawing->GetCuts();	MyAssert(cut1Index < cuts.size() && cut2Index < cuts.size());	cut1 = cuts[cut1Index];	cut2 = cuts[cut2Index];}