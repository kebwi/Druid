#include "Enums.h"#include "MainWindow.h"#include "Grid.h"#include "GWorldWrapper.h"#include "ToolsWindow.h"#include "BSpline.h"#include "BSplineToBSplineCut.h"#include "GenericIntersection.h"#include "BspCutIntersection.h"	//DEBUG#include "Drawing.h"#include "TextGenerator.h"#include "MinimalDrawing.h"#include "FloatPoint.h"#include "Colors.h"#include "PascalStringUtil.h"#include "trigConstants.h"#include "time.h"#include <list.h>#include <map.h>#include <math.h>#include <Quickdraw.h>#include <QuickTimeComponents.h>#include <string>#include <sstream>#include <fstream>using namespace::std;//******************************************************************************//Extern Globalsextern WindowPtr gReflectanceSliderWindow, gDataLogWindow;extern MainWindow *gMainWindow;extern ToolsWindow *gToolsWindow;extern Drawing *gDrawing;extern TextGenerator *gTextGenerator;extern Colors gColors;extern int gPointRadius;extern int gLabelingMethod;	//0:	tree search							//1:	uniquely determine from companion setextern int gCompanionSetMethod;	//0:	don't use companion sets								//1:	use companion sets to order search, but not to truncate search								//2:	use companion sets to truncate searchextern int gDepthEnumerationMethod;	//0:	use half the number of intersections on a boundary as the enumeration limit and enumerate from the first intersection on the boundary									//1:	find the depth range for each section of a boundary to use as the enumeration limit and enumerate from the deepest range intersection on the boundary (stupid idea, purely for comparative purposes)									//2:	find the depth range for each section of a boundary to use as the enumeration limit and enumerate from the shallowest range intersection on the boundaryextern int gBoundingMethod;	//0:	no bounding							//1:	boundingextern int gTreeSearchMethod;	//0:	depth-first-search								//1:	iterative deepening								//2:	breadth-first-searchextern float gTimeLimitScalar;extern  bool gDebug5;extern bool gTestLogOn;extern int gLogLine;//******************************************************************************//Global Declarationsint MainWindow::previousScrollValue = 0;static bool sMainWindowDlogCancel = false;int gTestType = -1;	//-1:	no test, will prevent data points from being recorded					//0:	test all test intersections once and record all data					//1:	there should be only one test intersection, and only record data for one node count (one of the two possible flips)static int gFileCounter = 0;stringstream* gOutputFileStream = NULL;//******************************************************************************//Function Prototypes	//	In external files		//	main.cppvoid MyAssert(bool condition);void RedrawInfoWindow();void RedrawSurfaceTraitsWindow();void DoErrorMessage(vector<const char*> errLines);		//	toolbox.cpppascal void WindowBoundaryDragEventHandler(EventLoopTimerRef theTimer, void* userData);pascal void MouseCatchUpEventHandler(EventLoopTimerRef theTimer, void* userData);pascal void LabelingAttemptPendingEventHandler(EventLoopTimerRef theTimer, void* userData);		//lineEquations.cppdouble LineSegmentAngle(FloatPoint p1, FloatPoint p2);FloatPoint ProjectPointAtAngle(FloatPoint origin, double angle, double segLength);#pragma mark -MainWindow::MainWindow(int windowRsrcId) : documentFSSpec(NULL), dataLoggingOn(false), dataLogNote(NULL), dataLogTextV(5), window(NULL), viewMode(KNOT_MODE), grid(NULL), showGrid(true), snapToGrid(false), backgroundImageGWW(NULL), exportingPict(false),	hilightedBSplineIndex(-1), hilightCode(-1), hilightedBSpline(NULL), hilightedIntersectionIndex(-1), hilightedIntersectionLoc(-99999, -99999), hilightedIntersection(NULL),	workingControlPoint(-1), windowBoundaryDragTimer(NULL), mouseCatchUpTimer(NULL), moveAllControlPoints(false),	undoStackPos(-1),	mouseMovedEventsFrozen(false), maxAllowedDelta(1000.0), timeOfLastUserMotion(0), labelPending(false),	labelingAttemptPendingTimer(NULL),	mainWindowStandardEventHandler(NULL), mainWindowHideEventHandler(NULL), mainWindowGeneralEventHandler(NULL){	CGrafPtr presentPort; 	GDHandle presentDevice;	GetGWorld(&presentPort, &presentDevice);	Rect screenBounds;	GetAvailableWindowPositioningBounds(presentDevice, &screenBounds);	int titleBarHeight = 22;	int maxWidth = screenBounds.right - screenBounds.left;	int maxHeight = screenBounds.bottom - screenBounds.top - titleBarHeight;		int dim = 700;	canvasSize.h = min(dim, maxWidth - 15);	canvasSize.v = min(dim, maxHeight - 15);		grid = new Grid(canvasSize);		//window = GetNewCWindow(windowRsrcId, NULL, NULL);	IBNibRef theNib;	OSStatus err = CreateNibReference(CFSTR("main"), &theNib);	CreateWindowFromNib(theNib, CFSTR("MainWindow"), &window);		SetWTitle(window, "\pUntitled");		//Keep things on the screen as much as possible	/*	Done at top of function	CGrafPtr presentPort; 	GDHandle presentDevice;	GetGWorld(&presentPort, &presentDevice);	Rect screenBounds;	GetAvailableWindowPositioningBounds(presentDevice, &screenBounds);	*/	Rect windowBounds;	GetPortBounds(GetWindowPort(window), &windowBounds);	SetPort(GetWindowPort(window));	Point pt;	pt.h = 0;	pt.v = 0;	LocalToGlobal(&pt);	if (pt.h > screenBounds.right - windowBounds.right)		pt.h = screenBounds.right - windowBounds.right;	if (pt.v > screenBounds.bottom - windowBounds.bottom)		pt.v = screenBounds.bottom - windowBounds.bottom;	if (pt.h < screenBounds.left)		pt.h = screenBounds.left;	if (pt.v < screenBounds.top)		pt.v = screenBounds.top;	MoveWindow(window, pt.h, pt.v, false);		//Done at top of function	//int titleBarHeight = 22;	//int maxWidth = screenBounds.right - screenBounds.left;	//int maxHeight = screenBounds.bottom - screenBounds.top - titleBarHeight;		SizeWindow(window, min((canvasSize.h + 15), maxWidth), min((canvasSize.v + 15), maxHeight), true);		ShowWindow(window);		SetPort(GetWindowPort(window));	Rect portBounds;	GetPortBounds(GetWindowPort(window), &portBounds);		Rect r;		SetRect(&r, 0, portBounds.bottom - 15, portBounds.right - 14, portBounds.bottom + 1); 	hScroll = NewControl(window, &r, "\p", true, 0, 0, 100, kControlScrollBarLiveProc, 0);	HiliteControl(hScroll, 255);		SetRect(&r, portBounds.right - 15, portBounds.top - 1, portBounds.right + 1, portBounds.bottom - 14); 	vScroll = NewControl(window, &r, "\p", true, 0, 0, 100, kControlScrollBarLiveProc, 0);	HiliteControl(vScroll, 255);		RecalcScrollBarSizes();		IncrementUndoStack();		gFileCounter = 0;	mouseClicks.clear();}MainWindow::~MainWindow(){	if (backgroundImageGWW)		delete backgroundImageGWW;		delete grid;	DisposeWindow(window);	DisposeControl(hScroll);	DisposeControl(vScroll);		for (int i = 0; i < undoStack.size(); i++)		delete undoStack[i];		if (dataLoggingOn)		ToggleDataLogging();}void MainWindow::GrabWorkingIndexes(){	workingBSplineIndexes.clear();		vector<BSpline*> bsplines = gDrawing->GetBSplines();		for (int i = 0; i < workingBSplines.size(); i++)	{		bool foundIt = false;		for (int j = 0; j < bsplines.size(); j++)			if (bsplines[j] == workingBSplines[i])			{				workingBSplineIndexes.push_back(j);				foundIt = true;				break;			}				MyAssert(foundIt);	}		if (hilightedBSpline)	{		MyAssert(!hilightedBSpline->dtored);		MyAssert(hilightCode != -1);	}	else MyAssert(hilightCode == -1);		if (hilightedIntersection)		MyAssert(!hilightedIntersection->GetDtored() && gDrawing->GetIntersectionIndex(hilightedIntersection) != -1);		hilightedBSplineIndex = hilightedBSpline ? gDrawing->GetBSplineIndex(hilightedBSpline) : -1;	hilightedIntersectionIndex = hilightedIntersection ? gDrawing->GetIntersectionIndex(hilightedIntersection) : -1;	hilightedIntersectionLoc = hilightedIntersection ? hilightedIntersection->GetLocation() : FloatPoint(-99999, -99999);}void MainWindow::RestoreWorkingIndexes(){	workingBSplines.clear();		vector<BSpline*> bsplines = gDrawing->GetBSplines();	vector<GenericIntersection*> intersections = gDrawing->GetIntersections();		for (int i = 0; i < workingBSplineIndexes.size(); i++)	{		MyAssert(workingBSplineIndexes[i] < bsplines.size());		workingBSplines.push_back(bsplines[workingBSplineIndexes[i]]);		MyAssert(!bsplines[workingBSplineIndexes[i]]->dtored);	}		hilightedBSpline = (hilightedBSplineIndex != -1) ? bsplines[hilightedBSplineIndex] : NULL;	if (hilightedBSpline)		MyAssert(hilightCode != -1);	else MyAssert(hilightCode == -1);	hilightedIntersection = NULL;// I'm not sure that these are recreatd in the original order during copying (hilightedIntersectionIndex != -1) ? intersections[hilightedIntersectionIndex] : NULL;	if (hilightedIntersectionLoc.h != -99999)		for (int i = 0; i < intersections.size(); i++)		{			FloatPoint l = intersections[i]->GetLocation();			if (l.h == hilightedIntersectionLoc.h && l.v == hilightedIntersectionLoc.v)			{				hilightedIntersection = intersections[i];				break;			}		}		if (hilightedBSpline)		MyAssert(!hilightedBSpline->dtored);	if (hilightedIntersection)		MyAssert(!hilightedIntersection->GetDtored());}void MainWindow::MovePointersFromDrawingToDrawing(Drawing* oldD, Drawing* newD){	vector<BSpline*> newBSplines = newD->GetBSplines();	vector<GenericIntersection*> newIntersections = newD->GetIntersections();		if (hilightedBSpline)		hilightedBSpline = newBSplines[oldD->GetBSplineIndex(hilightedBSpline)];	if (hilightedIntersection)		hilightedIntersection = newIntersections[oldD->GetIntersectionIndex(hilightedIntersection)];		for (int i = 0; i < workingBSplines.size(); i++)	{		int bsplineIndex = oldD->GetBSplineIndex(workingBSplines[i]);		workingBSplines[i] = newBSplines[bsplineIndex];	}}#pragma mark -WindowRef MainWindow::GetWindow(){	return window;}EventHandlerRef MainWindow::GetMainWindowStandardEventHandler(){	return mainWindowStandardEventHandler;}EventHandlerRef MainWindow::GetMainWindowHideEventHandler(){	return mainWindowHideEventHandler;}EventHandlerRef MainWindow::GetMainWindowGeneralEventHandler(){	return mainWindowGeneralEventHandler;}bool MainWindow::GetExportingPict(){	return exportingPict;}Point MainWindow::GetCanvasSize(){	return canvasSize;}Grid* MainWindow::GetGrid(){	return grid;}ControlHandle MainWindow::GetHscroll(){	return hScroll;}vector<BSpline*> MainWindow::GetWorkingObjects(){	return workingBSplines;}BSpline* MainWindow::GetHilightedObject(){	return hilightedBSpline;}GenericIntersection* MainWindow::GetHilightedIntersection(){	if (hilightedIntersection)	{		MyAssert(!hilightedIntersection->GetDtored() && gDrawing->GetIntersectionIndex(hilightedIntersection) != -1);		int index = gDrawing->GetIntersectionIndex(hilightedIntersection);	//This function will assert that the intersection is part of the drawing	}		return hilightedIntersection;}int MainWindow::GetWorkingControlPoint(){	return workingControlPoint;}MainWindow::ViewMode MainWindow::GetViewMode(){	return viewMode;}bool MainWindow::GetShowGrid(){	return showGrid;}void MainWindow::FreezeMouseMovedEvents(){	mouseMovedEventsFrozen = true;}void MainWindow::ResumeMouseMovedEvents(){	mouseMovedEventsFrozen = false;}#pragma mark -void MainWindow::SetMainWindowStandardEventHandler(EventHandlerRef theMainWindowStandardEventHandler){	mainWindowStandardEventHandler = theMainWindowStandardEventHandler;}void MainWindow::SetMainWindowHideEventHandler(EventHandlerRef theMainWindowHideEventHandler){	mainWindowHideEventHandler = theMainWindowHideEventHandler;}void MainWindow::SetMainWindowGeneralEventHandler(EventHandlerRef theMainWindowGeneralEventHandler){	mainWindowGeneralEventHandler = theMainWindowGeneralEventHandler;}#pragma mark -void MainWindow::SetWorkingSplineNULL(){	workingBSplines.clear();}void MainWindow::SetViewMode(ViewMode vm){	viewMode = vm;}		#pragma mark -void MainWindow::IncrementUndoStack(){	while (undoStack.size() > undoStackPos + 1)	{		delete undoStack.back();		undoStack.pop_back();	}		Drawing* undoStackState = new Drawing();	*undoStackState = *gDrawing;	undoStack.push_back(undoStackState);	undoStackPos++;		MenuHandle menuHandle = GetMenuHandle(EDIT_MENU);	EnableMenuItem(menuHandle, UNDO);}void MainWindow::ReplaceTopOfUndoStack(){	while (undoStack.size() > undoStackPos)	{		delete undoStack.back();		undoStack.pop_back();	}		Drawing* undoStackState = new Drawing();	*undoStackState = *gDrawing;	undoStack.push_back(undoStackState);		MyAssert(undoStackPos == undoStack.size() - 1);		MenuHandle menuHandle = GetMenuHandle(EDIT_MENU);	EnableMenuItem(menuHandle, UNDO);}		void MainWindow::Undo(){	MyAssert(undoStackPos >= 0 && undoStackPos < undoStack.size());	if (undoStackPos == 0)		return;		undoStackPos--;		hilightedBSpline = NULL;	hilightCode = -1;	hilightedIntersection = NULL;	hilightedBSplineIndex = -1;	hilightedIntersectionIndex = -1;	hilightedIntersectionLoc.h = hilightedIntersectionLoc.v = -99999;	workingBSplines.clear();	workingBSplineIndexes.clear();		*gDrawing = *undoStack[undoStackPos];		MenuHandle menuHandle = GetMenuHandle(EDIT_MENU);	EnableMenuItem(menuHandle, REDO);	if (undoStackPos == 0)		DisableMenuItem(menuHandle, UNDO);		Redraw();}void MainWindow::Redo(){	MyAssert(undoStackPos >= -1 && undoStackPos < undoStack.size());	if (undoStackPos == undoStack.size() - 1)		return;		undoStackPos++;		hilightedBSpline = NULL;	hilightCode = -1;	hilightedIntersection = NULL;	workingBSplines.clear();	workingBSplineIndexes.clear();		*gDrawing = *undoStack[undoStackPos];		MenuHandle menuHandle = GetMenuHandle(EDIT_MENU);	EnableMenuItem(menuHandle, UNDO);	if (undoStackPos == undoStack.size() - 1)		DisableMenuItem(menuHandle, REDO);		Redraw();}		#pragma mark -void MainWindow::SelectAll(){	workingBSplines.clear();		vector<BSpline*> BSplines = gDrawing->GetBSplines();	for (vector<BSpline*>::iterator i = BSplines.begin(); i != BSplines.end(); i++)		workingBSplines.push_back(*i);		if (windowBoundaryDragTimer)	{		RemoveEventLoopTimer(windowBoundaryDragTimer);		windowBoundaryDragTimer = NULL;	}		if (mouseCatchUpTimer)	{		RemoveEventLoopTimer(mouseCatchUpTimer);		mouseCatchUpTimer = NULL;	}		gToolsWindow->SetToolType(ToolsWindow::SURFACE_SELECT);		Redraw();}void MainWindow::DeselectAll(){	workingBSplines.clear();		if (windowBoundaryDragTimer)	{		RemoveEventLoopTimer(windowBoundaryDragTimer);		windowBoundaryDragTimer = NULL;	}		if (mouseCatchUpTimer)	{		RemoveEventLoopTimer(mouseCatchUpTimer);		mouseCatchUpTimer = NULL;	}		Redraw();}#pragma mark -void MainWindow::DeleteSelected(){	if (workingBSplines.size() == 0)		return;		for (vector<BSpline*>::iterator i = workingBSplines.begin(); i != workingBSplines.end(); i++)	{		gDrawing->RemoveBSpline(*i);		delete *i;	}		workingBSplines.clear();		hilightedBSpline = NULL;	hilightCode = -1;	hilightedIntersection = NULL;		gDrawing->VerifyPrevCuts();		Redraw();}#pragma mark -void MainWindow::DuplicateSelected(){	if (workingBSplines.size() == 0)		return;		IncrementUndoStack();		//Duplicate the bsplines	vector<BSpline*> dupBSplines;	map<BSpline*, BSpline*> dupBSplineMap;	for (vector<BSpline*>::iterator i = workingBSplines.begin(); i != workingBSplines.end(); i++)	{		BSpline* dupBSpline = new BSpline(**i, gDrawing, true);				//BSpline* dupBSpline = new BSpline(gDrawing);		//dupBSpline->SetDegree((*i)->GetDegree());		//dupBSpline->SetSurfaceTraits((*i)->GetSurfaceTraits());				vector<FloatPoint> controlPoints = (*i)->GetControlPoints();		for (int j = 0; j < controlPoints.size(); j++)			dupBSpline->AddControlPoint(controlPoints[j]);				FloatPoint newPos = dupBSpline->GetControlPointPosition(0);		newPos.h += 20;		newPos.v += 20;		dupBSpline->ChangeControlPoint(0, newPos, true, canvasSize);				gDrawing->AddBSpline(dupBSpline);				//dupBSpline->CleanUpIntersections(false, true, gDrawing->GetBSplines());				dupBSplines.push_back(dupBSpline);				dupBSplineMap[*i] = dupBSpline;	}		//This cut duplication code just isn't reaedy yet.  Needs a lot more work.	/*	//Duplicate the cuts	vector<BSplineToBSplineCut*> cuts = gDrawing->GetCuts();	for (int i = 0; i < cuts.size(); i++)		if (find(workingBSplines.begin(), workingBSplines.end(), cuts[i]->GetBsp1()) != workingBSplines.end())		{			MyAssert(find(workingBSplines.begin(), workingBSplines.end(), cuts[i]->GetBsp1()) != workingBSplines.end());			MyAssert(find(workingBSplines.begin(), workingBSplines.end(), cuts[i]->GetBsp2()) != workingBSplines.end());						BSpline* bsp1 = dupBSplineMap[cuts[i]->GetBsp1()];			MyAssert(find(dupBSplines.begin(), dupBSplines.end(), bsp1) != dupBSplines.end());			BSpline* bsp2 = dupBSplineMap[cuts[i]->GetBsp2()];			MyAssert(find(dupBSplines.begin(), dupBSplines.end(), bsp2) != dupBSplines.end());						gDrawing->DuplicateCut(cuts[i], bsp1, bsp2);		}	*/	vector<BSpline*> bsplineIntersDeleted;	for (vector<BSpline*>::iterator i = dupBSplines.begin(); i != dupBSplines.end(); i++)		HandleIntersectionChanges(*i, bsplineIntersDeleted, true, false);	for (vector<BSpline*>::iterator i = dupBSplines.begin(); i != dupBSplines.end(); i++)		BackupCurvePoints(*i);		vector<BSpline*> originalsAndDuplicates;	for (int i = 0; i < workingBSplines.size(); i++)		originalsAndDuplicates.push_back(workingBSplines[i]);	for (int i = 0; i < dupBSplines.size(); i++)		originalsAndDuplicates.push_back(dupBSplines[i]);		workingBSplines = dupBSplines;		CreateLegalLabeling(originalsAndDuplicates);		//Make sure the selection still includes whole objects.  This is just a bug fix.	//Proper duplication should preserve whole objects, but it doesn't.  Ugh.	for (int i = 0; i < workingBSplines.size(); i++)	{		vector<BSpline*> groupBSplines;		gDrawing->GetBSplinesInGroupFromBSpline(workingBSplines[i], groupBSplines);		for (int j = 0; j < groupBSplines.size(); j++)			if (find(workingBSplines.begin(), workingBSplines.end(), groupBSplines[j]) == workingBSplines.end())				workingBSplines.push_back(groupBSplines[j]);	}		//IncrementUndoStack();	Redraw();}vector<BSpline*> MainWindow::DuplicateSelectedDeleteOriginals(){	vector<BSpline*> dupBSplines;	if (workingBSplines.size() == 0)		return dupBSplines;		for (vector<BSpline*>::iterator i = workingBSplines.begin(); i != workingBSplines.end(); i++)	{		BSpline* dupBSpline = new BSpline(**i, gDrawing, true);				//BSpline* dupBSpline = new BSpline(gDrawing);		//dupBSpline->SetDegree((*i)->GetDegree());		//dupBSpline->SetSurfaceTraits((*i)->GetSurfaceTraits());				vector<FloatPoint> controlPoints = (*i)->GetControlPoints();		for (int j = 0; j < controlPoints.size(); j++)			dupBSpline->AddControlPoint(controlPoints[j]);				gDrawing->AddBSpline(dupBSpline);				gDrawing->RemoveBSpline(*i);		delete *i;				//dupBSpline->CleanUpIntersections(false, true, gDrawing->GetBSplines());				dupBSplines.push_back(dupBSpline);	}		vector<BSpline*> bsplineIntersDeleted;	for (vector<BSpline*>::iterator i = dupBSplines.begin(); i != dupBSplines.end(); i++)		HandleIntersectionChanges(*i, bsplineIntersDeleted, false, true);	for (vector<BSpline*>::iterator i = dupBSplines.begin(); i != dupBSplines.end(); i++)		BackupCurvePoints(*i);		hilightedBSpline = NULL;	hilightCode = -1;	hilightedIntersection = NULL;		return dupBSplines;}#pragma mark -FloatPoint MainWindow::FindSelectedCenter(){	double left = 9999, right = -9999;	double top = 9999, bottom = -9999;		for (vector<BSpline*>::iterator i = workingBSplines.begin(); i != workingBSplines.end(); i++)	{		vector<FloatPoint> controlPoints = (*i)->GetControlPoints();		for (vector<FloatPoint>::iterator i = controlPoints.begin(); i != controlPoints.end(); i++)		{			if ((*i).h < left)				left = (*i).h;			if ((*i).h > right)				right = (*i).h;			if ((*i).v < top)				top = (*i).v;			if ((*i).v > bottom)				bottom = (*i).v;		}	}		return FloatPoint((left + right) / 2.0, (top + bottom) / 2.0);}void MainWindow::FlipHorSelected(){	if (workingBSplines.size() == 0)		return;		FloatPoint selectionCenter = FindSelectedCenter();	for (vector<BSpline*>::iterator i = workingBSplines.begin(); i != workingBSplines.end(); i++)	{		(*i)->FlipHorizontal(selectionCenter);		//(*i)->CleanUpIntersections(false, true, gDrawing->GetBSplines());		(*i)->ReverseControlPointOrder();	}		vector<BSpline*> dupBSplines = DuplicateSelectedDeleteOriginals();	workingBSplines = dupBSplines;		CreateLegalLabeling(workingBSplines);	Redraw();}void MainWindow::FlipVerSelected(){	if (workingBSplines.size() == 0)		return;		FloatPoint selectionCenter = FindSelectedCenter();	for (vector<BSpline*>::iterator i = workingBSplines.begin(); i != workingBSplines.end(); i++)	{		(*i)->FlipVertical(selectionCenter);		//(*i)->CleanUpIntersections(false, true, gDrawing->GetBSplines());		(*i)->ReverseControlPointOrder();	}		vector<BSpline*> dupBSplines = DuplicateSelectedDeleteOriginals();	workingBSplines = dupBSplines;		CreateLegalLabeling(workingBSplines);	Redraw();}void MainWindow::Rotate90CWSelected(){	if (workingBSplines.size() == 0)		return;		FloatPoint selectionCenter = FindSelectedCenter();	for (vector<BSpline*>::iterator i = workingBSplines.begin(); i != workingBSplines.end(); i++)	{		(*i)->Rotate90CW(selectionCenter);		//(*i)->CleanUpIntersections(false, true, gDrawing->GetBSplines());	}		vector<BSpline*> dupBSplines = DuplicateSelectedDeleteOriginals();	workingBSplines = dupBSplines;		CreateLegalLabeling(workingBSplines);	Redraw();}void MainWindow::Rotate90CCWSelected(){	if (workingBSplines.size() == 0)		return;		FloatPoint selectionCenter = FindSelectedCenter();	for (vector<BSpline*>::iterator i = workingBSplines.begin(); i != workingBSplines.end(); i++)	{		(*i)->Rotate90CCW(selectionCenter);		//(*i)->CleanUpIntersections(false, true, gDrawing->GetBSplines());	}		vector<BSpline*> dupBSplines = DuplicateSelectedDeleteOriginals();	workingBSplines = dupBSplines;		CreateLegalLabeling(workingBSplines);	Redraw();}void MainWindow::Rotate180Selected(){	if (workingBSplines.size() == 0)		return;		FloatPoint selectionCenter = FindSelectedCenter();	for (vector<BSpline*>::iterator i = workingBSplines.begin(); i != workingBSplines.end(); i++)	{		(*i)->Rotate180(selectionCenter);		//(*i)->CleanUpIntersections(false, true, gDrawing->GetBSplines());	}		vector<BSpline*> dupBSplines = DuplicateSelectedDeleteOriginals();	workingBSplines = dupBSplines;		CreateLegalLabeling(workingBSplines);	Redraw();}pascal OSStatus MainWindow::RotationHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){	WindowRef           window = (WindowRef)userData;//NULL;	UInt32              whatHappened;	//OSStatus err = GetEventParameter(theEvent, kEventParamWindowRef, typeWindowRef,	//					NULL, sizeof(WindowRef), NULL, &window);	//err = GetEventParameter(theEvent, kEventParamDirectObject, typeWindowRef,	//					NULL, sizeof(WindowRef), NULL, &window);       whatHappened = GetEventKind(theEvent);		//http://developer.apple.com/documentation/Carbon/Conceptual/carbon_porting_guide/cpg_newtechstruct/chapter_5_section_6.html		switch (whatHappened)	{		case kEventControlHit:			ControlRef controlRef;			GetEventParameter(theEvent, kEventParamDirectObject, typeControlRef,								NULL, sizeof(ControlRef), NULL, &controlRef);						ControlID itemID;			GetControlID(controlRef, &itemID);						switch (itemID.id)			{				case 1:					QuitAppModalLoopForWindow(window);					break;				case 2:					sMainWindowDlogCancel = true;					QuitAppModalLoopForWindow(window);					break;				case 3:					break;			}			break;	}		//This makes dialog items "work", like highlight buttons while the mouse is pressed over a button and hilighting text fields when they are clicked in, etc.	//CallNextEventHandler(nextHandler, theEvent);		return noErr;}void MainWindow::RotateNumericSelected(){	if (workingBSplines.size() == 0)		return;		IBNibRef theNib;	OSStatus err = CreateNibReference(CFSTR("main"), &theNib);	long rotation = 0;	if (!err) 	{		//Create the window		WindowRef window;		CreateWindowFromNib(theNib, CFSTR("RotationDlog"), &window);				ControlID inID = { 'rotn', 3 };		ControlRef controlRef;		err = GetControlByID(window, &inID, &controlRef);				Str255 str255;		NumToString(0, str255);				char charStr[128];		PascalToC(str255, charStr);		Size bufferSize = str255[0], readSize;				err = SetControlData(controlRef, kControlEditTextPart, kControlEditTextTextTag, bufferSize, charStr);				ShowWindow(window);				InstallStandardEventHandler(GetWindowEventTarget(window));				EventTypeSpec dlogEventList[] = {{kEventClassControl, kEventControlHit}};				//We shouldn't have to pass the window in through the userdata,		//but there is a problem otherwise so we are forced to until we solve the problem.		//See AboutBoxHandler() for more on this.		InstallWindowEventHandler(window, NewEventHandlerUPP(RotationHandler), 1, dlogEventList, (void*)window, NULL);				sMainWindowDlogCancel = false;		RunAppModalLoopForWindow(window);				if (!sMainWindowDlogCancel)		{			inID.id = 3;			ControlRef controlRef;			err = GetControlByID(window, &inID, &controlRef);						Size outSize;			err = GetControlDataSize(controlRef, kControlEditTextPart, kControlEditTextTextTag, &outSize);						char charStr[128];			Size bufferSize = 128, readSize;						err = GetControlData(controlRef, kControlEditTextPart, kControlEditTextTextTag, bufferSize, charStr, &readSize);			charStr[readSize] = '\0';						CtoPascal(charStr, str255);			StringToNum(str255, &rotation);			while (rotation < 0)				rotation += 360;			while (rotation >= 360)				rotation -= 360;						double dRot = (double)rotation / (180.0 / Pi);			while (dRot < 0)				dRot += PiTimes2;			while (dRot >= PiTimes2)				dRot -= PiTimes2;						FloatPoint selectionCenter = FindSelectedCenter();			for (vector<BSpline*>::iterator i = workingBSplines.begin(); i != workingBSplines.end(); i++)			{				(*i)->RotateNumeric(dRot, selectionCenter);				//(*i)->CleanUpIntersections(false, true, gDrawing->GetBSplines());			}						vector<BSpline*> dupBSplines = DuplicateSelectedDeleteOriginals();			workingBSplines = dupBSplines;						CreateLegalLabeling(workingBSplines);			Redraw();		}				DisposeWindow(window);	}}void MainWindow::RotateFreeSelected(){	if (workingBSplines.size() == 0)		return;		CreateLegalLabeling(workingBSplines);	Redraw();}void MainWindow::ScaleNumericSelected(){	if (workingBSplines.size() == 0)		return;	/*	DialogPtr dialog;	Boolean dialogDone = false;	short itemHit, itemType;	Handle itemHandle;	Rect itemRect;		dialog = GetNewDialog(129, nil, (WindowPtr) -1L);		ShowWindow(GetDialogWindow(dialog));	SetPort(GetDialogPort(dialog));		SetDialogDefaultItem(dialog, 1);		GetDialogItem(dialog, 3, &itemType, &itemHandle, &itemRect);	SetDialogItemText(itemHandle, "\p1");		GetDialogItem(dialog, 4, &itemType, &itemHandle, &itemRect);	SetDialogItemText(itemHandle, "\p0");		while (!dialogDone)	{		ModalDialog(nil, &itemHit);				switch (itemHit)		{			case 1:			case 2:				dialogDone = true;				break;		}	}		Str255 textValue;	GetDialogItem(dialog, 3, &itemType, &itemHandle, &itemRect);	GetDialogItemText(itemHandle, textValue);		long firstVal;	StringToNum(textValue, &firstVal);		GetDialogItem(dialog, 4, &itemType, &itemHandle, &itemRect);	GetDialogItemText(itemHandle, textValue);		long secondVal;	StringToNum(textValue, &secondVal);		DisposeDialog(dialog);		if (firstVal < 0 || secondVal < 0)		return;	if (firstVal == 0 && secondVal == 0)		return;		if (secondVal >= 10000)		secondVal = 9999;		int divisor;	if (secondVal < 10)		divisor = 10;	else if (secondVal < 100)		divisor = 100;	else if (secondVal < 1000)		divisor = 1000;	else if (secondVal < 10000)		divisor = 10000;		double scaleAmount = (double)firstVal + (double)secondVal / (double(divisor));	*/	double scaleAmount = .9;		for (vector<BSpline*>::iterator i = workingBSplines.begin(); i != workingBSplines.end(); i++)	{		(*i)->ScaleNumeric(scaleAmount);		//(*i)->CleanUpIntersections(false, true, gDrawing->GetBSplines());	}		vector<BSpline*> dupBSplines = DuplicateSelectedDeleteOriginals();	workingBSplines = dupBSplines;		CreateLegalLabeling(workingBSplines);	Redraw();}void MainWindow::ScaleFreeSelected(){	if (workingBSplines.size() == 0)		return;		CreateLegalLabeling(workingBSplines);	Redraw();}#pragma mark -void MainWindow::SetRectangularGrid(){	if (grid->GetGridType() != Grid::RECTANGULAR_GRID)	{		grid->SetRectangularGrid();		Redraw();	}}void MainWindow::SetPolarGrid(){	if (grid->GetGridType() != Grid::POLAR_GRID)	{		grid->SetPolarGrid();		Redraw();	}}void MainWindow::ChangeGridSettings(){	if (grid->ChangeGridSettings())		Redraw();}void MainWindow::ToggleShowGrid(){	showGrid = !showGrid;	Redraw();}bool MainWindow::GetSnapToGrid(){	return snapToGrid;}Point MainWindow::GetPointerPos(){	return lastPointerPos;}void MainWindow::ToggleSnapToGrid(){	snapToGrid = !snapToGrid;}void MainWindow::SetShowGrid(bool newShowGrid){	showGrid = newShowGrid;}void MainWindow::SetSnapToGrid(bool newSnapToGrid){	snapToGrid = newSnapToGrid;}void MainWindow::GenerateGrid(){	grid->GenerateGrid(canvasSize);}Point MainWindow::CalcScrollOffset(){	Rect bounds;	GetPortBounds(GetWindowPort(window), &bounds);		Rect clipRect = bounds;	clipRect.right -= 15;	clipRect.bottom -= 15;		Point scrollOffset;	scrollOffset.h = -GetControlValue(hScroll);	scrollOffset.v = -GetControlValue(vScroll);		if (clipRect.right > canvasSize.h)	{		MyAssert(scrollOffset.h == 0);		scrollOffset.h = (clipRect.right - canvasSize.h) / 2;	}	if (clipRect.bottom > canvasSize.v)	{		MyAssert(scrollOffset.v == 0);		scrollOffset.v = (clipRect.bottom - canvasSize.v) / 2;	}		return scrollOffset;}#pragma mark -void MainWindow::ZoomFull(){	CGrafPtr presentPort; 	GDHandle presentDevice;	GetGWorld(&presentPort, &presentDevice);	Rect screenBounds;	GetAvailableWindowPositioningBounds(presentDevice, &screenBounds);		int titleBarHeight = 22;		int maxWidth = screenBounds.right - screenBounds.left;	int maxHeight = screenBounds.bottom - screenBounds.top - titleBarHeight;		SizeWindow(window, min((canvasSize.h + 15), maxWidth), min((canvasSize.v + 15), maxHeight), true);}void MainWindow::RecalcScrollBarSizes(){	Rect bounds;	/*	GetPortBounds(GetWindowPort(window), &bounds);	if (bounds.right > (canvasSize.h + 15) && bounds.bottom > (canvasSize.v + 15))		SizeWindow(window, (canvasSize.h + 15), (canvasSize.v + 15), true);	else if (bounds.right > (canvasSize.h + 15))		SizeWindow(window, (canvasSize.h + 15), bounds.bottom, true);	else if (bounds.bottom > (canvasSize.v + 15))		SizeWindow(window, bounds.right, (canvasSize.v + 15), true);	*/	GetPortBounds(GetWindowPort(window), &bounds);	Rect r;		SetRect(&r, 0, bounds.bottom - 15, bounds.right - 14, bounds.bottom + 1);	SetControlBounds(hScroll, &r);	//InvalWindowRect(window, &r);	HiliteControl(hScroll, 0);		SetRect(&r, bounds.right - 15, bounds.top - 1, bounds.right + 1, bounds.bottom - 14);	SetControlBounds(vScroll, &r);	//InvalWindowRect(window, &r);	HiliteControl(vScroll, 0);		int maxVal = canvasSize.h - (bounds.right - 15);	if (maxVal < 0)		maxVal = 0;	if (GetControlValue(hScroll) > maxVal)		SetControlValue(hScroll, maxVal);	SetControlMaximum(hScroll, maxVal);	SetControlViewSize(hScroll, canvasSize.h - maxVal);		maxVal = canvasSize.v - (bounds.bottom - 15);	if (maxVal < 0)		maxVal = 0;	if (GetControlValue(vScroll) > maxVal)		SetControlValue(vScroll, maxVal);	SetControlMaximum(vScroll, maxVal);	SetControlViewSize(vScroll, canvasSize.v - maxVal);		InvalWindowRect(window, &bounds);}void MainWindow::Redraw(){	RgnHandle tempRgn = NULL;	if (!exportingPict)	{		SetPort(GetWindowPort(window));				tempRgn = NewRgn();		GetClip(tempRgn);				Rect bounds;		GetPortBounds(GetWindowPort(window), &bounds);				Rect clipRect = bounds;		clipRect.right -= 15;		clipRect.bottom -= 15;		ClipRect(&clipRect);				if (clipRect.right > canvasSize.h || clipRect.bottom > canvasSize.v)		{			RGBColor gray = { 32768, 32768, 32768 };			RGBForeColor(&gray);			PaintRect(&clipRect);						if (!showGrid)			{				Rect canvasBounds = { 0, 0, canvasSize.v, canvasSize.h };				OffsetRect(&canvasBounds, (clipRect.right - canvasSize.h) / 2, (clipRect.bottom - canvasSize.v) / 2);				RGBForeColor(&gColors.canvas);				PaintRect(&canvasBounds);			}		}		else if (!showGrid)		{			RGBForeColor(&gColors.canvas);			PaintRect(&clipRect);		}	}	else	{		RGBForeColor(&gColors.canvas);		Rect bounds = { 0, 0, canvasSize.h, canvasSize.v };		PaintRect(&bounds);	}		bool exportingPictTemp = exportingPict;	exportingPict = false;		if (!exportingPict)		DrawGrid();		Point scrollOffset = CalcScrollOffset();		if (hilightedIntersection && gToolsWindow->GetToolType() == ToolsWindow::SUPER_SPLINE && viewMode != SURFACE_MODE && !exportingPict)	{		MyAssert(!hilightedIntersection->GetDtored() && gDrawing->GetIntersectionIndex(hilightedIntersection) != -1);		gDrawing->HilightOverlappingSubsurface(hilightedIntersection, scrollOffset, viewMode);	}		gDrawing->VerifyNothingDtored();	if (gToolsWindow->GetToolType() == ToolsWindow::SUPER_SPLINE || gToolsWindow->GetToolType() == ToolsWindow::CHANGE_CONTROL_POINT ||			gToolsWindow->GetToolType() == ToolsWindow::ADD_CONTROL_POINT || gToolsWindow->GetToolType() == ToolsWindow::REMOVE_CONTROL_POINT ||			gToolsWindow->GetToolType() == ToolsWindow::CHANGE_DEGREE || gToolsWindow->GetToolType() == ToolsWindow::SURFACE_SELECT)		gDrawing->DrawDrawing(viewMode, scrollOffset, canvasSize, workingBSplines, hilightedBSpline, hilightCode, exportingPict);	else gDrawing->DrawDrawing(viewMode, scrollOffset, canvasSize, workingBSplines, NULL, -1, exportingPict);	gDrawing->VerifyNothingDtored();		//Draw the intersections	if (true)//viewMode == SPLINE_MODE)		gDrawing->DrawIntersections(viewMode, scrollOffset, exportingPict);	/*	Only for debugging (comment out the similar code above if debugging as well)	if (hilightedIntersection && gToolsWindow->GetToolType() == ToolsWindow::SUPER_SPLINE && viewMode != SURFACE_MODE)	{		MyAssert(!hilightedIntersection->GetDtored() && gDrawing->GetIntersectionIndex(hilightedIntersection) != -1);		gDrawing->HilightOverlappingSubsurface(hilightedIntersection, scrollOffset, viewMode);	}	*/	if (hilightedIntersection && gToolsWindow->GetToolType() == ToolsWindow::SUPER_SPLINE && !exportingPict)	{		MyAssert(!hilightedIntersection->GetDtored() && gDrawing->GetIntersectionIndex(hilightedIntersection) != -1);		if (viewMode == SURFACE_MODE)			gDrawing->HilightOverlappingSubsurface(hilightedIntersection, scrollOffset, viewMode);		gDrawing->HilightIntersection(hilightedIntersection, scrollOffset, viewMode);	}		gDrawing->VerifyNothingDtored();		if (!exportingPict)		gTextGenerator->RenderGlyphs();		exportingPict = exportingPictTemp;		if (!exportingPict)	{		SetClip(tempRgn);		DisposeRgn(tempRgn);	}		if (!exportingPict)	{		//RedrawControls();		RedrawInfoWindow();		RedrawSurfaceTraitsWindow();	}		//MinimalDrawing* minimalDrawing = new MinimalDrawing(gDrawing);	//minimalDrawing->WriteMinimalDrawing();}void MainWindow::DrawGrid(){	if (showGrid)		grid->DrawGrid(window, canvasSize, CalcScrollOffset());		//================================================================================		if (backgroundImageGWW)	{		Rect srcRect, destRect;				Rect bounds;		GetPortBounds(GetWindowPort(window), &bounds);				bounds.right -= 15;		bounds.bottom -= 15;				if (bounds.right > canvasSize.h)			bounds.right = canvasSize.h;		if (bounds.bottom > canvasSize.v)			bounds.bottom = canvasSize.v;				srcRect = backgroundImageGWW->GetDim();				destRect = srcRect;		float scale = min(bounds.right / srcRect.right, bounds.bottom / srcRect.bottom);		destRect.right *= scale;		destRect.bottom *= scale;				OffsetRect(&destRect, canvasSize.h / 2 - destRect.right / 2, canvasSize.v / 2 - destRect.bottom / 2);				Point scrollOffset = CalcScrollOffset();				if (scrollOffset.h < 0)			OffsetRect(&destRect, -scrollOffset.h, 0);		else if (scrollOffset.h > 0)			OffsetRect(&destRect, scrollOffset.h, 0);				if (scrollOffset.v < 0)			OffsetRect(&destRect, 0, -scrollOffset.v);		else if (scrollOffset.v > 0)			OffsetRect(&destRect, 0, scrollOffset.v);				SetPort(GetWindowPort(window));		ForeColor(blackColor);		backgroundImageGWW->CopyWorldBits(srcRect, destRect, GetWindowPort(window), adMin);	}}void MainWindow::RedrawControls(){	//SetPort(GetWindowPort(window));	/*	Rect bounds;	GetPortBounds(GetWindowPort(window), &bounds);	Rect clipRect = bounds;		clipRect = bounds;	clipRect.top = clipRect.bottom - 15;	//ClipRect(&clipRect);	Draw1Control(hScroll);		clipRect = bounds;	clipRect.left = clipRect.right - 15;	//ClipRect(&clipRect);	Draw1Control(vScroll);	*/		DrawControls(window);		//UpdateControls(window);}#pragma mark -void MainWindow::HandleMouseDown(Point where, bool doubleClick, bool shiftKey, bool controlKey, bool optionKey, bool cmdKey){	//gDrawing->VerifyBackupsMatchPresent();	gDrawing->VerifyNothingDtored();		gDrawing->ClearBrandNewIntersections();		timeOfLastUserMotion = clock();		moveAllControlPoints = cmdKey;		SetPort(GetWindowPort(window));	GlobalToLocal(&where);		Rect portBounds;	GetPortBounds(GetWindowPort(window), &portBounds);	bool mouseInWindow = (where.h >= portBounds.left && where.h <= portBounds.right && where.v >= portBounds.top && where.v < portBounds.bottom);		Rect r;	ControlHandle theControl = NULL;	if (PtInRect(where, GetControlBounds(hScroll, &r)))		theControl = hScroll;	if (PtInRect(where, GetControlBounds(vScroll, &r)))		theControl = vScroll;	if (theControl != NULL)	{		HandleScrollBar(theControl, where);		return;	}		Point scrollOffset = CalcScrollOffset();	where.h -= scrollOffset.h;	where.v -= scrollOffset.v;		bool reflectanceChange = false;		if (gToolsWindow->GetToolType() == ToolsWindow::HAND)	{		gDrawing->ResetManualCut();		HandleHandTool(doubleClick, shiftKey, controlKey, optionKey, cmdKey);	}	else	{		bool pointExistsAlready = false;				int controlPoint;				BSpline* bsp;		if (gDrawing->FindControlPoint(FloatPoint(where), controlPoint, bsp) && (controlPoint != workingControlPoint || doubleClick))		{			gDrawing->ResetManualCut();			if (hilightedIntersection)				MyAssert(!hilightedIntersection->GetDtored() && gDrawing->GetIntersectionIndex(hilightedIntersection) != -1);			HandleClickOnControlPoint(bsp, where, controlPoint, doubleClick, shiftKey, controlKey, optionKey, cmdKey);			pointExistsAlready = true;		}				int intersectionPoint;		if (gDrawing->FindIntersectionPoint(FloatPoint(where), intersectionPoint))		{			gDrawing->ResetManualCut();			HandleClickOnIntersectionPoint(where, intersectionPoint, doubleClick, shiftKey, controlKey, optionKey, cmdKey);			pointExistsAlready = true;		}				int curveSegment;		if (!pointExistsAlready && workingControlPoint == -1 && gDrawing->FindCurveSegment(FloatPoint(where), curveSegment, bsp))		{			HandleClickOnCurve(bsp, where, curveSegment, doubleClick, shiftKey, controlKey, optionKey, cmdKey);			pointExistsAlready = true;						reflectanceChange = (shiftKey && controlKey);		}				int controlBoundarySegment;		if (!pointExistsAlready && workingControlPoint == -1 && gDrawing->FindControlBoundarySegment(FloatPoint(where), controlBoundarySegment, bsp))		{			gDrawing->ResetManualCut();			HandleClickOnBoundary(bsp, where, controlBoundarySegment, doubleClick, shiftKey, controlKey, optionKey, cmdKey);			pointExistsAlready = true;		}				if (!pointExistsAlready)		{			gDrawing->ResetManualCut();			HandleClickInOpenSpace(where, doubleClick, shiftKey, controlKey, optionKey, cmdKey);		}				if (!pointExistsAlready && gToolsWindow->GetToolType() == ToolsWindow::SURFACE_SELECT)		{			gDrawing->ResetManualCut();			DeselectAll();		}	}		//еее DEBUG	vector<GenericIntersection*> intersections = gDrawing->GetIntersections();	for (int i = 0; i < intersections.size(); i++)		MyAssert(intersections[i]->GetType() != GenericIntersection::BSP_CUT || !((BspCutIntersection*)intersections[i])->GetCutIsSlice());		//gDrawing->VerifyBackupsMatchPresent();	gDrawing->VerifyNothingDtored();		Redraw();		if (autoExportPict && mouseInWindow && !reflectanceChange)		ExportToPict(false, !doubleClick ? 1 : 2);}void MainWindow::HandleScrollBar(ControlHandle theControl, Point where){	short partCode = TestControl(theControl, where);	ControlActionUPP actionProc = NewControlActionUPP(WindowScrollBarProc);		if (partCode == kControlIndicatorPart)	{		previousScrollValue = GetControlValue(theControl);		TrackControl(theControl, where, actionProc);		if (previousScrollValue != GetControlValue(theControl))			WindowScrollBarProc(theControl, kControlIndicatorPart);	}	else if (partCode == kControlUpButtonPart || partCode == kControlDownButtonPart ||			partCode == kControlPageUpPart || kControlPageDownPart)	{		TrackControl(theControl, where, actionProc);	}}pascal void MainWindow::WindowScrollBarProc(ControlHandle theControl, short partCode){	short prev, maxx, next, delta, pageSize;		WindowRef window = gMainWindow->GetWindow();	Rect content;	GetPortBounds(GetWindowPort(window), &content);		ControlHandle hScroll = gMainWindow->GetHscroll();	if (theControl == hScroll)		pageSize = content.right - content.left;	else pageSize = content.bottom - content.top;		switch (partCode)	{		case kControlUpButtonPart:			prev = GetControlValue(theControl);			next = prev - 16;			break;		case kControlDownButtonPart:			prev = GetControlValue(theControl);			next = prev + 16;			break;		case kControlPageUpPart:			prev = GetControlValue(theControl);			next = prev - pageSize;			break;		case kControlPageDownPart:			prev = GetControlValue(theControl);			next = prev + pageSize;			break;		case kControlIndicatorPart:			prev = previousScrollValue;			previousScrollValue = next = GetControlValue(theControl);			break;		default:			return;	}		maxx = GetControlMaximum(theControl);	if (next < 0)		next = 0;	else if (next > maxx)		next = maxx;	delta = prev - next;	if (delta == 0)		return;	if (GetControlValue(theControl) != next)		SetControlValue(theControl, next);		//Don't need to redraw if the thumb is dragged against the end of the scrollbar, but for now, no big deal, just always redraw	gMainWindow->Redraw();}#pragma mark -void MainWindow::HandleHandTool(bool doubleClick, bool shiftKey, bool controlKey, bool optionKey, bool cmdKey){	if (doubleClick || controlKey || optionKey || cmdKey)		return;		SetPort(GetWindowPort(window));		MouseTrackingResult trackingResult;		Point where, startWhere;	GetMouse (&where);	startWhere = where;	trackingResult = kMouseTrackingMouseDown;		int oriHpos = GetControlValue(hScroll);	int oriVpos = GetControlValue(vScroll);		SetThemeCursor(kThemeClosedHandCursor);	while (trackingResult != kMouseTrackingMouseUp)	{		SetPort(GetWindowPort(window));		TrackMouseLocation (NULL, &where, &trackingResult);				if (oriHpos + (startWhere.h - where.h) < 0)		{			SetControlValue(hScroll, 0);			startWhere.h = where.h;			oriHpos = 0;		}		else if (oriHpos + (startWhere.h - where.h) > GetControlMaximum(hScroll))		{			SetControlValue(hScroll, GetControlMaximum(hScroll));			startWhere.h = where.h;			oriHpos = GetControlMaximum(hScroll);		}		else SetControlValue(hScroll, oriHpos + (startWhere.h - where.h));				if (oriVpos + (startWhere.v - where.v) < 0)		{			SetControlValue(vScroll, 0);			startWhere.v = where.v;			oriVpos = 0;		}		else if (oriVpos + (startWhere.v - where.v) > GetControlMaximum(vScroll))		{			SetControlValue(vScroll, GetControlMaximum(vScroll));			startWhere.v = where.v;			oriVpos = GetControlMaximum(vScroll);		}		else SetControlValue(vScroll, oriVpos + (startWhere.v - where.v));				//Don't need to redraw if the window view is dragged against the edge of the canvas, but for now, no big deal, just always redraw		Redraw();	}	SetThemeCursor(kThemeOpenHandCursor);}bool MainWindow::HandleIntersectionChanges(BSpline* bsp, vector<BSpline*>& bsplineIntersDeleted, bool forceToTop, bool cmdKey, bool dontProjectAnyInters){	//Keep track of intersections that have been projected and don't project them more than once	vector<GenericIntersection*> alreadyProjectedInters;		if (hilightedIntersection)		MyAssert(!hilightedIntersection->GetDtored() && gDrawing->GetIntersectionIndex(hilightedIntersection) != -1);		//Project the BSpline's intersections	vector<BSpline*> newBsplineIntersDeleted;	vector<BSplineToBSplineCut*> newCutIntersDeleted;	bool bspIntersDeletedOrReordered = bsp->ProjectIntersections(alreadyProjectedInters, newBsplineIntersDeleted,  newCutIntersDeleted, cmdKey, dontProjectAnyInters);	for (int i = 0; i < newBsplineIntersDeleted.size(); i++)		if (find(bsplineIntersDeleted.begin(), bsplineIntersDeleted.end(), newBsplineIntersDeleted[i]) == bsplineIntersDeleted.end())			bsplineIntersDeleted.push_back(newBsplineIntersDeleted[i]);		if (hilightedIntersection && gDrawing->GetIntersectionIndex(hilightedIntersection, false) == -1)		hilightedIntersection = NULL;		if (hilightedIntersection)		MyAssert(!hilightedIntersection->GetDtored() && gDrawing->GetIntersectionIndex(hilightedIntersection) != -1);		//Project the BSpline's cuts' intersections	vector<BSplineToBSplineCut*> bspCuts = gDrawing->GetCutsTouchingOneBSpline(bsp);	for (int i = 0; i < bspCuts.size(); i++)		//bspCuts[i]->ProjectIntersections(bsp, NULL);		bspCuts[i]->ProjectIntersections(alreadyProjectedInters);		bool cutIntersDeleted = false;	//After projecting the intersections, some cuts may not be good anymore		//Project connected Cuts' intersections	vector<BSplineToBSplineCut*> cuts = gDrawing->GetCutsForOneBSpline(bsp);	for (int ii = 0; ii < cuts.size(); ii++)		if (cuts[ii]->ProjectIntersections(alreadyProjectedInters))			cutIntersDeleted = true;		if (hilightedIntersection && gDrawing->GetIntersectionIndex(hilightedIntersection, false) == -1)		hilightedIntersection = NULL;		if (hilightedIntersection)		MyAssert(!hilightedIntersection->GetDtored() && gDrawing->GetIntersectionIndex(hilightedIntersection) != -1);		//Find new intersections on connected Cuts	bool newCutIntersFound = false;	bool foundOne = true;	while (foundOne)	{		foundOne = false;				cuts = gDrawing->GetCutsForOneBSpline(bsp);		for (int ii = 0; ii < cuts.size(); ii++)			if (cuts[ii]->FindAndAddNewIntersections(gDrawing->GetBSplines(), gDrawing->GetCuts()))			{				newCutIntersFound = true;								vector<BSplineToBSplineCut*> cuts1;				cuts1.push_back(cuts[ii]);				gDrawing->CleanUpSelfCrossingCuts(cuts1);			}	}	//Find new intersections on the BSpline	vector<BSpline*> groupBSplines;	if (cmdKey)		gDrawing->GetBSplinesInGroupFromBSpline(bsp, groupBSplines);	bool newBSplineIntersFound = bsp->FindAndAddNewIntersections(gDrawing->GetBSplines(), gDrawing->GetCuts(), groupBSplines, forceToTop, cmdKey);		if (hilightedIntersection)		MyAssert(!hilightedIntersection->GetDtored() && gDrawing->GetIntersectionIndex(hilightedIntersection) != -1);		//gDrawing->FindInterCompSetsForBrandNewInters();			//After projecting all the intersections and finding new intersections, "pull up" the previous point stores to the current positions	//This is done in BackupCurvePoints now	//bsp->BackupCurvePoints();	//cuts = gDrawing->GetCutsForOneBSpline(bsp);	//for (int ii = 0; ii < cuts.size(); ii++)	//	cuts[ii]->BackupStartEndLocs();	MyAssert(bsp->MakeIntersectionList());		if (hilightedIntersection)		MyAssert(!hilightedIntersection->GetDtored() && gDrawing->GetIntersectionIndex(hilightedIntersection) != -1);		//bool intersLegal = bsp->GetAllIntersectionsLegal();		gDrawing->VerifyNothingDtored();		if (hilightedIntersection)		MyAssert(!hilightedIntersection->GetDtored() && gDrawing->GetIntersectionIndex(hilightedIntersection) != -1);		return (bspIntersDeletedOrReordered || cutIntersDeleted || newBSplineIntersFound || newCutIntersFound);// || !intersLegal);}void MainWindow::BackupCurvePoints(BSpline* bsp){	bsp->BackupCurvePoints();	vector<BSplineToBSplineCut*> cuts = gDrawing->GetCutsForOneBSpline(bsp);	for (int i = 0; i < cuts.size(); i++)		cuts[i]->BackupStartEndLocs();}void MainWindow::HandleClickOnControlPoint(BSpline* bsp, Point where, int controlPoint, bool doubleClick, bool shiftKey, bool controlKey, bool optionKey, bool cmdKey){	switch (gToolsWindow->GetToolType())	{		case ToolsWindow::SUPER_SPLINE:			if (doubleClick && !controlKey)				FinishInProgressBSpline(bsp);			else if (optionKey && !controlKey && !cmdKey)			{				if (bsp->GetNumControlPoints() > 3)					DeleteControlPoint(bsp, controlPoint, cmdKey);				else DeleteBSpline(bsp);			}			else if (optionKey && cmdKey)				DeleteBSpline(bsp);			else if (controlKey && !cmdKey)				ChangeBSplineDegree(bsp, optionKey);			else if (!controlKey && !optionKey)				ChangeControlPoint(bsp, controlPoint, cmdKey);			break;		case ToolsWindow::NEW_SPLINE:			if (doubleClick && !controlKey)				FinishInProgressBSpline(bsp);			break;		case ToolsWindow::CHANGE_CONTROL_POINT:			if (!doubleClick && !controlKey && !optionKey)				ChangeControlPoint(bsp, controlPoint, cmdKey);			break;		case ToolsWindow::REMOVE_CONTROL_POINT:			if (!doubleClick && !optionKey && !controlKey && !cmdKey)			{				if (bsp->GetNumControlPoints() > 3)					DeleteControlPoint(bsp, controlPoint, cmdKey);				else DeleteBSpline(bsp);			}			else if (!doubleClick && !optionKey && !controlKey && cmdKey)				DeleteBSpline(bsp);			break;		case ToolsWindow::CHANGE_DEGREE:			if (!doubleClick && !controlKey && !cmdKey)				ChangeBSplineDegree(bsp, optionKey);			break;		case ToolsWindow::SURFACE_SELECT:			SelectBSpline(bsp, controlPoint, controlKey);			break;	}}void MainWindow::HandleClickOnIntersectionPoint(Point where, int intersectionPoint, bool doubleClick, bool shiftKey, bool controlKey, bool optionKey, bool cmdKey){	Point noScroll = {0, 0};		switch (gToolsWindow->GetToolType())	{		case ToolsWindow::SUPER_SPLINE:			if (!shiftKey && !controlKey && !optionKey && !cmdKey)				FlipIntersection(intersectionPoint);			else if (!shiftKey && controlKey && !optionKey && !cmdKey)	//Just a hack for making partially labeled figures for posters, papers, and other demos			{				vector<GenericIntersection*> intersections = gDrawing->GetIntersections();				if (intersections[intersectionPoint]->GetType() != GenericIntersection::BSP_BSP)				{					SysBeep(1);					return;				}								gDrawing->ClearOneIntersectionLabeling(intersectionPoint);			}			else if (!shiftKey && !controlKey && optionKey)				ToggleIntersectionPermanentContraint(intersectionPoint, cmdKey);						workingBSplines.clear();			break;		default:			DoNonSuperSplineIntersectionClickError();			break;	}		if (hilightedBSpline)	{		MyAssert(!hilightedBSpline->dtored);		MyAssert(hilightCode != -1);	}	if (hilightedIntersection)		MyAssert(!hilightedIntersection->GetDtored() && gDrawing->GetIntersectionIndex(hilightedIntersection) != -1);}void MainWindow::HandleClickOnBoundary(BSpline *bsp, Point where, int controlBoundarySegment, bool doubleClick, bool shiftKey, bool controlKey, bool optionKey, bool cmdKey){	SnapToGrid(where);		vector<BSpline*> affectedBSplines;		switch (gToolsWindow->GetToolType())	{		case ToolsWindow::SUPER_SPLINE:			if (!doubleClick && !shiftKey && !controlKey && !optionKey && !cmdKey)				SplitControlBoundarySegment(bsp, controlBoundarySegment, where);			else if (!shiftKey && !controlKey && optionKey && cmdKey)				DeleteBSpline(bsp);			break;		case ToolsWindow::ADD_CONTROL_POINT:			if (!doubleClick && !controlKey && !optionKey && !cmdKey)				SplitControlBoundarySegment(bsp, controlBoundarySegment, where);			break;		case ToolsWindow::CHANGE_DEGREE:			if (!doubleClick && !controlKey && !cmdKey)				ChangeBSplineDegree(bsp, optionKey);			break;		case ToolsWindow::SURFACE_SELECT:			SelectBSpline(bsp, -1, controlKey);			break;	}}void MainWindow::HandleClickOnCurve(BSpline *bsp, Point where, int curveSegment, bool doubleClick, bool shiftKey, bool controlKey, bool optionKey, bool cmdKey){	vector<BSpline*> affectedBSplines;		switch (gToolsWindow->GetToolType())	{		case ToolsWindow::SUPER_SPLINE:			if (!gDrawing->CreatingManualCut())			{				if (!doubleClick && !shiftKey && !controlKey && !optionKey && !cmdKey)					FlipSignOfOcclusion(bsp);				else if (!shiftKey && optionKey && cmdKey && cmdKey)					DeleteBSpline(bsp);				else if (shiftKey && !controlKey && !optionKey && !cmdKey)				{					FreezeMouseMovedEvents();					if (gDrawing->ChangeObjectRGB(bsp, where))						Redraw();					ResumeMouseMovedEvents();				}				else if (shiftKey && controlKey && !optionKey && !cmdKey)					ChangeObjectReflectance(bsp, where);				else if (!shiftKey && controlKey && !optionKey && !cmdKey)					gDrawing->CreateManualCut(bsp, curveSegment);			}			else			{				IncrementUndoStack();				gDrawing->CreateManualCut(bsp, curveSegment);			}			break;		case ToolsWindow::CHANGE_DEGREE:			if (!doubleClick && !controlKey && !cmdKey)				ChangeBSplineDegree(bsp, optionKey);			break;		case ToolsWindow::SURFACE_SELECT:			SelectBSpline(bsp, -1, controlKey);			break;	}}void MainWindow::HandleClickInOpenSpace(Point where, bool doubleClick, bool shiftKey, bool controlKey, bool optionKey, bool cmdKey){	SnapToGrid(where);		switch (gToolsWindow->GetToolType())	{		case ToolsWindow::SUPER_SPLINE:			if (!doubleClick && !controlKey && !optionKey && !cmdKey)				CreateNewBSpline(where);			else if (doubleClick)			{				workingBSplines.clear();				workingControlPoint = -1;			}			break;		case ToolsWindow::NEW_SPLINE:			if (!doubleClick && !controlKey && !optionKey && !cmdKey)				CreateNewBSpline(where);			else if (doubleClick)			{				workingBSplines.clear();				workingControlPoint = -1;			}			break;		default:			DoNonSuperSplineOrNewSplineOpenSpaceClickError();			break;	}		if (windowBoundaryDragTimer)	{		RemoveEventLoopTimer(windowBoundaryDragTimer);		windowBoundaryDragTimer = NULL;	}}void MainWindow::HandleExistingControlPoint(int controlPoint, bool cmdKey){	if (workingBSplines.size() != 1)	{		MyAssert(cmdKey);		//controlPoint = 0;	}		SetPort(GetWindowPort(window));	Rect portBounds;	GetPortBounds(GetWindowPort(window), &portBounds);		MouseTrackingResult trackingResult;		GetMouse(&lastWhere);		Point scrollOffset = CalcScrollOffset();	lastWhere.h -= scrollOffset.h;	lastWhere.v -= scrollOffset.v;		SnapToGrid(lastWhere);		int numPasses = 0, numDeltas = 0;	//еее debug only		trackingResult = kMouseTrackingMouseDown;		//Drawing* backup = new Drawing();		if (autoExportPict)		ExportToPict(false, true);		while (trackingResult != kMouseTrackingMouseUp)	{		Point where;		SetPort(GetWindowPort(window));		TrackMouseLocation(NULL, &where, &trackingResult);				if (trackingResult != kMouseTrackingMouseDragged)			continue;				timeOfLastUserMotion = clock();				if (where.h < 0 || where.v < 0 || where.h >= portBounds.right - 15 || where.v >= portBounds.bottom - 15)		{			workingControlPoint = controlPoint;			if (!windowBoundaryDragTimer)				InstallEventLoopTimer(GetMainEventLoop(), 0, .01 * kEventDurationSecond,								NewEventLoopTimerUPP(WindowBoundaryDragEventHandler), NULL, &windowBoundaryDragTimer);											if (mouseCatchUpTimer)			{				RemoveEventLoopTimer(mouseCatchUpTimer);				mouseCatchUpTimer = NULL;			}						continue;		}		else if ((where.h >= 0 && where.v >= 0 && where.h < portBounds.right - 15 && where.v < portBounds.bottom - 15) && windowBoundaryDragTimer)		{			RemoveEventLoopTimer(windowBoundaryDragTimer);			windowBoundaryDragTimer = NULL;		}				where.h -= scrollOffset.h;		where.v -= scrollOffset.v;				SnapToGrid(where);				gDrawing->ClearBrandNewIntersections();				//еее		vector<BSpline*> bsplines = gDrawing->GetBSplines();		BSpline **bspA = new BSpline*[bsplines.size()];		for (int i = 0; i < bsplines.size(); i++)			bspA[i] = bsplines[i];				for (int i = 0; i < bsplines.size(); i++)			MyAssert(!bsplines[i]->dtored);				//*backup = *gDrawing;				//еее		/*		bsplines = backup->GetBSplines();		BSpline **bspAA = new BSpline*[bsplines.size()];		for (int i = 0; i < bsplines.size(); i++)			bspAA[i] = bsplines[i];		*/		for (int i = 0; i < bsplines.size(); i++)			MyAssert(!bsplines[i]->dtored);				list<BSpline*> affectedBSplines;				//Build a list of all affected BSplines		MyAssert(workingBSplines.size() > 0);		for (vector<BSpline*>::iterator i = workingBSplines.begin(); i != workingBSplines.end(); i++)		{			if (find(affectedBSplines.begin(), affectedBSplines.end(), *i) == affectedBSplines.end())				affectedBSplines.push_back(*i);						if (false)//cmdKey)	//If doing a translation instead of a reshape, move all objects in the group at once			{				vector<BSpline*> groupBSplines;				gDrawing->GetBSplinesInGroupFromBSpline(*i, groupBSplines);								for (vector<BSpline*>::iterator j = groupBSplines.begin(); j != groupBSplines.end(); j++)					if (find(affectedBSplines.begin(), affectedBSplines.end(), *j) == affectedBSplines.end())						affectedBSplines.push_back(*j);			}		}				Point delta;		delta.h = where.h - lastWhere.h;		delta.v = where.v - lastWhere.v;				double maxDelta = max(fabs(delta.h), fabs(delta.v));		if (maxDelta > maxAllowedDelta)		{			double deltaScaler = maxAllowedDelta / maxDelta;			delta.h *= deltaScaler;			delta.v *= deltaScaler;		}				if (hilightedIntersection)			MyAssert(!hilightedIntersection->GetDtored() && gDrawing->GetIntersectionIndex(hilightedIntersection) != -1);				if (delta.h != 0 || delta.v != 0)		{			if (cmdKey)				for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)					(*i)->ConstrainMoveWithinCanvas(delta, canvasSize);						bool windingNumberChanged = false;			vector<BSpline*> bsplineIntersDeleted;			FloatPoint workingControlPointNewPos;			MyAssert(affectedBSplines.size() > 0);			for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)			{				MyAssert(controlPoint != -1);				FloatPoint prevWhere = (*i == workingBSplines.front()) ? (*i)->GetControlPointPosition(controlPoint) :																		(*i)->GetControlPointPosition(0);				FloatPoint newPos;				newPos.h = prevWhere.h + delta.h;				newPos.v = prevWhere.v + delta.v;				if (*i == workingBSplines.front())					workingControlPointNewPos = newPos;								//Changing the control point will also reshape the BSpline's curves				if ((*i == workingBSplines.front()) ? (*i)->ChangeControlPoint(controlPoint, FloatPoint(newPos), cmdKey, canvasSize) :													(*i)->ChangeControlPoint(0, FloatPoint(newPos), cmdKey, canvasSize))					if (!windingNumberChanged)						windingNumberChanged = true;			}						bool rippleLabel = false;			for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)			{				bool intersChanged = HandleIntersectionChanges(*i, bsplineIntersDeleted, false, cmdKey);								if (hilightedIntersection)					MyAssert(!hilightedIntersection->GetDtored() && gDrawing->GetIntersectionIndex(hilightedIntersection) != -1);								rippleLabel = (rippleLabel || windingNumberChanged || intersChanged);								gDrawing->VerifyNothingDtored();			}			for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)				BackupCurvePoints(*i);						vector<BSpline*> affectBSplinesVector;			for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)				affectBSplinesVector.push_back(*i);						//if (cmdKey)			//	gDrawing->FindWholeObjects2(affectBSplinesVector, false);						if (rippleLabel)			{				//gDrawing->FindWholeObjects2(affectBSplinesVector, false);								for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)				{					//Find BSplines connected by cuts					vector<BSpline*> groupBSplines;					gDrawing->GetBSplinesInGroupFromBSpline(*i, groupBSplines);										for (vector<BSpline*>::iterator j = groupBSplines.begin(); j != groupBSplines.end(); j++)						if (find(affectBSplinesVector.begin(), affectBSplinesVector.end(), *j) == affectBSplinesVector.end())							affectBSplinesVector.push_back(*j);				}								//Add bsplines that used to be connected by now-deleted intersections				for (int i = 0; i < bsplineIntersDeleted.size(); i++)					if (find(affectBSplinesVector.begin(), affectBSplinesVector.end(), bsplineIntersDeleted[i]) == affectBSplinesVector.end())						affectBSplinesVector.push_back(bsplineIntersDeleted[i]);								gDrawing->VerifyNothingDtored();								CreateLegalLabeling(affectBSplinesVector);			}			else			{				//gDrawing->VerifyLegalIntersections();				gDrawing->SetAllIntersectionsNoHardConstraint();			}						//lastWhere = where;			lastWhere.h = workingControlPointNewPos.h;			lastWhere.v = workingControlPointNewPos.v;			lastPointerPos = lastWhere;						Redraw();						numDeltas++;		}				if (maxDelta > maxAllowedDelta)		{			workingControlPoint = controlPoint;			if (!mouseCatchUpTimer)				InstallEventLoopTimer(GetMainEventLoop(), 0, .01 * kEventDurationSecond,								NewEventLoopTimerUPP(MouseCatchUpEventHandler), NULL, &mouseCatchUpTimer);		}				numPasses++;				if (autoExportPict)			ExportToPict(false);	}		//delete backup;		workingControlPoint = -1;}void MainWindow::HandleMouseMoved(Point where){	timeOfLastUserMotion = clock();		if (mouseMovedEventsFrozen)		return;		BSpline* hilightedBSplinePre = hilightedBSpline;	GenericIntersection* hilightedIntersectionPre = hilightedIntersection;		//if (gToolsWindow->GetToolType() == ToolsWindow::SURFACE_SELECT)	//	return;		gDrawing->ClearBrandNewIntersections();		SetPort(GetWindowPort(window));	Rect portBounds;	GetPortBounds(GetWindowPort(window), &portBounds);		GlobalToLocal(&where);	bool mouseInWindow = (where.h >= portBounds.left && where.h <= portBounds.right && where.v >= portBounds.top && where.v < portBounds.bottom);		Point scrollOffset = CalcScrollOffset();	where.h -= scrollOffset.h;	where.v -= scrollOffset.v;		//Keep track of the hilighted objects	//if (workingBSplines.size() == 0)	{		bool pointExistsAlready = false;		BSpline* bsp = NULL;		GenericIntersection* inter = NULL;				if (!hilightedBSpline)			hilightCode = -1;				int controlPoint = -1;		if (gDrawing->FindControlPoint(FloatPoint(where), controlPoint, bsp))		{			pointExistsAlready = true;			hilightCode = 1;		}				int intersectionPoint = -1;		if (gDrawing->FindIntersectionPoint(FloatPoint(where), intersectionPoint))		{			inter = gDrawing->GetIntersection(intersectionPoint);			pointExistsAlready = true;			hilightCode = 2;		}				int curveSegment = -1;		if (!pointExistsAlready && gDrawing->FindCurveSegment(FloatPoint(where), curveSegment, bsp))		{			pointExistsAlready = true;			hilightCode = 3;		}				int controlBoundarySegment = -1;		if (!pointExistsAlready && gDrawing->FindControlBoundarySegment(FloatPoint(where), controlBoundarySegment, bsp))		{			pointExistsAlready = true;			hilightCode = 4;		}				if (hilightedBSpline != bsp || hilightedIntersection != inter)		{			hilightedBSpline = bsp;			hilightedIntersection = inter;		}				if (!hilightedBSpline)			hilightCode = -1;				if (hilightedBSpline)			MyAssert(hilightCode != -1);		else MyAssert(hilightCode == -1);				if (hilightedIntersection)			MyAssert(!hilightedIntersection->GetDtored() && gDrawing->GetIntersectionIndex(hilightedIntersection) != -1);				lastPointerPos = where;		RedrawInfoWindow();				//return;	}		if (where.h < 0 || where.v < 0 || where.h >= portBounds.right - 15 || where.v >= portBounds.bottom - 15)	{		lastPointerPos = where;		RedrawInfoWindow();				if (!windowBoundaryDragTimer)			InstallEventLoopTimer(GetMainEventLoop(), 0, .01 * kEventDurationSecond,							NewEventLoopTimerUPP(WindowBoundaryDragEventHandler), NULL, &windowBoundaryDragTimer);									if (mouseCatchUpTimer)		{			RemoveEventLoopTimer(mouseCatchUpTimer);			mouseCatchUpTimer = NULL;		}				return;	}	else if ((where.h >= 0 && where.v >= 0 && where.h < portBounds.right - 15 && where.v < portBounds.bottom - 15) && windowBoundaryDragTimer)	{		RemoveEventLoopTimer(windowBoundaryDragTimer);		windowBoundaryDragTimer = NULL;	}		SnapToGrid(where);		Point delta;	delta.h = where.h - lastWhere.h;	delta.v = where.v - lastWhere.v;		double maxDelta = max(fabs(delta.h), fabs(delta.v));	if (maxDelta > maxAllowedDelta)	{		double deltaScaler = maxAllowedDelta / maxDelta;		delta.h *= deltaScaler;		delta.v *= deltaScaler;	}		Point newWhere;	newWhere.h = lastWhere.h + delta.h;	newWhere.v = lastWhere.v + delta.v;		//Drawing* backup = new Drawing();	//*backup = *gDrawing;		if (gToolsWindow->GetToolType() == ToolsWindow::SUPER_SPLINE || gToolsWindow->GetToolType() == ToolsWindow::NEW_SPLINE || gToolsWindow->GetToolType() == ToolsWindow::CHANGE_CONTROL_POINT)	{		if (workingBSplines.size() == 1)			if (workingControlPoint == -1)			{				if (fabs(lastDroppedControlPointLoc.h - where.h) > 10 || fabs(lastDroppedControlPointLoc.v - where.v) > 10)				{					workingControlPoint = workingBSplines.front()->AddControlPoint(FloatPoint(where));										gDrawing->RemoveAndRefindIntersections(workingBSplines.front());					MyAssert(workingBSplines.front()->MakeIntersectionList());					workingBSplines.front()->EqualizeNumberOfSections();										gDrawing->VerifyNothingDtored();										vector<BSpline*> bsplineIntersDeleted;					if (true)//HandleIntersectionChanges(workingBSplines.front(), bsplineIntersDeleted) || workingBSplines.front()->GetNumControlPoints() == 3)					{						//Only do this if HandleIntersectionChanges is called above						//BackupCurvePoints(workingBSplines.front());												vector<BSpline*> affectedBSplines;						affectedBSplines.push_back(workingBSplines.front());												//Find BSplines connected by cuts						vector<BSpline*> groupBSplines;						gDrawing->GetBSplinesInGroupFromBSpline(workingBSplines.front(), groupBSplines);												for (vector<BSpline*>::iterator j = groupBSplines.begin(); j != groupBSplines.end(); j++)							if (find(affectedBSplines.begin(), affectedBSplines.end(), *j) == affectedBSplines.end())								affectedBSplines.push_back(*j);												//Add bsplines that used to be connect by now-deleted intersections						for (int i = 0; i < bsplineIntersDeleted.size(); i++)							if (find(affectedBSplines.begin(), affectedBSplines.end(), bsplineIntersDeleted[i]) == affectedBSplines.end())								affectedBSplines.push_back(bsplineIntersDeleted[i]);												gDrawing->VerifyNothingDtored();												CreateLegalLabeling(affectedBSplines);												gDrawing->VerifyNothingDtored();					}					else					{						//gDrawing->VerifyLegalIntersections();						gDrawing->SetAllIntersectionsNoHardConstraint();					}				}			}			else			{				//Changing the control point will also reshape the BSpline's curves				bool windingNumberChanged2 = workingBSplines.front()->ChangeControlPoint(workingControlPoint, FloatPoint(newWhere), false, canvasSize);								vector<BSpline*> bsplineIntersDeleted;				bool intersChanged = HandleIntersectionChanges(workingBSplines.front(), bsplineIntersDeleted, false, false);				BackupCurvePoints(workingBSplines.front());								if (windingNumberChanged2 || intersChanged)				{					vector<BSpline*> affectedBSplines;					affectedBSplines.push_back(workingBSplines.front());										//Find BSplines connected by cuts					vector<BSpline*> groupBSplines;					gDrawing->GetBSplinesInGroupFromBSpline(workingBSplines.front(), groupBSplines);										for (vector<BSpline*>::iterator j = groupBSplines.begin(); j != groupBSplines.end(); j++)						if (find(affectedBSplines.begin(), affectedBSplines.end(), *j) == affectedBSplines.end())							affectedBSplines.push_back(*j);										//Add bsplines that used to be connect by now-deleted intersections					for (int i = 0; i < bsplineIntersDeleted.size(); i++)						if (find(affectedBSplines.begin(), affectedBSplines.end(), bsplineIntersDeleted[i]) == affectedBSplines.end())							affectedBSplines.push_back(bsplineIntersDeleted[i]);										CreateLegalLabeling(affectedBSplines);				}				else				{					//gDrawing->VerifyLegalIntersections();					gDrawing->SetAllIntersectionsNoHardConstraint();				}			}		if (maxDelta > maxAllowedDelta)		{			if (!mouseCatchUpTimer)				InstallEventLoopTimer(GetMainEventLoop(), 0, .01 * kEventDurationSecond,								NewEventLoopTimerUPP(MouseCatchUpEventHandler), NULL, &mouseCatchUpTimer);		}	}		//delete backup;		if (hilightedIntersection)		MyAssert(!hilightedIntersection->GetDtored() && gDrawing->GetIntersectionIndex(hilightedIntersection) != -1);		lastWhere = lastPointerPos = newWhere;		if (maxDelta > maxAllowedDelta)	{		if (!mouseCatchUpTimer)			InstallEventLoopTimer(GetMainEventLoop(), 0, .01 * kEventDurationSecond,							NewEventLoopTimerUPP(MouseCatchUpEventHandler), NULL, &mouseCatchUpTimer);	}		bool redraw = false;		if (hilightedBSplinePre != hilightedBSpline || hilightedIntersectionPre != hilightedIntersection)		redraw = true;		if (workingControlPoint != -1)		redraw = true;		if (gDrawing->CreatingManualCut())		redraw = true;		if (redraw)		Redraw();		if (autoExportPict && mouseInWindow)		ExportToPict(false);}void MainWindow::HandleWindowBoundaryDrag(){	if (mouseMovedEventsFrozen)		return;		if (workingBSplines.size() == 0)	{		RemoveEventLoopTimer(windowBoundaryDragTimer);		windowBoundaryDragTimer = NULL;		return;	}		GrafPtr oldPort;	GetPort(&oldPort);		SetPort(GetWindowPort(window));	Rect portBounds;	GetPortBounds(GetWindowPort(window), &portBounds);		Rect clipRect = portBounds;	clipRect.right -= 15;	clipRect.bottom -= 15;		Point where;	GetMouse(&where);	static Point lastDragWhere = { 0, 0 };	if (where.h != lastDragWhere.h || where.v != lastDragWhere.v)		timeOfLastUserMotion = clock();	lastDragWhere = where;		int speed;		Point scrollOffset = CalcScrollOffset();		if (where.h < 0)	{		speed = -where.h / 10;		if (speed == 0)			speed = 1;				where.h = -scrollOffset.h - speed;				if (GetControlValue(hScroll) >= speed)			SetControlValue(hScroll, GetControlValue(hScroll) - speed);		else SetControlValue(hScroll, 0);	}	else if (where.h >= clipRect.right)	{		speed = (where.h - (clipRect.right)) / 10;		if (speed == 0)			speed = 1;					where.h = clipRect.right - scrollOffset.h + speed;				if (GetControlValue(hScroll) <= GetControlMaximum(hScroll) - speed)			SetControlValue(hScroll, GetControlValue(hScroll) + speed);		else SetControlValue(hScroll, GetControlMaximum(hScroll));	}	else where.h -= scrollOffset.h;		if (where.v < 0)	{		speed = -where.v / 10;		if (speed == 0)			speed = 1;				where.v = -scrollOffset.v - speed;				if (GetControlValue(vScroll) >= speed)			SetControlValue(vScroll, GetControlValue(vScroll) - speed);		else SetControlValue(vScroll, 0);	}	else if (where.v >= clipRect.bottom)	{		speed = (where.v - (clipRect.bottom)) / 10;		if (speed == 0)			speed = 1;				where.v = clipRect.bottom - scrollOffset.v + speed;				if (GetControlValue(vScroll) <= GetControlMaximum(vScroll) - speed)			SetControlValue(vScroll, GetControlValue(vScroll) + speed);		else SetControlValue(vScroll, GetControlMaximum(vScroll));	}	else where.v -= scrollOffset.v;		SnapToGrid(where);		Point delta;	delta.h = where.h - lastWhere.h;	delta.v = where.v - lastWhere.v;		double maxDelta = max(fabs(delta.h), fabs(delta.v));	if (maxDelta > maxAllowedDelta)	{		double deltaScaler = maxAllowedDelta / maxDelta;		delta.h *= deltaScaler;		delta.v *= deltaScaler;	}		//Drawing* backup = new Drawing();	//*backup = *gDrawing;		//Build a list of all affected BSplines	list<BSpline*> affectedBSplines;	for (vector<BSpline*>::iterator i = workingBSplines.begin(); i != workingBSplines.end(); i++)	{		if (find(affectedBSplines.begin(), affectedBSplines.end(), *i) == affectedBSplines.end())			affectedBSplines.push_back(*i);				if (moveAllControlPoints)	//If doing a translation instead of a reshape, move all objects in the group at once		{			vector<BSpline*> groupBSplines;			gDrawing->GetBSplinesInGroupFromBSpline(*i, groupBSplines);						for (vector<BSpline*>::iterator j = groupBSplines.begin(); j != groupBSplines.end(); j++)				if (find(affectedBSplines.begin(), affectedBSplines.end(), *j) == affectedBSplines.end())					affectedBSplines.push_back(*j);		}	}		if (delta.h != 0 || delta.v != 0)	{		if (workingBSplines.size() == 1)		{			FloatPoint workingControlPointNewPos;						if (workingControlPoint == -1)			{				//workingControlPoint = workingBSplines.front()->AddControlPoint(FloatPoint(where));			}			else			{				if (moveAllControlPoints)					for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)						(*i)->ConstrainMoveWithinCanvas(delta, canvasSize);								bool windingNumberChanged = false;				vector<BSpline*> bsplineIntersDeleted;				for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)				{					MyAssert(workingControlPoint != -1);					FloatPoint prevWhere = (*i == workingBSplines.front()) ? (*i)->GetControlPointPosition(workingControlPoint) :																			(*i)->GetControlPointPosition(0);					FloatPoint newPos;					newPos.h = prevWhere.h + delta.h;					newPos.v = prevWhere.v + delta.v;					if (*i == workingBSplines.front())						workingControlPointNewPos = newPos;										//Changing the control point will also reshape the BSpline's curves					if ((*i == workingBSplines.front()) ? (*i)->ChangeControlPoint(workingControlPoint, FloatPoint(newPos), moveAllControlPoints, canvasSize) :														(*i)->ChangeControlPoint(0, FloatPoint(newPos), moveAllControlPoints, canvasSize))						if (!windingNumberChanged)							windingNumberChanged = true;				}								bool rippleLabel = false;				for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)				{					bool intersChanged = HandleIntersectionChanges(*i, bsplineIntersDeleted, false, moveAllControlPoints);										rippleLabel = (rippleLabel || windingNumberChanged || intersChanged);										gDrawing->VerifyNothingDtored();				}				for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)					BackupCurvePoints(*i);								if (rippleLabel)				{					vector<BSpline*> affectedBSplines;					affectedBSplines.push_back(workingBSplines.front());										//Find BSplines connected by cuts					vector<BSpline*> groupBSplines;					gDrawing->GetBSplinesInGroupFromBSpline(workingBSplines.front(), groupBSplines);										for (vector<BSpline*>::iterator j = groupBSplines.begin(); j != groupBSplines.end(); j++)						if (find(affectedBSplines.begin(), affectedBSplines.end(), *j) == affectedBSplines.end())							affectedBSplines.push_back(*j);										//Add bsplines that used to be connect by now-deleted intersections					for (int i = 0; i < bsplineIntersDeleted.size(); i++)						if (find(affectedBSplines.begin(), affectedBSplines.end(), bsplineIntersDeleted[i]) == affectedBSplines.end())							affectedBSplines.push_back(bsplineIntersDeleted[i]);										CreateLegalLabeling(affectedBSplines);				}				else gDrawing->SetAllIntersectionsNoHardConstraint();			}						if (moveAllControlPoints)			{				GrabWorkingIndexes();				gDrawing->VerifyLegalLabeling();				RestoreWorkingIndexes();			}						//lastWhere = where;			lastWhere.h = workingControlPointNewPos.h;			lastWhere.v = workingControlPointNewPos.v;		}	}		//delete backup;		Redraw();		SetPort(oldPort);}void MainWindow::HandleMouseCatchUp(){	timeOfLastUserMotion = clock();		if (mouseMovedEventsFrozen)		return;		if (workingBSplines.size() == 0)	{		RemoveEventLoopTimer(mouseCatchUpTimer);		mouseCatchUpTimer = NULL;		return;	}		GrafPtr oldPort;	GetPort(&oldPort);		SetPort(GetWindowPort(window));	Rect portBounds;	GetPortBounds(GetWindowPort(window), &portBounds);		Point where;	GetMouse(&where);	bool mouseInWindow = (where.h >= portBounds.left && where.h <= portBounds.right && where.v >= portBounds.top && where.v < portBounds.bottom);		//where.h += GetControlValue(hScroll);	//where.v += GetControlValue(vScroll);	Point scrollOffset = CalcScrollOffset();	where.h -= scrollOffset.h;	where.v -= scrollOffset.v;		if (where.h != lastWhere.h || where.v != lastWhere.v)	{		//At the time this function was first created, this code was simply copied verbatim from HandleExistingControlPoint().		//Could be cleaned up at some future time.				//Drawing* backup = new Drawing();		//*backup = *gDrawing;				list<BSpline*> affectedBSplines;				//Build a list of all affected BSplines		for (vector<BSpline*>::iterator i = workingBSplines.begin(); i != workingBSplines.end(); i++)		{			if (find(affectedBSplines.begin(), affectedBSplines.end(), *i) == affectedBSplines.end())				affectedBSplines.push_back(*i);						if (moveAllControlPoints)			{				vector<BSpline*> groupBSplines;				gDrawing->GetBSplinesInGroupFromBSpline(*i, groupBSplines);								for (vector<BSpline*>::iterator j = groupBSplines.begin(); j != groupBSplines.end(); j++)					if (find(affectedBSplines.begin(), affectedBSplines.end(), *j) == affectedBSplines.end())						affectedBSplines.push_back(*j);			}		}				Point delta;		delta.h = where.h - lastWhere.h;		delta.v = where.v - lastWhere.v;				double maxDelta = max(fabs(delta.h), fabs(delta.v));		if (maxDelta > maxAllowedDelta)		{			double deltaScaler = maxAllowedDelta / maxDelta;			delta.h *= deltaScaler;			delta.v *= deltaScaler;		}				if (workingControlPoint != -1 && (delta.h != 0 || delta.v != 0))		{			if (moveAllControlPoints)				for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)					(*i)->ConstrainMoveWithinCanvas(delta, canvasSize);						bool windingNumberChanged = false;			vector<BSpline*> bsplineIntersDeleted;			FloatPoint workingControlPointNewPos;			for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)			{				MyAssert(workingControlPoint != -1);				FloatPoint prevWhere = (*i == workingBSplines.front()) ? (*i)->GetControlPointPosition(workingControlPoint) :																		(*i)->GetControlPointPosition(0);				FloatPoint newPos;				newPos.h = prevWhere.h + delta.h;				newPos.v = prevWhere.v + delta.v;				if (*i == workingBSplines.front())					workingControlPointNewPos = newPos;								//Changing the control point will also reshape the BSpline's curves				if ((*i == workingBSplines.front()) ? (*i)->ChangeControlPoint(workingControlPoint, FloatPoint(newPos), moveAllControlPoints, canvasSize) :													(*i)->ChangeControlPoint(0, FloatPoint(newPos), moveAllControlPoints, canvasSize))					if (!windingNumberChanged)						windingNumberChanged = true;			}						bool rippleLabel = false;			for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)			{				bool intersChanged = HandleIntersectionChanges(*i, bsplineIntersDeleted, false, moveAllControlPoints);								rippleLabel = (rippleLabel || windingNumberChanged || intersChanged);								gDrawing->VerifyNothingDtored();			}			for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)				BackupCurvePoints(*i);			/*			bool rippleLabel = false;			vector<BSpline*> bsplineIntersDeleted;			FloatPoint workingControlPointNewPos;			for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)			{				MyAssert(workingControlPoint != -1);				FloatPoint prevWhere = (*i)->GetControlPointPosition(workingControlPoint);				newPos.h = prevWhere.h + delta.h;				newPos.v = prevWhere.v + delta.v;								//Changing the control point will also reshape the BSpline's curves				bool windingNumberChanged = (*i)->ChangeControlPoint(workingControlPoint, FloatPoint(newPos), false, canvasSize);								bool intersChanged = HandleIntersectionChanges(*i, bsplineIntersDeleted, false, moveAllControlPoints);								rippleLabel = (windingNumberChanged || intersChanged);			}			for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)				BackupCurvePoints(*i);			*/			if (rippleLabel)			{				vector<BSpline*> affectBSplinesVector;				for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)					affectBSplinesVector.push_back(*i);								for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)				{					//Find BSplines connected by cuts					vector<BSpline*> groupBSplines;					gDrawing->GetBSplinesInGroupFromBSpline(*i, groupBSplines);										for (vector<BSpline*>::iterator j = groupBSplines.begin(); j != groupBSplines.end(); j++)						if (find(affectBSplinesVector.begin(), affectBSplinesVector.end(), *j) == affectBSplinesVector.end())							affectBSplinesVector.push_back(*j);				}								//Add bsplines that used to be connect by now-deleted intersections				for (int i = 0; i < bsplineIntersDeleted.size(); i++)					if (find(affectBSplinesVector.begin(), affectBSplinesVector.end(), bsplineIntersDeleted[i]) == affectBSplinesVector.end())						affectBSplinesVector.push_back(bsplineIntersDeleted[i]);								CreateLegalLabeling(affectBSplinesVector);			}			else			{				//gDrawing->VerifyLegalIntersections();				gDrawing->SetAllIntersectionsNoHardConstraint();			}						//lastWhere = where;			lastWhere.h = workingControlPointNewPos.h;			lastWhere.v = workingControlPointNewPos.v;						Redraw();		}		else		{			RemoveEventLoopTimer(windowBoundaryDragTimer);			windowBoundaryDragTimer = NULL;		}				//delete backup;	}	else	//location hasn't changed, turn off timer	{		RemoveEventLoopTimer(windowBoundaryDragTimer);		windowBoundaryDragTimer = NULL;	}		if (autoExportPict && mouseInWindow)		ExportToPict(false);}#pragma mark -void MainWindow::FinishInProgressBSpline(BSpline* bsp){	workingBSplines.clear();	workingBSplines.push_back(bsp);		vector<BSpline*> affectedBSplines;	if (!gDrawing->TestBSplineForEnoughControlPoints(bsp, affectedBSplines))	{		workingBSplines.clear();		hilightedBSpline = NULL;		hilightCode = -1;		hilightedIntersection = NULL;				CreateLegalLabeling(affectedBSplines);	}		workingBSplines.clear();	workingControlPoint = -1;		IncrementUndoStack();}void MainWindow::DeleteControlPoint(BSpline* bsp, int controlPoint, bool deleteAllControlPoints){	MyAssert(!deleteAllControlPoints);	if (deleteAllControlPoints)	{		SysBeep(1);		return;	}		workingBSplines.clear();	workingBSplines.push_back(bsp);		bsp->RemoveControlPoint(controlPoint, deleteAllControlPoints);		vector<BSpline*> affectedBSplines;	if (!gDrawing->TestBSplineForEnoughControlPoints(bsp, affectedBSplines))	{		workingBSplines.clear();		hilightedBSpline = NULL;		hilightCode = -1;		hilightedIntersection = NULL;				CreateLegalLabeling(affectedBSplines);	}		vector<BSpline*> bsplineIntersDeleted;	bool intersChanged = HandleIntersectionChanges(bsp, bsplineIntersDeleted, false, false);	BackupCurvePoints(bsp);		MyAssert(bsp->MakeIntersectionList());	bsp->EqualizeNumberOfSections();		affectedBSplines.push_back(bsp);	gDrawing->FindWholeObjects2(affectedBSplines);		bsp->BackupCurvePoints();	vector<BSplineToBSplineCut*> cuts = gDrawing->GetCutsForOneBSpline(bsp);	cuts = gDrawing->GetCutsForOneBSpline(bsp);	for (int ii = 0; ii < cuts.size(); ii++)		cuts[ii]->BackupStartEndLocs();		CreateLegalLabeling(gDrawing->GetBSplines());		workingBSplines.clear();		IncrementUndoStack();}void MainWindow::ChangeBSplineDegree(BSpline* bsp, bool decrementDegree){	workingBSplines.clear();	workingBSplines.push_back(bsp);		//cmdKey should be false anyway if it gets here, so just use false	bsp->ChangeDegree(decrementDegree);	//bsp->CleanUpIntersections(gDrawing->GetBSplines(), gDrawing->GetCuts());	gDrawing->RemoveAndRefindIntersections(bsp);	MyAssert(bsp->MakeIntersectionList());	bsp->EqualizeNumberOfSections();		vector<BSpline*> affectedBSplines;	affectedBSplines.push_back(bsp);	gDrawing->FindWholeObjects2(affectedBSplines);		bsp->BackupCurvePoints();	vector<BSplineToBSplineCut*> cuts = gDrawing->GetCutsForOneBSpline(bsp);	for (int ii = 0; ii < cuts.size(); ii++)		cuts[ii]->BackupStartEndLocs();		CreateLegalLabeling(gDrawing->GetBSplines());		workingBSplines.clear();		IncrementUndoStack();}void MainWindow::ChangeControlPoint(BSpline* bsp, int controlPoint, bool moveAllControlPoints){	workingBSplines.clear();	workingBSplines.push_back(bsp);		workingControlPoint = controlPoint;	HandleExistingControlPoint(controlPoint, moveAllControlPoints);		workingBSplines.clear();		IncrementUndoStack();}#pragma mark -bool MainWindow::FlipIntersection(int intersectionPoint){	//Can't flip a nonBspBsp intersection	vector<GenericIntersection*> intersections = gDrawing->GetIntersections();	if (intersections[intersectionPoint]->GetType() != GenericIntersection::BSP_BSP)	{		SysBeep(1);		return false;	}		//Can't flip a permamently constrained intersection	if (intersections[intersectionPoint]->GetPermanentHardConstraint())	{		SysBeep(1);		return false;	}		GrabWorkingIndexes();	bool success = gDrawing->FlipAndLabel(intersectionPoint);	if (!success)		SysBeep(1);	RestoreWorkingIndexes();		IncrementUndoStack();		return success;}void MainWindow::ToggleIntersectionPermanentContraint(int intersectionPoint, bool toggleCompSet){	//Can't constraint a nonBspBsp intersection	vector<GenericIntersection*> intersections = gDrawing->GetIntersections();	if (intersections[intersectionPoint]->GetType() != GenericIntersection::BSP_BSP)	{		SysBeep(1);		return;	}		//gDrawing->ToggleIntersectionPermanentContraint(intersectionPoint);		gDrawing->SetIntersectionPermanentContraint(intersectionPoint, toggleCompSet, !intersections[intersectionPoint]->GetPermanentHardConstraint());		IncrementUndoStack();}void MainWindow::SplitControlBoundarySegment(BSpline* bsp, int controlBoundarySegment, Point newControlPointPos){	workingBSplines.clear();	workingBSplines.push_back(bsp);		//cmdKey should be false anyway if it gets here, so just use false	bsp->SplitControlBoundarySegment(controlBoundarySegment, FloatPoint(newControlPointPos));		//Remove cuts for the BSpline	vector<BSplineToBSplineCut*> cuts;// = gDrawing->GetCutsForOneBSpline(bsp);	//for (int i = 0; i < cuts.size(); i++)	//	gDrawing->RemoveCut(cuts[i], true);		MyAssert(bsp->MakeIntersectionList());	bsp->EqualizeNumberOfSections();		//cmdKey should be false anyway if it gets here, so just use false	//bsp->CleanUpIntersections(gDrawing->GetBSplines(), gDrawing->GetCuts());	gDrawing->RemoveAndRefindIntersections(bsp);	MyAssert(bsp->MakeIntersectionList());	bsp->EqualizeNumberOfSections();	vector<BSpline*> testBSplines;	testBSplines.push_back(bsp);	gDrawing->FindWholeObjects2(testBSplines);		bsp->BackupCurvePoints();	cuts = gDrawing->GetCutsForOneBSpline(bsp);	for (int ii = 0; ii < cuts.size(); ii++)		cuts[ii]->BackupStartEndLocs();		CreateLegalLabeling(gDrawing->GetBSplines());		workingControlPoint = controlBoundarySegment + 1;		Redraw();	HandleExistingControlPoint(workingControlPoint, false);		workingBSplines.clear();		IncrementUndoStack();}void MainWindow::FlipSignOfOcclusion(BSpline* bsp){	workingBSplines.clear();	workingBSplines.push_back(bsp);		bsp->ReverseControlPointOrder();		//Break the bsp out of its whole object	gDrawing->RemoveBspFromWholeObject(bsp);		//Really shouldn't be necessary to redo the intersections.  Just switch them around some.	//But for now, do it the ugly way.	//bsp->CleanUpIntersections(gDrawing->GetBSplines(), gDrawing->GetCuts());	gDrawing->RemoveAndRefindIntersections(bsp);	MyAssert(bsp->MakeIntersectionList());	bsp->EqualizeNumberOfSections();	vector<BSpline*> testBSplines;	testBSplines.push_back(bsp);	gDrawing->FindWholeObjects2(testBSplines);		bsp->BackupCurvePoints();		vector<BSplineToBSplineCut*> cuts = gDrawing->GetCutsForOneBSpline(bsp);	for (int ii = 0; ii < cuts.size(); ii++)		cuts[ii]->BackupStartEndLocs();		vector<BSpline*> affectedBSplines;	affectedBSplines.push_back(bsp);	CreateLegalLabeling(affectedBSplines);		Redraw();		workingBSplines.clear();		IncrementUndoStack();}#pragma mark -void MainWindow::SelectBSpline(BSpline* bsp, int controlPoint, bool dontWipeList){	moveAllControlPoints = true;		vector<BSpline*>::iterator iter = find(workingBSplines.begin(), workingBSplines.end(), bsp);		vector<BSpline*> affectedBSplines;	gDrawing->GetBSplinesInGroupFromBSpline(bsp, affectedBSplines);		//If the BSpline already exists in the working BSpline list and the control key is down, remove it	if (iter != workingBSplines.end())	{		if (dontWipeList)		{			for (int i = 0; i < affectedBSplines.size(); i++)			{				vector<BSpline*>::iterator iter1 = find(workingBSplines.begin(), workingBSplines.end(), affectedBSplines[i]);				if (iter1 != workingBSplines.end())					workingBSplines.erase(iter1);			}		}		else if (controlPoint != -1)		{			int i = 0;			while (i < workingBSplines.size() && workingBSplines[i] != bsp)				i++;			MyAssert(i != workingBSplines.size());			workingBSplines[i] = workingBSplines[0];			workingBSplines[0] = bsp;			HandleExistingControlPoint(controlPoint, true);		}	}	else	//Bspline isn't in the working BSpline list yet	{		if (!dontWipeList)	//If BSpline is not in list and control key is not down, remove present list before adding		{			workingBSplines.clear();						for (int i = 0; i < affectedBSplines.size(); i++)				if (find(workingBSplines.begin(), workingBSplines.end(), affectedBSplines[i]) == workingBSplines.end())					workingBSplines.push_back(affectedBSplines[i]);						if (controlPoint != -1)			{				int i = 0;				while (i < workingBSplines.size() && workingBSplines[i] != bsp)					i++;				MyAssert(i != workingBSplines.size());				workingBSplines[i] = workingBSplines[0];				workingBSplines[0] = bsp;							HandleExistingControlPoint(controlPoint, true);			}		}		else	//If BSpline is not in list and control key is down, add or remove without cleaning out the list		{			if (iter == workingBSplines.end())			{				for (int i = 0; i < affectedBSplines.size(); i++)					if (find(workingBSplines.begin(), workingBSplines.end(), affectedBSplines[i]) == workingBSplines.end())						workingBSplines.push_back(affectedBSplines[i]);								if (controlPoint != -1)				{					int i = 0;					while (i < workingBSplines.size() && workingBSplines[i] != bsp)						i++;					MyAssert(i != workingBSplines.size());					workingBSplines[i] = workingBSplines[0];					workingBSplines[0] = bsp;									HandleExistingControlPoint(controlPoint, true);				}			}			else			{				for (int i = 0; i < affectedBSplines.size(); i++)				{					vector<BSpline*>::iterator iter1 = find(workingBSplines.begin(), workingBSplines.end(), affectedBSplines[i]);					if (iter1 != workingBSplines.end())						workingBSplines.erase(iter1);				}			}		}	}		IncrementUndoStack();}#pragma mark -void MainWindow::CreateNewBSpline(Point firstControlPointPos){	if (workingBSplines.size() == 0)	{		workingBSplines.push_back(new BSpline(gDrawing));		gDrawing->AddBSpline(workingBSplines.front());		workingBSplines.front()->AddControlPoint(FloatPoint(firstControlPointPos));	}		lastDroppedControlPointLoc = lastWhere = firstControlPointPos;		workingControlPoint = -1;}void MainWindow::DeleteBSpline(BSpline* bsp){	vector<BSpline*> affectedBSplines;	gDrawing->GetBSplinesInGroupFromBSpline(bsp, affectedBSplines);	for (vector<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)		if (*i == bsp)		{			affectedBSplines.erase(i);			break;		}		gDrawing->RemoveBSpline(bsp);	delete bsp;	workingBSplines.clear();	hilightedBSpline = NULL;	hilightCode = -1;	hilightedIntersection = NULL;		gDrawing->EqualizeNumberOfSections();		CreateLegalLabeling(affectedBSplines);		IncrementUndoStack();}#pragma mark -void MainWindow::Nudge(NudgeDir dir, bool largeNudge){	if (workingControlPoint != -1 || workingBSplines.size() == 0)		return;		Point nudge = { 0, 0 };	switch (dir)	{		case LEFT:	nudge.h = -1;	break;		case RIGHT:	nudge.h = 1;	break;		case UP:	nudge.v = -1;	break;		case DOWN:	nudge.v = 1;	break;	}	if (largeNudge)	{		nudge.h *= 10;		nudge.v *= 10;	}		list<BSpline*> affectedBSplines;		//Build a list of all affected BSplines	MyAssert(workingBSplines.size() > 0);	for (vector<BSpline*>::iterator i = workingBSplines.begin(); i != workingBSplines.end(); i++)	{		if (find(affectedBSplines.begin(), affectedBSplines.end(), *i) == affectedBSplines.end())			affectedBSplines.push_back(*i);				if (cmdKey)	//If doing a translation instead of a reshape, move all objects in the group at once		{			vector<BSpline*> groupBSplines;			gDrawing->GetBSplinesInGroupFromBSpline(*i, groupBSplines);						for (vector<BSpline*>::iterator j = groupBSplines.begin(); j != groupBSplines.end(); j++)				if (find(affectedBSplines.begin(), affectedBSplines.end(), *j) == affectedBSplines.end())					affectedBSplines.push_back(*j);		}	}		for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)		(*i)->ConstrainMoveWithinCanvas(nudge, canvasSize);		bool windingNumberChanged = false;	vector<BSpline*> bsplineIntersDeleted;	MyAssert(affectedBSplines.size() > 0);	for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)	{		FloatPoint prevWhere = (*i)->GetControlPointPosition(0);		FloatPoint newPos;		newPos.h = prevWhere.h + nudge.h;		newPos.v = prevWhere.v + nudge.v;				//Changing the control point will also reshape the BSpline's curves		if ((*i)->ChangeControlPoint(0, FloatPoint(newPos), true, canvasSize))			if (!windingNumberChanged)				windingNumberChanged = true;	}		bool rippleLabel = false;	for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)	{		bool intersChanged = HandleIntersectionChanges(*i, bsplineIntersDeleted, false, cmdKey);				rippleLabel = (rippleLabel || windingNumberChanged || intersChanged);				gDrawing->VerifyNothingDtored();	}	for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)		BackupCurvePoints(*i);		if (rippleLabel)	{		vector<BSpline*> affectBSplinesVector;		for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)			affectBSplinesVector.push_back(*i);				for (list<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)		{			//Find BSplines connected by cuts			vector<BSpline*> groupBSplines;			gDrawing->GetBSplinesInGroupFromBSpline(*i, groupBSplines);						for (vector<BSpline*>::iterator j = groupBSplines.begin(); j != groupBSplines.end(); j++)				if (find(affectBSplinesVector.begin(), affectBSplinesVector.end(), *j) == affectBSplinesVector.end())					affectBSplinesVector.push_back(*j);		}				//Add bsplines that used to be connected by now-deleted intersections		for (int i = 0; i < bsplineIntersDeleted.size(); i++)			if (find(affectBSplinesVector.begin(), affectBSplinesVector.end(), bsplineIntersDeleted[i]) == affectBSplinesVector.end())				affectBSplinesVector.push_back(bsplineIntersDeleted[i]);				gDrawing->VerifyNothingDtored();				CreateLegalLabeling(affectBSplinesVector);	}	else	{		//gDrawing->VerifyLegalIntersections();		gDrawing->SetAllIntersectionsNoHardConstraint();	}		Redraw();}	#pragma mark -void MainWindow::ChangeObjectReflectance(BSpline* bsp, Point where){	SetPort(GetWindowPort(window));	LocalToGlobal(&where);		SurfaceTraits surfaceTraits = bsp->GetSurfaceTraits();	int sliderPos = surfaceTraits.interiorReflectance * 100.0;		SetPort(GetWindowPort(gReflectanceSliderWindow));	Rect winBounds;	GetPortBounds(GetWindowPort(gReflectanceSliderWindow), &winBounds);		MoveWindow(gReflectanceSliderWindow, where.h - (sliderPos + 10), where.v - 10, false);	BringToFront(gReflectanceSliderWindow);	ShowWindow(gReflectanceSliderWindow);		EraseRect(&winBounds);	ForeColor(blackColor);	MoveTo(10, 15);	Line(100, 0);		Rect sliderRect;	SetRect(&sliderRect, 0, 0, 9, 20);		OffsetRect(&sliderRect, sliderPos + 6, 5);	PaintOval(&sliderRect);		MouseTrackingResult trackingResult = kMouseTrackingMouseDown;		while (trackingResult != kMouseTrackingMouseUp)	{		SetPort(GetWindowPort(gReflectanceSliderWindow));		TrackMouseLocation(NULL, &where, &trackingResult);				if (trackingResult != kMouseTrackingMouseDragged)			continue;				timeOfLastUserMotion = clock();				sliderPos = where.h - 10;		if (sliderPos < 0)			sliderPos = 0;		else if (sliderPos > 100)			sliderPos = 100;				EraseRect(&winBounds);		ForeColor(blackColor);		MoveTo(10, 15);		Line(100, 0);				SetRect(&sliderRect, 0, 0, 9, 20);		OffsetRect(&sliderRect, sliderPos + 6, 5);		PaintOval(&sliderRect);				gDrawing->ChangeObjectReflectance(bsp, (double)sliderPos / 100.0);		Redraw();				if (autoExportPict)			ExportToPict(false);	}		HideWindow(gReflectanceSliderWindow);		IncrementUndoStack();}#pragma mark -void MainWindow::SnapToGrid(Point& p){	if (snapToGrid)		grid->SnapToGrid(p);}#pragma mark -void MainWindow::CreateBSplineFromControlPointList(vector<FloatPoint> controlPoints){	gDrawing->ClearBrandNewIntersections();		BSpline* bsp = new BSpline(gDrawing);	gDrawing->AddBSpline(bsp);	for (int i = 0; i < controlPoints.size(); i++)		bsp->AddControlPoint(controlPoints[i]);		vector<BSpline*> bsplineIntersDeleted;	bool intersChanged = HandleIntersectionChanges(bsp, bsplineIntersDeleted, false, false);	BackupCurvePoints(bsp);		gDrawing->VerifyNothingDtored();	/*	vector<BSpline*> affectBSplinesVector;	affectBSplinesVector.push_back(bsp);		gDrawing->VerifyNothingDtored();		CreateLegalLabeling(affectBSplinesVector);	*/	Redraw();}#pragma mark -void MainWindow::DoNonSuperSplineIntersectionClickError(){	vector<const char*> errLines;	errLines.push_back("You have clicked on an intersection.");	errLines.push_back("Are you trying to flip the intersection?");	errLines.push_back("If so, please select the Super Spline tool first.");	DoErrorMessage(errLines);}void MainWindow::DoNonSuperSplineOrNewSplineOpenSpaceClickError(){	vector<const char*> errLines;	errLines.push_back("You have clicked on open space.");	errLines.push_back("Are you trying to create a new spline?");	errLines.push_back("If so, please select the Super Spline or New Spline tool first.");	DoErrorMessage(errLines);}#pragma mark -void MainWindow::CreateLegalLabeling(){	vector<BSpline*> bsplines;	CreateLegalLabeling(bsplines);}void MainWindow::CreateLegalLabeling(vector<BSpline*> bsplines){	clock_t timeSinceLastUserMotion = clock() - timeOfLastUserMotion;	long sec100thsSinceLastUserMotion = timeSinceLastUserMotion / (CLOCKS_PER_SEC / 100);	if (sec100thsSinceLastUserMotion < 25)	//Wait a while after the user stops moving the mouse to try labeling	{		labelPending = true;	//I'm not clear on the utility of this variable.  Perhaps it can be completely removed from the project.				if (labelingAttemptPendingTimer)		{			RemoveEventLoopTimer(labelingAttemptPendingTimer);			labelingAttemptPendingTimer = NULL;		}				if (!labelingAttemptPendingTimer)			InstallEventLoopTimer(GetMainEventLoop(), 0, .25 * kEventDurationSecond,							NewEventLoopTimerUPP(LabelingAttemptPendingEventHandler), NULL, &labelingAttemptPendingTimer);				SetPort(GetWindowPort(window));		return;	//Still waiting for the user to stop moving and a delay to pass, so return	}		if (labelingAttemptPendingTimer)	{		RemoveEventLoopTimer(labelingAttemptPendingTimer);		labelingAttemptPendingTimer = NULL;	}		GrabWorkingIndexes();	bool success;	if (bsplines.size() > 0)		success = gDrawing->CreateLegalLabeling(bsplines, workingBSplines.size() != 0);	else success = gDrawing->CreateLegalLabeling(gDrawing->GetBSplines(), workingBSplines.size() != 0);	RestoreWorkingIndexes();		if (labelPending)		Redraw();		if (success)		ReplaceTopOfUndoStack();		//if (success)		labelPending = false;	/*else	//If the labeling failed, schedule a retry in the future	{		timeOfLastUserMotion = clock();		labelPending = true;				MyAssert(!labelingAttemptPendingTimer);		InstallEventLoopTimer(GetMainEventLoop(), 0, 3 * kEventDurationSecond,						NewEventLoopTimerUPP(LabelingAttemptPendingEventHandler), NULL, &labelingAttemptPendingTimer);	}*/		SetPort(GetWindowPort(window));	//Important, TrackMouseDown events (like in HandleExistingControlPoint) need this}void MainWindow::StopLabelingAttempt(){	SysBeep(1);}void MainWindow::ClearLabeling(){	gDrawing->ClearLabeling();		workingBSplines.clear();	hilightedBSpline = NULL;	hilightCode = -1;	hilightedIntersection = NULL;		Redraw();}void MainWindow::ClearDepths(){	gDrawing->ClearDepths();		workingBSplines.clear();	hilightedBSpline = NULL;	hilightCode = -1;	hilightedIntersection = NULL;		Redraw();}#pragma mark -void MainWindow::ProcessData(LogData& logData){	logData.numData = runningTimesAndNodes.size();	if (logData.numData > 0)	{		//for (int i = 0; i < logData.numData; i++)		//	MyAssert(runningTimesAndNodes[i].second == numNodes);				for (int i = 0; i < logData.numData; i++)		{			logData.runningTimes.push_back(runningTimesAndNodes[i].first);			logData.nodes.push_back(runningTimesAndNodes[i].second);		}		sort(logData.runningTimes.begin(), logData.runningTimes.end());		sort(logData.nodes.begin(), logData.nodes.end());				logData.rtMin = logData.runningTimes[0];		logData.rtMax = logData.runningTimes.back();		logData.nodesMin = logData.nodes[0];		logData.nodesMax = logData.nodes.back();				logData.rtMedian = logData.runningTimes[logData.numData / 2];		logData.nodesMedian = logData.nodes[logData.numData / 2];				logData.rtMean = 0;		logData.nodesMean = 0;		for (int i = 0; i < logData.numData; i++)		{			logData.rtMean += logData.runningTimes[i];			logData.nodesMean += logData.nodes[i];		}		logData.rtMean /= logData.numData;		logData.nodesMean /= logData.numData;				logData.rtVar = 0;		logData.nodesVar = 0;		for (int i = 0; i < logData.numData; i++)		{			logData.rtVar += (logData.runningTimes[i] - logData.rtMean) * (logData.runningTimes[i] - logData.rtMean);			logData.nodesVar += (logData.nodes[i] - logData.nodesMean) * (logData.nodes[i] - logData.nodesMean);		}		if (logData.numData > 1)		{			logData.rtVar /= (logData.numData - 1);			logData.nodesVar /= (logData.numData - 1);		}				logData.rtSD = sqrt(logData.rtVar);		logData.nodesSD = sqrt(logData.nodesVar);				logData.rtSEM = logData.rtSD / sqrt(logData.numData);	//standard error mean		logData.nodesSEM = logData.nodesSD / sqrt(logData.numData);	//standard error mean				logData.rt95percentCI = logData.rtSEM * 1.96;	//1.96 is only good for large samples (n > 30).  I'm not sure what to do for small samples.		logData.nodes95percentCI = logData.nodesSEM * 1.96;	//1.96 is only good for large samples (n > 30).  I'm not sure what to do for small samples.	}}void MainWindow::ToggleDataLogging(){	vector<string> lines;	if (dataLoggingOn)	{		//http://www.graphpad.com/articles/interpret/principles/stat_principles.htm		int numData = runningTimesAndNodes.size();		if (numData > 0)		{			LogData logData;			ProcessData(logData);						//============================================						WriteLogData(string("Results"), string("========================="));						WriteSearchParametersToLog();						Str255 str1;			string string1;						NumToString(numData, str1);			PascalToString(str1, string1);			WriteLogData(string("Num_data"), string1);						stringstream ss1;			for (int i = 0; i < numData; i++)			{				ss1 << logData.runningTimes[i];				if (i != numData - 1)					ss1 << "\t";			}			WriteLogData(string("Running_times"), ss1.str());						stringstream ss2;			for (int i = 0; i < numData; i++)			{				ss2 << logData.nodes[i];				if (i != numData - 1)					ss2 << "\t";			}			WriteLogData(string("Nodes"), ss2.str());						//============================================						FloatToPascal(logData.rtMedian, 5, str1);			PascalToString(str1, string1);			WriteLogData(string("RT_Median"), string1);						FloatToPascal(logData.rtMean, 5, str1);			PascalToString(str1, string1);			WriteLogData(string("RT_Mean"), string1);						FloatToPascal(logData.rtVar, 5, str1);			PascalToString(str1, string1);			WriteLogData(string("RT_Var"), string1);						FloatToPascal(logData.rtSD, 5, str1);			PascalToString(str1, string1);			WriteLogData(string("RT_Std_dev"), string1);						FloatToPascal(logData.rtSEM, 5, str1);			PascalToString(str1, string1);			WriteLogData(string("RT_Std_err_mean"), string1);						FloatToPascal(logData.rt95percentCI, 5, str1);			PascalToString(str1, string1);			WriteLogData(string("RT_95_percent"), string1);						//============================================						FloatToPascal(logData.nodesMedian, 5, str1);			PascalToString(str1, string1);			WriteLogData(string("Nd_Median"), string1);						FloatToPascal(logData.nodesMean, 5, str1);			PascalToString(str1, string1);			WriteLogData(string("Nd_Mean"), string1);						FloatToPascal(logData.nodesVar, 5, str1);			PascalToString(str1, string1);			WriteLogData(string("Nd_Var"), string1);						FloatToPascal(logData.nodesSD, 5, str1);			PascalToString(str1, string1);			WriteLogData(string("Nd_Std_dev"), string1);						FloatToPascal(logData.nodesSEM, 5, str1);			PascalToString(str1, string1);			WriteLogData(string("Nd_Std_err_mean"), string1);						FloatToPascal(logData.nodes95percentCI, 5, str1);			PascalToString(str1, string1);			WriteLogData(string("Nd_95_percent"), string1);						//============================================						runningTimesAndNodes.clear();		}				WriteLogData(string("Close_log"), string("========================================================"));		dataLoggingOn = false;	}	else	{		dataLoggingOn = true;		runningTimesAndNodes.clear();		WriteLogData(string("Open_log"), string("========================================================"));	}		if (!dataLoggingOn && dataLogNote)	{		delete dataLogNote;		dataLogNote = NULL;	}}bool MainWindow::GetDataLoggingOn(){	return dataLoggingOn;}void MainWindow::ToggleDataLogNote(){	if (!dataLoggingOn)		return;		if (dataLogNote)	{		if (dataLogNote->length() > 0)		{			dataLogTextV -= 10;			WriteLogData(string("Note"), *dataLogNote);		}		else		{			SetPort(GetWindowPort(gDataLogWindow));			Rect r;			GetPortBounds(GetWindowPort(gDataLogWindow), &r);			r.top = dataLogTextV - 8;			r.bottom = dataLogTextV + 2;			EraseRect(&r);			dataLogTextV -= 10;		}		delete dataLogNote;		dataLogNote = NULL;	}	else	{		dataLogNote = new string("");				SetPort(GetWindowPort(gDataLogWindow));		Rect bounds;		GetPortBounds(GetWindowPort(gDataLogWindow), &bounds);		TextSize(9);		ForeColor(cyanColor);		Str255 str1;				dataLogTextV += 10;		if (dataLogTextV > bounds.bottom - 2)		{			EraseRect(&bounds);			dataLogTextV = 15;		}				CtoPascal(dataLogNote->c_str(), str1);		MoveTo(10, dataLogTextV);		DrawString("\pNote                ");		DrawString(str1);		QDFlushPortBuffer(GetWindowPort(gDataLogWindow), NULL);	}}bool MainWindow::GetDataLogNoteInProgress(){	return (dataLogNote != NULL);}void MainWindow::AppendDataLogNote(char c){	if (!dataLoggingOn || !dataLogNote)		return;		if (c == '\b')	{		if (dataLogNote->length() > 0)			dataLogNote->pop_back();		else SysBeep(1);	}	else *dataLogNote += c;		SetPort(GetWindowPort(gDataLogWindow));	Rect r;	GetPortBounds(GetWindowPort(gDataLogWindow), &r);	r.top = dataLogTextV - 8;	r.bottom = dataLogTextV + 2;	EraseRect(&r);	TextSize(9);	ForeColor(cyanColor);	Str255 str1;	CtoPascal(dataLogNote->c_str(), str1);	MoveTo(10, dataLogTextV);	DrawString("\pNote                ");	DrawString(str1);	QDFlushPortBuffer(GetWindowPort(gDataLogWindow), NULL);}void MainWindow::WriteLogData(string header, string line){	if (!dataLoggingOn)		return;		//ofstream ofs;	//ofs.open("druidDataLog", ofstream::app);	//if (!ofs)	//	return;		SetPort(GetWindowPort(gDataLogWindow));	TextFont(FMGetFontFamilyFromName("\pMonaco"));	Rect bounds;	GetPortBounds(GetWindowPort(gDataLogWindow), &bounds);	TextSize(9);	ForeColor(blackColor);	Str255 str1;	dataLogTextV += 10;	if (dataLogTextV > bounds.bottom - 2)	{		EraseRect(&bounds);		dataLogTextV = 15;	}	MoveTo(10, dataLogTextV);	CtoPascal(header.c_str(), str1);	DrawString(str1);	int headerMaxLen = 30;	for (int i = 0; i < headerMaxLen - header.length(); i++)		DrawString("\p ");	CtoPascal(line.c_str(), str1);	DrawString(str1);	QDFlushPortBuffer(GetWindowPort(gDataLogWindow), NULL);		/*ofs*/(*gOutputFileStream) << header;	for (int i = 0; i < headerMaxLen - header.length(); i++)		/*ofs*/(*gOutputFileStream) << " ";	/*ofs*/(*gOutputFileStream) << line << endl;		//MyAssert(ofs);	//ofs.close();}void MainWindow::WriteSearchParametersToLog(){	if (!dataLoggingOn)		return;		stringstream ss;	ss << gLabelingMethod << "\t" << gCompanionSetMethod << "\t" << gDepthEnumerationMethod << "\t" << gBoundingMethod << "\t" << gTreeSearchMethod << "\t" << gTimeLimitScalar;		WriteLogData(string("Search_parameters"), ss.str());}void MainWindow::AddRunningTime(long double rt, int numNodes){	if (!dataLoggingOn)		return;		if (gTestType == 0 ||		(gTestType == 1 && (runningTimesAndNodes.size() == 0 || numNodes == runningTimesAndNodes[0].second)))	{		runningTimesAndNodes.push_back(pair<long double, int>(rt, numNodes));				SetPort(GetWindowPort(gDataLogWindow));		Rect bounds;		GetPortBounds(GetWindowPort(gDataLogWindow), &bounds);		TextSize(9);		ForeColor(redColor);		dataLogTextV += 10;		if (dataLogTextV > bounds.bottom - 2)		{			EraseRect(&bounds);			dataLogTextV = 15;		}		Str255 str1;		MoveTo(10, dataLogTextV);		DrawString("\pNew_running_time    ");		NumToString(runningTimesAndNodes.size(), str1);		DrawString(str1);		DrawString("\p     ");		FloatToPascal(rt, 5, str1);		DrawString(str1);		DrawString("\p     ");		NumToString(numNodes, str1);		DrawString(str1);		QDFlushPortBuffer(GetWindowPort(gDataLogWindow), NULL);	}}#pragma mark -void MainWindow::RunTests(int testType){	if (gOutputFileStream)		delete gOutputFileStream;	gOutputFileStream = new stringstream;		MyAssert(testType == 0 || testType == 1);	gTestType = testType;		int numData;	long double rtMedian, nodesMedian,				rtMean, nodesMean,				rtVar,  nodesVar,				rtSD, nodesSD,				rtSEM, nodesSEM,				rt95percentCI, nodes95percentCI;					if (gTestType == 1)	{		LogData notUsed;		RunTestsOneSearchParameters(-1, -1, notUsed);	}	else	{		bool whichTestsMask[19] = { false };		whichTestsMask[3] = true;				int numTestRounds = 0;		for (int i = 0; i < 19; i++)			if (whichTestsMask[i])				numTestRounds++;				vector<LogData> logDatas;		for (int i = 0; i < 19; i++)		{			if (!whichTestsMask[i])				continue;						switch (i)			{				//No search				case 0:					gLabelingMethod = 1;					gCompanionSetMethod = 2;					gDepthEnumerationMethod = 2;					gTreeSearchMethod = 1;					gBoundingMethod = 1;					break;								//Search				//Bounding enabled				//Iterative deepening enabled				case 1:					gLabelingMethod = 0;					gCompanionSetMethod = 2;					gDepthEnumerationMethod = 2;					gTreeSearchMethod = 1;					gBoundingMethod = 1;					break;				case 2:					gLabelingMethod = 0;					gCompanionSetMethod = 1;					gDepthEnumerationMethod = 2;					gTreeSearchMethod = 1;					gBoundingMethod = 1;					break;				case 3:					gLabelingMethod = 0;					gCompanionSetMethod = 0;					gDepthEnumerationMethod = 2;					gTreeSearchMethod = 1;					gBoundingMethod = 1;					break;				case 4:					gLabelingMethod = 0;					gCompanionSetMethod = 2;					gDepthEnumerationMethod = 1;					gTreeSearchMethod = 1;					gBoundingMethod = 1;					break;				case 5:					gLabelingMethod = 0;					gCompanionSetMethod = 1;					gDepthEnumerationMethod = 1;					gTreeSearchMethod = 1;					gBoundingMethod = 1;					break;				case 6:					gLabelingMethod = 0;					gCompanionSetMethod = 0;					gDepthEnumerationMethod = 1;					gTreeSearchMethod = 1;					gBoundingMethod = 1;					break;								//Bounding enabled				//Iterative deepening disabled				case 7:					gLabelingMethod = 0;					gCompanionSetMethod = 2;					gDepthEnumerationMethod = 2;					gTreeSearchMethod = 0;					gBoundingMethod = 1;					break;				case 8:					gLabelingMethod = 0;					gCompanionSetMethod = 1;					gDepthEnumerationMethod = 2;					gTreeSearchMethod = 0;					gBoundingMethod = 1;					break;				case 9:					gLabelingMethod = 0;					gCompanionSetMethod = 0;					gDepthEnumerationMethod = 2;					gTreeSearchMethod = 0;					gBoundingMethod = 1;					break;				case 10:					gLabelingMethod = 0;					gCompanionSetMethod = 2;					gDepthEnumerationMethod = 1;					gTreeSearchMethod = 0;					gBoundingMethod = 1;					break;				case 11:					gLabelingMethod = 0;					gCompanionSetMethod = 1;					gDepthEnumerationMethod = 1;					gTreeSearchMethod = 0;					gBoundingMethod = 1;					break;				case 12:					gLabelingMethod = 0;					gCompanionSetMethod = 0;					gDepthEnumerationMethod = 1;					gTreeSearchMethod = 0;					gBoundingMethod = 1;					break;								//Bounding disabled				//Iterative deepening disabled				case 13:					gLabelingMethod = 0;					gCompanionSetMethod = 2;					gDepthEnumerationMethod = 2;					gTreeSearchMethod = 0;					gBoundingMethod = 0;					break;				case 14:					gLabelingMethod = 0;					gCompanionSetMethod = 1;					gDepthEnumerationMethod = 2;					gTreeSearchMethod = 0;					gBoundingMethod = 0;					break;				case 15:					gLabelingMethod = 0;					gCompanionSetMethod = 0;					gDepthEnumerationMethod = 2;					gTreeSearchMethod = 0;					gBoundingMethod = 0;					break;				case 16:					gLabelingMethod = 0;					gCompanionSetMethod = 2;					gDepthEnumerationMethod = 1;					gTreeSearchMethod = 0;					gBoundingMethod = 0;					break;				case 17:					gLabelingMethod = 0;					gCompanionSetMethod = 1;					gDepthEnumerationMethod = 1;					gTreeSearchMethod = 0;					gBoundingMethod = 0;					break;				case 18:					gLabelingMethod = 0;					gCompanionSetMethod = 0;					gDepthEnumerationMethod = 1;					gTreeSearchMethod = 0;					gBoundingMethod = 0;					break;				default:					MyAssert(false);			}						LogData logData;			RunTestsOneSearchParameters(logDatas.size(), numTestRounds, logData);			logDatas.push_back(logData);		}				MyAssert(!dataLoggingOn);		ToggleDataLogging();				for (int i = 0; i < 8; i++)		{			string header;			switch (i)			{				case 0:	header = "Running_times_min";	break;				case 1:	header = "Running_times_max";	break;				case 2:	header = "Running_times_mean";	break;				case 3:	header = "Running_times_median";	break;				case 4:	header = "Nodes_min";	break;				case 5:	header = "Nodes_max";	break;				case 6:	header = "Nodes_mean";	break;				case 7:	header = "Nodes_median";	break;			}			WriteLogData(header, string("---------------"));						for (int j = 0; j < logDatas.size(); j++)			{				stringstream ss;				/*				switch (j)				{					case 0:	ss << 0;	break;										case 1:	ss << 2;	break;					case 2:	ss << 3;	break;					case 3:	ss << 4;	break;					case 4:	ss << 5;	break;					case 5:	ss << 6;	break;					case 6:	ss << 7;	break;										case 7:	ss << 9;	break;					case 8:	ss << 10;	break;					case 9:	ss << 11;	break;					case 10:	ss << 12;	break;					case 11:	ss << 13;	break;					case 12:	ss << 14;	break;										case 13:	ss << 16;	break;					case 14:	ss << 17;	break;					case 15:	ss << 18;	break;					case 16:	ss << 19;	break;					case 17:	ss << 20;	break;					case 18:	ss << 21;	break;				}				*/				ss << j;								ss << "\t";								switch (i)				{					case 0:	ss << logDatas[j].rtMin;	break;					case 1:	ss << logDatas[j].rtMax;	break;					case 2:	ss << logDatas[j].rtMean;	break;					case 3:	ss << logDatas[j].rtMedian;	break;					case 4:	ss << logDatas[j].nodesMin;	break;					case 5:	ss << logDatas[j].nodesMax;	break;					case 6:	ss << logDatas[j].nodesMean;	break;					case 7:	ss << logDatas[j].nodesMedian;	break;				}								WriteLogData(ss.str(), string(""));			}		}				ToggleDataLogging();	}		ofstream ofs;	ofs.open("druidDataLog", ofstream::app);	if (ofs)	{		ofs << gOutputFileStream->str();		ofs.close();		delete gOutputFileStream;		gOutputFileStream = NULL;	}}void MainWindow::RunTestsOneSearchParameters(int whichCase, int numCases, LogData& logData){	int testType = gTestType;		int numSamples = 1;	switch (gTestType)	{		case 0:			numSamples = 1;			break;		case 1:			numSamples = 10;			break;		default:			MyAssert(false);	}		testIntersectionIndexes.clear();	vector<GenericIntersection*> intersections = gDrawing->GetIntersections();	for (int i = 0; i < intersections.size(); i++)		if (intersections[i]->GetPermanentHardConstraint())		{			testIntersectionIndexes.push_back(i);			intersections[i]->SetPermanentHardConstraint(false);		}		if (gTestType == 1 && testIntersectionIndexes.size() != 1)	{		SysBeep(1);		gTestType = 0;		for (int i = 0; i < testIntersectionIndexes.size(); i++)			intersections[testIntersectionIndexes[i]]->SetPermanentHardConstraint(true);		return;	}		if (!dataLoggingOn)		ToggleDataLogging();		int numFlips = testIntersectionIndexes.size() * 2 * numSamples;	for (int i = 0; i < numFlips; i++)	{		int flipIntersectionIndex = i / (2 * numSamples);		bool success = FlipIntersection(testIntersectionIndexes[flipIntersectionIndex]);				if (!success && gLabelingMethod == 0)		{			int prevLabelingMethod = gLabelingMethod;			gLabelingMethod = 1;						if (gDebug5)			{				SetPort(GetWindowPort(gDataLogWindow));				Rect bounds;				GetPortBounds(GetWindowPort(gDataLogWindow), &bounds);				TextSize(9);				dataLogTextV += 10;				if (dataLogTextV > bounds.bottom - 2)				{					EraseRect(&bounds);					dataLogTextV = 15;				}				MoveTo(10, dataLogTextV);								ForeColor(greenColor);				DrawString("\pFlip failed, forcing flip");								QDFlushPortBuffer(GetWindowPort(gDataLogWindow), NULL);				SetPort(GetWindowPort(window));			}						gTestType = -1;	//This will prevent the forced flip from being recorded as a data point in AddRunningTime()			MyAssert(FlipIntersection(testIntersectionIndexes[flipIntersectionIndex]));			gTestType = testType;			gLabelingMethod = prevLabelingMethod;		}		/*		intersections = gDrawing->GetIntersections();		intersections[testIntersectionIndexes[flipIntersectionIndex]]->SetPermanentHardConstraint(true);		Redraw();		QDFlushPortBuffer(GetWindowPort(window), NULL);		intersections = gDrawing->GetIntersections();		intersections[testIntersectionIndexes[flipIntersectionIndex]]->SetPermanentHardConstraint(false);		*/		if (gDebug5)		{			SetPort(GetWindowPort(gDataLogWindow));			Rect bounds;			GetPortBounds(GetWindowPort(gDataLogWindow), &bounds);			TextSize(9);			dataLogTextV += 10;			if (dataLogTextV > bounds.bottom - 2)			{				EraseRect(&bounds);				dataLogTextV = 15;			}			MoveTo(10, dataLogTextV);						ForeColor(greenColor);			DrawString("\pTest ");			Str255 str1;			NumToString(i + 1, str1);			DrawString(str1);			DrawString("\p of ");			NumToString(numFlips, str1);			DrawString(str1);			DrawString("\p ----- ");			NumToString(whichCase + 1, str1);			DrawString(str1);			DrawString("\p of ");			NumToString(numCases, str1);			DrawString(str1);						QDFlushPortBuffer(GetWindowPort(gDataLogWindow), NULL);			SetPort(GetWindowPort(window));		}				clock_t st = clock();		while ((clock() - st) / CLOCKS_PER_SEC < .1);	//Slight pause between tests	}		MyAssert(dataLoggingOn);		ProcessData(logData);					ToggleDataLogging();		intersections = gDrawing->GetIntersections();	for (int i = 0; i < testIntersectionIndexes.size(); i++)		intersections[testIntersectionIndexes[i]]->SetPermanentHardConstraint(true);		Redraw();	SysBeep(1);}void MainWindow::RunPileTest(){	Rect r;		//=============================================================================================	//=============================================================================================	//=============================================================================================		//Incrementally build labeling	/*	//Turn data logging on	gTestLogOn = true;	SetPort(GetWindowPort(gDataLogWindow));	GetPortBounds(GetWindowPort(gDataLogWindow), &r);	EraseRect(&r);	TextSize(18);	ForeColor(blackColor);	MoveTo(10, 30);	gTestLogOn ? DrawString("\pTest Log on") : DrawString("\pTest Log off");	QDFlushPortBuffer(GetWindowPort(gDataLogWindow), NULL);		for (int i = 1; i < 20; i++)	{		if (gOutputFileStream)			delete gOutputFileStream;		gOutputFileStream = new stringstream;				for (int j = 0; j < 10; j++)		{			//Select the last bspline			vector<BSpline*> bsplines = gDrawing->GetBSplines();			SelectBSpline(bsplines.back(), -1, false);			Redraw();			QDFlushPortBuffer(GetWindowPort(window), NULL);						//Pause briefly			clock_t st = clock();			while (true)			{				clock_t pt = clock() - st;				clock_t transpiredTime = pt / CLOCKS_PER_SEC;				if (transpiredTime > .1)					break;			}						//Duplicate the selected bspline			DuplicateSelected();			Redraw();			QDFlushPortBuffer(GetWindowPort(window), NULL);						if (j < 9)			{				//Undo the duplication				Undo();			}		}				//Output an endline to the data log		//ofstream ofs;		//ofs.open("testData", ofstream::app);		//if (ofs)		//{			(*gOutputFileStream) << "!" << endl << endl;		//	ofs.close();		//}		gLogLine = 0;				//Update the data log window		SetPort(GetWindowPort(gDataLogWindow));		GetPortBounds(GetWindowPort(gDataLogWindow), &r);		EraseRect(&r);		TextSize(18);		ForeColor(blackColor);		MoveTo(10, 30);		DrawString("\pAdded log empty line");		QDFlushPortBuffer(GetWindowPort(gDataLogWindow), NULL);				SysBeep(1);		clock_t st1 = clock();		while ((clock() - st1) / CLOCKS_PER_SEC < .1);		SysBeep(1);		st1 = clock();		while ((clock() - st1) / CLOCKS_PER_SEC < .1);		SysBeep(1);				ofstream ofs;		ofs.open("druidPileTest", ofstream::app);		if (ofs)		{			ofs << gOutputFileStream->str();			ofs.close();			delete gOutputFileStream;			gOutputFileStream = NULL;		}	}		//Turn data logging off	gTestLogOn = false;	SetPort(GetWindowPort(gDataLogWindow));	GetPortBounds(GetWindowPort(gDataLogWindow), &r);	EraseRect(&r);	TextSize(18);	ForeColor(blackColor);	MoveTo(10, 30);	gTestLogOn ? DrawString("\pTest Log on") : DrawString("\pTest Log off");	QDFlushPortBuffer(GetWindowPort(gDataLogWindow), NULL);	*/	//=============================================================================================	//=============================================================================================	//=============================================================================================		//Clear and randomize labeling		for (int i = 0; i < 8; i++)	{		if (gOutputFileStream)			delete gOutputFileStream;		gOutputFileStream = new stringstream;				//Turn data logging on		gTestLogOn = true;		SetPort(GetWindowPort(gDataLogWindow));		GetPortBounds(GetWindowPort(gDataLogWindow), &r);		EraseRect(&r);		TextSize(18);		ForeColor(blackColor);		MoveTo(10, 30);		gTestLogOn ? DrawString("\pTest Log on") : DrawString("\pTest Log off");		QDFlushPortBuffer(GetWindowPort(gDataLogWindow), NULL);				for (int j = 0; j < 100; j++)		{			//Clear labeling, destroy equivalence classes, randomize crossing states			IncrementUndoStack();			ClearLabeling();			gDrawing->DeleteAllCompSets();			gDrawing->ClearAnalysisWindow();			gDrawing->RandomizeCrossingStates();			Redraw();			QDFlushPortBuffer(GetWindowPort(window), NULL);						IncrementUndoStack();						//Pause briefly			clock_t st = clock();			while (true)			{				clock_t pt = clock() - st;				clock_t transpiredTime = pt / CLOCKS_PER_SEC;				if (transpiredTime > .1)					break;			}						//Find a labeling			CreateLegalLabeling();			Redraw();			QDFlushPortBuffer(GetWindowPort(window), NULL);			QDFlushPortBuffer(GetWindowPort(gDataLogWindow), NULL);			int q = 1;		}				//Output an endline to the data log		//ofstream ofs;		//ofs.open("testData", ofstream::app);		//if (ofs)		//{			(*gOutputFileStream) << "!" << endl << endl;		//	ofs.close();		//}		gLogLine = 0;				//Update the data log window		SetPort(GetWindowPort(gDataLogWindow));		GetPortBounds(GetWindowPort(gDataLogWindow), &r);		EraseRect(&r);		TextSize(18);		ForeColor(blackColor);		MoveTo(10, 30);		DrawString("\pAdded log empty line");		QDFlushPortBuffer(GetWindowPort(gDataLogWindow), NULL);				//Turn data logging off		gTestLogOn = false;		SetPort(GetWindowPort(gDataLogWindow));		GetPortBounds(GetWindowPort(gDataLogWindow), &r);		EraseRect(&r);		TextSize(18);		ForeColor(blackColor);		MoveTo(10, 30);		gTestLogOn ? DrawString("\pTest Log on") : DrawString("\pTest Log off");		QDFlushPortBuffer(GetWindowPort(gDataLogWindow), NULL);				if (i < 19)		{			//Select the last bspline			vector<BSpline*> bsplines = gDrawing->GetBSplines();			SelectBSpline(bsplines.back(), -1, false);			Redraw();			QDFlushPortBuffer(GetWindowPort(window), NULL);						//Duplicate the selected bspline			DuplicateSelected();			Redraw();			QDFlushPortBuffer(GetWindowPort(window), NULL);						//Deselect all			DeselectAll();			Redraw();			QDFlushPortBuffer(GetWindowPort(window), NULL);			int q = 1;		}				SysBeep(1);		clock_t st1 = clock();		while ((clock() - st1) / CLOCKS_PER_SEC < .1);		SysBeep(1);		st1 = clock();		while ((clock() - st1) / CLOCKS_PER_SEC < .1);		SysBeep(1);				ofstream ofs;		ofs.open("druidPileTest", ofstream::app);		if (ofs)		{			ofs << gOutputFileStream->str();			ofs.close();			delete gOutputFileStream;			gOutputFileStream = NULL;		}	}}#pragma mark -OSErr MainWindow::OpenBackgroundImageFile(){	FSSpec theFSSpec;	OSErr theErr = noErr;		OSType openTypeList[] = {kQTFileTypePicture, kQTFileTypeGIF, kQTFileTypePNG, kQTFileTypeTIFF,							kQTFileTypePhotoShop, kQTFileTypeSGIImage, kQTFileTypeBMP, 'BMP ',							kQTFileTypeJPEG, kQTFileTypeJFIF, kQTFileTypeMacPaint, kQTFileTypeTargaImage,							kQTFileTypeQuickDrawGXPicture, kQTFileTypeQuickTimeImage};	short numTypes = 14;		theErr = GetOneFileWithPreview(numTypes, openTypeList, &theFSSpec, NULL);;		PicHandle thePic = NULL;		GraphicsImportComponent gi;	theErr = GetGraphicsImporterForFile(&theFSSpec, &gi);		if (theErr == noErr)	{		Rect boundsRect;		GraphicsImportGetBoundsRect(gi, &boundsRect);				thePic = OpenPicture(&boundsRect);				GraphicsImportDraw(gi);				ClosePicture();				CloseComponent(gi);	}		if (backgroundImageGWW)		delete backgroundImageGWW;	Rect imageDim = (*thePic)->picFrame;	backgroundImageGWW = new GWorldWrapper(32, imageDim, -1);	backgroundImageGWW->StartUsingGWorld();	DrawPicture(thePic, &imageDim);	backgroundImageGWW->FinishUsingGWorld();	KillPicture(thePic);		Redraw();		return theErr;}OSErr MainWindow::GetOneFileWithPreview(short numTypes, OSType openTypeList[], FSSpecPtr theFSSpecPtr, void *theFilterProc){	NavReplyRecord		myReply;	NavDialogOptions	myDialogOptions;	NavTypeListHandle	myOpenList = NULL;	NavEventUPP			myEventUPP = NewNavEventUPP(HandleNavEvent);	OSErr				myErr = noErr;		if (theFSSpecPtr == NULL)		return(paramErr);	// specify the options for the dialog box	NavGetDefaultDialogOptions(&myDialogOptions);	myDialogOptions.dialogOptionFlags -= kNavNoTypePopup;	myDialogOptions.dialogOptionFlags -= kNavAllowMultipleFiles;	BlockMoveData("\pDruid", myDialogOptions.clientName, 6);		// create a handle to an 'open' resource	myOpenList = (NavTypeListHandle)CreateOpenHandle('Drui', numTypes, openTypeList);	if (myOpenList != NULL)		HLock((Handle)myOpenList);		// prompt the user for a file	myErr = NavGetFile(NULL, &myReply, &myDialogOptions, myEventUPP, NULL, (NavObjectFilterUPP)theFilterProc, myOpenList, NULL);		if ((myErr == noErr) && myReply.validRecord)	{		AEKeyword		myKeyword;		DescType		myActualType;		Size			myActualSize = 0;				// get the FSSpec for the selected file		if (theFSSpecPtr != NULL)			myErr = AEGetNthPtr(&(myReply.selection), 1, typeFSS, &myKeyword, &myActualType, theFSSpecPtr, sizeof(FSSpec), &myActualSize);		NavDisposeReply(&myReply);	}		if (myOpenList != NULL) {		HUnlock((Handle)myOpenList);		DisposeHandle((Handle)myOpenList);	}		DisposeNavEventUPP(myEventUPP); 	return(myErr);}OSErr MainWindow::PutPictToFile(PicHandle thePicture, bool promptUser){	OSErr               anErr = noErr;	NavEventUPP			myEventUPP = NewNavEventUPP(HandleNavEvent);	NavReplyRecord      reply;	NavDialogOptions    dialogOptions;	OSType              fileTypeToSave = 'PICT';	AEKeyword   		theKeyword;	DescType    		actualType;	Size        		actualSize;	FSSpec      		documentFSSpec;	long				inOutCount;	short				refNum, count;	unsigned char 		header[512];		Str255 filename = "\pUntitled";	Str255 str1;	NumToString(gFileCounter, str1);	if (gFileCounter < 1000)		PascalAppend(filename, "\p0");	if (gFileCounter < 100)		PascalAppend(filename, "\p0");	if (gFileCounter < 10)		PascalAppend(filename, "\p0");	PascalAppend(filename, str1);	PascalAppend(filename, "\p.pct");	gFileCounter++;		for (count = 0; count < 512; count++)		header[count] = 0x00;	anErr = NavGetDefaultDialogOptions(&dialogOptions); 	dialogOptions.dialogOptionFlags |= kNavSelectDefaultLocation;	//CtoPascal("Untitled.pct", dialogOptions.savedFileName);	PascalCopy(filename, dialogOptions.savedFileName);		if (promptUser)	{		anErr = NavPutFile( nil, &reply, &dialogOptions, myEventUPP, fileTypeToSave, 'ttxt', nil );				if (anErr == noErr && reply.validRecord)		{				anErr = AEGetNthPtr(&(reply.selection), 1, typeFSS, &theKeyword, &actualType,								&documentFSSpec, sizeof(documentFSSpec), &actualSize );			if (anErr == noErr)			{				anErr = FSpCreate(&documentFSSpec, 'ttxt', fileTypeToSave, smSystemScript);				if (anErr == dupFNErr)				{					anErr = FSpDelete(&documentFSSpec);					anErr = FSpCreate(&documentFSSpec, 'ttxt', fileTypeToSave, smSystemScript);				}		// this is quick 'n' dirty or there'd be more robust handling here				// write the file				FSpOpenDF(&documentFSSpec, fsRdWrPerm, &refNum );				inOutCount = 512;				anErr = FSWrite(refNum, &inOutCount, header);		// write the header				if (anErr == noErr)				{					inOutCount = GetHandleSize((Handle)thePicture);					anErr = FSWrite(refNum, &inOutCount, *thePicture);				}				FSClose(refNum);			}						reply.translationNeeded = false;			anErr = NavCompleteSave(&reply, kNavTranslateInPlace);			NavDisposeReply(&reply);		}				return anErr;	}	else	{		anErr = GetAppFSSpec(&documentFSSpec);		if (anErr != noErr)			return anErr;				PascalCopy(filename, documentFSSpec.name);				anErr = FSpCreate(&documentFSSpec, 'ttxt', fileTypeToSave, smSystemScript);		if (anErr == dupFNErr)		{			anErr = FSpDelete(&documentFSSpec);			anErr = FSpCreate(&documentFSSpec, 'ttxt', fileTypeToSave, smSystemScript);		}		// this is quick 'n' dirty or there'd be more robust handling here				anErr = FSpOpenDF(&documentFSSpec, fsRdWrPerm, &refNum);	//Open the file				if (anErr != noErr)			return anErr;				inOutCount = 512;		anErr = FSWrite(refNum, &inOutCount, header);		// write the header		if (anErr != noErr)			return anErr;				inOutCount = GetHandleSize(Handle(thePicture));				HLock(Handle(thePicture));		anErr = FSWrite(refNum, &inOutCount, Ptr(*thePicture));		HUnlock(Handle(thePicture));				FSClose(refNum);	//Close the file				//KillPicture(picH);				return anErr;	}}OSErr MainWindow::GetAppFSSpec(FSSpec *myAppSpec){	ProcessSerialNumber	serial;	ProcessInfoRec		info;	OSErr				err = -1;		serial.highLongOfPSN	= 0;	serial.lowLongOfPSN	= kCurrentProcess;	info.processInfoLength	= sizeof(ProcessInfoRec);	info.processName		= NULL;	info.processSignature	= 'Drui';	info.processType		= 'APPL';	info.processAppSpec		= myAppSpec; //Points to app on exit	err = GetProcessInformation(&serial, &info);	return err;}void MainWindow::ToggleAutoPictExport(){	autoExportPict = !autoExportPict;}void MainWindow::ExportToPict(bool promptUser, int mouseClickDown){	exportingPict = true;		Rect clipRect = { 0, 0, canvasSize.v, canvasSize.h };	ClipRect(&clipRect);		OpenCPicParams cPicParams;	//http://developer.apple.com/documentation/QuickTime/INMAC/MACWIN/imPictures.10.htm	SetRect(&cPicParams.srcRect, 0, 0, canvasSize.h, canvasSize.v);	cPicParams.hRes = cPicParams.vRes =	0x00480000;	//72 dpi	//cPicParams.hRes = cPicParams.vRes =		0x012C0000;	//300 dpi	//cPicParams.hRes = cPicParams.vRes =		0x00100000;	//300 dpi	cPicParams.version = -2;		SetPort(GetWindowPort(window));	Point mouse;	GetMouse(&mouse);		PicHandle picH = OpenCPicture(&cPicParams);	Redraw();		if (!promptUser)	{		//Draw an arrow at the cursor position		ForeColor(blackColor);		MoveTo(mouse.h, mouse.v);		Line(0, 10);		MoveTo(mouse.h + 1, mouse.v + 1);		Line(0, 8);		MoveTo(mouse.h + 2, mouse.v + 2);		Line(0, 6);		MoveTo(mouse.h + 3, mouse.v + 3);		Line(0, 6);		MoveTo(mouse.h + 4, mouse.v + 4);		Line(0, 7);		MoveTo(mouse.h + 5, mouse.v + 5);		Line(0, 2);		MoveTo(mouse.h + 5, mouse.v + 10);		Line(0, 3);		MoveTo(mouse.h + 6, mouse.v + 6);		Line(0, 1);		MoveTo(mouse.h + 6, mouse.v + 12);		Line(0, 1);		MoveTo(mouse.h + 7, mouse.v + 7);		Line(0, 0);		ForeColor(whiteColor);		MoveTo(mouse.h - 1, mouse.v - 2);		Line(0, 14);		Line(3, -3);		Line(0, 1);		Line(1, 0);		Line(0, 2);		Line(1, 0);		Line(0, 1);		Line(1, 1);		Line(1, 0);		Line(1, -1);		Line(0, -1);		Line(-1, -1);		Line(0, -1);		Line(-1, -1);		Line(0, -1);		Line(4, 0);		Line(-9, -9);				if (mouseClickDown == 1)		{			MouseClick mouseClick;			mouseClick.loc = mouse;			mouseClick.doubleClick = false;			mouseClick.age = 1;			mouseClicks.push_back(mouseClick);		}		if (mouseClickDown == 2)		{			MouseClick mouseClick;			mouseClick.loc = mouse;			mouseClick.doubleClick = true;			mouseClick.age = 1;			mouseClicks.push_back(mouseClick);		}				for (list<MouseClick>::iterator i = mouseClicks.begin(); i != mouseClicks.end(); i++)			(*i).age++;		int mouseClickDuration = 30;		while (mouseClicks.size() > 0 && mouseClicks.front().age >= mouseClickDuration)			mouseClicks.pop_front();				for (list<MouseClick>::iterator i = mouseClicks.begin(); i != mouseClicks.end(); i++)		{			SetPort(GetWindowPort(window));			TextSize(24);			TextFace(bold);						MoveTo((*i).loc.h, (*i).loc.v + 30);			if ((*i).doubleClick)				Move(-StringWidth("\pDOUBLE "), 0);						int lightness = (*i).age * (65535 / mouseClickDuration);			if (lightness > 65535)				lightness = 65535;			MyAssert(!isnan(lightness));			RGBColor c = { 65535, lightness, lightness };			MyAssert(c.red == 65535);			MyAssert(c.green >= 0 && c.green <= 65535);			MyAssert(c.blue >= 0 && c.blue <= 65535);			RGBForeColor(&c);						if (!(*i).doubleClick)				DrawString("\pCLICK");			else DrawString("\pDOUBLE ");						PenSize(3, 3);			MoveTo((*i).loc.h - 1, (*i).loc.v - 6);			Line(0, 10);			MoveTo((*i).loc.h - 6, (*i).loc.v - 1);			Line(10, 0);			PenSize(1, 1);		}	}		ClosePicture();	PutPictToFile(picH, promptUser);	//KillPicture(picH);		exportingPict = false;}void MainWindow::ExportToPostscript(){	OSErr               err = noErr;	NavReplyRecord      reply;	NavDialogOptions    dialogOptions;	OSType              fileTypeToSave = 'TEXT';	AEKeyword   		theKeyword;	DescType    		actualType;	Size        		actualSize;	FSSpec      		fsSpec;	short				fRefNum;		//Display the file nav dialog box to let the user specify a location and name for the file	err = NavGetDefaultDialogOptions(&dialogOptions); 	dialogOptions.dialogOptionFlags |= kNavSelectDefaultLocation;	CtoPascal("Untitled.eps", dialogOptions.savedFileName);	err = NavPutFile( nil, &reply, &dialogOptions, nil, fileTypeToSave, 'Drui', nil );	if (err == noErr && reply.validRecord)	{			err = AEGetNthPtr(&(reply.selection), 1, typeFSS, &theKeyword, &actualType,							&fsSpec, sizeof(fsSpec), &actualSize );		if (err == noErr)		{			//Create a new file			err = FSpCreate(&fsSpec, 'Drui', fileTypeToSave, smSystemScript);			if (err == dupFNErr)			{				err = FSpDelete(&fsSpec);				err = FSpCreate(&fsSpec, 'Drui', fileTypeToSave, smSystemScript);				if (err != noErr)					return;			}						//Open the file			err = FSpOpenDF(&fsSpec, fsRdWrPerm, &fRefNum);			if (err != noErr)				return;						WritePostscriptHeader(fRefNum);						PaintPostscriptBackgroundCanvas(fRefNum);						//grid->DrawPostscriptGrid(fRefNum, canvasSize);	//optional, note that this should match the behavior of exporting a pict in Redraw()						gDrawing->DrawPostscriptDrawing(fRefNum, viewMode, canvasSize);						//Draw the intersections			if (true)//viewMode == SPLINE_MODE)				gDrawing->DrawPostscriptIntersections(fRefNum, viewMode, canvasSize);						WritePostscriptTailer(fRefNum);						//Close the file			err = FSClose(fRefNum);		}	}		reply.translationNeeded = false;	err = NavCompleteSave(&reply, kNavTranslateInPlace);	NavDisposeReply(&reply);}void MainWindow::WritePostscriptHeader(short fRefNum){	string st;	ostringstream oss;	oss << canvasSize.h;	oss << " ";	oss << canvasSize.v;	string canvasDim;	canvasDim += oss.str();		//Declare a postscript file	st += "%!PS-Adobe-2.0 EPSF-1.2\n";		//Write some meta data and global image characteristics	st += "%%Title: #<graphic:adjoin>\n";	st += "%%Creator: Druid\n";	st += "%%BoundingBox: 0 0 ";		st += canvasDim;		st += "\n";	st += "%%Pages: 1\n";	st += "save\n";	st += "/inch {72 mul} def\n";	st += "/displine { /y2 exch def /x2 exch def /y1 exch def /x1 exch def\n";	st += "x1 y1 moveto x2 y2 lineto stroke } def\n";	st += "%%EndProlog\n";	st += "%%%Page: 1 1\n";	//st += "0 0 translate\n";	st += canvasDim;		st += " scale\n";		//Frame the border of the canvas	//st += "0.001 setlinewidth\n";	//st += "0 0 moveto 1 0 lineto 1 1 lineto 0 1 lineto closepath\n";	//st += "stroke\n";		long strLen = st.length();	OSErr err = FSWrite(fRefNum, &strLen, st.c_str());}void MainWindow::WritePostscriptTailer(short fRefNum){	string st;		//A necessary postscript command to finally render the drawn page	st += "showpage\n";		long strLen = st.length();	OSErr err = FSWrite(fRefNum, &strLen, st.c_str());}void MainWindow::PaintPostscriptBackgroundCanvas(short fRefNum){	//if (gColors.canvas.red == 65535 && gColors.canvas.green == 65535 && gColors.canvas.blue == 65535)	//	return;		string st;		long strLen = st.length();	OSErr err = FSWrite(fRefNum, &strLen, st.c_str());		ostringstream oss;	oss << 0;	oss << " ";	oss << 0;	oss << " moveto\n";		oss << 1;	oss << " ";	oss << 0;	oss << " lineto\n";		oss << 1;	oss << " ";	oss << 1;	oss << " lineto\n";		oss << 0;	oss << " ";	oss << 1;	oss << " lineto\n";		oss << "closepath\n";		oss << ((double)gColors.canvas.red / 65535.0);	oss << " ";	oss << ((double)gColors.canvas.green / 65535.0);	oss << " ";	oss << ((double)gColors.canvas.blue / 65535.0);		oss << " setrgbcolor\n";		oss << "fill\n";		st = oss.str();	strLen = st.length();	err = FSWrite(fRefNum, &strLen, st.c_str());}#pragma mark -void MainWindow::OpenFromFile(){	NavReplyRecord		reply;	NavDialogOptions	dialogOptions;	NavTypeListHandle	openList = NULL;	NavEventUPP			eventUPP = NewNavEventUPP(HandleNavEvent);	OSErr				err = noErr;	short				numTypes = 1;	OSType				openTypeList[] = { 'drui' };	void				*theFilterProc = NULL;	FSSpecPtr			newDocumentFSSpec = new FSSpec;		// specify the options for the dialog box	NavGetDefaultDialogOptions(&dialogOptions);	dialogOptions.dialogOptionFlags -= kNavNoTypePopup;	dialogOptions.dialogOptionFlags -= kNavAllowMultipleFiles;	BlockMoveData("\pDruid", dialogOptions.clientName, 6);		// create a handle to an 'open' resource	openList = (NavTypeListHandle)CreateOpenHandle('Drui', numTypes, openTypeList);	if (openList != NULL)		HLock((Handle)openList);		// prompt the user for a file	err = NavGetFile(NULL, &reply, &dialogOptions, eventUPP, NULL, (NavObjectFilterUPP)theFilterProc, openList, NULL);		if ((err == noErr) && reply.validRecord)	{		AEKeyword		keyword;		DescType		actualType;		Size			actualSize = 0;				// get the FSSpec for the selected file		err = AEGetNthPtr(&(reply.selection), 1, typeFSS, &keyword, &actualType, newDocumentFSSpec, sizeof(FSSpec), &actualSize);		NavDisposeReply(&reply);	}		if (openList != NULL) {		HUnlock((Handle)openList);		DisposeHandle((Handle)openList);	}		DisposeNavEventUPP(eventUPP);		if (err != noErr)		return;		short fRefNum;	err = FSpOpenDF(newDocumentFSSpec, fsRdPerm, &fRefNum);	if (err == noErr)	{		if (documentFSSpec)			delete documentFSSpec;		documentFSSpec = newDocumentFSSpec;				ReadFromFile(fRefNum);				undoStackPos = -1;		while (undoStack.size() > undoStackPos + 1)		{			delete undoStack.back();			undoStack.pop_back();		}		IncrementUndoStack();				ZoomFull();		Redraw();	}	else delete newDocumentFSSpec;}	/*void MainWindow::AutoOpenFileFromAppleEvent(EventRef theEvent){	char c;	GetEventParameter(theEvent, kEventParamKeyMacCharCodes, typeChar,						NULL, sizeof(char), NULL, &c);		UInt32              whatHappened;	whatHappened = GetEventKind(theEvent);	MyAssert(whatHappened == kEventAppleEvent);		OSType eventType;	GetEventParameter(theEvent, kEventParamAEEventID, typeType,						NULL, sizeof(OSType), NULL, &eventType);	MyAssert(eventType == kAEOpenDocuments);		}*/void MainWindow::AutoOpenFileFromAppleEvent(const AppleEvent* theAppleEvent){	AEDescList docList;	long fileCount;	Size actualSize;	AEKeyword keywd;	DescType returnedType;	bool success = false;	OSErr err, theErr;	err = AEGetParamDesc(theAppleEvent, keyDirectObject, typeAEList, &docList);	if (err == noErr)		err = AECountItems(&docList, &fileCount);		for (int i = 1; i <= fileCount; i++)	{		theErr = noErr;				FSSpecPtr newDocumentFSSpec = new FSSpec;		err = AEGetNthPtr(&docList, i, typeFSS, &keywd, &returnedType, newDocumentFSSpec, sizeof(FSSpec), &actualSize);				short fRefNum;		err = FSpOpenDF(newDocumentFSSpec, fsRdPerm, &fRefNum);		if (err == noErr)		{			if (documentFSSpec)				delete documentFSSpec;			documentFSSpec = newDocumentFSSpec;						ReadFromFile(fRefNum);						undoStackPos = -1;			while (undoStack.size() > undoStackPos + 1)			{				delete undoStack.back();				undoStack.pop_back();			}			IncrementUndoStack();						success = true;		}		else delete newDocumentFSSpec;				//еее		//Druid does not presently support multiple open documents, so just open the first document and break out		break;	}	AEDisposeDesc(&docList);		if (success)	{		ZoomFull();		Redraw();	}}void MainWindow::ReadFromFile(short fRefNum){	MyAssert(documentFSSpec);	SetWTitle(window, documentFSSpec->name);		//Grab the entire thing into a stringstream buffer	long fileNumBytes;	OSErr err = GetEOF(fRefNum, &fileNumBytes);	char* fileByteBuffer = new char[fileNumBytes];	err = FSRead(fRefNum, &fileNumBytes, fileByteBuffer);	istringstream fileBuffer(fileByteBuffer);	delete [] fileByteBuffer;		string st;		//Read the header	fileBuffer >> st;	if (st != "Druid")		return;		//Read the version	double fileVersion;	fileBuffer >> st >> fileVersion;		//Erase the present drawing information	workingBSplineIndexes.clear();	workingBSplines.clear();	hilightedBSplineIndex = -1;	hilightedBSpline = NULL;	hilightCode = -1;	hilightedIntersectionIndex = -1;	hilightedIntersectionLoc.h = hilightedIntersectionLoc.v = -99999;	hilightedIntersection = NULL;	workingControlPoint = -1;	moveAllControlPoints = false;		if (windowBoundaryDragTimer)	{		RemoveEventLoopTimer(windowBoundaryDragTimer);		windowBoundaryDragTimer = NULL;	}	if (mouseCatchUpTimer)	{		RemoveEventLoopTimer(mouseCatchUpTimer);		mouseCatchUpTimer = NULL;	}	if (labelingAttemptPendingTimer)	{		RemoveEventLoopTimer(labelingAttemptPendingTimer);		labelingAttemptPendingTimer = NULL;	}		SetControlValue(hScroll, 0);	SetControlValue(vScroll, 0);		//Read the canvas size	fileBuffer >> canvasSize.h >> canvasSize.v;		//Read separator	fileBuffer >> st;		gDrawing->LoadFileData(fileBuffer, fileVersion);		grid->GenerateGrid(canvasSize);}Handle MainWindow::CreateOpenHandle(OSType theApplicationSignature, short theNumTypes, const OSTypePtr theTypeList){	Handle myHandle = NULL;		// see if we have an 'open' resource...	myHandle = Get1Resource('open', 128);	if ( myHandle != NULL && ResError() == noErr )	{		DetachResource( myHandle );		return myHandle;	} else {		myHandle = NULL;	}		// nope, use the passed in types and dynamically create the NavTypeList	if (theTypeList == NULL)		return myHandle;		if (theNumTypes > 0)	{		myHandle = NewHandle(sizeof(NavTypeList) + (theNumTypes * sizeof(OSType)));		if (myHandle != NULL)		{			NavTypeListHandle 	myOpenResHandle	= (NavTypeListHandle)myHandle;						(*myOpenResHandle)->componentSignature = theApplicationSignature;			(*myOpenResHandle)->osTypeCount = theNumTypes;			BlockMoveData(theTypeList, (*myOpenResHandle)->osType, theNumTypes * sizeof(OSType));		}	}		return myHandle;}pascal void MainWindow::HandleNavEvent(NavEventCallbackMessage theCallBackSelector, NavCBRecPtr theCallBackParms, void *theCallBackUD){#pragma unused(theCallBackUD)	WindowPtr		myWindow = NULL;			if (theCallBackSelector == kNavCBEvent) {		switch (theCallBackParms->eventData.eventDataParms.event->what) {			case updateEvt:#if TARGET_OS_MAC				// Handle Update Event#endif				break;			case nullEvent:				// Handle Null Event				break;		}	}}void MainWindow::SaveToFile(bool promptForFileName){	//Do the Mac dialog	OSErr err = noErr;	if (promptForFileName || !documentFSSpec)	{		documentFSSpec = new FSSpec;				NavReplyRecord      reply;		NavDialogOptions    dialogOptions;		OSType              fileTypeToSave = 'drui';		AEKeyword   		theKeyword;		DescType    		actualType;		Size        		actualSize;				//Display the file nav dialog box to let the user specify a location and name for the file		err = NavGetDefaultDialogOptions(&dialogOptions); 		dialogOptions.dialogOptionFlags |= kNavSelectDefaultLocation | kNavPreserveSaveFileExtension;		CtoPascal("Untitled.dru", dialogOptions.savedFileName);		err = NavPutFile( nil, &reply, &dialogOptions, nil, fileTypeToSave, 'Drui', nil );		if (err == noErr && reply.validRecord)		{				err = AEGetNthPtr(&(reply.selection), 1, typeFSS, &theKeyword, &actualType,								documentFSSpec, sizeof(*documentFSSpec), &actualSize );			if (err == noErr)			{				//Create a new file				err = FSpCreate(documentFSSpec, 'Drui', fileTypeToSave, smSystemScript);				if (err == dupFNErr)				{					err = FSpDelete(documentFSSpec);					err = FSpCreate(documentFSSpec, 'Drui', fileTypeToSave, smSystemScript);					if (err != noErr)						return;				}								//Open the file			}		}				reply.translationNeeded = false;		err = NavCompleteSave(&reply, kNavTranslateInPlace);		NavDisposeReply(&reply);	}		short fRefNum;	err = FSpOpenDF(documentFSSpec, fsRdWrPerm, &fRefNum);	if (err != noErr)		return;		SetWTitle(window, documentFSSpec->name);		//===================================================================================		string st;	ostringstream oss;		//All Druid files start with a recognizable header	oss << "Druid\n";		//All Druid files have a file version number	double fileVersion = 1.2;	oss << "Version " << fileVersion << "\n";		//Add the canvas size	oss << canvasSize.h << " " << canvasSize.v << "\n";		oss << "Drawing========================================\n";		//That's it for MainWindow data	st += oss.str();	long strLen = st.length();	err = FSWrite(fRefNum, &strLen, st.c_str());		//Add the drawing	gDrawing->DumpFileData(fRefNum, fileVersion);		//Close the file	err = FSClose(fRefNum);}