#include "BSplineToBSplineCut.h"#include "BSpline.h"#include "BspCutIntersection.h"#include "BspCutTIntersection.h"#include "CutCutIntersection.h"#include "Drawing.h"	//еее DEBUG#include <math.h>#include <string>#include <sstream>using namespace::std;//******************************************************************************//Extern Globalsextern bool gDebug;extern Drawing *gDrawing;	//еее	DEBUG//******************************************************************************//Global Declarations//******************************************************************************//Function Prototypes	//	In external files		//	main.cppvoid MyAssert(bool condition);		//	lineEquations.cppdouble LineSegmentLength(FloatPoint p1, FloatPoint p2);bool PointLineSegmentDistance(FloatPoint point, FloatPoint p1, FloatPoint p2, double &pointLineDist);int LineCrossLineDirection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2);bool LineSegmentIntersection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2, FloatPoint &intersection);bool LineSegmentIntersection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2,							FloatPoint &intersection, double& lineSegInter1, double& lineSegInter2);#pragma mark -BSplineToBSplineCut::BSplineToBSplineCut(Drawing* theDrawing, BSpline* initBsp1, BSpline* initBsp2,										int initCv1, int initSg1, int initCv2, int initSg2, int initSectionDepth) :	drawing(theDrawing), bsp1(initBsp1), bsp2(initBsp2), cv1(initCv1), sg1(initSg1), cv2(initCv2), sg2(initSg2), dtored(false){	startLoc.h = startLoc.v = endLoc.h = endLoc.v = -999999;	prevStartLoc.h = prevStartLoc.v = prevEndLoc.h = prevEndLoc.v = -999999;		MyAssert(bsp1);		if (!bsp2)	//A cut to a theoretical infinite boundary		cv2 = sg2 = -1;		RecalcStartEndLocs();	BackupStartEndLocs();		//Create an initial section	sectionDepths.push_back(initSectionDepth);	sectionDepthConstraints.push_back(false);}BSplineToBSplineCut::BSplineToBSplineCut(BSplineToBSplineCut& cut, Drawing* theDrawing){	MyAssert(!cut.dtored);		if (theDrawing == cut.drawing)	{		bsp1 = cut.bsp1;		bsp2 = cut.bsp2;	}	else bsp1 = bsp2 = NULL;		cv1 = cut.cv1;	cv2 = cut.cv2;	sg1 = cut.sg1;	sg2 = cut.sg2;	startLoc = cut.startLoc;	endLoc = cut.endLoc;	prevStartLoc = cut.prevStartLoc;	prevEndLoc = cut.prevEndLoc;		dtored = cut.dtored;		MyAssert(startLoc.h != 0 && startLoc.v != 0 && endLoc.h != 0 && endLoc.v != 0);	MyAssert(prevStartLoc.h != 0 && prevStartLoc.v != 0 && prevEndLoc.h != 0 && prevEndLoc.v != 0);		drawing = theDrawing;		//Section depths	int vectorSize = cut.sectionDepths.size();	sectionDepths.resize(vectorSize);	for (int i = 0; i < vectorSize; i++)		sectionDepths[i] = cut.sectionDepths[i];		//Section depths	vectorSize = cut.maxPossibleSectionDepths.size();	maxPossibleSectionDepths.resize(vectorSize);	for (int i = 0; i < vectorSize; i++)		maxPossibleSectionDepths[i] = cut.maxPossibleSectionDepths[i];		//Min section depth constraints		vectorSize = cut.sectionDepthConstraints.size();	sectionDepthConstraints.resize(vectorSize);	for (int i = 0; i < vectorSize; i++)		sectionDepthConstraints[i] = cut.sectionDepthConstraints[i];}BSplineToBSplineCut::BSplineToBSplineCut(Drawing* theDrawing) : dtored(false), drawing(theDrawing){	startLoc.h = startLoc.v = endLoc.h = endLoc.v = -999999;	prevStartLoc.h = prevStartLoc.v = prevEndLoc.h = prevEndLoc.v = -999999;}BSplineToBSplineCut::~BSplineToBSplineCut(){	MyAssert(!dtored);		for (int i = 0; i < intersections.size(); i++)	{		MyAssert(!intersections[i]->GetDtored());				switch (intersections[i]->GetType())		{			case GenericIntersection::BSP_CUT:				((BspCutIntersection*)intersections[i])->SetNullCut();				break;			case GenericIntersection::BSP_CUT_T:				((BspCutTIntersection*)intersections[i])->SetNullCut();				break;			case GenericIntersection::CUT_CUT:				((CutCutIntersection*)intersections[i])->SetNullCut(this);				break;		}				delete intersections[i];				MyAssert(sectionDepths.size() == sectionDepthConstraints.size());	}		dtored = true;}void BSplineToBSplineCut::AddIntersection(GenericIntersection* intersection, bool equalizeSections, bool reweave){	MyAssert(!dtored);		//Find the distance from the new intersection to the start location	double newInterDistToStart = LineSegmentLength(startLoc, intersection->GetLocation());		//Find where to insert the new intersection, sorted by distance from the start location	vector<GenericIntersection*>::iterator interIter = intersections.begin();	vector<int>::iterator sectionIter = sectionDepths.begin();	vector<bool>::iterator sectionDepthConstIter = sectionDepthConstraints.begin();		int insertDepth;	if (equalizeSections)	{		MyAssert(sectionDepths.size() > 0);		insertDepth = sectionDepths[0];				MyAssert(sectionDepthConstraints.size() > 0);	}		int numInters = intersections.size();	//еее	for (;		interIter != intersections.end();		interIter++/*, sectionIter++, sectionDepthConstIter++*/)	{		MyAssert(*interIter);		MyAssert(!(*interIter)->GetDtored());		MyAssert(interIter != intersections.end());				double interDistToStart = LineSegmentLength(startLoc, (*interIter)->GetLocation());		if (interDistToStart > newInterDistToStart)			break;				if (equalizeSections)		{			if (sectionIter != sectionDepths.end())//MyAssert(sectionIter != sectionDepths.end());	//Should this assert be valid?  Why don't the sections match the intersections?				insertDepth = *sectionIter;			else insertDepth = sectionDepths.back();	//Ack!  Is this the right way to handle this?		}				if (sectionIter != sectionDepths.end())			sectionIter++;		if (sectionDepthConstIter != sectionDepthConstraints.end())			sectionDepthConstIter++;	}		intersections.insert(interIter, intersection);		//Insert a section with depth equal to the preceeding section	if (equalizeSections)	{		sectionDepths.insert(sectionIter, insertDepth);		sectionDepthConstraints.insert(sectionDepthConstIter, false);	}		MyAssert(sectionDepths.size() == sectionDepthConstraints.size());		if (intersections[0]->GetType() == GenericIntersection::BSP_CUT_T && intersections[intersections.size() - 1]->GetType() == GenericIntersection::BSP_CUT_T)		if (reweave)			ReweaveCut();}void BSplineToBSplineCut::RemoveIntersection(GenericIntersection* intersection, bool equalizeSections, bool reweave){	MyAssert(!dtored);		//Find where to remove the intersection	vector<GenericIntersection*>::iterator interIter;	int sectionCounter = 0;		for (interIter = intersections.begin(); interIter != intersections.end(); interIter++, sectionCounter++)		if (*interIter == intersection)			break;	MyAssert(interIter != intersections.end());		//If the intersection fell off the start of the cut instead of the end, back up one section	if (0)//sectionDepths.size() > 1 && LineSegmentLength(intersection->GetLocation(), startLoc) < LineSegmentLength(intersection->GetLocation(), endLoc))		sectionCounter--;	//If the intersection is the final T intersection, back up one section	else if (intersections.size() > 1 && intersection == intersections[intersections.size() - 1])	{		MyAssert(sectionCounter == sectionDepths.size());		sectionCounter--;	}	MyAssert(sectionCounter >= 0);		//Remove the intersection	intersections.erase(interIter);		//Remove the section	if (equalizeSections && sectionDepths.size() > 1)	{		vector<int>::iterator sectionIter = sectionDepths.begin();		vector<bool>::iterator sectionDepthConstIter = sectionDepthConstraints.begin();				MyAssert(sectionCounter < sectionDepths.size() && sectionCounter < sectionDepthConstraints.size());				for (int i = 0; i < sectionCounter; i++)		{			sectionIter++;			sectionDepthConstIter++;		}				sectionDepths.erase(sectionIter);		sectionDepthConstraints.erase(sectionDepthConstIter);	}		MyAssert(sectionDepths.size() == sectionDepthConstraints.size());		if (reweave)		ReweaveCut();}int BSplineToBSplineCut::GetCutIndex(){	return drawing->GetCutIndex(this);}vector<GenericIntersection*> BSplineToBSplineCut::GetIntersections(){	return intersections;}BSpline* BSplineToBSplineCut::GetBsp1(){	return bsp1;}BSpline* BSplineToBSplineCut::GetBsp2(){	return bsp2;}int BSplineToBSplineCut::GetCv1(){	return cv1;}int BSplineToBSplineCut::GetCv2(){	return cv2;}int BSplineToBSplineCut::GetSg1(){	return sg1;}int BSplineToBSplineCut::GetSg2(){	return sg2;}		FloatPoint BSplineToBSplineCut::GetStart(){	return startLoc;}FloatPoint BSplineToBSplineCut::GetEnd(){	return endLoc;}		FloatPoint BSplineToBSplineCut::GetPrevStart(){	return prevStartLoc;}int BSplineToBSplineCut::GetNumIntersections(){	return intersections.size();}GenericIntersection* BSplineToBSplineCut::GetFirstIntersection(){	MyAssert(intersections[0]->GetType() == GenericIntersection::BSP_CUT_T);	return intersections[0];}GenericIntersection* BSplineToBSplineCut::GetLastIntersection(){	MyAssert(intersections[intersections.size() - 1]->GetType() == GenericIntersection::BSP_CUT_T);	return intersections[intersections.size() - 1];}FloatPoint BSplineToBSplineCut::GetPrevEnd(){	return prevEndLoc;}		int BSplineToBSplineCut::GetSectionBeforeIntersection(GenericIntersection* intersection){	MyAssert(sectionDepths.size() == intersections.size() - 1 || endLoc.h == -999999);		MyAssert(find(intersections.begin(), intersections.end(), intersection) != intersections.end());		int intersectionIndex = -1;	for (intersectionIndex++; intersectionIndex < intersections.size(); intersectionIndex++)		if (intersections[intersectionIndex] == intersection)			break;		intersectionIndex--;		MyAssert(intersectionIndex != intersections.size());	MyAssert(intersectionIndex < sectionDepths.size());		return intersectionIndex;}int BSplineToBSplineCut::GetSectionAfterIntersection(GenericIntersection* intersection){	MyAssert(sectionDepths.size() == intersections.size() - 1 || endLoc.h == -999999);		MyAssert(find(intersections.begin(), intersections.end(), intersection) != intersections.end());		int intersectionIndex = -1;	for (intersectionIndex++; intersectionIndex < intersections.size(); intersectionIndex++)		if (intersections[intersectionIndex] == intersection)			break;		MyAssert(intersectionIndex != intersections.size());	MyAssert(intersectionIndex < sectionDepths.size());		return intersectionIndex;}int BSplineToBSplineCut::GetArbitraryPointDepth(FloatPoint interLoc){	double pointLineDist;	MyAssert(PointLineSegmentDistance(interLoc, startLoc, endLoc, pointLineDist));	MyAssert(pointLineDist < .1);		MyAssert(sectionDepths.size() > 0);	if (sectionDepths.size() == 1)		return sectionDepths[0];		double interDistFromStart = LineSegmentLength(interLoc, startLoc);		int intersectionIndex = 0;	for (intersectionIndex = 0; intersectionIndex < intersections.size(); intersectionIndex++)	{		double oneInterDistFromStart = LineSegmentLength(intersections[intersectionIndex]->GetLocation(), startLoc);		if (oneInterDistFromStart > interDistFromStart)			break;	}	//MyAssert(intersectionIndex > 0 && intersectionIndex < intersections.size());	MyAssert(intersectionIndex > 0 && intersectionIndex <= intersections.size() && intersectionIndex <= sectionDepths.size());		return sectionDepths[intersectionIndex - 1];}int BSplineToBSplineCut::GetSectionDepthBeforeIntersection(GenericIntersection* intersection){	//Find the intersection's sorted position in the intersection list	int interIndex = GetIntersectionIndex(intersection);		//The sorted position corresponds directly to which section is being requested	MyAssert(interIndex != 0);	//Can't get section before the start intersection	return sectionDepths[interIndex - 1];}int BSplineToBSplineCut::GetSectionDepthAfterIntersection(GenericIntersection* intersection){	//Find the intersection's sorted position in the intersection list	int interIndex = GetIntersectionIndex(intersection);		//The sorted position corresponds directly to which section is being requested	MyAssert(interIndex != intersections.size() - 1);	//Can't get section after the end intersection	return sectionDepths[interIndex];}int BSplineToBSplineCut::GetMaxPossibleSectionDepthBeforeIntersection(GenericIntersection* intersection){	int sectionIndex = GetSectionBeforeIntersection(intersection);		MyAssert(sectionIndex < maxPossibleSectionDepths.size());	return maxPossibleSectionDepths[sectionIndex];}int BSplineToBSplineCut::GetMaxPossibleSectionDepthAfterIntersection(GenericIntersection* intersection){	int sectionIndex = GetSectionAfterIntersection(intersection);		MyAssert(sectionIndex < maxPossibleSectionDepths.size());	return maxPossibleSectionDepths[sectionIndex];}vector<int>* BSplineToBSplineCut::GetSectionDepths(){	return &sectionDepths;}int BSplineToBSplineCut::GetMinIntersectionGap(){	int minGapDepth = 999999;		for (int i = 0; i < intersections.size(); i++)	{		GenericIntersection* intersection = intersections[i];				//I think we can ignore BspCutT and CutCut intersections		if (intersection->GetType() != GenericIntersection::BSP_CUT)			continue;				BspCutIntersection* bspCutInter = (BspCutIntersection*)intersection;				//Get the intersection's basic data		BSpline* bsp = bspCutInter->GetBsp();		BSplineToBSplineCut* cut = bspCutInter->GetCut();		int curve = bspCutInter->GetCv();		int seg = bspCutInter->GetSg();		int occludedEdge = bspCutInter->DetermineOccludedEdge();				//Get the four depths at the intersection		int bspEnd1Depth = bsp->GetSectionDepthBeforeIntersection(intersection, curve, seg);		int bspEnd2Depth = bsp->GetSectionDepthAfterIntersection(intersection, curve, seg);		int cutEnd1Depth = cut->GetSectionDepthBeforeIntersection(intersection);		int cutEnd2Depth = cut->GetSectionDepthAfterIntersection(intersection);				MyAssert(intersection->IntersectionLegal());				if (!bspCutInter->GetBspOnTop())	// Cut on top		{			//No need to calc gap depth when on top, unless interested in negative gap depths, which we aren't right now		}		else	//Bsp on top		{			MyAssert(occludedEdge == 1 || occludedEdge == 2);			MyAssert(cut == this);			MyAssert(bspEnd1Depth == bspEnd2Depth);			int gapDepth = (occludedEdge == 1 ? cutEnd2Depth : cutEnd1Depth) - bspEnd1Depth;			MyAssert(gapDepth >= 0);						if (gapDepth < minGapDepth)				minGapDepth = gapDepth;		}	}		//If didn't find any relevant intersections, return min section depth instead	/*if (minGapDepth == 999999)	{		for (int i = 0; i < sectionDepths.size(); i++)			if (sectionDepths[i] < minGapDepth)				minGapDepth = sectionDepths[i];	}*/		//If didn't find any relevant intersections, return 0 instead	//if (minGapDepth == 999999)	//	minGapDepth = 0;		return minGapDepth;}bool BSplineToBSplineCut::GetSectionDepthConstraintBeforeIntersection(GenericIntersection* intersection){	int sectionIndex = GetSectionBeforeIntersection(intersection);		return sectionDepthConstraints[sectionIndex];}bool BSplineToBSplineCut::GetSectionDepthConstraintAfterIntersection(GenericIntersection* intersection){	int sectionIndex = GetSectionAfterIntersection(intersection);		return sectionDepthConstraints[sectionIndex];}int BSplineToBSplineCut::GetIntersectionIndex(GenericIntersection* intersection){	MyAssert(sectionDepths.size() == intersections.size() - 1 || endLoc.h == -999999);		int index = -1;		for (index++; index < intersections.size(); index++)		if (intersections[index] == intersection)			break;	MyAssert(index < intersections.size());		return index;}bool BSplineToBSplineCut::GetAllSectionsConstrained(){	for (int i = 0; i < sectionDepthConstraints.size(); i++)		if (!sectionDepthConstraints[i])			return false;		return true;}bool BSplineToBSplineCut::GetAllIntersectionsLegal(bool assertIt){	for (int i = 0; i < intersections.size(); i++)		if (!intersections[i]->IntersectionLegal())		{			if (assertIt)			{				GenericIntersection* intersection = intersections[i];				MyAssert(false);				intersection->IntersectionLegal();			}			return false;		}		return true;}GenericIntersection* BSplineToBSplineCut::FindPrevIntersection(GenericIntersection* intersection){	MyAssert(sectionDepths.size() == intersections.size() - 1 || endLoc.h == -999999);		//Find the intersection's location along the cut, its sorted position on the cut with respect to any other intersections on the cut	int index;	MyAssert(!intersection->SelfIntersection());		MyAssert(intersections[0] != intersection);		for (index = 0; index < intersections.size(); index++)		if (intersections[index] == intersection)			break;		MyAssert(index > 0 && index < intersections.size());		return intersections[(index + (intersections.size() - 1)) % intersections.size()];}GenericIntersection* BSplineToBSplineCut::FindNextIntersection(GenericIntersection* intersection){	MyAssert(sectionDepths.size() == intersections.size() - 1 || endLoc.h == -999999);		//Find the intersection's location along the cut, its sorted position on the cut with respect to any other intersections on the cut	int index;	MyAssert(!intersection->SelfIntersection());		MyAssert(intersections[intersections.size() - 1] != intersection);		for (index = 0; index < intersections.size(); index++)		if (intersections[index] == intersection)			break;		MyAssert(index >= 0 && index < intersections.size() - 1);		return intersections[(index + 1) % intersections.size()];}#pragma mark -void BSplineToBSplineCut::Invert(){	BSpline* tempBsp = bsp1;	bsp1 = bsp2;	bsp2 = tempBsp;		int tempInt = cv1;	cv1 = cv2;	cv2 = tempInt;		tempInt = sg1;	sg1 = sg2;	sg2 = tempInt;		FloatPoint tempFP = startLoc;	startLoc = endLoc;	endLoc = tempFP;		tempFP = prevStartLoc;	prevStartLoc = prevEndLoc;	prevEndLoc = tempFP;		vector<GenericIntersection*> intersectionsTemp = intersections;	for (int i = 0; i < intersections.size(); i++)		intersections[i] = intersectionsTemp[intersections.size() - 1 - i];		vector<int> sectionDepthsTemp = sectionDepths;	for (int i = 0; i < sectionDepths.size(); i++)		sectionDepths[i] = sectionDepthsTemp[sectionDepths.size() - 1 - i];		vector<int> maxPossibleSectionDepthsTemp = maxPossibleSectionDepths;	for (int i = 0; i < maxPossibleSectionDepths.size(); i++)		maxPossibleSectionDepths[i] = maxPossibleSectionDepthsTemp[maxPossibleSectionDepths.size() - 1 - i];		vector<bool> sectionDepthConstraintsTemp = sectionDepthConstraints;	for (int i = 0; i < sectionDepthConstraints.size(); i++)		sectionDepthConstraints[i] = sectionDepthConstraintsTemp[sectionDepthConstraints.size() - 1 - i];		MyAssert(intersections[0]->GetType() == GenericIntersection::BSP_CUT_T &&			((BspCutTIntersection*)intersections[0])->GetAtStart());	((BspCutTIntersection*)intersections[0])->SetAtStart(false);		MyAssert(intersections[intersections.size() - 1]->GetType() == GenericIntersection::BSP_CUT_T &&			((BspCutTIntersection*)intersections[intersections.size() - 1])->GetAtStart());	((BspCutTIntersection*)intersections[intersections.size() - 1])->SetAtStart(false);}#pragma mark -		void BSplineToBSplineCut::InitSectionDepths(int sectionZeroDepth){	MyAssert(sectionDepths.size() == 0 && sectionDepthConstraints.size() == 0);		sectionDepths.push_back(sectionZeroDepth);	sectionDepthConstraints.push_back(false);}#pragma mark -void BSplineToBSplineCut::IncreaseCurveStart(){	MyAssert(cv1 < bsp1->GetNumControlPoints() - 1);	cv1++;	MyAssert(cv1 < bsp1->GetNumControlPoints());}void BSplineToBSplineCut::IncreaseCurveEnd(){	MyAssert(cv2 < bsp2->GetNumControlPoints() - 1);	cv2++;	MyAssert(cv2 < bsp2->GetNumControlPoints());}void BSplineToBSplineCut::DecreaseCurveStart(){	MyAssert(cv1 > 0);	cv1--;	MyAssert(cv1 >= 0);}void BSplineToBSplineCut::DecreaseCurveEnd(){	MyAssert(cv2 > 0);	cv2--;	MyAssert(cv2 >= 0);}#pragma mark -		void BSplineToBSplineCut::SetSectionDepthBeforeIntersection(GenericIntersection* intersection, int depth){	int intersectionIndex = GetIntersectionIndex(intersection);	intersectionIndex = (intersectionIndex + (sectionDepths.size() - 1)) % sectionDepths.size();		sectionDepths[intersectionIndex] = depth;}void BSplineToBSplineCut::SetSectionDepthAfterIntersection(GenericIntersection* intersection, int depth){	int intersectionIndex = GetIntersectionIndex(intersection);		sectionDepths[intersectionIndex] = depth;}void BSplineToBSplineCut::SetSectionDepthConstraintBeforeIntersection(GenericIntersection* intersection, bool value){	int sectionIndex = GetSectionBeforeIntersection(intersection);		sectionDepthConstraints[sectionIndex] = value;}void BSplineToBSplineCut::SetSectionDepthConstraintAfterIntersection(GenericIntersection* intersection, bool value){	int sectionIndex = GetSectionAfterIntersection(intersection);		sectionDepthConstraints[sectionIndex] = value;}void BSplineToBSplineCut::InitSectionMaxPossibleDepths(){	maxPossibleSectionDepths.resize(sectionDepths.size());	for (int i = 0; i < maxPossibleSectionDepths.size(); i++)		maxPossibleSectionDepths[i] = 0;}bool BSplineToBSplineCut::IncrementMaxPossibleSectionDepthBeforeIntersection(GenericIntersection* intersection, int depth){	int intersectionIndex = GetIntersectionIndex(intersection);	MyAssert(intersectionIndex > 0);	intersectionIndex = intersectionIndex - 1;		if (depth > maxPossibleSectionDepths[intersectionIndex])	{		maxPossibleSectionDepths[intersectionIndex] = depth;		return true;	}		return false;}bool BSplineToBSplineCut::IncrementMaxPossibleSectionDepthAfterIntersection(GenericIntersection* intersection, int depth){	int intersectionIndex = GetIntersectionIndex(intersection);	MyAssert(intersectionIndex < intersections.size() - 1);		if (depth > maxPossibleSectionDepths[intersectionIndex])	{		maxPossibleSectionDepths[intersectionIndex] = depth;		return true;	}		return false;}void BSplineToBSplineCut::SetAllSectionsNoHardConstraint(){	MyAssert(sectionDepths.size() == intersections.size() - 1);		for (int i = 0; i < sectionDepthConstraints.size(); i++)		sectionDepthConstraints[i] = false;}void BSplineToBSplineCut::PushPullCut(int depthChange){	if (depthChange == 0)		return;		for (int i = 0; i < sectionDepths.size(); i++)		sectionDepths[i] += depthChange;}#pragma mark -void BSplineToBSplineCut::MakeAllDepthsZero(){	for (vector<int>::iterator i = sectionDepths.begin(); i != sectionDepths.end(); i++)		*i = 0;}#pragma mark -void BSplineToBSplineCut::ReweaveCut(){	MyAssert(sectionDepths.size() == intersections.size() - 1);		if (intersections.size() < 2)		return;		if (intersections[0]->GetType() != GenericIntersection::BSP_CUT_T || intersections[intersections.size() - 1]->GetType() != GenericIntersection::BSP_CUT_T)		return;		MyAssert(intersections[0]->GetType() == GenericIntersection::BSP_CUT_T && intersections[intersections.size() - 1]->GetType() == GenericIntersection::BSP_CUT_T);		int traversalDepth = bsp1->GetSectionDepthBeforeIntersection(intersections[0], cv1, sg1);	BSpline* emptySpaceEdge = NULL;	bool crossedEmptySpace = false;		sectionDepths[0] = traversalDepth;		// еее Determine if the starting T junction is an empty space edge		for (int k = 1; k < intersections.size() - 1; k++)	{		switch (intersections[k]->GetType())		{			case GenericIntersection::BSP_BSP:				MyAssert(false);				break;			case GenericIntersection::BSP_CUT:				MyAssert(k != 0 && k != intersections.size() - 1);								BspCutIntersection* bspCutInter = (BspCutIntersection*)intersections[k];								int bspCutIntersectionDepth = bspCutInter->GetBsp()->GetArbitraryCurvePointDepth(bspCutInter->GetCv(), bspCutInter->GetSg(), bspCutInter->GetLocation());								bool presentDepthMatchesBspCutIntersectionDepth = (traversalDepth == bspCutIntersectionDepth);								int occludedEdge = bspCutInter->DetermineOccludedEdge();								//If not in empty space, weave the depth up and down as appropriate.				//If in empty space, and the bspCutIntersection's bspline doesn't end the empty space, do nothing.				//If in empty space, and the bspCutIntersectoin's bspline ends the empty space, reassign the depth and continue traversing.				if (!emptySpaceEdge)				{					if (bspCutInter->GetBspOnTop())					{						MyAssert(occludedEdge == 1 || occludedEdge == 2);						if (occludedEdge == 1)							traversalDepth--;						else traversalDepth++;					}										sectionDepths[k] = traversalDepth;				}				else if (bspCutInter->GetBsp() == emptySpaceEdge &&					presentDepthMatchesBspCutIntersectionDepth && occludedEdge == 2)				{					traversalDepth = bspCutIntersectionDepth;					emptySpaceEdge = NULL;				}								//If entering empty space, remember the bspline that bounds the empty space				if (!emptySpaceEdge && presentDepthMatchesBspCutIntersectionDepth && occludedEdge == 1)				{					emptySpaceEdge = bspCutInter->GetBsp();					crossedEmptySpace = true;				}				break;			case GenericIntersection::BSP_CUT_T:				MyAssert(false);				break;			case GenericIntersection::CUT_CUT:				MyAssert(k != 0 && k != intersections.size() - 1);								sectionDepths[k] = sectionDepths[k - 1];				break;			default:				MyAssert(false);		}	}		//Make sure the end of the cut is legal	//Can't do this since it might happen in the middle of a new pair of intersections	//MyAssert(bsp2->GetSectionDepthBeforeIntersection(intersections[0], cv1, sg1) == sectionDepths[sectionDepths.size() - 1]);}void BSplineToBSplineCut::ProjectIntersections(BSpline* bsp, BSplineToBSplineCut* cut){	MyAssert(sectionDepths.size() == intersections.size() - 1);		for (int i = 0; i < intersections.size(); i++)	{		if (bsp && intersections[i]->GetType() == GenericIntersection::BSP_CUT && ((BspCutIntersection*)intersections[i])->GetBsp() == bsp)		{			GenericIntersection* bspCutInter = intersections[i];			RemoveIntersection(bspCutInter, true);			AddIntersection(bspCutInter, true);		}		else if (cut && intersections[i]->GetType() == GenericIntersection::CUT_CUT && (((CutCutIntersection*)intersections[i])->GetCut1() == cut ||																						((CutCutIntersection*)intersections[i])->GetCut2() == cut))		{			GenericIntersection* cutCutInter = intersections[i];			RemoveIntersection(cutCutInter, true);			AddIntersection(cutCutInter, true);		}	}		ReweaveCut();}		bool BSplineToBSplineCut::ProjectIntersections(vector<GenericIntersection*>& alreadyProjectedInters){	MyAssert(sectionDepths.size() == intersections.size() - 1 || endLoc.h == -999999);		vector<GenericIntersection*> deleteIntersections;	vector<pair<GenericIntersection*, double> > distIntersMoved;		//======================================================================================================		//Make a copy of the intersections before the intersection propagation	vector<GenericIntersection*> prevIntersections;	for (int i = 0; i < intersections.size(); i++)		prevIntersections.push_back(intersections[i]);		//Iterate through the intersections	for (int i = 0; i < intersections.size(); i++)	{		GenericIntersection* intersection = intersections[i];				//Don't project an intersection more than once		if (find(alreadyProjectedInters.begin(), alreadyProjectedInters.end(), intersection) != alreadyProjectedInters.end())			continue;				switch (intersection->GetType())		{			case GenericIntersection::BSP_BSP:				MyAssert(false);					break;			case GenericIntersection::BSP_CUT:				ProjectBspCutIntersection(intersection, deleteIntersections,											distIntersMoved);					break;			case GenericIntersection::BSP_CUT_T:				ProjectBspCutTIntersection(intersection);					break;			case GenericIntersection::CUT_CUT:				ProjectCutCutIntersection(intersection, deleteIntersections);					break;		}				alreadyProjectedInters.push_back(intersection);	//Will include deleted intersections, but that's okay	}	//End loop for all intersections		//======================================================================================================		//If any intersections perfectly overlap, they represent an error that must be fixed.	//Intersections that should have been deleted were not because their vanishing was not detected higher up in this function.	if (distIntersMoved.size() >= 2)		for (int i = 0; i < distIntersMoved.size() - 1; i++)			for (int j = i + 1; j < distIntersMoved.size(); j++)				if (distIntersMoved[i].first->GetLocation() == distIntersMoved[j].first->GetLocation())				{					//Fix the error by deleting the intersection that moved further to get to the new location.					//This is ugly, there is no guarantee that this always deletes the right intersection.										if (distIntersMoved[i].second > distIntersMoved[j].second)						deleteIntersections.push_back(distIntersMoved[i].first);					else deleteIntersections.push_back(distIntersMoved[j].first);				}		//Delete any intersections that have vanished	bool intersectionsDeleted = false;	if (deleteIntersections.size() != 0)	{		for (vector<GenericIntersection*>::iterator i = deleteIntersections.begin(); i != deleteIntersections.end(); i++)			delete *i;		intersectionsDeleted = true;		ReweaveCut();	}		//Determine if the intersection order changed	bool segmentIntersectionReorder = false;	if (!intersectionsDeleted)	{		MyAssert(intersections.size() == prevIntersections.size());		for (int i = 0; i < intersections.size(); i++)			if (intersections[i] != prevIntersections[i])				segmentIntersectionReorder = true;	}		//Notify any BspCutT intersections to update their start and end points	//Shouldn't be necessary since it should be handled in BSpline	//for (int i = 0; i < intersections.size(); i++)	//	if (intersections[i]->GetType() == GenericIntersection::BSP_CUT_T)	//		((BspCutTIntersection*)intersections[i])->RecalcStartEndLocs();		return (intersectionsDeleted || segmentIntersectionReorder);}#pragma mark-void BSplineToBSplineCut::ProjectBspCutIntersection(GenericIntersection* intersection, vector<GenericIntersection*>& deleteIntersections,								vector<pair<GenericIntersection*, double> >& distIntersMoved){	BspCutIntersection* bspCutInter = (BspCutIntersection*)intersection;		MyAssert(bspCutInter->GetCut() == this);		int cvbk = bspCutInter->GetCv();	int sgbk = bspCutInter->GetSg();	FloatPoint oldLoc = bspCutInter->GetLocation();		//еее	bspCutInter->SetCurveAndSeg(cvbk, sgbk);	bspCutInter->SetLocation(oldLoc);		FloatPoint newLoc;		int seg;	int segOld;		FloatPoint pA1pre, pA2pre, pA1post, pA2post;		GetIntersectionSegmentPoints(intersection, seg, segOld,								pA1post, pA2post, pA1pre, pA2pre);		//Test, make sure the starting line segments originally intersected	double lineSegInter1pre, lineSegInter2pre;	LineSegmentIntersection(pA1pre, pA2pre, prevStartLoc, prevEndLoc, newLoc, lineSegInter1pre, lineSegInter2pre);	MyAssert(!(lineSegInter1pre < 0 || lineSegInter1pre > 1.0 || lineSegInter2pre < 0 || lineSegInter2pre > 1.0));		//Keep projecting the intersection until the new location is found	int curveEndWrap = 0;	int searchDir = 0;	int numIts = 0;	bool noIntersectionFound = false;	while (true)	{		//Infinite loop check		if (numIts++ >= 100)		{			bspCutInter->SetCurveAndSeg(cvbk, sgbk);			bspCutInter->SetLocation(oldLoc);			noIntersectionFound = true;			break;		}				//Test whether the segment presently in question intersects the cut		double lineSegInter1post, lineSegInter2post;		if (LineSegmentIntersection(pA1post, pA2post, startLoc, endLoc, newLoc, lineSegInter1post, lineSegInter2post))			//if (intersection->SelfIntersection() && lineSegInter1post > .01 && lineSegInter1post < .99 && lineSegInter2post > .01 && lineSegInter2post < .99)			{				//We're done, just update the intersection's position and end				bspCutInter->SetLocation(newLoc);				break;			}				//Getting here means the segment doesn't intersect the cut				//Determine the direction the intersection moves along the BSpline from the original location on the segment.		//Don't allow the intersection search to go the other direction past the original segment at any point in time.		if (numIts == 1)			if (DetermineSearchDirection(newLoc,										pA1pre, pA2pre, pA1post, pA2post,										lineSegInter1pre, lineSegInter2pre,										searchDir))				noIntersectionFound = true;				if (noIntersectionFound)			break;				MyAssert(searchDir != 0);				int result = SwitchSegments(intersection, lineSegInter1post,											cvbk, sgbk, cvbk, sgbk,											pA1post, pA2post,											seg, noIntersectionFound, curveEndWrap);		if (result == 0)			break;		else if (result == 1)			continue;				//Intersection fell off the end of the cut (not entirely sure about the analysis here)		bspCutInter->SetCurveAndSeg(cvbk, sgbk);		bspCutInter->SetLocation(oldLoc);		noIntersectionFound = true;		break;	}	//End loop for one intersection		double distMoved = sqrt((newLoc.h - oldLoc.h) * (newLoc.h - oldLoc.h) + (newLoc.v - oldLoc.v) * (newLoc.v - oldLoc.v));		//еее Kind of a hack	if (!noIntersectionFound && distMoved > 300)	{		bspCutInter->SetCurveAndSeg(cvbk, sgbk);		bspCutInter->SetLocation(oldLoc);		noIntersectionFound = true;	}		if (noIntersectionFound)	{		deleteIntersections.push_back(bspCutInter);		return;	}		distIntersMoved.push_back(pair<GenericIntersection*, double>(bspCutInter, distMoved));		//Might need to change curves	ChangeCurves(intersection,					seg, segOld,					curveEndWrap);		//Might need to change order on cut	double distToStart = LineSegmentLength(startLoc, bspCutInter->GetLocation());	int listPos = 0;	while (listPos < intersections.size() && intersections[listPos] != bspCutInter)		listPos++;	MyAssert(listPos > 0 && listPos < intersections.size() - 1);		double prevDistToStart = LineSegmentLength(startLoc, intersections[listPos - 1]->GetLocation());	double nextDistToStart = LineSegmentLength(startLoc, intersections[listPos + 1]->GetLocation());		//Shouldn't be out of order with both neighbor intersections	MyAssert(distToStart > prevDistToStart || distToStart < nextDistToStart);	bool reweave = (distToStart < prevDistToStart || distToStart > nextDistToStart);		while (distToStart < prevDistToStart)	{		MyAssert(listPos > 1);				//Swap the intersections		GenericIntersection* prevInter = intersections[listPos - 1];		intersections[listPos - 1] = bspCutInter;		intersections[listPos] = prevInter;		listPos--;				if (listPos == 1)			MyAssert(intersections[listPos - 1]->GetType() == GenericIntersection::BSP_CUT_T);				prevDistToStart = LineSegmentLength(startLoc, intersections[listPos - 1]->GetLocation());	}	while (distToStart > nextDistToStart)	{		MyAssert(listPos < intersections.size() - 2);				//Swap the intersections		GenericIntersection* nextInter = intersections[listPos + 1];		intersections[listPos + 1] = bspCutInter;		intersections[listPos] = nextInter;		listPos++;				if (listPos == intersections.size() - 1)			MyAssert(intersections[listPos + 1]->GetType() == GenericIntersection::BSP_CUT_T);				nextDistToStart = LineSegmentLength(startLoc, intersections[listPos + 1]->GetLocation());	}		if (reweave)		ReweaveCut();		//Make sure the resulting line segments actually do intersect	GetIntersectionSegmentPoints(intersection, seg, segOld,								pA1post, pA2post, pA1pre, pA2pre);		double lineSegInter1post, lineSegInter2post;	MyAssert(LineSegmentIntersection(pA1post, pA2post, startLoc, endLoc, newLoc, lineSegInter1post, lineSegInter2post));}void BSplineToBSplineCut::GetIntersectionSegmentPoints(GenericIntersection* intersection, int& seg, int& segOld,														FloatPoint& pA1post, FloatPoint& pA2post, FloatPoint& pA1pre, FloatPoint& pA2pre){	MyAssert(intersection->GetType() == GenericIntersection::BSP_CUT);		seg = ((BspCutIntersection*)intersection)->GetCv() * BSpline::sNumSegmentsPerCurve + ((BspCutIntersection*)intersection)->GetSg();		segOld = seg;		//Get the endpoints of the moving segment	vector<vector<FloatPoint>*> curvePoints = *((BspCutIntersection*)intersection)->GetBsp()->GetCurvePoints();	pA1post = (*curvePoints[seg / BSpline::sNumSegmentsPerCurve])[seg % BSpline::sNumSegmentsPerCurve];	pA2post = (*curvePoints[((seg + 1) / BSpline::sNumSegmentsPerCurve) % curvePoints.size()])[(seg + 1) % BSpline::sNumSegmentsPerCurve];		vector<vector<FloatPoint>*> prevCurvePoints = *((BspCutIntersection*)intersection)->GetBsp()->GetPrevCurvePoints();	pA1pre = (*prevCurvePoints[seg / BSpline::sNumSegmentsPerCurve])[seg % BSpline::sNumSegmentsPerCurve];	pA2pre = (*prevCurvePoints[((seg + 1) / BSpline::sNumSegmentsPerCurve) % prevCurvePoints.size()])[(seg + 1) % BSpline::sNumSegmentsPerCurve];}bool BSplineToBSplineCut::DetermineSearchDirection(FloatPoint newLoc,										FloatPoint pA1pre, FloatPoint pA2pre, FloatPoint pA1post, FloatPoint pA2post, 										double lineSegInter1pre, double lineSegInter2pre,										int& searchDir){	bool noIntersectionFound = false;	FloatPoint startLocProj, endLocProj;	FloatPoint pA1preProj, pA2preProj;	double projDistFrac = .000001;	double lineSegInter1preProj, lineSegInter2preProj;		MyAssert(LineSegmentIntersection(pA1pre, pA2pre, prevStartLoc, prevEndLoc, newLoc, lineSegInter1preProj, lineSegInter2preProj));	do	{		startLocProj.h = prevStartLoc.h + (startLoc.h - prevStartLoc.h) * projDistFrac;		startLocProj.v = prevStartLoc.v + (startLoc.v - prevStartLoc.v) * projDistFrac;		endLocProj.h = prevEndLoc.h + (endLoc.h - prevEndLoc.h) * projDistFrac;		endLocProj.v = prevEndLoc.v + (endLoc.v - prevEndLoc.v) * projDistFrac;				pA1preProj.h = pA1pre.h + (pA1post.h - pA1pre.h) * projDistFrac;		pA1preProj.v = pA1pre.v + (pA1post.v - pA1pre.v) * projDistFrac;		pA2preProj.h = pA2pre.h + (pA2post.h - pA2pre.h) * projDistFrac;		pA2preProj.v = pA2pre.v + (pA2post.v - pA2pre.v) * projDistFrac;				MyAssert(LineSegmentIntersection(pA1preProj, pA2preProj, startLocProj, endLocProj, newLoc, lineSegInter1preProj, lineSegInter2preProj));				projDistFrac *= 10.0;	} while (lineSegInter1preProj == lineSegInter1pre || lineSegInter2preProj == lineSegInter2pre);		searchDir = (lineSegInter1preProj > lineSegInter1pre ? 1 : -1);		return noIntersectionFound;}int BSplineToBSplineCut::SwitchSegments(GenericIntersection* intersection, double lineSegInter1post,									int cv1bk, int sg1bk, int cv2bk, int sg2bk,									FloatPoint& pA1post, FloatPoint& pA2post,									int& seg, bool& noIntersectionFound, int& curveEndWrap){	vector<vector<FloatPoint>*> curvePoints = *((BspCutIntersection*)intersection)->GetBsp()->GetCurvePoints();		//If the moving segment isn't on the intersection, switch segments on the moving object	if (lineSegInter1post < 0)	{		//Change segments		pA2post = pA1post;				int prevSeg = seg;		seg--;		if (seg < 0)		{			seg += curvePoints.size() * BSpline::sNumSegmentsPerCurve;			curveEndWrap = -1;		}				pA1post = (*curvePoints[seg / BSpline::sNumSegmentsPerCurve])[seg % BSpline::sNumSegmentsPerCurve];				MyAssert(intersection->GetType() == GenericIntersection::BSP_CUT);				((BspCutIntersection*)intersection)->DecreaseSeg(curvePoints.size());							return 1;	}	else if (lineSegInter1post > 1.0)	{		//Change segments		pA1post = pA2post;				int prevSeg = seg;		seg++;		if (seg >= curvePoints.size() * BSpline::sNumSegmentsPerCurve)		{			seg -= curvePoints.size() * BSpline::sNumSegmentsPerCurve;			curveEndWrap = 1;		}				pA2post = (*curvePoints[((seg + 1) / BSpline::sNumSegmentsPerCurve) % curvePoints.size()])[(seg + 1) % BSpline::sNumSegmentsPerCurve];				MyAssert(intersection->GetType() == GenericIntersection::BSP_CUT);		((BspCutIntersection*)intersection)->IncreaseSeg(curvePoints.size());				return 1;	}		return 2;}void BSplineToBSplineCut::ChangeCurves(GenericIntersection* intersection,							int seg, int segOld,							int curveEndWrap){	if (seg / BSpline::sNumSegmentsPerCurve != segOld / BSpline::sNumSegmentsPerCurve || seg != segOld)	{		//MyAssert(seg / BSpline::sNumSegmentsPerCurve == segold / BSpline::sNumSegmentsPerCurve);		((BspCutIntersection*)intersection)->GetBsp()->MoveIntersection(intersection, segOld / BSpline::sNumSegmentsPerCurve,																		segOld % BSpline::sNumSegmentsPerCurve,																		seg / BSpline::sNumSegmentsPerCurve,																		seg % BSpline::sNumSegmentsPerCurve, 1);				//Check for wrap around the ends		if (curveEndWrap == -1)			((BspCutIntersection*)intersection)->GetBsp()->WrapSectionDepths(false);		else if (curveEndWrap == 1)			((BspCutIntersection*)intersection)->GetBsp()->WrapSectionDepths(true);	}	else ((BspCutIntersection*)intersection)->GetBsp()->CheckSegmentIntersectionOrder(intersection);}#pragma mark-void BSplineToBSplineCut::ProjectBspCutTIntersection(GenericIntersection* intersection){	//Nothing to do here.  This will be handled in BSpline::ProjectBspCutTIntersection().}#pragma mark-void BSplineToBSplineCut::ProjectCutCutIntersection(GenericIntersection* intersection, vector<GenericIntersection*>& deleteIntersections){	//Check that the two cuts still intersect, then just update the location of the intersection		CutCutIntersection* cutCutInter = (CutCutIntersection*)intersection;		FloatPoint startLoc1 = cutCutInter->GetCut1()->GetStart();	FloatPoint endLoc1 = cutCutInter->GetCut1()->GetEnd();	FloatPoint startLoc2 = cutCutInter->GetCut2()->GetStart();	FloatPoint endLoc2 = cutCutInter->GetCut2()->GetEnd();		FloatPoint newInterLoc;	if (LineSegmentIntersection(startLoc1, endLoc1, startLoc2, endLoc2, newInterLoc))		cutCutInter->SetLocation(newInterLoc);	else deleteIntersections.push_back(cutCutInter);		//Might need to change order on cut	double distToStart = LineSegmentLength(startLoc, cutCutInter->GetLocation());	int listPos = 0;	while (listPos < intersections.size() && intersections[listPos] != cutCutInter)		listPos++;	MyAssert(listPos > 0 && listPos < intersections.size() - 1);		double prevDistToStart = LineSegmentLength(startLoc, intersections[listPos - 1]->GetLocation());	double nextDistToStart = LineSegmentLength(startLoc, intersections[listPos + 1]->GetLocation());		//Shouldn't be out of order with both neighbor intersections	MyAssert(distToStart > prevDistToStart || distToStart < nextDistToStart);	bool reweave = (distToStart < prevDistToStart || distToStart > nextDistToStart);		while (distToStart < prevDistToStart)	{		MyAssert(listPos > 1);				//Swap the intersections		GenericIntersection* prevInter = intersections[listPos - 1];		intersections[listPos - 1] = cutCutInter;		intersections[listPos] = prevInter;		listPos--;				if (listPos == 1)			MyAssert(intersections[listPos - 1]->GetType() == GenericIntersection::BSP_CUT_T);				prevDistToStart = LineSegmentLength(startLoc, intersections[listPos - 1]->GetLocation());	}	while (distToStart > nextDistToStart)	{		MyAssert(listPos < intersections.size() - 2);				//Swap the intersections		GenericIntersection* nextInter = intersections[listPos + 1];		intersections[listPos + 1] = cutCutInter;		intersections[listPos] = nextInter;		listPos++;				if (listPos == intersections.size() - 1)			MyAssert(intersections[listPos + 1]->GetType() == GenericIntersection::BSP_CUT_T);				nextDistToStart = LineSegmentLength(startLoc, intersections[listPos + 1]->GetLocation());	}		if (reweave)		ReweaveCut();		BSplineToBSplineCut* otherCut = cutCutInter->GetOtherCut(this);	otherCut->ProjectIntersections(NULL, this);}#pragma mark-bool BSplineToBSplineCut::FindAndAddNewIntersections(vector<BSpline*> bsplines, vector<BSplineToBSplineCut*> cuts){	if (!bsp2)		return;		double intersectionMatchDiff = .00000001;	bool anyIntersectionsFound = false;		//Find new intersections with BSplines	for (int bspCnt = 0; bspCnt < bsplines.size(); bspCnt++)	{		bool intersectionFound = false;		BSpline* bsp = bsplines[bspCnt];				FloatPoint intersectionLoc;		FloatPoint pA1, pA2;				//Iterate over this BSpline's curves		vector<vector<FloatPoint>*> curvePoints = *bsp->GetCurvePoints();		for (int i = 0; i < curvePoints.size(); i++)			//Iterate over one of this BSpline's curve's segments			for (int j = 0; j < BSpline::sNumSegmentsPerCurve; j++)			{				pA1 = (*curvePoints[i])[j];				if (j == BSpline::sNumSegmentsPerCurve - 1)					pA2 = (*curvePoints[(i + 1) % curvePoints.size()])[0];				else pA2 = (*curvePoints[i])[j + 1];								//Test whether the segment intersects the cut				if (LineSegmentIntersection(pA1, pA2, startLoc, endLoc, intersectionLoc))				{					//Check the intersection against existing intersections.  Only add the intersection if it doesn't exist yet.					bool intersectionAlreadyExists = false;					for (vector<GenericIntersection*>::iterator iter = intersections.begin(); iter != intersections.end(); iter++)						if (fabs((*iter)->GetLocation().h - intersectionLoc.h) < intersectionMatchDiff &&							fabs((*iter)->GetLocation().v - intersectionLoc.v) < intersectionMatchDiff)						{							intersectionAlreadyExists = true;							break;						}											if (!intersectionAlreadyExists)					{						int edgeDirection = LineCrossLineDirection(startLoc, endLoc, pA1, pA2);						if (edgeDirection != 0)						{							//It is an open question as to whether the bsp should be on top when the depth of th bsp and the cut are equal.							//	IMPORTANT --- Which ever way this is done, keep it in sync with the same function in the other bspline/cut class.														//bool bspOnTop = (bsp->GetArbitraryCurvePointDepth(i, j, intersectionLoc) <= GetArbitraryPointDepth(intersectionLoc));							bool bspOnTop = (bsp->GetArbitraryCurvePointDepth(i, j, intersectionLoc) < GetArbitraryPointDepth(intersectionLoc));														BspCutIntersection* newIntersection = new BspCutIntersection(drawing, intersectionLoc,								bsp, this, drawing->GetBSplineIndex(bsp), drawing->GetCutIndex(this), i, j, bspOnTop, edgeDirection);														MyAssert(!newIntersection->GetDtored());														AddIntersection((GenericIntersection*)newIntersection);							bsp->AddIntersection(i, j, (GenericIntersection*)newIntersection);							anyIntersectionsFound = intersectionFound = true;						}					}				}			}				if (intersectionFound)		{			bsp->MakeIntersectionList();			bsp->EqualizeNumberOfSections();		}	}		//Find intersections with cuts	for (int cutCnt = 0; cutCnt < cuts.size(); cutCnt++)	{		if (cuts[cutCnt] == this)	//Don't self-check			continue;				BSplineToBSplineCut* cut = cuts[cutCnt];				FloatPoint otherStartLoc = cut->GetStart();		FloatPoint otherEndLoc = cut->GetEnd();				FloatPoint intersectionLoc;				if (LineSegmentIntersection(startLoc, endLoc, otherStartLoc, otherEndLoc, intersectionLoc))		{			//Check the intersection against existing intersections.  Only add the intersection if it doesn't exist yet.			bool intersectionAlreadyExists = false;			for (vector<GenericIntersection*>::iterator iter = intersections.begin(); iter != intersections.end(); iter++)				if (fabs((*iter)->GetLocation().h - intersectionLoc.h) < intersectionMatchDiff &&					fabs((*iter)->GetLocation().v - intersectionLoc.v) < intersectionMatchDiff)				{					intersectionAlreadyExists = true;					break;				}						if (!intersectionAlreadyExists)			{				CutCutIntersection* newIntersection = new CutCutIntersection(drawing, intersectionLoc,					this, cut, drawing->GetCutIndex(this), drawing->GetCutIndex(cut), false);								MyAssert(!newIntersection->GetDtored());								AddIntersection((GenericIntersection*)newIntersection);				cut->AddIntersection((GenericIntersection*)newIntersection);				anyIntersectionsFound = true; //Possibily not necessary, not sure			}		}	}		//The cut may no longer be valid	//Don't do anything here yet ееееееееееееееееееее		return anyIntersectionsFound;}#pragma mark-void BSplineToBSplineCut::DrawCut(RGBColor color, MainWindow::ViewMode viewMode, Point scrollOffset, bool showDepths){	MyAssert(sectionDepths.size() == intersections.size() - 1 || endLoc.h == -999999);		//Define the "deep" version of the color	RGBColor colorDeep = color;	colorDeep.red += (65535 - colorDeep.red) * .67;	colorDeep.green += (65535 - colorDeep.green) * .67;	colorDeep.blue += (65535 - colorDeep.blue) * .67;		RGBColor gray;	gray.red = gray.green = gray.blue = 65535 * .67;		bool allIntersectionsLegal = GetAllIntersectionsLegal(false);		//Plot the sections	MyAssert(sectionDepths.size() == intersections.size() - 1 || endLoc.h == -999999);		for (int i = 0; i < sectionDepths.size(); i++)	{		if (sectionDepths[i] == 0)		{			if (allIntersectionsLegal)				RGBForeColor(&color);			else ForeColor(blackColor);		}		else		{			if (allIntersectionsLegal)				RGBForeColor(&colorDeep);			else RGBForeColor(&gray);		}				FloatPoint pt1 = intersections[i]->GetLocation();		FloatPoint pt2 = intersections[i + 1]->GetLocation();				MoveTo(pt1.h + scrollOffset.h, pt1.v + scrollOffset.v);		LineTo(pt2.h + scrollOffset.h, pt2.v + scrollOffset.v);				if (showDepths)// && sectionDepths[i] > 0)		{			ForeColor(blackColor);			FloatPoint centerSegLoc;			centerSegLoc.h = (pt1.h + pt2.h) / 2;			centerSegLoc.v = (pt1.v + pt2.v) / 2;			MoveTo(centerSegLoc.h + 5 + scrollOffset.h, centerSegLoc.v + scrollOffset.v);			Str255 str;			NumToString(sectionDepths[i], str);			DrawString(str);						if (maxPossibleSectionDepths.size() == sectionDepths.size())			{				DrawString("\p / ");				NumToString(maxPossibleSectionDepths[i], str);				DrawString(str);			}		}	}		//Mark the start of the cut	Rect r;	SetRect(&r, startLoc.h - 3 + scrollOffset.h, startLoc.v - 3 + scrollOffset.v, startLoc.h + 3 + scrollOffset.h, startLoc.v + 3 + scrollOffset.v);	ForeColor(blackColor);	PaintOval(&r);}void BSplineToBSplineCut::DrawPostscriptCut(short fRefNum, RGBColor color, MainWindow::ViewMode viewMode, Point canvasSize, bool showDepths){	string st;		MyAssert(sectionDepths.size() == intersections.size() - 1 || endLoc.h == -999999);		//Define the "deep" version of the color	RGBColor colorDeep = color;	colorDeep.red += (65535 - colorDeep.red) * .67;	colorDeep.green += (65535 - colorDeep.green) * .67;	colorDeep.blue += (65535 - colorDeep.blue) * .67;		RGBColor gray;	gray.red = gray.green = gray.blue = 65535 * .67;		bool allIntersectionsLegal = GetAllIntersectionsLegal(false);		//	0.0001	for hairlines, such as for posters	//	0.001	for print, such as papers	//	0.01	for pixelated images, such as presentations	double lineThickness = .002;	//The rest of this line is from BSpline.cpp	//drawOccludedSections ? .002 : (surfaceTraits.borderThickness / (double)max(canvasSize.h, canvasSize.v));	ostringstream lineThicknessOss;	lineThicknessOss << lineThickness;	st += lineThicknessOss.str();	st += " setlinewidth\n";		//Plot the sections	MyAssert(sectionDepths.size() == intersections.size() - 1 || endLoc.h == -999999);		for (int i = 0; i < sectionDepths.size(); i++)	{		if (sectionDepths[i] == 0)		{			ostringstream oss;			if (allIntersectionsLegal)			{				oss << ((double)color.red / 65535.0);				oss << " ";				oss << ((double)color.green / 65535.0);				oss << " ";				oss << ((double)color.blue / 65535.0);			}			else			{				oss << 0;				oss << " ";				oss << 0;				oss << " ";				oss << 0;			}						oss << " setrgbcolor\n";						st += oss.str();		}		else		{			ostringstream oss;			if (allIntersectionsLegal)			{				oss << ((double)colorDeep.red / 65535.0);				oss << " ";				oss << ((double)colorDeep.green / 65535.0);				oss << " ";				oss << ((double)colorDeep.blue / 65535.0);			}			else			{				oss << .66667;//((double)gray.red / 65535.0);				oss << " ";				oss << .66667;//((double)gray.green / 65535.0);				oss << " ";				oss << .66667;//((double)gray.blue / 65535.0);			}						oss << " setrgbcolor\n";						st += oss.str();		}				FloatPoint pt1 = intersections[i]->GetLocation();		FloatPoint pt2 = intersections[i + 1]->GetLocation();				ostringstream oss;		oss << (double)pt1.h / canvasSize.h;		oss << " ";		oss << (double)(canvasSize.v - pt1.v) / canvasSize.v;		oss << " moveto\n";				oss << (double)pt2.h / canvasSize.h;		oss << " ";		oss << (double)(canvasSize.v - pt2.v) / canvasSize.v;		oss << " lineto\n";				oss << "stroke\n";				st += oss.str();				if (showDepths)// && sectionDepths[i] > 0)		{			//ForeColor(blackColor);			FloatPoint centerSegLoc;			centerSegLoc.h = (pt1.h + pt2.h) / 2;			centerSegLoc.v = (pt1.v + pt2.v) / 2;			//MoveTo(centerSegLoc.h + 5 + scrollOffset.h, centerSegLoc.v + scrollOffset.v);			Str255 str;			NumToString(sectionDepths[i], str);			//DrawString(str);						//st += "/Times-Roman findfont .02 scalefont setfont\n";			st += "/Times-Roman findfont .03 scalefont setfont\n";						ostringstream oss;						oss << 0;			oss << " ";			oss << 0;			oss << " ";			oss << 0;						oss << " setrgbcolor\n";						oss << "newpath\n";						oss << (double)centerSegLoc.h / canvasSize.h;			oss << " ";			oss << (double)(canvasSize.v - centerSegLoc.v) / canvasSize.v;			oss << " moveto\n";						oss << "(";			oss << sectionDepths[i];			oss << ") show\n";						st += oss.str();		}	}		long strLen = st.length();	OSErr err = FSWrite(fRefNum, &strLen, st.c_str());}#pragma mark -void BSplineToBSplineCut::DumpFileData(short fRefNum){	string st;	ostringstream oss;		//Add the BSpline indexes	oss << "  " << drawing->GetBSplineIndex(bsp1) << " " << (bsp2 ? drawing->GetBSplineIndex(bsp2) : -1) << "\n";		//Add the curves and segs	oss << "  " << cv1 << " " << cv2 << " " << sg1 << " " << sg2 << "\n";		//File version 1.0 and 1.1 would write out the section depths.  No longer though.	//Add the number of sections	//oss << "  " << sectionDepths.size() << "\n";	//Add the section depths	//for (int i = 0; i < sectionDepths.size(); i++)	//	oss << "    " << sectionDepths[i] << "\n";		//That's it for Cut data	st += oss.str();	long strLen = st.length();	OSErr err = FSWrite(fRefNum, &strLen, st.c_str());}void BSplineToBSplineCut::LoadFileData(istringstream& iss, double fileVersion){	//Erase the present Cut (shouldn't be necessary since this Cut should have just been created, but oh well)		//sectionDepths.clear();	//sectionDepthConstraints.clear();		//=======================================================================================		//Load the BSpline indexes	int bsp1Index, bsp2Index;	iss >> bsp1Index >> bsp2Index;		vector<BSpline*> bsplines = drawing->GetBSplines();	MyAssert(bsp1Index < bsplines.size() && (bsp2Index < bsplines.size() || bsp2Index == -1));	bsp1 = bsplines[bsp1Index];	bsp2 = (bsp2Index != -1) ? bsplines[bsp2Index] : NULL;		//Load the curves and segs	iss >> cv1 >> cv2 >> sg1 >> sg2;		if (fileVersion == 1.0 || fileVersion == 1.1)	{		//Load the number of sections		int numSections;		iss >> numSections;		//sectionDepths.resize(numSections);		//sectionDepthConstraints.resize(numSections);				//Load the section depths		for (int i = 0; i < numSections; i++)		{			int sectionDepth;			iss >> sectionDepth;			//sectionDepths[i] = sectionDepth;		}	}		RecalcStartEndLocs();	BackupStartEndLocs();}#pragma mark -void BSplineToBSplineCut::SetBSplines(BSpline* theBsp1, BSpline* theBsp2){	bsp1 = theBsp1;	bsp2 = theBsp2;}void BSplineToBSplineCut::SetCurvesAndSegs(int newCv1, int newSg1, int newCv2, int newSg2){	cv1 = newCv1;	cv2 = newCv2;	sg1 = newSg1;	sg2 = newSg2;}void BSplineToBSplineCut::NullAllBspsAndCuts(){	for (int i = 0; i < intersections.size(); i++)	{		MyAssert(!intersections[i]->GetDtored());				switch (intersections[i]->GetType())		{			case GenericIntersection::BSP_BSP:				MyAssert(false);				break;			case GenericIntersection::BSP_CUT:				((BspCutIntersection*)intersections[i])->SetNullBsp();				((BspCutIntersection*)intersections[i])->SetNullCut();				break;			case GenericIntersection::BSP_CUT_T:				((BspCutTIntersection*)intersections[i])->SetNullBsp();				((BspCutTIntersection*)intersections[i])->SetNullCut();								if (((BspCutTIntersection*)intersections[i])->GetInfiniteWholeObject())					MyAssert(!((BspCutTIntersection*)intersections[i])->GetInfiniteWholeObject()->dtored);				break;			case GenericIntersection::CUT_CUT:				((CutCutIntersection*)intersections[i])->SetCut1(NULL, -1);				((CutCutIntersection*)intersections[i])->SetCut2(NULL, -1);				break;		}	}}void BSplineToBSplineCut::VerifyBackupsMatchPresent(){	MyAssert(sectionDepths.size() == intersections.size() - 1 || endLoc.h == -999999);		//MyAssert(prevStartLoc == startLoc && prevEndLoc == endLoc);	MyAssert(prevStartLoc.Equal(startLoc, .01) && prevEndLoc.Equal(endLoc, .01));}void BSplineToBSplineCut::VerifyNothingDtored(){	MyAssert(!dtored);	for (int i = 0; i < intersections.size(); i++)		MyAssert(!intersections[i]->GetDtored());}void BSplineToBSplineCut::BackupStartEndLocs(){	prevStartLoc = startLoc;	prevEndLoc = endLoc;		MyAssert(prevStartLoc.h != 0 && prevStartLoc.v != 0 && prevEndLoc.h != 0 && prevEndLoc.v != 0);}void BSplineToBSplineCut::RecalcStartEndLocs(){	RecalcStartLoc();	RecalcEndLoc();}void BSplineToBSplineCut::RecalcStartLoc(){	prevStartLoc = startLoc;		MyAssert(prevStartLoc.h != 0 && prevStartLoc.v != 0);		//Calculate the start loc	MyAssert(bsp1);		//MyAssert(BSpline::sNumSegmentsPerCurve >= 2);		vector<vector<FloatPoint>*>* curvePoints = bsp1->GetCurvePoints();	int bspTotalCurveSegs = curvePoints->size() * BSpline::sNumSegmentsPerCurve;	MyAssert(bspTotalCurveSegs > 0);		int segIndex = cv1 * BSpline::sNumSegmentsPerCurve + sg1;	int nextSegIndex = (segIndex + 1) % bspTotalCurveSegs;		startLoc.h = ((*(*curvePoints)[cv1])[sg1].h +				(*(*curvePoints)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].h) / 2;	startLoc.v = ((*(*curvePoints)[cv1])[sg1].v +				(*(*curvePoints)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].v) / 2;		MyAssert(startLoc.h != 0 && startLoc.v != 0);}void BSplineToBSplineCut::RecalcEndLoc(){	prevEndLoc = endLoc;		MyAssert(prevEndLoc.h != 0 && prevEndLoc.v != 0);		if (bsp2)	{		//Calculate the end loc		vector<vector<FloatPoint>*>* curvePoints = bsp2->GetCurvePoints();		int bspTotalCurveSegs = curvePoints->size() * BSpline::sNumSegmentsPerCurve;		MyAssert(bspTotalCurveSegs > 0);				int segIndex = cv2 * BSpline::sNumSegmentsPerCurve + sg2;		int nextSegIndex = (segIndex + 1) % bspTotalCurveSegs;				endLoc.h = ((*(*curvePoints)[cv2])[sg2].h +					(*(*curvePoints)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].h) / 2;		endLoc.v = ((*(*curvePoints)[cv2])[sg2].v +					(*(*curvePoints)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].v) / 2;	}	else	//No bsp2 means this Cut is an infinite Cut	{		//infinite Cuts extends horizontally to the left infinitely		endLoc.h = -999999;		endLoc.v = startLoc.v;	}		MyAssert(endLoc.h != 0 && endLoc.v != 0);}/*int BSplineToBSplineCut::DetermineStartOrEnd(BspCutTIntersection* inter){	if (intersections[0] == inter)		return 0;		if (intersections[intersections.size() - 1] == inter)		return 1;		MyAssert(false);	return -1;}*/