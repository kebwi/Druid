#include "BSpline.h"#include "Drawing.h"#include "Grid.h"#include "MainWindow.h"#include "ToolsWindow.h"#include "TextGenerator.h"#include "Enums.h"#include "Colors.h"#include <fstream>#define kMoveToFront (WindowPtr) -1L//******************************************************************************//Extern Globalsextern WindowRef gHelpTagWindow, gColorsWindow, gInfoWindow, gToolHelpWindow, gAnalysisWindow,	gReflectanceSliderWindow, gSurfaceTraitsWindow, gDataLogWindow;extern bool gQuit;extern MainWindow *gMainWindow;extern Drawing* gDrawing;extern ToolsWindow *gToolsWindow;extern TextGenerator *gTextGenerator;extern int gLabelingMethod;extern int gCompanionSetMethod;extern int gDepthEnumerationMethod;extern int gBoundingMethod;extern int gTreeSearchMethod;extern float gTimeLimitScalar;extern SurfaceTraits gSurfaceTraits;extern bool gDebug12;extern bool gDebug14;extern bool gTestLogOn;extern int gLogLine;extern clock_t gCSECsearchTime;//******************************************************************************//Global Declarationsconst MenuCommand kCommandOpenBGimage = FOUR_CHAR_CODE ('bgim');const MenuCommand kCommandExpPict = FOUR_CHAR_CODE ('expc');const MenuCommand kCommandExpPS = FOUR_CHAR_CODE ('exps');const MenuCommand kCommandDataLoggingOn = FOUR_CHAR_CODE ('dlon');const MenuCommand kCommandDeselectAll = FOUR_CHAR_CODE ('dlal');const MenuCommand kCommandDuplicate = FOUR_CHAR_CODE ('dupl');const MenuCommand kCommandFlipH = FOUR_CHAR_CODE ('flpH');const MenuCommand kCommandFlipV = FOUR_CHAR_CODE ('flpV');const MenuCommand kCommandRot90CW = FOUR_CHAR_CODE ('rtCW');const MenuCommand kCommandRot90CCW = FOUR_CHAR_CODE ('rtCC');const MenuCommand kCommandRot180 = FOUR_CHAR_CODE ('rtHF');const MenuCommand kCommandRotNumeric = FOUR_CHAR_CODE ('rtnm');const MenuCommand kCommandRotFree = FOUR_CHAR_CODE ('rtfr');const MenuCommand kCommandScaleNumeric = FOUR_CHAR_CODE ('scnm');const MenuCommand kCommandScaleFree = FOUR_CHAR_CODE ('scfr');const MenuCommand kCommandShowTools = FOUR_CHAR_CODE ('shtl');const MenuCommand kCommandShowColors = FOUR_CHAR_CODE ('shcl');const MenuCommand kCommandShowInfo = FOUR_CHAR_CODE ('shif');const MenuCommand kCommandShowToolHelp = FOUR_CHAR_CODE ('shth');const MenuCommand kCommandShowAnalysis = FOUR_CHAR_CODE ('shan');const MenuCommand kCommandShowSurfaceTraits = FOUR_CHAR_CODE ('shst');const MenuCommand kCommandShowDataLog = FOUR_CHAR_CODE ('shdl');const MenuCommand kCommandHideAllWindows = FOUR_CHAR_CODE ('hdal');const MenuCommand kCommandShowCrossingStates = FOUR_CHAR_CODE ('crst');const MenuCommand kCommandShowCuts = FOUR_CHAR_CODE ('cuts');const MenuCommand kCommandShowDepths = FOUR_CHAR_CODE ('dths');const MenuCommand kCommandShowCompSets = FOUR_CHAR_CODE ('cpst');const MenuCommand kCommandSplineMode = FOUR_CHAR_CODE ('spln');const MenuCommand kCommandKnotMode = FOUR_CHAR_CODE ('knot');const MenuCommand kCommandSurfaceMode = FOUR_CHAR_CODE ('surf');//Note that I was forced to hardcode these constants into the nib file.  If they are changed in either the nib file or the code, the other must be changed to match.const MenuCommand kCommandGridSettings = FOUR_CHAR_CODE ('grst');const MenuCommand kCommandShowGrid = FOUR_CHAR_CODE ('shgr');const MenuCommand kCommandSnapToGrid = FOUR_CHAR_CODE ('sngr');const MenuCommand kCommandSignOfOcclusionArrows = FOUR_CHAR_CODE ('soar');const MenuCommand kCommandSignOfOcclusionHashes = FOUR_CHAR_CODE ('sohs');const MenuCommand kCommandSignOfOcclusionSmallerHashes = FOUR_CHAR_CODE ('hssm');const MenuCommand kCommandSignOfOcclusionLargerHashes = FOUR_CHAR_CODE ('hslg');static bool sSavingFile = false;//******************************************************************************//Function Prototypes	//	In this filevoid MenuBarInit();void WindowInit();void EventHandlersInit();void MainWindowEventHandlersInit();void MainWindowEventHandlersDestroy();void ToolBoxInit();//pascal OSStatus AppleEventHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData);static pascal OSErr OpenDocAppleEventHandler(const AppleEvent* theAppleEvent, AppleEvent* reply, long refCon);pascal OSStatus KeyboardHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData);pascal OSStatus DoWindowHide(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData);pascal OSStatus MainWindowHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData);pascal OSStatus MouseMovedHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData);pascal void WindowBoundaryDragEventHandler(EventLoopTimerRef theTimer, void* userData);pascal void MouseCatchUpEventHandler(EventLoopTimerRef theTimer, void* userData);pascal void LabelingAttemptPendingEventHandler(EventLoopTimerRef theTimer, void* userData);pascal OSStatus ToolsWindowHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData);pascal OSStatus ColorsWindowHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData);pascal OSStatus InfoWindowHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData);pascal OSStatus ToolHelpWindowHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData);pascal OSStatus AnalysisWindowHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData);pascal OSStatus SurfaceTraitsWindowHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData);pascal OSStatus DataLogWindowHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData);pascal void SurfaceTraitsSliderHandler(ControlRef controlRef, ControlPartCode partCode);pascal OSStatus MenuHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData);	//	In external files		//main.cppvoid MyAssert(bool condition);void DoAboutBox();void RedrawColorsWindow();void RedrawInfoWindow();void RedrawToolHelpWindow();void RedrawSurfaceTraitsWindow();void HandleColorChange(Point where);void HandleSurfaceTraitsColorChange(Point where);void HandleColorWindowMouseMoved(Point where);#pragma mark -void MenuBarInit(){	MenuHandle menuHandle;		IBNibRef theNib;	OSStatus err = CreateNibReference(CFSTR("main"), &theNib);	if (err == noErr)		err = SetMenuBarFromNib(theNib, CFSTR("MainMenuBar"));		//Remove the Quit menu item from the File menu when running on OS X.	long result;	err = Gestalt(gestaltMenuMgrAttr, &result);	if (!err && (result & gestaltMenuMgrAquaLayoutMask))	{		menuHandle = GetMenuHandle(FILE_MENU);		DeleteMenuItem(menuHandle, QUIT);		DeleteMenuItem(menuHandle, QUIT - 1);	}		//InsertMenu isn't working for some reason (GetMenu() is returning NULL).  I know I thought it should only be necessary for nib files, but I can't get my nib submenus to work.	//We don't need it anyway.  With nib files, I handle submenus using GetMenuItemHierarchicalMenu().	/*	menuHandle = GetMenuHandle(GRID_MENU);	menuHandle = GetMenu(GRID_MENU);	InsertMenu(GetMenu(GRID_MENU), -1);	//I think this is unnecessary for nib files, only for resources	menuHandle = GetMenuHandle(GRID_MENU);	menuHandle = GetMenu(GRID_MENU);	*/	menuHandle = GetMenuHandle(EDIT_MENU);	DisableMenuItem(menuHandle, UNDO);	DisableMenuItem(menuHandle, REDO);	DisableMenuItem(menuHandle, CUT);	DisableMenuItem(menuHandle, COPY);	DisableMenuItem(menuHandle, PASTE);	//DisableMenuItem(menuHandle, CLEAR);		menuHandle = GetMenuHandle(VIEW_MENU);	CheckMenuItem(menuHandle, SHOW_TOOLS, true);	CheckMenuItem(menuHandle, SHOW_COLORS, true);	CheckMenuItem(menuHandle, SHOW_INFO, true);	CheckMenuItem(menuHandle, SHOW_TOOL_HELP, true);	CheckMenuItem(menuHandle, SHOW_ANALYSIS, true);	CheckMenuItem(menuHandle, SHOW_SURFACE_TRAITS, true);	CheckMenuItem(menuHandle, SHOW_DATA_LOG, true);		CheckMenuItem(menuHandle, SHOW_CROSSING_STATES, gDrawing->GetShowCrossingStates());	CheckMenuItem(menuHandle, SHOW_CUTS, gDrawing->GetShowCuts());	CheckMenuItem(menuHandle, SHOW_DEPTHS, gDrawing->GetShowDepths());	CheckMenuItem(menuHandle, SHOW_COMP_SETS, gDrawing->GetShowCompSets());		switch (gMainWindow->GetViewMode())	{		case MainWindow::SPLINE_MODE:			CheckMenuItem(menuHandle, VIEW_SPLINE_MODE, true);			DisableMenuItem(GetMenuHandle(FILE_MENU), EXPORT_TO_PS);			break;		case MainWindow::KNOT_MODE:			CheckMenuItem(menuHandle, VIEW_KNOT_MODE, true);			break;		case MainWindow::SURFACE_MODE:			CheckMenuItem(menuHandle, VIEW_SURFACE_MODE, true);			break;	}		MenuRef hierMenuRef;	GetMenuItemHierarchicalMenu(GetMenuHandle(VIEW_MENU), GRID_SETTINGS1, &hierMenuRef);	CheckMenuItem(hierMenuRef, SHOW_GRID, gMainWindow->GetShowGrid());	CheckMenuItem(hierMenuRef, SNAP_TO_GRID, gMainWindow->GetSnapToGrid());		GetMenuItemHierarchicalMenu(GetMenuHandle(VIEW_MENU), SIGN_OF_OCCLUSION, &hierMenuRef);	if (BSpline::sShadeWithArrows)		CheckMenuItem(hierMenuRef, SIGN_OF_OCCLUSION_ARROWS, true);	else CheckMenuItem(hierMenuRef, SIGN_OF_OCCLUSION_HASHES, true);		DrawMenuBar();}void WindowInit(){	//gMainWindow = GetNewCWindow(128, NULL, NULL);		//kFloatingWindowClass	//gColorsWindow = GetNewCWindow(130, NULL, NULL);	//gInfoWindow = GetNewCWindow(131, NULL, NULL);	//gToolHelpWindow = GetNewCWindow(132, NULL, NULL);	//gAnalysisWindow = GetNewCWindow(133, NULL, NULL);	//gReflectanceSliderWindow = GetNewCWindow(134, NULL, NULL);		//MacWindows.h	/*	floatProc                     = 1985,	floatGrowProc                 = 1987,	floatZoomProc                 = 1989,	floatZoomGrowProc             = 1991,	floatSideProc                 = 1993,	floatSideGrowProc             = 1995,	floatSideZoomProc             = 1997,	floatSideZoomGrowProc         = 1999	*/		//To change window attributes	//ChangeWindowAttributes(gMainWindow, NULL, kWindowResizableAttribute);		//=============================================================================		IBNibRef theNib;	OSStatus err = CreateNibReference(CFSTR("main"), &theNib);		CreateWindowFromNib(theNib, CFSTR("HelpTagWindow"), &gHelpTagWindow);	HideWindow(gHelpTagWindow);		CreateWindowFromNib(theNib, CFSTR("ColorsWindow"), &gColorsWindow);	ShowWindow(gColorsWindow);		CreateWindowFromNib(theNib, CFSTR("InfoWindow"), &gInfoWindow);	ShowWindow(gInfoWindow);		CreateWindowFromNib(theNib, CFSTR("ToolHelpWindow"), &gToolHelpWindow);	ShowWindow(gToolHelpWindow);		CreateWindowFromNib(theNib, CFSTR("SearchStatusWindow"), &gAnalysisWindow);	ShowWindow(gAnalysisWindow);		CreateWindowFromNib(theNib, CFSTR("OpacitySlider"), &gReflectanceSliderWindow);	HideWindow(gReflectanceSliderWindow);		CreateWindowFromNib(theNib, CFSTR("SurfaceTraits"), &gSurfaceTraitsWindow);	ShowWindow(gSurfaceTraitsWindow);		CreateWindowFromNib(theNib, CFSTR("DataLog"), &gDataLogWindow);	ShowWindow(gDataLogWindow);		//Keep things on the screen as much as possible	CGrafPtr presentPort; 	GDHandle presentDevice;	GetGWorld(&presentPort, &presentDevice);	Rect screenBounds;	GetAvailableWindowPositioningBounds(presentDevice, &screenBounds);		for (int i = 0; i < 6; i++)	{		WindowRef windowRef;		switch (i)		{			case 0:	windowRef = gColorsWindow;	break;			case 1:	windowRef = gInfoWindow;	break;			case 2:	windowRef = gToolHelpWindow;	break;			case 3:	windowRef = gAnalysisWindow;	break;			case 4:	windowRef = gSurfaceTraitsWindow;	break;			case 5:	windowRef = gDataLogWindow;	break;		}				Rect windowBounds;		GetPortBounds(GetWindowPort(windowRef), &windowBounds);		SetPort(GetWindowPort(windowRef));		Point pt;		pt.h = 0;		pt.v = 0;		LocalToGlobal(&pt);		if (pt.h > screenBounds.right - windowBounds.right)			pt.h = screenBounds.right - windowBounds.right;		if (pt.v > screenBounds.bottom - windowBounds.bottom)			pt.v = screenBounds.bottom - windowBounds.bottom;		if (pt.h < screenBounds.left)			pt.h = screenBounds.left;		if (pt.v < screenBounds.top)			pt.v = screenBounds.top;		MoveWindow(windowRef, pt.h, pt.v, false);	}}void EventHandlersInit(){	//EventTypeSpec eventTypesApple[] = {{(kEventClassAppleEvent), kEventAppleEvent}};		//InstallApplicationEventHandler(NewEventHandlerUPP(AppleEventHandler), 1, eventTypesApple, NULL, NULL);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, NewAEEventHandlerUPP(&OpenDocAppleEventHandler), 0, false);		//===============================================================================	MainWindowEventHandlersInit();		//===============================================================================	WindowRef toolsWindow = gToolsWindow->GetWindow();		InstallStandardEventHandler(GetWindowEventTarget(toolsWindow));	InstallStandardEventHandler(GetWindowEventTarget(gColorsWindow));	InstallStandardEventHandler(GetWindowEventTarget(gInfoWindow));	InstallStandardEventHandler(GetWindowEventTarget(gToolHelpWindow));	InstallStandardEventHandler(GetWindowEventTarget(gAnalysisWindow));	InstallStandardEventHandler(GetWindowEventTarget(gReflectanceSliderWindow));	InstallStandardEventHandler(GetWindowEventTarget(gSurfaceTraitsWindow));	InstallStandardEventHandler(GetWindowEventTarget(gDataLogWindow));		//===============================================================================	EventTypeSpec eventTypesKB[] = {{kEventClassKeyboard, kEventRawKeyDown},									{kEventClassKeyboard, kEventRawKeyRepeat},									{kEventClassKeyboard, kEventRawKeyUp}};		InstallApplicationEventHandler(NewEventHandlerUPP(KeyboardHandler), 3, eventTypesKB, NULL, NULL);		//===============================================================================	EventTypeSpec eventTypeWD = {kEventClassWindow, kEventWindowClose};		InstallWindowEventHandler(toolsWindow, NewEventHandlerUPP(DoWindowHide), 1, &eventTypeWD, NULL, NULL);	InstallWindowEventHandler(gColorsWindow, NewEventHandlerUPP(DoWindowHide), 1, &eventTypeWD, NULL, NULL);	InstallWindowEventHandler(gInfoWindow, NewEventHandlerUPP(DoWindowHide), 1, &eventTypeWD, NULL, NULL);	InstallWindowEventHandler(gToolHelpWindow, NewEventHandlerUPP(DoWindowHide), 1, &eventTypeWD, NULL, NULL);	InstallWindowEventHandler(gAnalysisWindow, NewEventHandlerUPP(DoWindowHide), 1, &eventTypeWD, NULL, NULL);	InstallWindowEventHandler(gSurfaceTraitsWindow, NewEventHandlerUPP(DoWindowHide), 1, &eventTypeWD, NULL, NULL);	InstallWindowEventHandler(gDataLogWindow, NewEventHandlerUPP(DoWindowHide), 1, &eventTypeWD, NULL, NULL);		//===============================================================================		//This mouse move handler can't be "part of" the main window handlers because	//it won't get triggered if the mouse is moving while outside the window boundaries.	EventTypeSpec mouseMovedEventList[] = {kEventClassMouse, kEventMouseMoved};                                 	InstallApplicationEventHandler(NewEventHandlerUPP(MouseMovedHandler), 1, mouseMovedEventList, NULL, NULL);		//===============================================================================	EventTypeSpec toolsEventList[] = {{kEventClassWindow, kEventWindowDrawContent},									{kEventClassWindow, kEventWindowActivated},									{kEventClassWindow, kEventWindowClickContentRgn},									{kEventClassMouse, kEventMouseUp}};                                 	InstallWindowEventHandler(toolsWindow, NewEventHandlerUPP(ToolsWindowHandler), 4, toolsEventList, NULL, NULL);		//===============================================================================	EventTypeSpec colorsEventList[] = {{kEventClassWindow, kEventWindowDrawContent},									{kEventClassWindow, kEventWindowActivated},									{kEventClassWindow, kEventWindowClickContentRgn}};                                 	InstallWindowEventHandler(gColorsWindow, NewEventHandlerUPP(ColorsWindowHandler), 3, colorsEventList, NULL, NULL);		//===============================================================================	EventTypeSpec infoEventList[] = {{kEventClassWindow, kEventWindowDrawContent},									{kEventClassWindow, kEventWindowActivated}};                                 	InstallWindowEventHandler(gInfoWindow, NewEventHandlerUPP(InfoWindowHandler), 2, infoEventList, NULL, NULL);		//===============================================================================	EventTypeSpec toolHelpEventList[] = {{kEventClassWindow, kEventWindowDrawContent},										{kEventClassWindow, kEventWindowActivated}};                                 	InstallWindowEventHandler(gToolHelpWindow, NewEventHandlerUPP(ToolHelpWindowHandler), 2, toolHelpEventList, NULL, NULL);		//===============================================================================	EventTypeSpec analysisEventList[] = {{kEventClassWindow, kEventWindowDrawContent},										{kEventClassWindow, kEventWindowActivated}};                                 	InstallWindowEventHandler(gAnalysisWindow, NewEventHandlerUPP(AnalysisWindowHandler), 2, analysisEventList, NULL, NULL);		//===============================================================================	EventTypeSpec surfaceTraitsEventList[] = {{kEventClassWindow, kEventWindowDrawContent},											{kEventClassWindow, kEventWindowActivated},											{kEventClassWindow, kEventWindowClickContentRgn}};                                 	InstallWindowEventHandler(gSurfaceTraitsWindow, NewEventHandlerUPP(SurfaceTraitsWindowHandler), 3, surfaceTraitsEventList, NULL, NULL);		ControlID inID = { 'sftr', 1 };	ControlRef controlRef;	GetControlByID(gSurfaceTraitsWindow, &inID, &controlRef);	SetControlAction(controlRef, NewControlActionUPP(SurfaceTraitsSliderHandler));		inID.id = 2;	GetControlByID(gSurfaceTraitsWindow, &inID, &controlRef);	GetControlByID(gSurfaceTraitsWindow, &inID, &controlRef);	SetControlAction(controlRef, NewControlActionUPP(SurfaceTraitsSliderHandler));		inID.id = 3;	GetControlByID(gSurfaceTraitsWindow, &inID, &controlRef);	GetControlByID(gSurfaceTraitsWindow, &inID, &controlRef);	SetControlAction(controlRef, NewControlActionUPP(SurfaceTraitsSliderHandler));		//===============================================================================	EventTypeSpec dataLogEventList[] = {{kEventClassWindow, kEventWindowDrawContent},										{kEventClassWindow, kEventWindowActivated}};                                 	InstallWindowEventHandler(gDataLogWindow, NewEventHandlerUPP(DataLogWindowHandler), 2, dataLogEventList, NULL, NULL);		//===============================================================================	SetMenuItemCommandID (GetMenuHandle(APPLE_MENU), 1, kHICommandAbout);		SetMenuItemCommandID (GetMenuHandle(FILE_MENU), NEW, kHICommandNew);	SetMenuItemCommandID (GetMenuHandle(FILE_MENU), OPEN, kHICommandOpen);	SetMenuItemCommandID (GetMenuHandle(FILE_MENU), OPEN_BG_IMAGE, kCommandOpenBGimage);	SetMenuItemCommandID (GetMenuHandle(FILE_MENU), SAVE, kHICommandSave);	SetMenuItemCommandID (GetMenuHandle(FILE_MENU), SAVE_AS, kHICommandSaveAs);	SetMenuItemCommandID (GetMenuHandle(FILE_MENU), CLOSE, kHICommandClose);	SetMenuItemCommandID (GetMenuHandle(FILE_MENU), EXPORT_TO_PICT, kCommandExpPict);	SetMenuItemCommandID (GetMenuHandle(FILE_MENU), EXPORT_TO_PS, kCommandExpPS);	SetMenuItemCommandID (GetMenuHandle(FILE_MENU), DATA_LOGGING_ON, kCommandDataLoggingOn);	SetMenuItemCommandID (GetMenuHandle(FILE_MENU), QUIT, kHICommandQuit);		SetMenuItemCommandID (GetMenuHandle(EDIT_MENU), UNDO, kHICommandUndo);	SetMenuItemCommandID (GetMenuHandle(EDIT_MENU), REDO, kHICommandRedo);	SetMenuItemCommandID (GetMenuHandle(EDIT_MENU), CLEAR, kHICommandClear);	SetMenuItemCommandID (GetMenuHandle(EDIT_MENU), SELECT_ALL, kHICommandSelectAll);	SetMenuItemCommandID (GetMenuHandle(EDIT_MENU), DESELECT_ALL, kCommandDeselectAll);	SetMenuItemCommandID (GetMenuHandle(EDIT_MENU), DUPLICATE, kCommandDuplicate);		SetMenuItemCommandID (GetMenuHandle(BSPLINE_MENU), FLIP_H, kCommandFlipH);	SetMenuItemCommandID (GetMenuHandle(BSPLINE_MENU), FLIP_V, kCommandFlipV);	SetMenuItemCommandID (GetMenuHandle(BSPLINE_MENU), ROT_90_CW, kCommandRot90CW);	SetMenuItemCommandID (GetMenuHandle(BSPLINE_MENU), ROT_90_CCW, kCommandRot90CCW);	SetMenuItemCommandID (GetMenuHandle(BSPLINE_MENU), ROT_180, kCommandRot180);	SetMenuItemCommandID (GetMenuHandle(BSPLINE_MENU), ROT_NUMERIC, kCommandRotNumeric);	SetMenuItemCommandID (GetMenuHandle(BSPLINE_MENU), ROT_FREE, kCommandRotFree);	SetMenuItemCommandID (GetMenuHandle(BSPLINE_MENU), SCALE_NUMERIC, kCommandScaleNumeric);	SetMenuItemCommandID (GetMenuHandle(BSPLINE_MENU), SCALE_FREE, kCommandScaleFree);		SetMenuItemCommandID (GetMenuHandle(VIEW_MENU), SHOW_TOOLS, kCommandShowTools);	SetMenuItemCommandID (GetMenuHandle(VIEW_MENU), SHOW_COLORS, kCommandShowColors);	SetMenuItemCommandID (GetMenuHandle(VIEW_MENU), SHOW_INFO, kCommandShowInfo);	SetMenuItemCommandID (GetMenuHandle(VIEW_MENU), SHOW_TOOL_HELP, kCommandShowToolHelp);	SetMenuItemCommandID (GetMenuHandle(VIEW_MENU), SHOW_ANALYSIS, kCommandShowAnalysis);	SetMenuItemCommandID (GetMenuHandle(VIEW_MENU), SHOW_SURFACE_TRAITS, kCommandShowSurfaceTraits);	SetMenuItemCommandID (GetMenuHandle(VIEW_MENU), SHOW_DATA_LOG, kCommandShowDataLog);	SetMenuItemCommandID (GetMenuHandle(VIEW_MENU), HIDE_ALL_WINDOWS, kCommandHideAllWindows);	SetMenuItemCommandID (GetMenuHandle(VIEW_MENU), SHOW_CROSSING_STATES, kCommandShowCrossingStates);	SetMenuItemCommandID (GetMenuHandle(VIEW_MENU), SHOW_CUTS, kCommandShowCuts);	SetMenuItemCommandID (GetMenuHandle(VIEW_MENU), SHOW_DEPTHS, kCommandShowDepths);	SetMenuItemCommandID (GetMenuHandle(VIEW_MENU), SHOW_COMP_SETS, kCommandShowCompSets);	SetMenuItemCommandID (GetMenuHandle(VIEW_MENU), VIEW_SPLINE_MODE, kCommandSplineMode);	SetMenuItemCommandID (GetMenuHandle(VIEW_MENU), VIEW_KNOT_MODE, kCommandKnotMode);	SetMenuItemCommandID (GetMenuHandle(VIEW_MENU), VIEW_SURFACE_MODE, kCommandSurfaceMode);		//Note that the following code doesn't work because GetMenuHandle() returns NULL for a submenu in the nib file.	//Thus, I was forced to hardcode these constants into the nib file.  If they are changed in either the nib file or the code, the other must be changed to match.	/*	menuHandle = GetMenuHandle(GRID_MENU);	err = SetMenuItemCommandID (GetMenuHandle(GRID_MENU), GRID_SETTINGS2, kCommandGridSettings);	SetMenuItemCommandID (GetMenuHandle(GRID_MENU), SHOW_GRID, kCommandShowGrid);	SetMenuItemCommandID (GetMenuHandle(GRID_MENU), SNAP_TO_GRID, kCommandSnapToGrid);	*/	EventTypeSpec myEvents = {kEventClassCommand, kEventCommandProcess};		InstallApplicationEventHandler(NewEventHandlerUPP(MenuHandler), 1, &myEvents, NULL, NULL);}void MainWindowEventHandlersInit(){	WindowRef mainWindow = gMainWindow->GetWindow();		/*EventHandlerRef mainWindowStandardEventHandler = */InstallStandardEventHandler(GetWindowEventTarget(mainWindow));	//gMainWindow->SetMainWindowStandardEventHandler(mainWindowStandardEventHandler);		//===============================================================================	EventTypeSpec eventTypeWD = {kEventClassWindow, kEventWindowClose};		/*EventHandlerRef mainWindowHideEventHandler = */InstallWindowEventHandler(mainWindow, NewEventHandlerUPP(DoWindowHide), 1, &eventTypeWD, NULL, NULL);	//gMainWindow->SetMainWindowHideEventHandler(mainWindowHideEventHandler);		//===============================================================================	EventTypeSpec windEventList[] = {{kEventClassWindow, kEventWindowDrawContent},									{kEventClassWindow, kEventWindowActivated},									{kEventClassWindow, kEventWindowGetClickActivation},									{kEventClassWindow, kEventWindowClickContentRgn},									{kEventClassWindow, kEventWindowHandleContentClick},									{kEventClassWindow, kEventWindowBoundsChanged},									{kEventClassWindow, kEventWindowZoom}};                                 	/*EventHandlerRef mainWindowGeneralEventHandler = */InstallWindowEventHandler(mainWindow, NewEventHandlerUPP(MainWindowHandler), 7, windEventList, NULL, NULL);	//gMainWindow->SetMainWindowGeneralEventHandler(mainWindowGeneralEventHandler);}void MainWindowEventHandlersDestroy(){	return;		RemoveEventHandler(gMainWindow->GetMainWindowStandardEventHandler());	RemoveEventHandler(gMainWindow->GetMainWindowHideEventHandler());	RemoveEventHandler(gMainWindow->GetMainWindowGeneralEventHandler());}	void ToolBoxInit(){	InitCursor();	//EnterMovies();}/*pascal OSStatus AppleEventHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){	char c;	OSErr err = GetEventParameter(theEvent, kEventParamKeyMacCharCodes, typeChar,						NULL, sizeof(char), NULL, &c);		UInt32              whatHappened;	whatHappened = GetEventKind(theEvent);		switch (whatHappened)	{		case kEventAppleEvent:			OSType eventType;			err = GetEventParameter(theEvent, kEventParamAEEventID, typeType,								NULL, sizeof(OSType), NULL, &eventType);			switch (eventType)			{				case kAEOpenApplication:	//'oapp':	//Open application, called at startup					break;				case kAEOpenDocuments:		//'odoc':	//Open document, called when a document icon is drag-and-dropped onto the app's finder icon					gMainWindow->AutoOpenFileFromAppleEvent(theEvent);					break;				case kAEPrintDocuments:		//'pdoc':	//Print document, called when the finder or another app wants a document printed, not just opened					break;				case kAEQuitApplication:	//'quit':	//Quit application, called when finder quits the app (by control-clicking the dock for example)					QuitApplicationEventLoop();					break;			}			break;	}		return noErr;}*/static pascal OSErr OpenDocAppleEventHandler(const AppleEvent* theAppleEvent, AppleEvent* reply, long refCon){	gMainWindow->AutoOpenFileFromAppleEvent(theAppleEvent);		return noErr;}pascal OSStatus KeyboardHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){	if (sSavingFile)	//To prevent keystrokes in a file name dialog box from issuing commands to Druid in beneath the dialog		return eventNotHandledErr;		char c;	OSErr err = GetEventParameter(theEvent, kEventParamKeyMacCharCodes, typeChar,						NULL, sizeof(char), NULL, &c);		UInt32              whatHappened;	whatHappened = GetEventKind(theEvent);		if (gToolsWindow->GetToolType() == ToolsWindow::TEXT)		return eventNotHandledErr;		UInt32 modifierKeys;	err = GetEventParameter(theEvent, kEventParamKeyModifiers, typeUInt32,						NULL, sizeof(UInt32), NULL, &modifierKeys);		//If typing a note in the log, then key strokes are captured for that purpose	if (gMainWindow->GetDataLogNoteInProgress() && c != '\r')	{		if (whatHappened == kEventRawKeyDown || whatHappened == kEventRawKeyRepeat)			gMainWindow->AppendDataLogNote(c);		return eventNotHandledErr;	}		if (whatHappened == kEventRawKeyDown || whatHappened == kEventRawKeyRepeat)	{		switch (c)		{			case ' ':				if (whatHappened == kEventRawKeyDown)					gToolsWindow->HandleSpaceBarDown();				break;			case '\34':	//left arrow				gMainWindow->Nudge(MainWindow::LEFT, modifierKeys & shiftKey);				break;			case '\35':	//right arrow				gMainWindow->Nudge(MainWindow::RIGHT, modifierKeys & shiftKey);				break;			case '\36':	//up arrow				gMainWindow->Nudge(MainWindow::UP, modifierKeys & shiftKey);				break;			case '\37':	//down arrow				gMainWindow->Nudge(MainWindow::DOWN, modifierKeys & shiftKey);				break;			/*case 'P':				if (whatHappened == kEventRawKeyDown)					gMainWindow->ToggleAutoPictExport();				break;			case 'p':				if (whatHappened == kEventRawKeyDown)				{					for (int i = 0; i < 10; i++)						gMainWindow->ExportToPict(false);				}				break;			*/case 'y':				if (whatHappened == kEventRawKeyDown)					gMainWindow->RunPileTest();				break;			case 't':				if (whatHappened == kEventRawKeyDown)				{					//sSavingFile = true;					//gMainWindow->ExportToPostscript();					//sSavingFile = false;					gMainWindow->RunTests(0);				}				break;			case 'T':				if (whatHappened == kEventRawKeyDown)					gMainWindow->RunTests(1);				break;			case '\r':				if (whatHappened == kEventRawKeyDown)					gMainWindow->ToggleDataLogNote();				break;			case 'L':				if (whatHappened == kEventRawKeyDown)				{					gTestLogOn = !gTestLogOn;										SetPort(GetWindowPort(gDataLogWindow));					Rect r;					GetPortBounds(GetWindowPort(gDataLogWindow), &r);					EraseRect(&r);					TextSize(18);					ForeColor(blackColor);					MoveTo(10, 30);					gTestLogOn ? DrawString("\pTest Log on") : DrawString("\pTest Log off");				}				break;			case 'k':				if (whatHappened == kEventRawKeyDown)				{					if (gTestLogOn)					{						ofstream ofs;						ofs.open("testData", ofstream::app);						if (ofs)						{							ofs << endl;							ofs.close();						}						gLogLine = 0;												SetPort(GetWindowPort(gDataLogWindow));						Rect r;						GetPortBounds(GetWindowPort(gDataLogWindow), &r);						EraseRect(&r);						TextSize(18);						ForeColor(blackColor);						MoveTo(10, 30);						DrawString("\pAdded log empty line");					}				}				break;			case 'l':				if (whatHappened == kEventRawKeyDown)				{					gMainWindow->IncrementUndoStack();					gMainWindow->CreateLegalLabeling();					gMainWindow->Redraw();				}				break;			/*case 's':				if (whatHappened == kEventRawKeyDown)					gMainWindow->StopLabelingAttempt();				break;			*/case '/':				if (whatHappened == kEventRawKeyDown)				{					gMainWindow->IncrementUndoStack();					gMainWindow->ClearDepths();				}				break;			case '?':				if (whatHappened == kEventRawKeyDown)				{					gMainWindow->IncrementUndoStack();					gMainWindow->ClearLabeling();				}				break;			case '\'':				if (whatHappened == kEventRawKeyDown)				{					gMainWindow->IncrementUndoStack();					gDrawing->DeleteAllCompSets();					gMainWindow->Redraw();				}				break;			case 'g':				if (whatHappened == kEventRawKeyDown)				{					gMainWindow->IncrementUndoStack();					gDrawing->AttemptToFindBetterCuts();					gMainWindow->Redraw();				}				break;			case '\\':				if (whatHappened == kEventRawKeyDown)				{					gMainWindow->IncrementUndoStack();					gDrawing->ClearAnalysisWindow();					gDrawing->FindInterCompSetsForAllInters();					gMainWindow->Redraw();										//Tests					/*					for (int iii = 0; iii < 20; iii++)					{						gDrawing->DeleteAllCompSets();	//¥¥¥Just for tests												gMainWindow->IncrementUndoStack();						gDrawing->ClearAnalysisWindow();						gDrawing->FindInterCompSetsForAllInters();						ofstream ofs;						ofs.open("csecSearch", ofstream::app);						if (ofs)						{							ofs << gDrawing->GetNumIntersections() << "\t" << gCSECsearchTime << endl;							ofs.close();						}					}										SysBeep(1);					clock_t st = clock();					while ((clock() - st) / CLOCKS_PER_SEC < .2);					SysBeep(1);					st = clock();					while ((clock() - st) / CLOCKS_PER_SEC < .2);					SysBeep(1);					st = clock();					while ((clock() - st) / CLOCKS_PER_SEC < .2);					SysBeep(1);					st = clock();					while ((clock() - st) / CLOCKS_PER_SEC < .2);					SysBeep(1);					st = clock();					while ((clock() - st) / CLOCKS_PER_SEC < .2);					SysBeep(1);										gMainWindow->Redraw();					*/				}				break;			case '|':				gMainWindow->IncrementUndoStack();				gDrawing->ClearAnalysisWindow();				//gDrawing->FindInterCompSetsForUnlabeledDrawing();				gDrawing->FindInterCompSetsForAllInters2();				gMainWindow->Redraw();				break;			case '=':				if (whatHappened == kEventRawKeyDown)				{					gMainWindow->IncrementUndoStack();					gMainWindow->ClearLabeling();					gDrawing->DeleteAllCompSets();										//==============================================										//gMainWindow->IncrementUndoStack();					gDrawing->ClearAnalysisWindow();					gDrawing->RandomizeCrossingStates();					gMainWindow->Redraw();				}				break;			case '+':				if (whatHappened == kEventRawKeyDown)				{					gMainWindow->IncrementUndoStack();					gDrawing->ClearAnalysisWindow();					gDrawing->SortBSplineCrossingStates();					gMainWindow->Redraw();				}				break;			case '\b':	//backspace				gMainWindow->IncrementUndoStack();				gMainWindow->DeleteSelected();				break;			case '[':				gLabelingMethod = 0;				gDrawing->ClearAnalysisWindow();				break;			case ']':				gLabelingMethod = 1;				gDrawing->ClearAnalysisWindow();				break;			case '1':				gCompanionSetMethod = 0;				gDrawing->ClearAnalysisWindow();				break;			case '2':				gCompanionSetMethod = 1;				gDrawing->ClearAnalysisWindow();				break;			case '3':				gCompanionSetMethod = 2;				gDrawing->ClearAnalysisWindow();				break;			case 'q':				gDepthEnumerationMethod = 0;				gDrawing->ClearAnalysisWindow();				break;			case 'w':				gDepthEnumerationMethod = 1;				gDrawing->ClearAnalysisWindow();				break;			case 'e':				gDepthEnumerationMethod = 2;				gDrawing->ClearAnalysisWindow();				break;			case 'a':				gBoundingMethod = 0;				gDrawing->ClearAnalysisWindow();				break;			case 's':				gBoundingMethod = 1;				gDrawing->ClearAnalysisWindow();				break;			case 'z':				gTreeSearchMethod = 0;				gDrawing->ClearAnalysisWindow();				break;			case 'x':				gTreeSearchMethod = 1;				gDrawing->ClearAnalysisWindow();				break;			case 'c':				//gTreeSearchMethod = 2;				//gDrawing->ClearAnalysisWindow();				break;			case ',':				if (gTimeLimitScalar >= 10.0)					gTimeLimitScalar /= 10.0;				if (gTimeLimitScalar < 1.0)					gTimeLimitScalar = 1.0;				gDrawing->ClearAnalysisWindow();				break;			case '.':				if (gTimeLimitScalar < 1000000.0)					gTimeLimitScalar *= 10.0;				gDrawing->ClearAnalysisWindow();				break;			case '`':				gDebug14 = !gDebug14;				if (!gDebug14)					gDebug12 = false;				gDrawing->ClearAnalysisWindow();				break;			case '~':				gDebug12 = !gDebug12;				if (gDebug12)					gDebug14 = true;				gDrawing->ClearAnalysisWindow();				break;					}	}	else if (whatHappened == kEventRawKeyUp)	{		switch (c)		{			case ' ':				gToolsWindow->HandleSpaceBarUp();				break;		}	}		//Allow other parts of the program to use the key events as well.	return eventNotHandledErr;}pascal OSStatus DoWindowHide(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){	WindowRef window;		OSErr err = GetEventParameter(theEvent, kEventParamWindowRef, typeWindowRef,						NULL, sizeof(WindowRef), NULL, &window);	err = GetEventParameter(theEvent, kEventParamDirectObject, typeWindowRef,						NULL, sizeof(WindowRef), NULL, &window);		if (window != gMainWindow->GetWindow())		HideWindow(window);		if (window == gToolsWindow->GetWindow())		CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_TOOLS, false);	else if (window == gColorsWindow)		CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_COLORS, false);	else if (window == gInfoWindow)		CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_INFO, false);	else if (window == gToolHelpWindow)		CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_TOOL_HELP, false);	else if (window == gAnalysisWindow)		CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_ANALYSIS, false);	else if (window == gSurfaceTraitsWindow)		CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_SURFACE_TRAITS, false);	else if (window == gDataLogWindow)		CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_DATA_LOG, false);			return noErr;}pascal OSStatus MainWindowHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){	WindowRef           window;	UInt32              whatHappened;	OSErr err = GetEventParameter(theEvent, kEventParamWindowRef, typeWindowRef,						NULL, sizeof(WindowRef), NULL, &window);	err = GetEventParameter(theEvent, kEventParamDirectObject, typeWindowRef,						NULL, sizeof(WindowRef), NULL, &window);    								whatHappened = GetEventKind(theEvent);		//http://developer.apple.com/documentation/Carbon/Conceptual/carbon_porting_guide/cpg_newtechstruct/chapter_5_section_6.html		Point where;		switch (whatHappened)	{		case kEventWindowDrawContent:	//Contents need to be redrawn		case kEventWindowActivated:		case kEventWindowGetClickActivation:			gMainWindow->RedrawControls();			gMainWindow->Redraw();			break;		case kEventWindowBoundsChanged:	//Window size has changed or window has been dragged			gMainWindow->RecalcScrollBarSizes();			break;		case kEventWindowClickContentRgn:	//Mouse click in window		case kEventWindowHandleContentClick:			UInt32 modifierKeys;			err = GetEventParameter(theEvent, kEventParamKeyModifiers, typeUInt32,								NULL, sizeof(UInt32), NULL, &modifierKeys);						err = GetEventParameter(theEvent, kEventParamMouseLocation, typeQDPoint,								NULL, sizeof(Point), NULL, &where);						UInt32 clickCount;			err = GetEventParameter(theEvent, kEventParamClickCount, typeUInt32,								NULL, sizeof(UInt32), NULL, &clickCount);						gMainWindow->HandleMouseDown(where, clickCount == 2,								(modifierKeys & shiftKey),								(modifierKeys & controlKey),								(modifierKeys & optionKey),								(modifierKeys & cmdKey));			break;		case kEventWindowZoom:			gMainWindow->ZoomFull();			break;	}		return noErr;}//This mouse move handler can't be "part of" the main window handlers because//it won't get triggered if the mouse is moving while outside the window boundaries.pascal OSStatus MouseMovedHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){	if (gToolsWindow->GetToolType() == ToolsWindow::HAND)		SetThemeCursor(kThemeOpenHandCursor);		Point where;	OSErr err = GetEventParameter(theEvent, kEventParamMouseLocation, typeQDPoint,						NULL, sizeof(Point), NULL, &where);	HandleColorWindowMouseMoved(where);	gMainWindow->HandleMouseMoved(where);	gToolsWindow->HandleMouseMoved(where);}pascal void WindowBoundaryDragEventHandler(EventLoopTimerRef theTimer, void* userData){	gMainWindow->HandleWindowBoundaryDrag();}pascal void MouseCatchUpEventHandler(EventLoopTimerRef theTimer, void* userData){	gMainWindow->HandleMouseCatchUp();}pascal void LabelingAttemptPendingEventHandler(EventLoopTimerRef theTimer, void* userData){	gMainWindow->CreateLegalLabeling();}pascal OSStatus ToolsWindowHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){	WindowRef           window;	UInt32              whatHappened;	UInt32				eventClass;	OSErr err = GetEventParameter(theEvent, kEventParamWindowRef, typeWindowRef,						NULL, sizeof(WindowRef), NULL, &window);	err = GetEventParameter(theEvent, kEventParamDirectObject, typeWindowRef,						NULL, sizeof(WindowRef), NULL, &window);    								whatHappened = GetEventKind(theEvent);	eventClass = GetEventClass(theEvent);		Point where;		if (eventClass == kEventClassWindow)		switch (whatHappened)		{			case kEventWindowDrawContent:	//Contents need to be redrawn			case kEventWindowActivated:			case kEventWindowGetClickActivation:				if (!gMainWindow->GetExportingPict())					gToolsWindow->Redraw();				break;			case kEventWindowClickContentRgn:	//Mouse click in window				err = GetEventParameter(theEvent, kEventParamMouseLocation, typeQDPoint,									NULL, sizeof(Point), NULL, &where);													gToolsWindow->HandleToolSelection(where, true);				break;		}	else if (eventClass == kEventClassMouse)		switch (whatHappened)		{			case kEventMouseUp:	//Mouse button released				err = GetEventParameter(theEvent, kEventParamMouseLocation, typeQDPoint,									NULL, sizeof(Point), NULL, &where);													gToolsWindow->HandleToolSelection(where, false);		}		return noErr;}pascal OSStatus ColorsWindowHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){	WindowRef           window;	UInt32              whatHappened;	OSErr err = GetEventParameter(theEvent, kEventParamWindowRef, typeWindowRef,						NULL, sizeof(WindowRef), NULL, &window);	err = GetEventParameter(theEvent, kEventParamDirectObject, typeWindowRef,						NULL, sizeof(WindowRef), NULL, &window);    								whatHappened = GetEventKind(theEvent);		switch (whatHappened)	{		case kEventWindowDrawContent:	//Contents need to be redrawn		case kEventWindowActivated:		case kEventWindowGetClickActivation:			if (!gMainWindow->GetExportingPict())				RedrawColorsWindow();			break;		case kEventWindowClickContentRgn:	//Mouse click in window			Point where;			err = GetEventParameter(theEvent, kEventParamMouseLocation, typeQDPoint,								NULL, sizeof(Point), NULL, &where);											HandleColorChange(where);			break;	}		return noErr;}pascal OSStatus InfoWindowHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){	WindowRef           window;	UInt32              whatHappened;	OSErr err = GetEventParameter(theEvent, kEventParamWindowRef, typeWindowRef,						NULL, sizeof(WindowRef), NULL, &window);	err = GetEventParameter(theEvent, kEventParamDirectObject, typeWindowRef,						NULL, sizeof(WindowRef), NULL, &window);    								whatHappened = GetEventKind(theEvent);		switch (whatHappened)	{		case kEventWindowDrawContent:	//Contents need to be redrawn		case kEventWindowActivated:		case kEventWindowGetClickActivation:			if (!gMainWindow->GetExportingPict())				RedrawInfoWindow();			break;	}		return noErr;}pascal OSStatus ToolHelpWindowHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){	WindowRef           window;	UInt32              whatHappened;	OSErr err = GetEventParameter(theEvent, kEventParamWindowRef, typeWindowRef,						NULL, sizeof(WindowRef), NULL, &window);	err = GetEventParameter(theEvent, kEventParamDirectObject, typeWindowRef,						NULL, sizeof(WindowRef), NULL, &window);    								whatHappened = GetEventKind(theEvent);		switch (whatHappened)	{		case kEventWindowDrawContent:	//Contents need to be redrawn		case kEventWindowActivated:		case kEventWindowGetClickActivation:			if (!gMainWindow->GetExportingPict())				RedrawToolHelpWindow();			break;	}		return noErr;}pascal OSStatus AnalysisWindowHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){	WindowRef           window;	UInt32              whatHappened;	OSErr err = GetEventParameter(theEvent, kEventParamWindowRef, typeWindowRef,						NULL, sizeof(WindowRef), NULL, &window);	err = GetEventParameter(theEvent, kEventParamDirectObject, typeWindowRef,						NULL, sizeof(WindowRef), NULL, &window);    								whatHappened = GetEventKind(theEvent);		switch (whatHappened)	{		case kEventWindowDrawContent:	//Contents need to be redrawn		case kEventWindowActivated:		case kEventWindowGetClickActivation:			break;	}		return noErr;}pascal OSStatus SurfaceTraitsWindowHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){	WindowRef           window;	UInt32              whatHappened;	OSErr err = GetEventParameter(theEvent, kEventParamWindowRef, typeWindowRef,								NULL, sizeof(WindowRef), NULL, &window);	err = GetEventParameter(theEvent, kEventParamDirectObject, typeWindowRef,						NULL, sizeof(WindowRef), NULL, &window);    								whatHappened = GetEventKind(theEvent);		switch (whatHappened)	{		case kEventWindowDrawContent:	//Contents need to be redrawn		case kEventWindowActivated:		case kEventWindowGetClickActivation:			if (!gMainWindow->GetExportingPict())				RedrawSurfaceTraitsWindow();			break;		case kEventWindowClickContentRgn:	//Mouse click in window			Point where;			err = GetEventParameter(theEvent, kEventParamMouseLocation, typeQDPoint,								NULL, sizeof(Point), NULL, &where);											HandleSurfaceTraitsColorChange(where);			break;	}		CallNextEventHandler(nextHandler, theEvent);	return noErr;}pascal OSStatus DataLogWindowHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){	WindowRef           window;	UInt32              whatHappened;	OSErr err = GetEventParameter(theEvent, kEventParamWindowRef, typeWindowRef,						NULL, sizeof(WindowRef), NULL, &window);	err = GetEventParameter(theEvent, kEventParamDirectObject, typeWindowRef,						NULL, sizeof(WindowRef), NULL, &window);    								whatHappened = GetEventKind(theEvent);		switch (whatHappened)	{		case kEventWindowDrawContent:	//Contents need to be redrawn		case kEventWindowActivated:		case kEventWindowGetClickActivation:			break;	}		return noErr;}pascal void SurfaceTraitsSliderHandler(ControlRef controlRef, ControlPartCode partCode){	ControlID inID = { 'sftr', 1 };	GetControlByID(gSurfaceTraitsWindow, &inID, &controlRef);	long controlVal = GetControl32BitValue(controlRef);	gSurfaceTraits.interiorReflectance = (double)controlVal / 100.0;		inID.id = 2;	GetControlByID(gSurfaceTraitsWindow, &inID, &controlRef);	controlVal = GetControl32BitValue(controlRef);	gSurfaceTraits.borderReflectance = (double)controlVal / 100.0;		inID.id = 3;	GetControlByID(gSurfaceTraitsWindow, &inID, &controlRef);	controlVal = GetControl32BitValue(controlRef);	gSurfaceTraits.borderThickness = (double)controlVal / 10.0;		vector<BSpline*> workingBSplines = gMainWindow->GetWorkingObjects();	vector<WholeObject*> wholeObjects = gDrawing->GetWholeObjects();		//Build a vector  of all affected BSplines	vector<BSpline*> affectedBSplines;	for (vector<BSpline*>::iterator i = workingBSplines.begin(); i != workingBSplines.end(); i++)	{		if (find(affectedBSplines.begin(), affectedBSplines.end(), *i) == affectedBSplines.end())			affectedBSplines.push_back(*i);				vector<BSpline*> groupBSplines;		gDrawing->GetBSplinesInGroupFromBSpline(*i, groupBSplines);				for (vector<BSpline*>::iterator j = groupBSplines.begin(); j != groupBSplines.end(); j++)			if (find(affectedBSplines.begin(), affectedBSplines.end(), *j) == affectedBSplines.end())				affectedBSplines.push_back(*j);	}		//Set the color for all the BSplines in the group	for (int i = 0; i < affectedBSplines.size(); i++)		affectedBSplines[i]->SetSurfaceTraits(gSurfaceTraits);		gMainWindow->Redraw();}pascal OSStatus MenuHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){	HICommand commandStruct;	OSErr err = GetEventParameter(theEvent, kEventParamDirectObject, typeHICommand,						NULL, sizeof(HICommand), NULL, &commandStruct);		UInt32 theCommandID = commandStruct.commandID;	MenuRef theMenu = commandStruct.menu.menuRef;	short theItem = commandStruct.menu.menuItemIndex;	MenuRef hierMenuRef = NULL;		switch (theCommandID)	{		case kHICommandAbout:			DoAboutBox();			break;		case kHICommandNew:			{				Grid grid(*gMainWindow->GetGrid());				bool showGrid = gMainWindow->GetShowGrid();				bool snapToGrid = gMainWindow->GetSnapToGrid();				bool showCrossingStates = gDrawing->GetShowCrossingStates();				bool showCuts = gDrawing->GetShowCuts();				bool showDepths = gDrawing->GetShowDepths();				bool showCompSets = gDrawing->GetShowCompSets();								MainWindowEventHandlersDestroy();				delete gMainWindow;				delete gDrawing;				gDrawing = new Drawing();	//It is important to create the Drawing before creating the MainWindow				gMainWindow = new MainWindow(128);				MainWindowEventHandlersInit();								*gMainWindow->GetGrid() = grid;				gMainWindow->SetShowGrid(showGrid);				gMainWindow->SetSnapToGrid(snapToGrid);				gDrawing->SetShowCrossingStates(showCrossingStates);				gDrawing->SetShowCuts(showCuts);				gDrawing->SetShowDepths(showDepths);				gDrawing->SetShowCompSets(showCompSets);						MenuHandle menuHandle = GetMenuHandle(EDIT_MENU);				DisableMenuItem(menuHandle, UNDO);				DisableMenuItem(menuHandle, REDO);			}			break;		case kHICommandOpen:			gMainWindow->OpenFromFile();			break;		case kCommandOpenBGimage:			gMainWindow->OpenBackgroundImageFile();			break;		case kHICommandSave:			sSavingFile = true;			gMainWindow->SaveToFile(false);			sSavingFile = false;			break;		case kHICommandSaveAs:			sSavingFile = true;			gMainWindow->SaveToFile(true);			sSavingFile = false;			break;		case kHICommandClose:			break;		case kCommandExpPict:			sSavingFile = true;			gMainWindow->ExportToPict();			sSavingFile = false;			break;		case kCommandExpPS:			sSavingFile = true;			gMainWindow->ExportToPostscript();			sSavingFile = false;			break;		case kCommandDataLoggingOn:			gMainWindow->ToggleDataLogging();			CheckMenuItem(GetMenuHandle(FILE_MENU), DATA_LOGGING_ON, gMainWindow->GetDataLoggingOn());			break;		case kHICommandQuit:			QuitApplicationEventLoop();			break;		case kHICommandUndo:			gMainWindow->Undo();			break;		case kHICommandRedo:			gMainWindow->Redo();			break;		case kHICommandClear:			gMainWindow->DeleteSelected();			break;		case kHICommandSelectAll:			gMainWindow->SelectAll();			break;		case kCommandDeselectAll:			gMainWindow->DeselectAll();			break;		case kCommandDuplicate:			gMainWindow->DuplicateSelected();			break;		case kCommandFlipH:			gMainWindow->FlipHorSelected();			break;		case kCommandFlipV:			gMainWindow->FlipVerSelected();			break;		case kCommandRot90CW:			gMainWindow->Rotate90CWSelected();			break;		case kCommandRot90CCW:			gMainWindow->Rotate90CCWSelected();			break;		case kCommandRot180:			gMainWindow->Rotate180Selected();			break;		case kCommandRotNumeric:			gMainWindow->RotateNumericSelected();			break;		case kCommandRotFree:			gMainWindow->RotateFreeSelected();			break;		case kCommandScaleNumeric:			gMainWindow->ScaleNumericSelected();			break;		case kCommandScaleFree:			gMainWindow->ScaleFreeSelected();			break;		case kCommandShowTools:			if (IsWindowVisible(gToolsWindow->GetWindow()))			{				HideWindow(gToolsWindow->GetWindow());				CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_TOOLS, false);			}			else			{				ShowWindow(gToolsWindow->GetWindow());				CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_TOOLS, true);			}			break;		case kCommandShowColors:			if (IsWindowVisible(gColorsWindow))			{				HideWindow(gColorsWindow);				CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_COLORS, false);			}			else			{				ShowWindow(gColorsWindow);				CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_COLORS, true);			}			break;		case kCommandShowInfo:			if (IsWindowVisible(gInfoWindow))			{				HideWindow(gInfoWindow);				CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_INFO, false);			}			else			{				ShowWindow(gInfoWindow);				CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_INFO, true);			}			break;		case kCommandShowToolHelp:			if (IsWindowVisible(gToolHelpWindow))			{				HideWindow(gToolHelpWindow);				CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_TOOL_HELP, false);			}			else			{				ShowWindow(gToolHelpWindow);				CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_TOOL_HELP, true);			}			break;		case kCommandShowAnalysis:			if (IsWindowVisible(gAnalysisWindow))			{				HideWindow(gAnalysisWindow);				CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_ANALYSIS, false);			}			else			{				ShowWindow(gAnalysisWindow);				CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_ANALYSIS, true);			}			break;		case kCommandShowSurfaceTraits:			if (IsWindowVisible(gSurfaceTraitsWindow))			{				HideWindow(gSurfaceTraitsWindow);				CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_SURFACE_TRAITS, false);			}			else			{				ShowWindow(gSurfaceTraitsWindow);				CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_SURFACE_TRAITS, true);			}			break;		case kCommandShowDataLog:			if (IsWindowVisible(gDataLogWindow))			{				HideWindow(gDataLogWindow);				CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_DATA_LOG, false);			}			else			{				ShowWindow(gDataLogWindow);				CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_DATA_LOG, true);			}			break;		case kCommandHideAllWindows:			HideWindow(gToolsWindow->GetWindow());			HideWindow(gColorsWindow);			HideWindow(gInfoWindow);			HideWindow(gToolHelpWindow);			HideWindow(gAnalysisWindow);			HideWindow(gSurfaceTraitsWindow);			HideWindow(gDataLogWindow);						CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_TOOLS, false);			CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_COLORS, false);			CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_INFO, false);			CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_TOOL_HELP, false);			CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_ANALYSIS, false);			CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_SURFACE_TRAITS, false);			CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_DATA_LOG, false);			break;		case kCommandShowCrossingStates:			gDrawing->ToggleShowCrossingStates();			CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_CROSSING_STATES, gDrawing->GetShowCrossingStates());			gMainWindow->Redraw();			break;		case kCommandShowCuts:			gDrawing->ToggleShowCuts();			CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_CUTS, gDrawing->GetShowCuts());			gMainWindow->Redraw();			break;		case kCommandShowDepths:			gDrawing->ToggleShowDepths();			CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_DEPTHS, gDrawing->GetShowDepths());			gMainWindow->Redraw();			break;		case kCommandShowCompSets:			gDrawing->ToggleShowCompSets();			CheckMenuItem(GetMenuHandle(VIEW_MENU), SHOW_COMP_SETS, gDrawing->GetShowCompSets());			gMainWindow->Redraw();			break;		case kCommandSplineMode:			gMainWindow->SetViewMode(MainWindow::SPLINE_MODE);			CheckMenuItem(GetMenuHandle(VIEW_MENU), VIEW_SPLINE_MODE, true);			CheckMenuItem(GetMenuHandle(VIEW_MENU), VIEW_KNOT_MODE, false);			CheckMenuItem(GetMenuHandle(VIEW_MENU), VIEW_SURFACE_MODE, false);			DisableMenuItem(GetMenuHandle(FILE_MENU), EXPORT_TO_PS);			gMainWindow->Redraw();			break;		case kCommandKnotMode:			gMainWindow->SetViewMode(MainWindow::KNOT_MODE);			CheckMenuItem(GetMenuHandle(VIEW_MENU), VIEW_SPLINE_MODE, false);			CheckMenuItem(GetMenuHandle(VIEW_MENU), VIEW_KNOT_MODE, true);			CheckMenuItem(GetMenuHandle(VIEW_MENU), VIEW_SURFACE_MODE, false);			EnableMenuItem(GetMenuHandle(FILE_MENU), EXPORT_TO_PS);			gMainWindow->Redraw();			break;		case kCommandSurfaceMode:			gMainWindow->SetViewMode(MainWindow::SURFACE_MODE);			CheckMenuItem(GetMenuHandle(VIEW_MENU), VIEW_SPLINE_MODE, false);			CheckMenuItem(GetMenuHandle(VIEW_MENU), VIEW_KNOT_MODE, false);			CheckMenuItem(GetMenuHandle(VIEW_MENU), VIEW_SURFACE_MODE, true);			EnableMenuItem(GetMenuHandle(FILE_MENU), EXPORT_TO_PS);			gMainWindow->Redraw();			break;		case kCommandGridSettings:			gMainWindow->ChangeGridSettings();			break;		case kCommandShowGrid:			gMainWindow->ToggleShowGrid();			GetMenuItemHierarchicalMenu(GetMenuHandle(VIEW_MENU), GRID_SETTINGS1, &hierMenuRef);			CheckMenuItem(hierMenuRef, SHOW_GRID, gMainWindow->GetShowGrid());			break;		case kCommandSnapToGrid:			gMainWindow->ToggleSnapToGrid();			GetMenuItemHierarchicalMenu(GetMenuHandle(VIEW_MENU), GRID_SETTINGS1, &hierMenuRef);			CheckMenuItem(hierMenuRef, SNAP_TO_GRID, gMainWindow->GetSnapToGrid());			break;		case kCommandSignOfOcclusionArrows:			BSpline::sShadeWithArrows = true;			GetMenuItemHierarchicalMenu(GetMenuHandle(VIEW_MENU), SIGN_OF_OCCLUSION, &hierMenuRef);			CheckMenuItem(hierMenuRef, SIGN_OF_OCCLUSION_ARROWS, BSpline::sShadeWithArrows);			CheckMenuItem(hierMenuRef, SIGN_OF_OCCLUSION_HASHES, !BSpline::sShadeWithArrows);			gMainWindow->Redraw();			break;		case kCommandSignOfOcclusionHashes:			BSpline::sShadeWithArrows = false;			GetMenuItemHierarchicalMenu(GetMenuHandle(VIEW_MENU), SIGN_OF_OCCLUSION, &hierMenuRef);			CheckMenuItem(hierMenuRef, SIGN_OF_OCCLUSION_ARROWS, BSpline::sShadeWithArrows);			CheckMenuItem(hierMenuRef, SIGN_OF_OCCLUSION_HASHES, !BSpline::sShadeWithArrows);			gMainWindow->Redraw();			break;		case kCommandSignOfOcclusionSmallerHashes:			BSpline::sShadeSize--;			if (BSpline::sShadeSize < 2)				BSpline::sShadeSize = 2;			gMainWindow->Redraw();			break;		case kCommandSignOfOcclusionLargerHashes:			BSpline::sShadeSize++;			if (BSpline::sShadeSize > 15)				BSpline::sShadeSize = 15;			gMainWindow->Redraw();			break;		default:			return eventNotHandledErr;	}		//OSStatus result = CallNextEventHandler (nextHandler, theEvent); 		return noErr;}