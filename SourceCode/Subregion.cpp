#include "Subregion.h"#include "Drawing.h"#include "GenericIntersection.h"#include "BspCutIntersection.h"#include "trigConstants.h"	//debug#include "Random.h"	//debug//******************************************************************************//Extern Globalsextern int gA;extern int gB;//******************************************************************************//Function Prototypes	//	In external files		//lineEquations.cppdouble LineSegmentLength(FloatPoint p1, FloatPoint p2);double LineSegmentAngle(FloatPoint p1, FloatPoint p2);FloatPoint ProjectPointAtAngle(FloatPoint origin, double angle, double segLength);#pragma mark -Subregion::Subregion() : furthestLeftPointIdx(-1){	color.red = color.green = color.blue = 0;	//emptySubregion = false;	subregionDrawn = false;	row = 0;}Subregion::~Subregion(){	DeleteAllIntersections();}void Subregion::DeleteAllIntersections(){	for (int i = 0; i < sliceIntersections.size(); i++)		delete sliceIntersections[i].intersection;	sliceIntersections.clear();}bool Subregion::DetermineSubregionColor2(){	if (layerSurfaceTraits.size() == 0)		return false;		//Calculate the contribution each layer makes to the final color and accumulate the final color	color.red = color.green = color.blue = 0;	double accumReflectance = 0;	//should sum to 1	for (int j = 0; j <= layerSurfaceTraits.size(); j++)	{		//See note in the "hard layers" loop about this		if (j < layerSurfaceTraits.size() && layerSurfaceTraits[j].second.interiorReflectance == -1)			continue;				double transmittanceAboveLayer = 1.0;		for (int k = 0; k < j; k++)			if (layerSurfaceTraits[k].second.interiorReflectance != -1)				transmittanceAboveLayer *= (1.0 - layerSurfaceTraits[k].second.interiorReflectance);				MyAssert(transmittanceAboveLayer >= 0 && transmittanceAboveLayer <= 1.0);				double transmittedReflectance;		if (j < layerSurfaceTraits.size())			transmittedReflectance = transmittanceAboveLayer * layerSurfaceTraits[j].second.interiorReflectance;		else transmittedReflectance = transmittanceAboveLayer;	//Background layer for the canvas				MyAssert(transmittedReflectance >= 0 && transmittedReflectance <= 1.0);				accumReflectance += transmittedReflectance;		MyAssert(accumReflectance <= 1.0);				if (j < layerSurfaceTraits.size())		{			int newVal = color.red + layerSurfaceTraits[j].second.interiorColor.red * transmittedReflectance;			MyAssert(newVal <= 65535);			color.red = newVal;						newVal = color.green + layerSurfaceTraits[j].second.interiorColor.green * transmittedReflectance;			MyAssert(newVal <= 65535);			color.green = newVal;						newVal = color.blue + layerSurfaceTraits[j].second.interiorColor.blue * transmittedReflectance;			MyAssert(newVal <= 65535);			color.blue = newVal;		}		else	//Background layer for the canvas		{			int newVal = color.red + (int)gColors.canvas.red * transmittedReflectance;			MyAssert(newVal <= 65535);			color.red = newVal;						newVal = color.green + (int)gColors.canvas.green * transmittedReflectance;			MyAssert(newVal <= 65535);			color.green = newVal;						newVal = color.blue + (int)gColors.canvas.blue * transmittedReflectance;			MyAssert(newVal <= 65535);			color.blue = newVal;		}	}	MyAssert(accumReflectance > .99 && accumReflectance <= 1.0);		return true;}bool Subregion::Draw(Point scrollOffset, CGrafPtr debugGrafPtr){	if (subregionDrawn)		return false;		bool drawThisSubregionNow = true;	for (int j = 0; j < requiredPredrawnSubregions.size(); j++)		if (!requiredPredrawnSubregions[j]->subregionDrawn)		{			drawThisSubregionNow = false;			break;		}		if (!drawThisSubregionNow)		return false;	subregionDrawn = true;		PolyHandle poly = OpenPoly();		FloatPoint prevPoint = points[0];	MoveTo(prevPoint.h, prevPoint.v);	for (int j = 1; j <= points.size(); j++)	{		FloatPoint thisPoint = points[j % points.size()];		LineTo(thisPoint.h, thisPoint.v);		prevPoint = thisPoint;	}		ClosePoly();	OffsetPoly(poly, scrollOffset.h, scrollOffset.v);		if (debugGrafPtr)	{		PenSize(2, 2);				ForeColor(blueColor);		FramePoly(poly);				QDFlushPortBuffer(debugGrafPtr, NULL);				int qq = 1;				ForeColor(whiteColor);		FramePoly(poly);				QDFlushPortBuffer(debugGrafPtr, NULL);				PenSize(1, 1);				qq = 1;	}		//еее The color determination should go at the top of the loop, so as to skip the creation of	//the polygon when the subregion is skipped entirely, but for debugging, keep it down here	//so that blue outline will appear above	if (!DetermineSubregionColor2())		return true;		RGBForeColor(&color);		PenSize(1, 1);	PaintPoly(poly);		if (debugGrafPtr)	{		QDFlushPortBuffer(debugGrafPtr, NULL);				int qq = 1;	}		KillPoly(poly);		return true;}void Subregion::DrawDebug(Point scrollOffset, CGrafPtr debugGrafPtr, bool thick){	PolyHandle poly = OpenPoly();		FloatPoint prevPoint = points[0];	MoveTo(prevPoint.h, prevPoint.v);	for (int j = 1; j <= points.size(); j++)	{		FloatPoint thisPoint = points[j % points.size()];		LineTo(thisPoint.h, thisPoint.v);		prevPoint = thisPoint;	}		ClosePoly();	OffsetPoly(poly, scrollOffset.h, scrollOffset.v);		if (thick)		PenSize(2, 2);	else PenSize(1, 1);	FramePoly(poly);	KillPoly(poly);		QDFlushPortBuffer(debugGrafPtr, NULL);		int qq = 1;}#pragma mark -//==============================================================================================================//==============================================================================================================//==============================================================================================================void SurfaceSubregionGraph::DrawDebug(Point scrollOffset, int offsetH, int offsetV, CGrafPtr debugGrafPtr){	float angleIncrement = PiTimes2 / (float)nodes.size();	float radius = 170.0;	FloatPoint center(radius + 50 + offsetH, radius + 50 + offsetV);	//int spacing = 75;		Str255 str;		//debug	SurfaceSubregionGraphEdge* myEdges[10] = { NULL };	for (int i = 0; i < edges.size(); i++)		myEdges[i] = edges[i];		//Make a location for each node	vector<pair<SurfaceSubregionGraph::SurfaceSubregionGraphNode*, FloatPoint> > nodeLocs;	vector<pair<FloatPoint, int > > cogHits;	ForeColor(blackColor);	for (int i = 0; i < nodes.size(); i++)	{		switch (i % 6)		{			case 0:	ForeColor(redColor);	break;			case 1:	ForeColor(greenColor);	break;			case 2:	ForeColor(blueColor);	break;			case 3:	RGBColor c = { 32768, 32768, 0 };	RGBForeColor(&c);	break;			case 4:	ForeColor(magentaColor);	break;			case 5:	ForeColor(cyanColor);	break;		}				float angle = i * angleIncrement;		FloatPoint loc = ProjectPointAtAngle(center, angle, radius);		//FloatPoint loc2 = ProjectPointAtAngle(center, angle, radius + 15);		FloatPoint loc3 = ProjectPointAtAngle(center, angle, radius + 30);				nodeLocs.push_back(pair<SurfaceSubregionGraph::SurfaceSubregionGraphNode*, FloatPoint>(nodes[i], loc));				//Draw an oval for the node		//Rect r = { loc.v - 3, loc.h - 3, loc.v + 3, loc.h + 3 };		//Rect r = { loc.v - 10, loc.h - 10, loc.v + 10, loc.h + 10 };		//FrameOval(&r);				//Write the node's index on the graph		TextSize(14);		TextFace(bold);		str[0] = 1;		if (i < 26)			str[1] = 'A' + i;		else str[1] = 'a' + i;		//MoveTo(loc2.h - 5, loc2.v + 5);		MoveTo(loc.h - 5, loc.v + 5);		DrawString(str);				Subregion *sr = nodes[i]->subregion;		FloatPoint cog;		for (int k = 0; k < sr->points.size(); k++)		{			cog.h += sr->points[k].h;			cog.v += sr->points[k].v;		}		cog.h /= sr->points.size();		cog.v /= sr->points.size();				int j = 0;		for (j = 0; j < cogHits.size(); j++)			if (cogHits[j].first == cog)				break;		if (j == cogHits.size())			cogHits.push_back(pair<FloatPoint, int>(cog, 0));		else cog.v += (++cogHits[j].second * 15);				//Write the node's index on the drawing		TextSize(18);		MoveTo(cog.h, cog.v);		DrawString(str);				//Write the node's crossed and uncrossable boundaries		TextSize(9);		TextFace(0);		ForeColor(greenColor);		for (int j = 0; j < nodes[i]->crossedSubboundaries.size(); j++)		{			NumToString(nodes[i]->crossedSubboundaries[j], str);			MoveTo(loc3.h, loc3.v + j * 10);			DrawString(str);		}				ForeColor(redColor);		for (int j = 0; j < nodes[i]->uncrossableSubboundaries.size(); j++)		{			NumToString(nodes[i]->uncrossableSubboundaries[j], str);			MoveTo(loc3.h, loc3.v + nodes[i]->uncrossableSubboundaries.size() * 10 + j * 10);			DrawString(str);		}				QDFlushPortBuffer(debugGrafPtr, NULL);		int qe = 1;	}		//Draw the edges	for (int i = 0; i < nodes.size(); i++)	{		//Just an assert		bool foundIt = false;		for (int j = 0; j < nodeLocs.size(); j++)			if (nodeLocs[j].first == nodes[i])			{				foundIt = true;				break;			}		MyAssert(foundIt);				for (int j = 0; j < nodes[i]->fromToEdgePairs.size(); j++)		{			pair<SurfaceSubregionGraphEdge*, SurfaceSubregionGraphEdge*> edgePair = nodes[i]->fromToEdgePairs[j];						//Just an assert			foundIt = false;			for (int j = 0; j < nodeLocs.size(); j++)				if (nodeLocs[j].first == edgePair.first->nodeFrom)				{					foundIt = true;					break;				}			MyAssert(foundIt);			foundIt = false;			for (int j = 0; j < nodeLocs.size(); j++)				if (nodeLocs[j].first == edgePair.first->nodeTo)				{					foundIt = true;					break;				}			MyAssert(foundIt);			foundIt = false;			for (int j = 0; j < nodeLocs.size(); j++)				if (nodeLocs[j].first == edgePair.second->nodeFrom)				{					foundIt = true;					break;				}			MyAssert(foundIt);			foundIt = false;			for (int j = 0; j < nodeLocs.size(); j++)				if (nodeLocs[j].first == edgePair.second->nodeTo)				{					foundIt = true;					break;				}			MyAssert(foundIt);						MyAssert(edgePair.first->nodeTo == nodes[i] || edgePair.second->nodeFrom == nodes[i]);						FloatPoint fromLoc(-999999, -999999);			for (int k = 0; k < nodeLocs.size(); k++)				if (nodeLocs[k].first == edgePair.second->nodeFrom)				{					fromLoc = nodeLocs[k].second;					break;				}			MyAssert(fromLoc.h != -999999);						FloatPoint toLoc(-999999, -999999);			for (int k = 0; k < nodeLocs.size(); k++)				if (nodeLocs[k].first == edgePair.second->nodeTo)				{					toLoc = nodeLocs[k].second;					break;				}			MyAssert(toLoc.h != -999999);						double segLength = LineSegmentLength(fromLoc, toLoc) - 25;			double angle = LineSegmentAngle(fromLoc, toLoc);			FloatPoint toLoc2 = ProjectPointAtAngle(fromLoc, angle, segLength);			toLoc2.h += RandNegInt(11);			toLoc2.v += RandNegInt(11);						switch (i % 6)			{				case 0:	ForeColor(redColor);	break;				case 1:	ForeColor(greenColor);	break;				case 2:	ForeColor(blueColor);	break;				case 3:	RGBColor c = { 32768, 32768, 0 };	RGBForeColor(&c);	break;				case 4:	ForeColor(magentaColor);	break;				case 5:	ForeColor(cyanColor);	break;			}						MoveTo(fromLoc.h, fromLoc.v);			LineTo(toLoc2.h, toLoc2.v);						Rect r = {toLoc2.v - 1, toLoc2.h - 1, toLoc2.v + 2, toLoc2.h + 2};			PaintOval(&r);						NumToString(edgePair.second->crossedSubboundary, str);			MoveTo((fromLoc.h + toLoc2.h) / 2, (fromLoc.v + toLoc2.v) / 2);			if (edgePair.second->crossedIntoSurface)				TextFace(bold);			else TextFace(0);			TextSize(9);			DrawString(str);						ForeColor(blackColor);			TextSize(9);			NumToString(edgePair.first->crossedSubboundary, str);			MoveTo(fromLoc.h + 10, fromLoc.v - 5 + j * 10);			if (edgePair.first->crossedIntoSurface)				TextFace(bold);			else TextFace(0);			DrawString(str);			DrawString("\p,");						NumToString(edgePair.second->crossedSubboundary, str);			if (edgePair.second->crossedIntoSurface)				TextFace(bold);			else TextFace(0);			DrawString(str);						QDFlushPortBuffer(debugGrafPtr, NULL);			int qe = 1;		}				for (int j = 0; j < nodes[i]->spillEdges.size(); j++)		{			SurfaceSubregionGraph::SurfaceSubregionGraphEdge* edge = nodes[i]->spillEdges[j];						//Just an assert			foundIt = false;			for (int j = 0; j < nodeLocs.size(); j++)				if (nodeLocs[j].first == edge->nodeFrom)				{					foundIt = true;					break;				}			MyAssert(foundIt);			foundIt = false;			for (int j = 0; j < nodeLocs.size(); j++)				if (nodeLocs[j].first == edge->nodeTo)				{					foundIt = true;					break;				}			MyAssert(foundIt);						MyAssert(edge->nodeFrom == nodes[i] || edge->nodeTo == nodes[i]);			MyAssert(edge->nodeFrom != edge->nodeTo);						if (edge->nodeFrom != nodes[i])				continue;						FloatPoint fromLoc(-999999, -999999);			for (int k = 0; k < nodeLocs.size(); k++)				if (nodeLocs[k].first == edge->nodeFrom)				{					fromLoc = nodeLocs[k].second;					break;				}			MyAssert(fromLoc.h != -999999);						FloatPoint toLoc(-999999, -999999);			for (int k = 0; k < nodeLocs.size(); k++)				if (nodeLocs[k].first == edge->nodeTo)				{					toLoc = nodeLocs[k].second;					break;				}			MyAssert(toLoc.h != -999999);						double segLength = LineSegmentLength(fromLoc, toLoc) - 25;			double angle = LineSegmentAngle(fromLoc, toLoc);			FloatPoint toLoc2 = ProjectPointAtAngle(fromLoc, angle, segLength);			toLoc2.h += RandNegInt(11);			toLoc2.v += RandNegInt(11);						switch (i % 6)			{				case 0:	ForeColor(redColor);	break;				case 1:	ForeColor(greenColor);	break;				case 2:	ForeColor(blueColor);	break;				case 3:	RGBColor c = { 32768, 32768, 0 };	RGBForeColor(&c);	break;				case 4:	ForeColor(magentaColor);	break;				case 5:	ForeColor(cyanColor);	break;			}						PenSize(3, 3);			MoveTo(fromLoc.h - 1, fromLoc.v - 1);			LineTo(toLoc2.h - 1, toLoc2.v - 1);			PenSize(1, 1);						Rect r = {toLoc2.v - 2, toLoc2.h - 2, toLoc2.v + 3, toLoc2.h + 3};			PaintOval(&r);						NumToString(edge->crossedSubboundary, str);			MoveTo((fromLoc.h + toLoc2.h) / 2, (fromLoc.v + toLoc2.v) / 2);			if (edge->crossedIntoSurface)				TextFace(bold);			else TextFace(0);			TextSize(9);			DrawString(str);						ForeColor(blackColor);			TextSize(9);			NumToString(edge->crossedSubboundary, str);			if (edge->crossedIntoSurface)				TextFace(bold);			else TextFace(0);			DrawString(str);						QDFlushPortBuffer(debugGrafPtr, NULL);			int qe = 1;		}	}}