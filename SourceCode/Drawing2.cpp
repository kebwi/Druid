#include "Drawing.h"#include "MinimalDrawing.h"#include "BSpline.h"#include "BSplineToBSplineCut.h"#include "GenericIntersection.h"#include "BspBspIntersection.h"#include "BspCutIntersection.h"#include "BspCutTIntersection.h"#include "CutCutIntersection.h"#include "MainWindow.h"	//еее#include "FloatPoint.h"#include "Colors.h"#include "trigConstants.h"#include "Random.h"#include "PascalStringUtil.h"#include <ColorPicker.h>#include <time.h>#include <algorithm.h>#include <utility.h> //for pair#include <math.h>#include <list.h>#include <vector.h>#include <string>#include <sstream>#include <fstream>using namespace::std;//******************************************************************************//Extern Globalsextern WindowPtr gAnalysisWindow, gDataLogWindow;	//еееextern Colors gColors;extern MainWindow* gMainWindow;extern Drawing *gDrawing;extern int gPointRadius;extern int gFindPointDist;extern UserEventUPP gEventProcUPP;extern unsigned long Drawing::sTreeWalk;extern SurfaceTraits Drawing::sOldSurfaceTraits;extern ColorChangedUPP Drawing::sColorChangedUPP;extern NColorChangedUPP Drawing::sColorNChangedUPP;extern int gLabelingMethod;	//0:	tree search							//1:	uniquely determine from companion setextern int gCompanionSetMethod;	//0:	don't use companion sets								//1:	use companion sets to order search, but not to truncate search								//2:	use companion sets to truncate searchextern int gDepthEnumerationMethod;	//0:	use half the number of intersections on a boundary as the enumeration limit and enumerate from the first intersection on the boundary									//1:	find the depth range for each section of a boundary to use as the enumeration limit and enumerate from the deepest range intersection on the boundary (stupid idea, purely for comparative purposes)									//2:	find the depth range for each section of a boundary to use as the enumeration limit and enumerate from the shallowest range intersection on the boundaryextern int gBoundingMethod;	//0:	no bounding							//1:	boundingextern int gTreeSearchMethod;	//0:	depth-first-search								//1:	iterative deepening								//2:	breadth-first-searchextern float gTimeLimitScalar;extern bool gMouseTerminated;extern bool gDebug;extern bool gDebug1;extern bool gDebug3;extern bool gDebug5;extern bool gDebug6;extern bool gDebug7;extern bool gDebug8;extern bool gDebug10;extern bool gDebug11;extern bool gDebug12;extern bool gDebug14;extern int gTextH;extern int gTextV;extern int gNumSliceAttempts;extern int gA;extern int gB;extern vector<pair<GenericIntersection*, int> > gInterDists;extern int gHorizon;extern stringstream* gOutputFileStream;//******************************************************************************//Global Declarationsstruct CutInfo{	int bsp1Index, bsp2Index;	int cv1, cv2;	int sg1, sg2;};bool gTestLogOn = false;int gLogLine = 0;//******************************************************************************//Function Prototypes	//	In external files		//	main.cppvoid MyAssert(bool condition);pascal Boolean ColorPickerEventProc(EventRecord *event);		//lineEquations.cppdouble LineSegmentLength(FloatPoint p1, FloatPoint p2);double LineSegmentAngle(FloatPoint p1, FloatPoint p2);FloatPoint ProjectPointAtAngle(FloatPoint origin, double angle, double segLength);int LineCrossLineDirection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2);bool LineSegmentIntersection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2, FloatPoint &intersection);bool LineSegmentIntersection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2,							FloatPoint &intersection, double& lineSegInter1, double& lineSegInter2);bool HorizontalLineSegmentIntersection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2,							FloatPoint &intersection, double& lineSegInter1, double& lineSegInter2);#pragma mark -void Drawing::DrawDrawing(MainWindow::ViewMode viewMode, Point scrollOffset, Point canvasSize, vector<BSpline*> workingBSplines, BSpline* hilightedBSpline, int hilightCode, bool exportingPict){	//MyAssert(interCompanionPairSets.size() == 0);	//This is no longer used, it should always be empty (delete it from the code at some future point).		if (hilightedBSpline)		MyAssert(hilightCode != -1);	else MyAssert(hilightCode == -1);		if (viewMode == MainWindow::SPLINE_MODE || viewMode == MainWindow::KNOT_MODE)	{		for (vector<BSpline*>::iterator i = bsplines.begin(); i != bsplines.end(); i++)		{			//Find the whole object for the BSpline			int wholeObjectIndex = -1;			for (int j = 0; j < wholeObjects.size(); j++)				if (find(wholeObjects[j]->bsplines.begin(), wholeObjects[j]->bsplines.end(), *i) != wholeObjects[j]->bsplines.end())				{					wholeObjectIndex = j;					break;				}						//Find the color for the whole object			/*			SurfaceTraits surfaceTraits;			if (wholeObjectIndex != -1)			{				for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)					if (wholeObjects[wholeObjectIndex]->bsplines[j]->GetWindingNumber() >= 0)					{						surfaceTraits = wholeObjects[wholeObjectIndex]->bsplines[j]->GetSurfaceTraits();						break;					}			}			else			{				surfaceTraits.interiorColor.red = surfaceTraits.interiorColor.green = surfaceTraits.interiorColor.blue = 0;	//0 is reserved as a "flag" for an illegal boundary				surfaceTraits.interiorReflectance = 1.0;				surfaceTraits.borderColor.red = surfaceTraits.interiorColor.red;				surfaceTraits.borderColor.green = surfaceTraits.interiorColor.green;				surfaceTraits.borderColor.blue = surfaceTraits.interiorColor.blue;				surfaceTraits.borderReflectance = surfaceTraits.interiorReflectance;				surfaceTraits.borderThickness = 1.0;			}			*/			(*i)->DrawBSpline(viewMode, scrollOffset, find(workingBSplines.begin(), workingBSplines.end(), *i) != workingBSplines.end(), hilightedBSpline == *i, showDepths, exportingPict);		}				if (showCuts)		{			for (vector<BSplineToBSplineCut*>::iterator i = bsplinePairCuts.begin(); i != bsplinePairCuts.end(); i++)			{				//Find the whole object for the Cut				int wholeObjectIndex = -1;				for (int j = 0; j < wholeObjects.size(); j++)					if (find(wholeObjects[j]->bsplines.begin(), wholeObjects[j]->bsplines.end(), (*i)->GetBsp1()) != wholeObjects[j]->bsplines.end())					{						wholeObjectIndex = j;						break;					}								//Find the color for the whole object				SurfaceTraits surfaceTraits;				bool foundIt = false;				if (wholeObjectIndex != -1)				{					for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)						if (wholeObjects[wholeObjectIndex]->bsplines[j]->GetWindingNumber() > 0)						{							surfaceTraits = wholeObjects[wholeObjectIndex]->bsplines[j]->GetSurfaceTraits();							foundIt = true;							break;						}					if (!foundIt)					{						for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)							if (wholeObjects[wholeObjectIndex]->bsplines[j]->GetWindingNumber() == 0)							{								surfaceTraits = wholeObjects[wholeObjectIndex]->bsplines[j]->GetSurfaceTraits();								foundIt = true;								break;							}					}					if (!foundIt)					{						for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)							if (wholeObjects[wholeObjectIndex]->bsplines[j]->GetWindingNumber() < 0)							{								surfaceTraits = wholeObjects[wholeObjectIndex]->bsplines[j]->GetSurfaceTraits();								foundIt = true;								break;							}					}					MyAssert(foundIt);				}				else				{					surfaceTraits.interiorColor.red = surfaceTraits.interiorColor.green = surfaceTraits.interiorColor.blue = 0;	//0 is reserved as a "flag" for an illegal boundary					surfaceTraits.interiorReflectance = 1.0;					surfaceTraits.borderColor.red = surfaceTraits.interiorColor.red;					surfaceTraits.borderColor.green = surfaceTraits.interiorColor.green;					surfaceTraits.borderColor.blue = surfaceTraits.interiorColor.blue;					surfaceTraits.borderReflectance = surfaceTraits.interiorReflectance;					surfaceTraits.borderThickness = 1.0;				}								(*i)->DrawCut(surfaceTraits.interiorColor, viewMode, scrollOffset, showDepths);			}						if (manualCutStartBsp)			{				vector<vector<FloatPoint>*> curvePoints = *manualCutStartBsp->GetCurvePoints();								int cv1 = manualCutStartSeg / BSpline::sNumSegmentsPerCurve;				int sg1 = manualCutStartSeg % BSpline::sNumSegmentsPerCurve;								FloatPoint segStart = (*curvePoints[cv1])[sg1];				int cv1a = cv1, sg1a = sg1 + 1;				if (sg1a == BSpline::sNumSegmentsPerCurve)				{					sg1a = 0;					cv1a++;					if (cv1a > curvePoints.size())						cv1 = 0;				}				FloatPoint segEnd = (*curvePoints[cv1a])[sg1a];								FloatPoint cutStart;				cutStart.h = (segStart.h + segEnd.h) / 2;				cutStart.v = (segStart.v + segEnd.v) / 2;								Rect r = { cutStart.v - 4, cutStart.h - 4, cutStart.v + 3, cutStart.h + 3 };				OffsetRect(&r, scrollOffset.h, scrollOffset.v);								Point mouseLoc;				GetMouse(&mouseLoc);				//GlobalToLocal(&mouseLoc);								if (hilightCode == 3)				{					ForeColor(redColor);					PenSize(2, 2);									}				else				{					ForeColor(blackColor);					PenSize(1, 1);				}								PaintOval(&r);				MoveTo(cutStart.h + scrollOffset.h, cutStart.v + scrollOffset.v);				LineTo(mouseLoc.h, mouseLoc.v);								PenSize(1, 1);			}		}	}	else if (viewMode == MainWindow::SURFACE_MODE)	{		for (int i = 0; i < intersections.size(); i++)			if (!intersections[i]->IntersectionLegal())				return;				vector<Subregion*> subregions;		CollectAllSubregions(subregions, NULL, canvasSize, true);				if (gDebug7)		{			Rect r;			GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);			EraseRect(&r);			//gMainWindow->DrawGrid();						Point scrollOffset = {0, 0};			vector<BSpline*> workingBSplines;			DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);						int qa = 1;		}				CalculateRequiredPredrawnSubregionsAndColor(subregions);				//Draw each surface		CGrafPtr debugGrafPtr = gDebug7 ? GetWindowPort(gMainWindow->GetWindow()) : NULL;		int numSubregionsDrawn = 0;		int numAttempts = 0;		while (numSubregionsDrawn < subregions.size())		{			MyAssert(numAttempts++ < subregions.size());			for (int i = 0; i < subregions.size(); i++)			{				if (subregions[i]->Draw(scrollOffset, debugGrafPtr))					numSubregionsDrawn++;				/*				if (subregions[i]->subregionDrawn)					continue;								bool drawThisSubregionNow = true;				for (int j = 0; j < subregions[i]->requiredPredrawnSubregions.size(); j++)					if (!subregions[i]->requiredPredrawnSubregions[j]->subregionDrawn)					{						drawThisSubregionNow = false;						break;					}								if (!drawThisSubregionNow)					continue;				subregions[i]->subregionDrawn = true;				numSubregionsDrawn++;								PolyHandle poly = OpenPoly();								FloatPoint prevPoint = subregions[i]->points[0];				MoveTo(prevPoint.h, prevPoint.v);				for (int j = 1; j <= subregions[i]->points.size(); j++)				{					FloatPoint thisPoint = subregions[i]->points[j % subregions[i]->points.size()];					LineTo(thisPoint.h, thisPoint.v);					prevPoint = thisPoint;				}								ClosePoly();				OffsetPoly(poly, scrollOffset.h, scrollOffset.v);								if (gDebug7)				{					PenSize(2, 2);										ForeColor(blueColor);					FramePoly(poly);										QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qa = 1;										ForeColor(whiteColor);					FramePoly(poly);										QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										PenSize(1, 1);										qa = 1;				}								//еее The color determination should go at the top of the loop, so as to skip the creation of				//the polygon when the subregion is skipped entirely, but for debugging, keep it down here				//so that blue outline will appear above				RGBColor subregionColor = {0, 0, 0};				if (!DetermineSubregionColor2(subregions[i], subregionColor))					continue;								RGBForeColor(&subregionColor);								PenSize(1, 1);				PaintPoly(poly);								if (gDebug7)				{					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qa = 1;				}								KillPoly(poly);				*/			}		}				//еее DEBUG		for (int i = 0; i < intersections.size(); i++)			MyAssert(intersections[i]->GetType() != GenericIntersection::BSP_CUT || !((BspCutIntersection*)intersections[i])->GetCutIsSlice());		for (int i = 0; i < brandNewIntersections.size(); i++)			MyAssert(brandNewIntersections[i]->GetType() != GenericIntersection::BSP_CUT || !((BspCutIntersection*)brandNewIntersections[i])->GetCutIsSlice());				//Destroy the subregions		for (int i = 0; i < subregions.size(); i++)			delete subregions[i];		subregions.clear();				//Hilight the depth 0 edges		for (int i = 0; i < bsplines.size(); i++)			bsplines[i]->OutlineDepthZeroSections(scrollOffset);				//Frame the BSplines		if (!exportingPict)			for (int i = 0; i < bsplines.size(); i++)				if (find(workingBSplines.begin(), workingBSplines.end(), bsplines[i]) != workingBSplines.end() || hilightedBSpline == bsplines[i])					bsplines[i]->DrawControlPointBoundary(scrollOffset, find(workingBSplines.begin(), workingBSplines.end(), bsplines[i]) != workingBSplines.end(), hilightedBSpline == bsplines[i]);	}		VerifyPrevCuts();}void Drawing::CollectAllSubregions(vector<Subregion*>& subregions, map<unsigned long, vector<Subregion*> >* boundarySectionMap, Point canvasSize, bool collectSubregionSurfaceDepths){	/*	if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pCollecting all subregions");				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}	*/	if (gDebug7)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));		Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::SPLINE_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qa = 1;	}		MyAssert(subregions.size() == 0);		//Keep track of traversed sections	vector<TraversedSection> traversedSections;		//Loop through all the intersections	for (int i = 0; i < intersections.size(); i++)	{		//Skip CutCut intersections		//if (intersections[i]->GetType() == GenericIntersection::CUT_CUT)		//	continue;				//Skip the end of infinite cuts		if (intersections[i]->GetType() == GenericIntersection::BSP_CUT_T && !((BspCutTIntersection*)intersections[i])->GetBsp())			continue;				//Find the subregions for this intersection		int numPasses;		switch (intersections[i]->GetType())		{			case GenericIntersection::BSP_BSP:		 		numPasses = 4;				break;			case GenericIntersection::BSP_CUT:		 		numPasses = 6;				break;			case GenericIntersection::BSP_CUT_T:		 		numPasses = 2;				break;			case GenericIntersection::CUT_CUT:				//MyAssert(false);		 		numPasses = 8;				break;		}				for (int pass = 0; pass < numPasses; pass++)		{			Subregion* subregion = new Subregion;			if (FindOneIntersectionOneSubregion(intersections[i], pass, subregion, boundarySectionMap, traversedSections, collectSubregionSurfaceDepths))			{				//Shrink the exterior border of the surface to fit the canvas (only affects infinite surfaces)				for (int i = 0; i < subregion->points.size(); i++)				{					if (subregion->points[i].h < 0)						subregion->points[i].h = 0;					if (subregion->points[i].v < 0)						subregion->points[i].v = 0;					if (subregion->points[i].h > canvasSize.h - 1)						subregion->points[i].h = canvasSize.h - 1;					if (subregion->points[i].v > canvasSize.v - 1)						subregion->points[i].v = canvasSize.v - 1;				}								if (gDebug7)				{					ForeColor(blackColor);					PenSize(2, 2);					FloatPoint prevLoc = subregion->points[0];					for (int i = 1; i <= subregion->points.size(); i++)					{						FloatPoint loc = subregion->points[i % subregion->points.size()];						MoveTo(max(prevLoc.h, 0.0), prevLoc.v);						LineTo(max(loc.h, 0.0), loc.v);						prevLoc = loc;					}										QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qa = 1;										ForeColor(whiteColor);					prevLoc = subregion->points[0];					for (int i = 1; i <= subregion->points.size(); i++)					{						FloatPoint loc = subregion->points[i % subregion->points.size()];						MoveTo(max(prevLoc.h, 0.0), prevLoc.v);						LineTo(max(loc.h, 0.0), loc.v);						prevLoc = loc;					}					PenSize(1, 1);										ForeColor(blackColor);					PenSize(1, 1);					prevLoc = subregion->points[0];					for (int i = 1; i <= subregion->points.size(); i++)					{						FloatPoint loc = subregion->points[i % subregion->points.size()];						MoveTo(max(prevLoc.h, 0.0), prevLoc.v);						LineTo(max(loc.h, 0.0), loc.v);						prevLoc = loc;					}					PenSize(1, 1);										QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										qa = 1;				}								subregions.push_back(subregion);	//Save the subregion			}			else delete subregion;		}	}		//Create subregions for BSplines that have no intersections	for (int i = 0; i < bsplines.size(); i++)		if (bsplines[i]->GetNumIntersections() == 0 && bsplines[i]->GetNumControlPoints() >= 3 && bsplines[i]->GetWindingNumber() > 0)		{			Subregion* subregion = new Subregion;			vector<vector<FloatPoint>*> curvePoints = *bsplines[i]->GetCurvePoints();			for (int j = 0; j < curvePoints.size(); j++)				for (int k = 0; k < BSpline::sNumSegmentsPerCurve; k++)				{					if (subregion->furthestLeftPointIdx != -1)					{						if ((*curvePoints[j])[k].h > -999998 && (*curvePoints[j])[k].h < subregion->points[subregion->furthestLeftPointIdx].h)							subregion->furthestLeftPointIdx = subregion->points.size();					}					else					{						//MyAssert(subregion->points.size() == 0);						subregion->furthestLeftPointIdx = subregion->points.size();					}					subregion->points.push_back((*curvePoints[j])[k]);				}						vector<int> sectionDepths = *bsplines[i]->GetSectionDepths();			MyAssert(sectionDepths.size() == 1);						//subregion->sectionBspDepths.push_back(pair<BSpline*, int>(bsplines[i], sectionDepths[0]));			/////////////////////////////////////////////			WholeObject* wholeObject = NULL;			MyAssert(FindOrCreateWholeObjectForBSpline(bsplines[i], wholeObject));			subregion->sectionWODepths.push_back(pair<WholeObject*, int>(wholeObject, sectionDepths[0]));						subregions.push_back(subregion);		}}//Returns true is successful, false if subregion already foundbool Drawing::FindOneIntersectionOneSubregion(GenericIntersection* intersection, int pass, Subregion* subregion, map<unsigned long, vector<Subregion*> >* boundarySectionMap,											vector<TraversedSection>& traversedSections, bool collectSubregionSurfaceDepths){	//gDebug7 = false;	//if (intersection->GetType() == GenericIntersection::CUT_CUT)	//	gDebug7 = true;		Rect r;	if (gDebug7)	{		PenSize(2, 2);				FloatPoint loc = intersection->GetLocation();		SetRect(&r, max(loc.h, 0.0) - 10, loc.v - 10, max(loc.h, 0.0) + 10, loc.v + 10);		ForeColor(redColor);		FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qa = 1;				ForeColor(whiteColor);		FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		//The subregion is defined by a clockwise list of the intersections marking its corners	MyAssert(subregion->points.size() == 0);	//This is a list of every tiny little sub-spline straight-line segment around the perimeter of the subregion		GenericIntersection* prevInter = intersection;	GenericIntersection* thisInter = intersection;	GenericIntersection* nextInter = intersection;		BSpline* traverseBsp = NULL;	BSplineToBSplineCut* traverseCut = NULL;	WholeObject* traverseWO = NULL;	bool traversalOnTop = true;	bool traverseForward = true;	bool enteredCutForwards = true;		//Initialize traversalOnTop, traverseForward, traverseBsp, traverseCut, and enteredCutForwards for the starting position	switch (thisInter->GetType())	{		case GenericIntersection::BSP_BSP:			traversalOnTop = (pass == 0 || pass == 2);			traverseForward = (pass == 0 || pass == 1);						traverseBsp = traversalOnTop ? ((BspBspIntersection*)thisInter)->GetBsp1() : ((BspBspIntersection*)thisInter)->GetBsp2();			break;		case GenericIntersection::BSP_CUT:			if (pass == 0 || pass == 1)	//Traverse bsp			{				traverseBsp = ((BspCutIntersection*)thisInter)->GetBsp();				traversalOnTop = ((BspCutIntersection*)thisInter)->GetBspOnTop();				traverseForward = (pass == 0);			}			else if (pass == 2 || pass == 3)	//Traverse cut on material side			{				traverseCut = ((BspCutIntersection*)thisInter)->GetCut();				traversalOnTop = !((BspCutIntersection*)thisInter)->GetBspOnTop();				traverseForward = (pass == 2);			}			else	//Traverse cut on empty side			{				traverseCut = ((BspCutIntersection*)thisInter)->GetCut();				traversalOnTop = !((BspCutIntersection*)thisInter)->GetBspOnTop();				traverseForward = (pass == 4);				enteredCutForwards = false;			}			break;		case GenericIntersection::BSP_CUT_T:			traversalOnTop = true;			traverseForward = (pass == 0) ? true : (((BspCutTIntersection*)thisInter)->GetAtStart() ? true : false);						if (pass == 0)				traverseBsp = ((BspCutTIntersection*)thisInter)->GetBsp();			else if (pass == 1)			{				traverseCut = ((BspCutTIntersection*)thisInter)->GetCut();				enteredCutForwards = false;			}			break;		case GenericIntersection::CUT_CUT:			//MyAssert(false);			traversalOnTop = (pass == 0 || pass == 1 || pass == 2 || pass == 3);			traverseForward = (pass == 0 || pass == 1 || pass == 4 || pass == 5);			enteredCutForwards = (pass == 0 || pass == 2 || pass == 4 || pass == 6);			traverseCut = traversalOnTop ? ((CutCutIntersection*)thisInter)->GetCut1() : ((CutCutIntersection*)thisInter)->GetCut2();			break;	}		//Keep track of every oriented section during the subregion perimeter traversal (traversing a section in a particular direction (there are two possible directions))	vector<TraversedSection> traversedSectionsThisSubregion;		//Loop until the subregion perimeter traversal starts repeating itself	//bool traversingInfiniteSolid = false;		Don't think this variable is necessary anymore.  It is replaced by traverseWO.	bool subregionFoundAlready = false;	bool firstPass = true;	int prevFurthestLeftPointIdx;	int skipOneFurthestLeftPointIdxCounter = 0;	while (true)	{		//Get the curve and seg of the traversal bsp at the present intersection		int thisCv = -1, thisSg = -1, thisInfiniteWOsection = -1;		switch (thisInter->GetType())		{			case GenericIntersection::BSP_BSP:				if (traversalOnTop)				{					thisCv = ((BspBspIntersection*)thisInter)->GetCv1();					thisSg = ((BspBspIntersection*)thisInter)->GetSg1();				}				else	//traversal bsp on bottom				{					thisCv = ((BspBspIntersection*)thisInter)->GetCv2();					thisSg = ((BspBspIntersection*)thisInter)->GetSg2();				}				MyAssert(thisCv != -1 && thisSg != -1);				break;			case GenericIntersection::BSP_CUT:				thisCv = ((BspCutIntersection*)thisInter)->GetCv();				thisSg = ((BspCutIntersection*)thisInter)->GetSg();				MyAssert(thisCv != -1 && thisSg != -1);				break;			case GenericIntersection::BSP_CUT_T:				thisCv = ((BspCutTIntersection*)thisInter)->GetCv();				thisSg = ((BspCutTIntersection*)thisInter)->GetSg();				thisInfiniteWOsection = FindInfiniteWOsectionForInter((BspCutTIntersection*)thisInter);				MyAssert((thisCv != -1 && thisInfiniteWOsection == -1) || (thisCv == -1 && thisInfiniteWOsection != -1));				break;			case GenericIntersection::CUT_CUT:				//MyAssert(false);	//Is this possible?  Probably no reason for concern here.				break;		}				if (traverseWO)// && traversingInfiniteSolid)		{			MyAssert(!traverseBsp);			MyAssert(thisInter->GetType() == GenericIntersection::BSP_CUT_T);			MyAssert(!((BspCutTIntersection*)thisInter)->GetBsp());		}				//Find the next intersection on the traversal boundary		if (traverseBsp)		{			if (traverseForward)	//forward				nextInter = traverseBsp->FindNextIntersection(thisInter, thisCv, thisSg);			else nextInter = traverseBsp->FindPrevIntersection(thisInter, thisCv, thisSg);		}		else if (traverseCut)		{			//if (enteredCutForwards == 1)	//forward			//	nextInter = traverseForward ? traverseCut->FindNextIntersection(thisInter) : traverseCut->FindPrevIntersection(thisInter);			//else nextInter = traverseForward ? traverseCut->FindNextIntersection(thisInter) : traverseCut->FindPrevIntersection(thisInter);						nextInter = traverseForward ? traverseCut->FindNextIntersection(thisInter) : traverseCut->FindPrevIntersection(thisInter);		}		else	//Infinite cut		{			MyAssert(traverseWO);			MyAssert(thisInter->GetType() == GenericIntersection::BSP_CUT_T);			if (traverseForward)	//forward				nextInter = FindNextInfiniteSolidCut((BspCutTIntersection*)thisInter, true);			else			{				// nextInter = FindPrevInfiniteSolidCut((BspCutTIntersection*)thisInter);				nextInter = thisInter;			}		}				//Create a structure to represent this oriented section (the section being traversed in the unique direction it is being traversed)		TraversedSection ts(thisInter, nextInter, traversalOnTop, traverseForward, (thisInter->GetType() == GenericIntersection::BSP_BSP ? -1 : ((enteredCutForwards ? 1 : 0))));				//Here's another way of storing this information that doesn't depend on the availability of top-bottom crossing-state information.		//This method basically makes the TraversedSection approach old-fashioned, but we still use that approach here, so we keep it around.		//Note that some of the information in these structures is not initialized here and will be filled in near the bottom of the while loop.		MyAssert(thisCv != -1 || thisInfiniteWOsection != -1 || thisInter->GetType() == GenericIntersection::CUT_CUT);		OrientedBoundarySection obs(traverseBsp, traverseCut, traverseWO, thisInter, nextInter, thisCv, thisSg, thisInfiniteWOsection, traverseForward);		UnorientedBoundarySection ubs(traverseBsp, traverseCut, traverseWO, thisInter, nextInter, thisCv, thisSg, thisInfiniteWOsection, traverseForward);				//Check if the present-to-next pair has already been traversed in another subregion		if (find(traversedSections.begin(), traversedSections.end(), ts) != traversedSections.end() &&			find(traversedSectionsThisSubregion.begin(), traversedSectionsThisSubregion.end(), ts) == traversedSectionsThisSubregion.end())		{			if (gDebug7)			{				PenSize(2, 2);								FloatPoint loc = nextInter->GetLocation();				SetRect(&r, max(loc.h, 0.0) - 8, loc.v - 8, max(loc.h, 0.0) + 8, loc.v + 8);				ForeColor(cyanColor);				FrameOval(&r);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qa = 1;								ForeColor(whiteColor);				FrameOval(&r);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			}						subregionFoundAlready = true;						if (boundarySectionMap)			{				for (int i = 0; i < subregion->ubss.size(); i++)				{					unsigned long hashKey = subregion->ubss[i].GetHashKey();					vector<Subregion*> ubsSubregions = (*boundarySectionMap)[hashKey];					bool foundIt = false;					for (vector<Subregion*>::iterator iter = ubsSubregions.begin(); iter != ubsSubregions.end(); iter++)						if ((*iter) == subregion)						{							if (gDebug7)							{								PenSize(2, 2);																FloatPoint loc = subregion->ubss[i].startInter->GetLocation();								SetRect(&r, max(loc.h, 0.0) - 8, loc.v - 8, max(loc.h, 0.0) + 8, loc.v + 8);								ForeColor(greenColor);								FrameOval(&r);																loc = subregion->ubss[i].endInter->GetLocation();								SetRect(&r, max(loc.h, 0.0) - 8, loc.v - 8, max(loc.h, 0.0) + 8, loc.v + 8);								ForeColor(redColor);								FrameOval(&r);																QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);																int qa = 1;																ForeColor(whiteColor);								loc = subregion->ubss[i].startInter->GetLocation();								SetRect(&r, max(loc.h, 0.0) - 8, loc.v - 8, max(loc.h, 0.0) + 8, loc.v + 8);								FrameOval(&r);																loc = subregion->ubss[i].endInter->GetLocation();								SetRect(&r, max(loc.h, 0.0) - 8, loc.v - 8, max(loc.h, 0.0) + 8, loc.v + 8);								FrameOval(&r);							}														ubsSubregions.erase(iter);							foundIt = true;														break;						}					if (foundIt)						(*boundarySectionMap)[hashKey] = ubsSubregions;				}			}						break;		}				//Check if the subregion is done		if (find(traversedSectionsThisSubregion.begin(), traversedSectionsThisSubregion.end(), ts) != traversedSectionsThisSubregion.end())		{			if (gDebug7)			{				PenSize(2, 2);								FloatPoint loc = nextInter->GetLocation();				SetRect(&r, max(loc.h, 0.0) - 8, loc.v - 8, max(loc.h, 0.0) + 8, loc.v + 8);				ForeColor(blueColor);				FrameOval(&r);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qa = 1;								ForeColor(whiteColor);				FrameOval(&r);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			}						//Sometimes this assert gives a false positive, which means a section is being traversed twice.			//I'm not sure if this is a serious error.  It doesn't seem to adversely affect the rendering.			//MyAssert(find(traversedSections.begin(), traversedSections.end(), ts) == traversedSections.end());						traversedSections.push_back(ts);			break;		}				if (gDebug7)		{			PenSize(2, 2);						FloatPoint loc = nextInter->GetLocation();			SetRect(&r, max(loc.h, 0.0) - 6, loc.v - 6, max(loc.h, 0.0) + 6, loc.v + 6);			ForeColor(greenColor);			FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qa = 1;						ForeColor(whiteColor);			FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}				//Add this section to the traversed section lists		if (!firstPass)			traversedSections.push_back(ts);		traversedSectionsThisSubregion.push_back(ts);				//Add this intersection to the subregion's intersection list		subregion->corners.push_back(thisInter);				//Add this section to the subregion's section list		subregion->obss.push_back(obs);		subregion->ubss.push_back(ubs);				//Add this intersection's location to the subregion's point list		prevFurthestLeftPointIdx = subregion->furthestLeftPointIdx;		//if (skipOneFurthestLeftPointIdxCounter > 0)			if (subregion->furthestLeftPointIdx != -1)			{				if (thisInter->GetLocation().h > -999998 && thisInter->GetLocation().h < subregion->points[subregion->furthestLeftPointIdx].h)					subregion->furthestLeftPointIdx = subregion->points.size();			}			else			{				//MyAssert(subregion->points.size() == 0);				subregion->furthestLeftPointIdx = subregion->points.size();			}		subregion->points.push_back(thisInter->GetLocation());				//Add the depth between the two intersections and the traverse bsp to the subregion.		//Only do this when traversing forward because a backward traversal doesn't bound "inward" into this subregion.		if (collectSubregionSurfaceDepths && traverseBsp && traverseForward)		{			MyAssert(!traverseCut);						int depth = traverseBsp->GetSectionDepth(thisInter, nextInter, traversalOnTop, traverseForward);			/*			//Get the group for the traversal BSpline			vector<BSpline*> groupBSplines;			GetBSplinesInGroupFromBSpline(traverseBsp, groupBSplines);						//Only put each object/depth pair in the subregion's depth list once						bool groupDepthAlreadyRepresented = false;			for (int i = 0; i < subregion->sectionBspDepths.size(); i++)				if (find(groupBSplines.begin(), groupBSplines.end(), subregion->sectionBspDepths[i].first) != groupBSplines.end())					if (subregion->sectionBspDepths[i].second == depth)					{						groupDepthAlreadyRepresented = true;						break;					}						if (!groupDepthAlreadyRepresented)				subregion->sectionBspDepths.push_back(pair<BSpline*, int>(traverseBsp, depth));			*/			//////////////////////////////////			WholeObject* wholeObject = NULL;			MyAssert(FindOrCreateWholeObjectForBSpline(traverseBsp, wholeObject));						bool groupDepthAlreadyRepresented = false;			for (int i = 0; i < subregion->sectionWODepths.size(); i++)				if (subregion->sectionWODepths[i].first == wholeObject)					if (subregion->sectionWODepths[i].second == depth)					{						groupDepthAlreadyRepresented = true;						break;					}						if (!groupDepthAlreadyRepresented)				subregion->sectionWODepths.push_back(pair<WholeObject*, int>(wholeObject, depth));		}				//Strange special case for BspCut intersections.		//There can be an infinitely short segment of BSpline bounding into the region as the traversal turns 180 degrees on the cut at the intersection.		if (nextInter->GetType() == GenericIntersection::BSP_CUT && !traverseBsp && !enteredCutForwards)		{			if ((traverseForward && ((BspCutIntersection*)nextInter)->GetEdgeDirection() == -1) ||				(!traverseForward && ((BspCutIntersection*)nextInter)->GetEdgeDirection() == 1))				{										if (gDebug7)					{						PenSize(2, 2);												FloatPoint loc = nextInter->GetLocation();						SetRect(&r, max(loc.h, 0.0) - 6, loc.v - 6, max(loc.h, 0.0) + 6, loc.v + 6);						ForeColor(yellowColor);						FrameOval(&r);												QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qa = 1;												ForeColor(whiteColor);						FrameOval(&r);												QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);					}										BSpline* bsp = ((BspCutIntersection*)nextInter)->GetBsp();					int depth = bsp->GetArbitraryCurvePointDepth(								((BspCutIntersection*)nextInter)->GetCv(), ((BspCutIntersection*)nextInter)->GetSg(), nextInter->GetLocation());										if (!((BspCutIntersection*)nextInter)->GetBspOnTop())						depth--;										//MyAssert(depth >= 0);										/*					//Get the group for the BSpline					vector<BSpline*> groupBSplines;					GetBSplinesInGroupFromBSpline(bsp, groupBSplines);										//Only put each object/depth pair in the subregion's depth list once					bool groupDepthAlreadyRepresented = false;					for (int i = 0; i < subregion->sectionBspDepths.size(); i++)						if (find(groupBSplines.begin(), groupBSplines.end(), subregion->sectionBspDepths[i].first) != groupBSplines.end())							if (subregion->sectionBspDepths[i].second == depth)							{								groupDepthAlreadyRepresented = true;								break;							}										if (!groupDepthAlreadyRepresented)						subregion->sectionBspDepths.push_back(pair<BSpline*, int>(bsp, depth));					*/					//////////////////////////////					WholeObject* wholeObject = NULL;					MyAssert(FindOrCreateWholeObjectForBSpline(bsp, wholeObject));										bool groupDepthAlreadyRepresented = false;					for (int i = 0; i < subregion->sectionWODepths.size(); i++)						if (subregion->sectionWODepths[i].first == wholeObject)							if (subregion->sectionWODepths[i].second == depth)							{								groupDepthAlreadyRepresented = true;								break;							}										if (!groupDepthAlreadyRepresented)						subregion->sectionWODepths.push_back(pair<WholeObject*, int>(wholeObject, depth));				}		}				//Remember some previous state before making the "turned corner" changes		BSpline* oldTraverseBsp = traverseBsp;		BSplineToBSplineCut* oldTraverseCut = traverseCut;		WholeObject* oldTraverseWO = traverseWO;		//bool oldTraversingInfiniteSolid = traversingInfiniteSolid;		bool oldTraversalOnTop = traversalOnTop;		bool oldTraverseForward = traverseForward;				bool traverseToTop = true;	//Although initialized here, this basically needs to be assigned during the corner turning below				//Turn the corner		int occludedEdge = nextInter->DetermineOccludedEdge();		if (!nextInter->SelfIntersection())		{			if (nextInter->GetType() == GenericIntersection::BSP_BSP)			{				BspBspIntersection* bspBspNextInter = (BspBspIntersection*)nextInter;								MyAssert(!traverseCut);								//Set the new traverse direction				if (bspBspNextInter->GetBsp1() == traverseBsp)	//Traversal arrived on top, turns corner to bottom				{					traversalOnTop = false;					traverseToTop = !traversalOnTop;					if (occludedEdge == 3)						traverseForward = !traverseForward;				}				else	//Traversal arrived on bottom, turns corner to top				{					traversalOnTop = true;					traverseToTop = !traversalOnTop;					if (occludedEdge == 4)						traverseForward = !traverseForward;				}								//Set the new traverse boundary				traverseBsp = bspBspNextInter->GetOtherBsp(traverseBsp);			}			else if (nextInter->GetType() == GenericIntersection::BSP_CUT)			{				BspCutIntersection* bspCutNextInter = (BspCutIntersection*)nextInter;								//Set the new traverse direction				if (traverseBsp)	//Traversal arrived on bspline, turns corner to cut				{					traversalOnTop = !bspCutNextInter->GetBspOnTop();					traverseToTop = !traversalOnTop;					if (occludedEdge == 1)						traverseForward = !traverseForward;					else if (occludedEdge == -1)					{						int edgeCrossDirection = bspCutNextInter->GetEdgeDirection();						if (edgeCrossDirection == -1)							traverseForward = !traverseForward;					}				}				else	//Traversal arrived on cut				{					if (enteredCutForwards)	//Turn onto bspline					{						traversalOnTop = bspCutNextInter->GetBspOnTop();						traverseToTop = !traversalOnTop;						if (occludedEdge == 2)							traverseForward = !traverseForward;						else if (occludedEdge == -1)						{							int edgeCrossDirection = bspCutNextInter->GetEdgeDirection();							if (edgeCrossDirection == 1)								traverseForward = !traverseForward;						}					}					else	//Turn 180 degrees on the cut					{						traverseForward = !traverseForward;						traverseToTop = traversalOnTop;					}				}								if (traverseBsp || enteredCutForwards)	//Don't switch boundaries when turning 180 degrees on a cut				{					//Set the new traverse boundary					if (traverseBsp)					{						traverseBsp = NULL;						MyAssert(!traverseCut);						traverseCut = bspCutNextInter->GetCut();					}					else					{						traverseCut = NULL;						MyAssert(!traverseBsp);						traverseBsp = bspCutNextInter->GetBsp();					}				}				else	//Turning 180 degrees on a cut				{					subregion->furthestLeftPointIdx = prevFurthestLeftPointIdx;					skipOneFurthestLeftPointIdxCounter = 2;				}			}			else if (nextInter->GetType() == GenericIntersection::BSP_CUT_T)			{				BspCutTIntersection* bspCutTNextInter = (BspCutTIntersection*)nextInter;								//Set the new traverse direction				if (traverseBsp || traverseWO)//traversingInfiniteSolid)				{					enteredCutForwards = traverseForward;										//Turn into cut					traverseForward = bspCutTNextInter->GetAtStart();				}				else				{					//Turn out of cut onto the BSpline boundary in the same direction that the cut was entered from a BSpline boundary					traverseForward = enteredCutForwards;					enteredCutForwards = true;				}								//Set the new traverse boundary				if (traverseBsp || traverseWO)//traversingInfiniteSolid)				{ 					traverseBsp = NULL;					traverseWO = NULL;					MyAssert(!traverseCut);					traverseCut = bspCutTNextInter->GetCut();					//traversingInfiniteSolid = false;				}				else				{					traverseCut = NULL;					MyAssert(!traverseBsp && !traverseWO);					traverseBsp = bspCutTNextInter->GetBsp();					if (!traverseBsp)					{						traverseWO = bspCutTNextInter->GetInfiniteWholeObject();						MyAssert(traverseWO);					}										//traverseBsp will be NULL for an infinite cut					//if (!traverseBsp)					//	traversingInfiniteSolid = true;				}								traversalOnTop = traverseToTop = true;			}			else if (nextInter->GetType() == GenericIntersection::CUT_CUT)			{				MyAssert(!traverseBsp);								CutCutIntersection* cutCutNextInter = (CutCutIntersection*)nextInter;								if (enteredCutForwards)	//Turn corner onto crossing cut				{					//Set the new traverse direction					int edgeCrossDirection;					//if (traversalOnTop)					if (cutCutNextInter->GetCut1() == traverseCut)					{						if (traverseForward)							edgeCrossDirection = LineCrossLineDirection(cutCutNextInter->GetCut1()->GetStart(),																		cutCutNextInter->GetCut1()->GetEnd(),																		cutCutNextInter->GetCut2()->GetStart(),																		cutCutNextInter->GetCut2()->GetEnd());						else edgeCrossDirection = LineCrossLineDirection(cutCutNextInter->GetCut1()->GetEnd(),																		cutCutNextInter->GetCut1()->GetStart(),																		cutCutNextInter->GetCut2()->GetStart(),																		cutCutNextInter->GetCut2()->GetEnd());					}					else	//traversal on bottom					{						if (traverseForward)							edgeCrossDirection = LineCrossLineDirection(cutCutNextInter->GetCut2()->GetStart(),																		cutCutNextInter->GetCut2()->GetEnd(),																		cutCutNextInter->GetCut1()->GetStart(),																		cutCutNextInter->GetCut1()->GetEnd());						else edgeCrossDirection = LineCrossLineDirection(cutCutNextInter->GetCut2()->GetEnd(),																		cutCutNextInter->GetCut2()->GetStart(),																		cutCutNextInter->GetCut1()->GetStart(),																		cutCutNextInter->GetCut1()->GetEnd());					}					MyAssert(edgeCrossDirection != 0);										if (edgeCrossDirection == 1)	//Cross cut goes left						traverseForward = false;					else traverseForward = true;	//Cross cut goes right										//traversalOnTop = traverseToTop = true;					traversalOnTop = traverseToTop = !(cutCutNextInter->GetCut1() == traverseCut);				}				else	//Turn 180 degrees on the cut				{					traverseForward = !traverseForward;					traverseToTop = traversalOnTop;										subregion->furthestLeftPointIdx = prevFurthestLeftPointIdx;					skipOneFurthestLeftPointIdxCounter = 2;				}								//Set the new traverse boundary				if (enteredCutForwards)	//Don't switch boundaries when turning 180 degrees on a cut					traverseCut = cutCutNextInter->GetOtherCut(traverseCut);			}		}		else	//Traversing to self Intersection		{			//Find the four intersections in all four directions from the new intersection			GenericIntersection* topPrev = ((BspBspIntersection*)nextInter)->GetBsp1()->FindPrevIntersection(((BspBspIntersection*)nextInter), ((BspBspIntersection*)nextInter)->GetCv1(), ((BspBspIntersection*)nextInter)->GetSg1());			GenericIntersection* topNext = ((BspBspIntersection*)nextInter)->GetBsp1()->FindNextIntersection(((BspBspIntersection*)nextInter), ((BspBspIntersection*)nextInter)->GetCv1(), ((BspBspIntersection*)nextInter)->GetSg1());			GenericIntersection* botPrev = ((BspBspIntersection*)nextInter)->GetBsp2()->FindPrevIntersection(((BspBspIntersection*)nextInter), ((BspBspIntersection*)nextInter)->GetCv2(), ((BspBspIntersection*)nextInter)->GetSg2());			GenericIntersection* botNext = ((BspBspIntersection*)nextInter)->GetBsp2()->FindNextIntersection(((BspBspIntersection*)nextInter), ((BspBspIntersection*)nextInter)->GetCv2(), ((BspBspIntersection*)nextInter)->GetSg2());						//Use the match between the intersection the traversal came from and the correct neighbor from the new 			//intersection to determine if the traversal arrived at the new intersection on the top or the bottom						if (!thisInter->SelfIntersection())	//Not a traversal between two self intersections			{				//Exactly one of the following four tests should succeed (no more, no less).  Otherwise it's still ambiguous and it's not working properly.				//Theoretically, this could be converted into an if/else once I'm confident in the MyAsserts (confident only one test passes).				bool foundIt = false;				if (thisInter == topPrev && traverseForward)				{					foundIt = true;					traverseToTop = true;				}				if (thisInter == topNext && !traverseForward)				{					MyAssert(!foundIt);					foundIt = true;					traverseToTop = true;				}				if (thisInter == botPrev && traverseForward)				{					MyAssert(!foundIt);					foundIt = true;					traverseToTop = false;				}				if (thisInter == botNext && !traverseForward)				{					MyAssert(!foundIt);					foundIt = true;					traverseToTop = false;				}				MyAssert(foundIt);			}			else	//Traversal from self intersection, therefore traversal between two self intersections			{				MyAssert(thisInter->SelfIntersection());				MyAssert(nextInter->SelfIntersection());				MyAssert(((BspBspIntersection*)thisInter)->GetBsp1() == ((BspBspIntersection*)nextInter)->GetBsp1());								if (thisInter == nextInter)	//Traversal between the same intersection				{					traverseToTop = !traversalOnTop;					//traverseForward doesn't change				}				else	//Traversal between two different self-intersections				{					//Given the curve-segment that the traversal started from, only one of the two curve-segments at the next intersection					//can directly follow the starting curve-segment.  Find it.										int totalCurveSegments = traverseBsp->GetCurvePoints()->size() * BSpline::sNumSegmentsPerCurve;										//Get the curve-segment that started the traversal					int cvStart = traversalOnTop ? ((BspBspIntersection*)thisInter)->GetCv1() : ((BspBspIntersection*)thisInter)->GetCv2();					int sgStart = traversalOnTop ? ((BspBspIntersection*)thisInter)->GetSg1() : ((BspBspIntersection*)thisInter)->GetSg2();					int cvSg = cvStart * totalCurveSegments + sgStart;										//Get the two curve-segments at the next intersection					int cv1 = ((BspBspIntersection*)nextInter)->GetCv1();					int cv2 = ((BspBspIntersection*)nextInter)->GetCv2();					int sg1 = ((BspBspIntersection*)nextInter)->GetSg1();					int sg2 = ((BspBspIntersection*)nextInter)->GetSg2();					int cvSg1 = cv1 * totalCurveSegments + sg1;					int cvSg2 = cv2 * totalCurveSegments + sg2;					MyAssert(cvSg1 != cvSg2);										//Determine which curve-segment directly follows or preceeds, depending on the traverseForward					if ((cvSg1 > cvSg && cvSg2 > cvSg) || (cvSg1 < cvSg && cvSg2 < cvSg))					{						if (cvSg1 < cvSg2)							traverseToTop = traverseForward;						else traverseToTop = !traverseForward;					}					else if (cvSg1 > cvSg && cvSg2 < cvSg)						traverseToTop = traverseForward;					else if (cvSg1 < cvSg && cvSg2 > cvSg)						traverseToTop = !traverseForward;					else	//one of the new intersection's curve-segments matches the starting curve-segments					{						MyAssert(cvSg1 != cvSg || cvSg2 != cvSg);	//I'm pretty sure this should be impossible												vector<vector<FloatPoint>*> curvePoints = *traverseBsp->GetCurvePoints();						FloatPoint cvSgStartLoc = (*curvePoints[cvStart])[sgStart];												//Get the distance from the curve segment start to this intersection						double thisInterSegPos = LineSegmentLength(cvSgStartLoc, thisInter->GetLocation());												//Get the distance from the curve segment start to the next intersection						double nextInterSegPos = LineSegmentLength(cvSgStartLoc, nextInter->GetLocation());												//Figure out which curve-segment at the next intersection directly follows or preceeds this intersection from the starting curve-segment						if (cvSg1 == cvSg && cvSg2 != cvSg)						{							if (nextInterSegPos > thisInterSegPos)								traverseToTop = traverseForward;							else traverseToTop = !traverseForward;						}						else if (cvSg2 == cvSg && cvSg1 != cvSg)						{							if (nextInterSegPos > thisInterSegPos)								traverseToTop = !traverseForward;							else traverseToTop = traverseForward;						}						else MyAssert(false);	//I'm pretty sure this should be impossible					}				}			}						//Set the new traverse direction			if (traverseToTop)	//Traversal arrived on top, turns corner to bottom			{				traversalOnTop = false;				if (occludedEdge == 3)					traverseForward = !traverseForward;			}			else	//Traversal arrived on bottom, turns corner to top			{				traversalOnTop = true;				if (occludedEdge == 4)					traverseForward = !traverseForward;			}						//Set the new traverse boundary			traverseBsp = ((BspBspIntersection*)nextInter)->GetOtherBsp(traverseBsp);		}				//Finish filling in the BoundarySection structs		int nextCv = -1, nextSg = -1, nextInfiniteWOsection = -1;		if (oldTraverseBsp)			switch (nextInter->GetType())			{				case GenericIntersection::BSP_BSP:					if (traverseToTop)					{						nextCv = ((BspBspIntersection*)nextInter)->GetCv1();						nextSg = ((BspBspIntersection*)nextInter)->GetSg1();					}					else	//traversal bsp on bottom					{						nextCv = ((BspBspIntersection*)nextInter)->GetCv2();						nextSg = ((BspBspIntersection*)nextInter)->GetSg2();					}					break;				case GenericIntersection::BSP_CUT:					nextCv = ((BspCutIntersection*)nextInter)->GetCv();					nextSg = ((BspCutIntersection*)nextInter)->GetSg();					break;				case GenericIntersection::BSP_CUT_T:					nextCv = ((BspCutTIntersection*)nextInter)->GetCv();					nextSg = ((BspCutTIntersection*)nextInter)->GetSg();					nextInfiniteWOsection = ((BspCutTIntersection*)nextInter)->GetInfiniteWOsection();					break;				case GenericIntersection::CUT_CUT:					MyAssert(false);					break;			}		else if (oldTraverseCut)			switch (nextInter->GetType())			{				case GenericIntersection::BSP_BSP:					MyAssert(false);					break;				case GenericIntersection::BSP_CUT:					nextCv = ((BspCutIntersection*)nextInter)->GetCv();					nextSg = ((BspCutIntersection*)nextInter)->GetSg();					break;				case GenericIntersection::BSP_CUT_T:					nextCv = ((BspCutTIntersection*)nextInter)->GetCv();					nextSg = ((BspCutTIntersection*)nextInter)->GetSg();					nextInfiniteWOsection = ((BspCutTIntersection*)nextInter)->GetInfiniteWOsection();					break;				case GenericIntersection::CUT_CUT:					break;			}		else if (oldTraverseWO)			switch (nextInter->GetType())			{				case GenericIntersection::BSP_BSP:					MyAssert(false);					break;				case GenericIntersection::BSP_CUT:					MyAssert(false);					break;				case GenericIntersection::BSP_CUT_T:					nextCv = ((BspCutTIntersection*)nextInter)->GetCv();					nextSg = ((BspCutTIntersection*)nextInter)->GetSg();					nextInfiniteWOsection = ((BspCutTIntersection*)nextInter)->GetInfiniteWOsection();					break;				case GenericIntersection::CUT_CUT:					MyAssert(false);					break;			}				OrientedBoundarySection* obs1 = &subregion->obss[subregion->obss.size() - 1];		UnorientedBoundarySection* ubs1 = &subregion->ubss[subregion->ubss.size() - 1];		MyAssert(obs1->bsp == oldTraverseBsp && obs1->cut == oldTraverseCut);		MyAssert(ubs1->bsp == oldTraverseBsp && ubs1->cut == oldTraverseCut);				if (obs1->startInter->GetType() != GenericIntersection::CUT_CUT)			MyAssert(obs1->startCv != -1 || obs1->startInfiniteWOsection != -1);				if (oldTraverseBsp)			MyAssert(obs1->bsp && !obs1->cut && ubs1->bsp && !ubs1->cut);		else MyAssert(!obs1->bsp && !ubs1->bsp);				obs1->endCv = nextCv;		obs1->endSg = nextSg;		obs1->endInfiniteWOsection = nextInfiniteWOsection;		if (ubs1->endCv == -1)		{			MyAssert(ubs1->endSg == -1);			ubs1->endCv = nextCv;			ubs1->endSg = nextSg;			ubs1->endInfiniteWOsection = nextInfiniteWOsection;		}		else if (ubs1->startCv == -1)		{			MyAssert(ubs1->startSg == -1);			ubs1->startCv = nextCv;			ubs1->startSg = nextSg;			ubs1->startInfiniteWOsection = nextInfiniteWOsection;		}		if (oldTraverseBsp)			obs1->subboundaryIndex = ubs1->subboundaryIndex = oldTraverseBsp->FindSubboundaryForSection(*ubs1);		else obs1->subboundaryIndex = ubs1->subboundaryIndex = 0;				if (obs1->startInter->GetType() != GenericIntersection::CUT_CUT)			MyAssert(obs1->startCv != -1 || obs1->startInfiniteWOsection != -1);		if (obs1->endInter->GetType() != GenericIntersection::CUT_CUT)			MyAssert(obs1->endCv != -1 || obs1->endInfiniteWOsection != -1);				if (boundarySectionMap)		{			unsigned long hashKey = ubs1->GetHashKey();			vector<Subregion*> ubsSubregions = (*boundarySectionMap)[hashKey];						if (ubs1->cut)			{				if (gDebug7)				{					PenSize(2, 2);										FloatPoint loc;					ForeColor(blackColor);					for (int ii = 0; ii < subregion->corners.size(); ii++)					{						loc = subregion->corners[ii]->GetLocation();						SetRect(&r, max(loc.h, 0.0) - 6, loc.v - 6, max(loc.h, 0.0) + 6, loc.v + 6);						FrameOval(&r);					}										loc = ubs1->startInter->GetLocation();					SetRect(&r, max(loc.h, 0.0) - 8, loc.v - 8, max(loc.h, 0.0) + 8, loc.v + 8);					ForeColor(cyanColor);					FrameOval(&r);										loc = ubs1->endInter->GetLocation();					SetRect(&r, max(loc.h, 0.0) - 8, loc.v - 8, max(loc.h, 0.0) + 8, loc.v + 8);					ForeColor(magentaColor);					FrameOval(&r);										loc = thisInter->GetLocation();					SetRect(&r, max(loc.h, 0.0) - 12, loc.v - 12, max(loc.h, 0.0) + 12, loc.v + 12);					ForeColor(greenColor);					FrameOval(&r);										loc = nextInter->GetLocation();					SetRect(&r, max(loc.h, 0.0) - 12, loc.v - 12, max(loc.h, 0.0) + 12, loc.v + 12);					ForeColor(redColor);					FrameOval(&r);										QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qa = 1;										ForeColor(whiteColor);					for (int ii = 0; ii < subregion->corners.size(); ii++)					{						loc = subregion->corners[ii]->GetLocation();						SetRect(&r, max(loc.h, 0.0) - 6, loc.v - 6, max(loc.h, 0.0) + 6, loc.v + 6);						FrameOval(&r);					}					loc = ubs1->startInter->GetLocation();					SetRect(&r, max(loc.h, 0.0) - 8, loc.v - 8, max(loc.h, 0.0) + 8, loc.v + 8);					FrameOval(&r);					loc = ubs1->endInter->GetLocation();					SetRect(&r, max(loc.h, 0.0) - 8, loc.v - 8, max(loc.h, 0.0) + 8, loc.v + 8);					FrameOval(&r);					loc = thisInter->GetLocation();					SetRect(&r, max(loc.h, 0.0) - 12, loc.v - 12, max(loc.h, 0.0) + 12, loc.v + 12);					FrameOval(&r);					loc = nextInter->GetLocation();					SetRect(&r, max(loc.h, 0.0) - 12, loc.v - 12, max(loc.h, 0.0) + 12, loc.v + 12);					FrameOval(&r);										QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);									}			}						MyAssert(ubsSubregions.size() < 4);			bool foundIt = false;			for (vector<Subregion*>::iterator iter = ubsSubregions.begin(); iter != ubsSubregions.end(); iter++)				if ((*iter) == subregion)				{					ubsSubregions.erase(iter);					foundIt = true;					break;				}						if (!foundIt)				ubsSubregions.push_back(subregion);						if (ubsSubregions.size() != 0)				(*boundarySectionMap)[hashKey] = ubsSubregions;			else (*boundarySectionMap).erase(hashKey);		}				//Even though it chronologically makes sense to gather the points before turning the corner,		//the corner turning information is helpful here.		//Specifically, it is helpful to know if the traversal arrived at the next intersection on top or bottom.		if (oldTraverseBsp)// && !oldTraversingInfiniteSolid)		{			MyAssert(oldTraverseBsp && !oldTraverseCut && !oldTraverseWO);			//Gather the points between the two intersections and add them to the point list			vector<FloatPoint> intermediatePoints;			oldTraverseBsp->GetSectionPoints(thisInter, nextInter, oldTraversalOnTop, traverseToTop, false, oldTraverseForward, intermediatePoints);					if (gDebug7)			{				PenSize(2, 2);								FloatPoint loc = nextInter->GetLocation();				ForeColor(greenColor);								FloatPoint prevPoint = thisInter->GetLocation();				MoveTo(max(prevPoint.h, 0.0), prevPoint.v);				for (int i = 0; i < intermediatePoints.size(); i++)				{					LineTo(max(intermediatePoints[i].h, 0.0), intermediatePoints[i].v);					prevPoint = intermediatePoints[i];				}				FloatPoint nextPoint = nextInter->GetLocation();				LineTo(max(nextPoint.h, 0.0), nextPoint.v);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								//long st = TickCount();				//while (TickCount() - st < 15);								int qa = 1;				/*				ForeColor(whiteColor);								prevPoint = thisInter->GetLocation();				MoveTo(max(prevPoint.h, 0.0), prevPoint.v);				for (int i = 0; i < intermediatePoints.size(); i++)				{					LineTo(max(intermediatePoints[i].h, 0.0), intermediatePoints[i].v);					prevPoint = intermediatePoints[i];				}				nextPoint = nextInter->GetLocation();				LineTo(max(nextPoint.h, 0.0), nextPoint.v);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				*/			}						for (int i = 0; i < intermediatePoints.size(); i++)			{				if (subregion->furthestLeftPointIdx != -1)				{					if (intermediatePoints[i].h < subregion->points[subregion->furthestLeftPointIdx].h)						subregion->furthestLeftPointIdx = subregion->points.size();				}				else				{					//MyAssert(subregion->points.size() == 0);					subregion->furthestLeftPointIdx = subregion->points.size();				}				subregion->points.push_back(intermediatePoints[i]);			}		}		else if (oldTraverseWO)		{			MyAssert(!oldTraverseBsp && !oldTraverseCut && oldTraverseWO);			FloatPoint thisLoc = thisInter->GetLocation();			FloatPoint nextLoc = nextInter->GetLocation();			MyAssert(thisLoc.h < 0 && nextLoc.h < 0);			if (oldTraverseForward && thisLoc.v <= nextLoc.v)			{				FloatPoint loc = thisInter->GetLocation();				if (gDebug7)				{					PenSize(2, 2);					ForeColor(greenColor);					MoveTo(max(loc.h, 0.0), loc.v);				}								FloatPoint p;				p.h = p.v = 0;				/*				if (subregion->furthestLeftPointIdx != -1)				{					if (p.h < subregion->points[subregion->furthestLeftPointIdx].h)						subregion->furthestLeftPointIdx = subregion->points.size();				}				else				{					//MyAssert(subregion->points.size() == 0);					subregion->furthestLeftPointIdx = subregion->points.size();				}				*/				subregion->points.push_back(p);								if (gDebug7)					LineTo(0, 0);								p.h = 999999;				p.v = 0;				subregion->points.push_back(p);								if (gDebug7)					LineTo(698, 0);								p.h = 999999;				p.v = 999999;				subregion->points.push_back(p);								if (gDebug7)					LineTo(698, 698);								p.h = 0;				p.v = 999999;				subregion->points.push_back(p);								if (gDebug7)				{					LineTo(0, 698);					loc = nextInter->GetLocation();					LineTo(max(loc.h, 0.0), loc.v);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										long st = TickCount();					while (TickCount() - st < 15);										int qa = 1;				}			}			/*			else if (0)//(!oldTraverseForward && thisLoc.v >= nextLoc.v)			{				FloatPoint loc = thisInter->GetLocation();				if (gDebug7)				{					PenSize(2, 2);					ForeColor(greenColor);					MoveTo(max(loc.h, 0.0), loc.v);				}								FloatPoint p;				p.h = 0;				p.v = 999999;				if (subregion->furthestLeftPointIdx != -1)				{					if (p.h < subregion->points[subregion->furthestLeftPointIdx].h)						subregion->furthestLeftPointIdx = subregion->points.size();				}				else				{					//MyAssert(subregion->points.size() == 0);					subregion->furthestLeftPointIdx = subregion->points.size();				}				subregion->points.push_back(p);								if (gDebug7)					LineTo(0, 698);								p.h = 999999;				p.v = 999999;				subregion->points.push_back(p);								if (gDebug7)					LineTo(698, 698);								p.h = 999999;				p.v = 0;				subregion->points.push_back(p);								if (gDebug7)					LineTo(698, 0);								p.h = p.v = 0;				subregion->points.push_back(p);								if (gDebug7)				{					LineTo(0, 0);					loc = nextInter->GetLocation();					LineTo(max(loc.h, 0.0), loc.v);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qa = 1;				}			}*/		}		else		{			MyAssert(!oldTraverseBsp && oldTraverseCut && !oldTraverseWO);			if (gDebug7)			{				PenSize(2, 2);								ForeColor(greenColor);								FloatPoint loc = thisInter->GetLocation();				MoveTo(max(loc.h, 0.0), loc.v);				loc = nextInter->GetLocation();				LineTo(max(loc.h, 0.0), loc.v);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qa = 1;				/*				ForeColor(whiteColor);								loc = thisInter->GetLocation();				MoveTo(max(loc.h, 0.0), loc.v);				loc = nextInter->GetLocation();				LineTo(max(loc.h, 0.0), loc.v);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				*/			}		}				prevInter = thisInter;		thisInter = nextInter;				firstPass = false;				if (skipOneFurthestLeftPointIdxCounter > 0)			skipOneFurthestLeftPointIdxCounter--;	}		PenSize(1, 1);	//DEBUG		if (subregionFoundAlready)		return false;		if (subregion->corners.size() == 2)	{		for (int i = 0; i < subregion->corners.size(); i++)			if (subregion->corners[i]->GetType() == GenericIntersection::BSP_BSP)				return true;	//Can't be a cut sliver				if (gDebug7)		{			ForeColor(cyanColor);			subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			int qa = 1;		}				for (int i = 0; i < subregion->obss.size(); i++)			if (subregion->obss[i].bsp)				return true;				if (gDebug7)		{			ForeColor(redColor);			subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			int qa = 1;		}		return false;	}		//MyAssert(subregion->furthestLeftPointIdx != -1);		return true;}vector<CutIntersection> Drawing::FindAllIntersectionsForOneSlice(FloatPoint sliceFromPoint, int sliceStartingDepth){	FloatPoint sliceToPoint = sliceFromPoint;	sliceToPoint.h = -999999;		vector<CutIntersection> sliceIntersections;		FloatPoint cvPt1, cvPt2;	FloatPoint intersectionLoc;	double lineInter1, lineInter2;	for (int k = 0; k < bsplines.size(); k++)	//Loop through all BSplines	{		vector<vector<FloatPoint>*>* curvePoints = bsplines[k]->GetCurvePoints();		for (int m = 0; m < curvePoints->size(); m++)	//Loop through the BSpline's curves			for (int n = 0; n < BSpline::sNumSegmentsPerCurve; n++)	//Loop through the curve segs on one of the BSpline's curves			{				//Get the two endpoints of the curve segment				cvPt1 = (*(*curvePoints)[m])[n];				if (n == BSpline::sNumSegmentsPerCurve - 1)					cvPt2 = (*(*curvePoints)[(m + 1) % curvePoints->size()])[0];				else cvPt2 = (*(*curvePoints)[m])[n + 1];								//Find out if the curve segment intersects the slice line seg defined in the passed in parameters				if (HorizontalLineSegmentIntersection(sliceFromPoint, sliceToPoint, cvPt1, cvPt2, intersectionLoc, lineInter1, lineInter2))				{					//Getting here means the curve segment intersects the slice line seg										int edgeDirection = LineCrossLineDirection(sliceFromPoint, sliceToPoint, cvPt1, cvPt2);					if (edgeDirection != 0)					{						//Calculate the distance of the intersection from the start of the line segment						double distToStart = LineSegmentLength(sliceFromPoint, intersectionLoc);												//Assume that points really really close to the start are the point where the slice began and skip them						//	NOT SURE ABOUT THIS			if (distToStart > .1)						{							//Create a little struct to hold the necessary information about the intersection,							//primarily its distance from the start of the test line seg							CutIntersection cutIntersection;														//This is just a starting estimate.  The slice will be "woven" later and this will be settled better.							bool bspOnTop = (bsplines[k]->GetArbitraryCurvePointDepth(m, n, intersectionLoc) <= sliceStartingDepth);														BspCutIntersection* bspSliceInter = new BspCutIntersection(this, intersectionLoc, bsplines[k], NULL,															GetBSplineIndex(bsplines[k]), -1, m, n, bspOnTop, edgeDirection, true);														cutIntersection.intersection = bspSliceInter;							cutIntersection.crossingWholeObject = FindWholeObjectForBSpline(bsplines[k]);							cutIntersection.distFromStart = distToStart;														sliceIntersections.push_back(cutIntersection);						}					}				}			}	}		//Add intersections for the infinite surfaces	for (int i = 0; i < wholeObjects.size(); i++)	{		for (int j = 0; j < wholeObjects[i]->bgDepths.size(); j++)		{			int bspInfiniteDepth = wholeObjects[i]->bgDepths[j];						//Create a little struct to hold the necessary information about the intersection,			//primarily its distance from the start of the test line seg			CutIntersection cutIntersection;						//This is just a starting estimate.  The slice will be "woven" later and this will be settled better.			bool bspOnTop = (bspInfiniteDepth <= sliceStartingDepth);						intersectionLoc.h = 0;//-999999 - bspInfiniteDepth;			intersectionLoc.v = sliceFromPoint.v;						//Calculate the distance of the intersection from the start of the line segment			double distToStart = LineSegmentLength(sliceFromPoint, intersectionLoc);						BspCutIntersection* bspSliceInter = new BspCutIntersection(this, intersectionLoc, NULL, NULL,												-1, -1, -1, -1, bspOnTop, -1, true);						cutIntersection.intersection = bspSliceInter;			cutIntersection.crossingWholeObject = wholeObjects[i];			cutIntersection.distFromStart = distToStart;						sliceIntersections.push_back(cutIntersection);		}	}		//Add intersections with cuts	for (int i = 0; i < bsplinePairCuts.size(); i++)	{		BSplineToBSplineCut* cut = bsplinePairCuts[i];				//Find out if the curve segment intersects the slice line seg defined in the passed in parameters		if (HorizontalLineSegmentIntersection(sliceFromPoint, sliceToPoint, cut->GetStart(), cut->GetEnd(), intersectionLoc, lineInter1, lineInter2))		{			//Getting here means the cut intersects the slice line seg						int edgeDirection = LineCrossLineDirection(sliceFromPoint, sliceToPoint, cut->GetStart(), cut->GetEnd());			if (edgeDirection != 0)			{				//Calculate the distance of the intersection from the start of the line segment				double distToStart = LineSegmentLength(sliceFromPoint, intersectionLoc);								//Assume that points really really close to the start are the point where the slice began and skip them				//	NOT SURE ABOUT THIS			if (distToStart > .1)				{					//Create a little struct to hold the necessary information about the intersection,					//primarily its distance from the start of the test line seg					CutIntersection cutIntersection;										CutCutIntersection* cutSliceInter = new CutCutIntersection(this, intersectionLoc, cut, NULL, GetCutIndex(cut), -1, true);										cutIntersection.intersection = cutSliceInter;					cutIntersection.crossingWholeObject = FindWholeObjectForCut(cut);					cutIntersection.distFromStart = distToStart;										sliceIntersections.push_back(cutIntersection);				}			}		}	}		//Sort the intersections based on their distance from the start of the slice	CutIntersectionSort cis;	sort(sliceIntersections.begin(), sliceIntersections.end(), cis);		return sliceIntersections;}bool Drawing::FindLegalSlice(Subregion* subregion){	//Pick test points within the bounding box of the points.	//Check how many times a slice from a test point crosses the segments bounding the region.	//If the slice crosses the region's boundary exactly once, it is legal.	//Actually, any odd number of boundary-slice crossings would count, but other things are cleaner if it is confined to crossing just once.		//Additionally, it is a good idea to require that the first intersection on the slice be an intersection on the region's boundary.	//This test can produce false negatives (acceptable slices might be rejected, similar to rejecting odd border counts, as mentioned above), but should	//prevent false positives (slices that cause trouble will be rejected).	//In particular, if there is a boundary inside the region in question that doesn't touch (intersect) the region's boundary (a disconnected component in the knot-diagram),	//then using a slice that originates inside the interior boundary causes problems.  A slice that originates to the right of the interior	//boundary and goes through it to get to the infinitely-left point would be okay, but will be rejected by the present code.  Oh well.		//Find the bounding box of the points;	FloatPoint upperLeftBB, lowerRightBB;	upperLeftBB.h = 999999;	upperLeftBB.v = 999999;	lowerRightBB.h = -999999;	lowerRightBB.v = -999999;	for (int i = 0; i < subregion->points.size(); i++)	{		if (subregion->points[i].h < upperLeftBB.h)			upperLeftBB.h = subregion->points[i].h;		if (subregion->points[i].v < upperLeftBB.v)			upperLeftBB.v = subregion->points[i].v;		if (subregion->points[i].h > lowerRightBB.h)			lowerRightBB.h = subregion->points[i].h;		if (subregion->points[i].v > lowerRightBB.v)			lowerRightBB.v = subregion->points[i].v;	}	int bbWidth = lowerRightBB.h - upperLeftBB.h + 1;	int bbHeight = lowerRightBB.v - upperLeftBB.v + 1;		//Shrink the bounds a tiny bit	if (bbWidth >= 5)	{		upperLeftBB.h++;		lowerRightBB.h--;	}	if (bbHeight >= 5)	{		upperLeftBB.v++;		lowerRightBB.v--;	}	bbWidth = lowerRightBB.h - upperLeftBB.h + 1;	bbHeight = lowerRightBB.v - upperLeftBB.v + 1;		if (gDebug7)	{		ForeColor(yellowColor);		subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));		int qa = 1;	}		//Pick test points at random until done	int maxNumTries = 100;	for (int tries = 0; tries < maxNumTries; tries++)	{		gNumSliceAttempts++;				//Pick a random test point within the bounding box		FloatPoint testPoint;		testPoint.h = RandZeroFloat((float)bbWidth) + upperLeftBB.h;		testPoint.v = RandZeroFloat((float)bbHeight) + upperLeftBB.v;				if (gDebug7)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));			PenSize(1, 1);						ForeColor(cyanColor);						MoveTo(testPoint.h, testPoint.v);			LineTo(0, testPoint.v);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			int qa = 1;		}				//Make an infinite line from the point going left		FloatPoint testPointEnd = testPoint;		testPointEnd.h = -999999;				//Count how many times the test line crosses the region's boundary segments		int sliceInterCount = 0;		bool badInters = false;		FloatPoint intersectionLoc, sliceInterLoc;		double lineInter1, lineInter2;		int edgeDirection;		for (int i = 0; i < subregion->points.size(); i++)		{			if (gDebug7)			{				SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;								FloatPoint loc = subregion->points[i];				SetRect(&r, loc.h - 5, loc.v - 5, loc.h + 5, loc.v + 5);				ForeColor(greenColor);				FrameOval(&r);								loc = subregion->points[(i + 1) % subregion->points.size()];				SetRect(&r, loc.h - 5, loc.v - 5, loc.h + 5, loc.v + 5);				ForeColor(redColor);				FrameOval(&r);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qa = 1;			}						if (HorizontalLineSegmentIntersection(testPoint, testPointEnd, subregion->points[i], subregion->points[(i + 1) % subregion->points.size()], intersectionLoc, lineInter1, lineInter2))			{				sliceInterLoc = intersectionLoc;								//Find the edge direction				edgeDirection = LineCrossLineDirection(testPoint, testPointEnd, subregion->points[i], subregion->points[(i + 1) % subregion->points.size()]);				MyAssert(edgeDirection != 0);								sliceInterCount++;				if (sliceInterCount > 1 || edgeDirection != -1)				{					badInters = true;					break;				}			}						if (gDebug7)			{				SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;				ForeColor(whiteColor);								FloatPoint loc = subregion->points[i];				SetRect(&r, loc.h - 5, loc.v - 5, loc.h + 5, loc.v + 5);				FrameOval(&r);								loc = subregion->points[(i + 1) % subregion->points.size()];				SetRect(&r, loc.h - 5, loc.v - 5, loc.h + 5, loc.v + 5);				FrameOval(&r);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qa = 1;			}		}				if (sliceInterCount == 0 || badInters)		{			if (gDebug7)			{				PenSize(1, 1);								ForeColor(whiteColor);								MoveTo(testPoint.h, testPoint.v);				LineTo(0, testPoint.v);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qa = 1;			}			continue;		}				//Update the test point to be just barely to the right of the slice intersection		testPoint.h = sliceInterLoc.h + .01;				//The slice is good with respect to the region's boundary.		//Now make sure the first intersection on the slice is an intersection within the region's boundary.		subregion->sliceIntersections = FindAllIntersectionsForOneSlice(testPoint, 0);		if (subregion->sliceIntersections.size() > 0)		{			//Find the first Bsp intersection on the slice (as opposed to a Cut intersection)			//int firstBspInterIndex = 0;			//for (firstBspInterIndex = 0; firstBspInterIndex < subregion->sliceIntersections.size(); firstBspInterIndex++)			//	if (subregion->sliceIntersections[firstBspInterIndex].intersection->GetType() == GenericIntersection::BSP_CUT)			//		break;			/*			if (firstBspInterIndex == subregion->sliceIntersections.size())	//The slice has no Bsp intersections at all, so we can't use the slice doesn't originate inside the subregion			{				for (int i = 0; i < subregion->sliceIntersections.size(); i++)					delete subregion->sliceIntersections[i].intersection;				subregion->sliceIntersections.clear();								if (gDebug7)				{					PenSize(1, 1);										ForeColor(whiteColor);										MoveTo(testPoint.h, testPoint.v);					LineTo(0, testPoint.v);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qa = 1;				}				continue;			}			*/			//Get the location of the first Bsp intersection			FloatPoint firstInterLoc = subregion->sliceIntersections[/*firstBspInterIndex*/0].intersection->GetLocation();						if (firstInterLoc != sliceInterLoc)	//If the first Bsp inter is not one of the subregion's border segments, reject it			//if (!sliceInterLoc.Equal(firstInterLoc, .01))			{				for (int i = 0; i < subregion->sliceIntersections.size(); i++)					delete subregion->sliceIntersections[i].intersection;				subregion->sliceIntersections.clear();								if (gDebug7)				{					PenSize(1, 1);										ForeColor(whiteColor);										MoveTo(testPoint.h, testPoint.v);					LineTo(0, testPoint.v);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qa = 1;				}				continue;			}						//Remove intersections from the front of the list until the slice intersection is found			/*			bool foundOne = true;			while (foundOne)			{				foundOne = false;				for (vector<CutIntersection>::iterator iter = subregion->sliceIntersections.begin(); iter != subregion->sliceIntersections.end(); iter++)					if ((*iter).intersection->GetLocation() != sliceInterLoc)					{						subregion->sliceIntersections.erase(iter);						foundOne = true;						break;					}			}			MyAssert(subregion->sliceIntersections.size() > 0);			*/		}		else MyAssert(sliceInterLoc.h == 0);				if (gDebug7)		{			PenSize(1, 1);						ForeColor(whiteColor);						MoveTo(testPoint.h, testPoint.v);			LineTo(0, testPoint.v);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qa = 1;		}				subregion->sliceFromPoint = testPoint;		return true;	}		//Bailed	return false;}bool Drawing::FindLegalSlice2(Subregion* subregion){	//Pick test points within the bounding box of the points.	//Check how many times a slice from a test point crosses the segments bounding the region.	//If the slice crosses the region's boundary exactly once, it is legal.	//Actually, any odd number of boundary-slice crossings would count, but other things are cleaner if it is confined to crossing just once.		//Additionally, it is a good idea to require that the first intersection on the slice be an intersection on the region's boundary.	//This test can produce false negatives (acceptable slices might be rejected, similar to rejecting odd border counts, as mentioned above), but should	//prevent false positives (slices that cause trouble will be rejected).	//In particular, if there is a boundary inside the region in question that doesn't touch (intersect) the region's boundary (a disconnected component in the knot-diagram),	//then using a slice that originates inside the interior boundary causes problems.  A slice that originates to the right of the interior	//boundary and goes through it to get to the infinitely-left point would be okay, but will be rejected by the present code.  Oh well.		//gDebug7 = true;	if (gDebug7)	{		Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		//gMainWindow->DrawGrid();				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);				ForeColor(yellowColor);		subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));		int qa = 1;	}		//Most likely a "sliver" subregion inside a cut or slice	if (subregion->furthestLeftPointIdx == -1)		return false;		bool keepGoing = true;	int attempt = 0;	while (keepGoing && attempt < 6)	{		keepGoing = false;				gNumSliceAttempts++;		int seg = subregion->furthestLeftPointIdx;		MyAssert(seg != -1 && seg < subregion->points.size());				FloatPoint p1 = subregion->points[seg];		FloatPoint p2 = subregion->points[(seg + 1) % subregion->points.size()];		FloatPoint p3 = subregion->points[(seg + (subregion->points.size() - 1)) % subregion->points.size()];				if (gDebug7)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));			Rect r;			SetRect(&r, max(p1.h, 10.0) - 3, p1.v - 3, max(p1.h, 10.0) + 3, p1.v + 3);			ForeColor(blueColor);			PaintOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			int qa = 1;		}				//MyAssert(p1.h < p2.h && p1.h < p3.h);		FloatPoint testPoint;		int sliceInterCount = 0;		bool badInters = false;		FloatPoint sliceInterLoc;		int nextAttempt = 0;		for (int j = attempt; j < 6; j++)		{			nextAttempt = attempt + 1;			if (gDebug7)			{				Rect r;				GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);				EraseRect(&r);				gMainWindow->DrawGrid();								Point scrollOffset = {0, 0};				vector<BSpline*> workingBSplines;				DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);								ForeColor(greenColor);				subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));								SetRect(&r, max(p1.h, 10.0) - 3, p1.v - 3, max(p1.h, 10.0) + 3, p1.v + 3);				ForeColor(blueColor);				PaintOval(&r);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qa = 1;			}						switch (j)			{				case 0:					if (p1.h >= p2.h)						continue;					testPoint.h = (p1.h + p2.h) / 2.0 + .1;					testPoint.v = (p1.v + p2.v) / 2.0;					break;				case 1:					if (p1.h >= p3.h)						continue;					testPoint.h = (p1.h + p3.h) / 2.0 + .1;					testPoint.v = (p1.v + p3.v) / 2.0;					break;				case 2:					if (p1.h >= p2.h)						continue;					testPoint.h = (p1.h + p2.h) / 2.0 - .1;					testPoint.v = (p1.v + p2.v) / 2.0;					break;				case 3:					if (p1.h >= p3.h)						continue;					testPoint.h = (p1.h + p3.h) / 2.0 - .1;					testPoint.v = (p1.v + p3.v) / 2.0;					break;								case 4:	//Presumably an infinite surface					testPoint.h = .01;					testPoint.v = p1.v - .1;					break;				case 5:	//Presumably an infinite surface					testPoint.h = .01;					testPoint.v = p1.v + .1;					break;				default:					MyAssert(false);			}						if (gDebug7)			{				SetPort(GetWindowPort(gMainWindow->GetWindow()));				PenSize(1, 1);								Rect r;				SetRect(&r, max(testPoint.h, 10.0) - 3, testPoint.v - 3, max(testPoint.h, 10.0) + 3, testPoint.v + 3);				ForeColor(magentaColor);				PaintOval(&r);								ForeColor(cyanColor);								MoveTo(max(testPoint.h, 10.0), testPoint.v);				LineTo(0, testPoint.v);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qa = 1;			}						//Make an infinite line from the point going left			FloatPoint testPointEnd = testPoint;			testPointEnd.h = -999999;						//SHOULDN'T HAVE TO TEST FOR SUBREGION BOUNDARY INTERSECTIONS.  IT SHOULD ALWAYS BE 1.			//REMOVE THIS CODE ONCE IT IS TESTED.			//Count how many times the test line crosses the region's boundary segments			sliceInterCount = 0;			badInters = false;			FloatPoint intersectionLoc;			double lineInter1, lineInter2;			int edgeDirection;			for (int i = 0; i < subregion->points.size(); i++)			{				if (gDebug7)				{					SetPort(GetWindowPort(gMainWindow->GetWindow()));					Rect r;										FloatPoint loc = subregion->points[i];					SetRect(&r, loc.h - 5, loc.v - 5, loc.h + 5, loc.v + 5);					ForeColor(greenColor);					FrameOval(&r);										loc = subregion->points[(i + 1) % subregion->points.size()];					SetRect(&r, loc.h - 5, loc.v - 5, loc.h + 5, loc.v + 5);					ForeColor(redColor);					FrameOval(&r);										QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);					int qa = 1;				}								if (HorizontalLineSegmentIntersection(testPoint, testPointEnd, subregion->points[i], subregion->points[(i + 1) % subregion->points.size()], intersectionLoc, lineInter1, lineInter2))				{					sliceInterLoc = intersectionLoc;										//Find the edge direction					edgeDirection = LineCrossLineDirection(testPoint, testPointEnd, subregion->points[i], subregion->points[(i + 1) % subregion->points.size()]);										sliceInterCount++;					if (sliceInterCount > 1 || edgeDirection != -1)					{						badInters = true;						break;					}				}			}						MyAssert(sliceInterCount <= 2);			if (sliceInterCount == 1 && !badInters)				break;		}				attempt = nextAttempt;				MyAssert(sliceInterCount <= 1);		if (sliceInterCount == 0 || badInters)		{			if (gDebug7)			{				Rect r;				GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);				EraseRect(&r);				//gMainWindow->DrawGrid();								Point scrollOffset = {0, 0};				vector<BSpline*> workingBSplines;				DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);								ForeColor(redColor);				subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));								PenSize(1, 1);								ForeColor(cyanColor);								MoveTo(max(testPoint.h, 10.0), testPoint.v);				LineTo(0, testPoint.v);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qa = 1;			}			return false;	//Must be an infinite subregion with no infinite surfaces (so, just the background canvas).  Actually, could be the "inside" of an infinite cut as well.		}				//Update the test point to be just barely to the right of the slice intersection		//testPoint.h = sliceInterLoc.h + .01;	//Only necessary if testing slices, not if creating one from the furthest left subregion boundary point				//The slice is good with respect to the region's boundary.		//Now make sure the first intersection on the slice is an intersection within the region's boundary.		subregion->sliceIntersections = FindAllIntersectionsForOneSlice(testPoint, 0);		if (subregion->sliceIntersections.size() > 0)		{			//Get the location of the first Bsp intersection						FloatPoint firstInterLoc = subregion->sliceIntersections[/*firstBspInterIndex*/0].intersection->GetLocation();						GenericIntersection *gi = subregion->sliceIntersections[0].intersection;			BspCutIntersection *bci = (BspCutIntersection*)gi;						if (!sliceInterLoc.Equal(firstInterLoc, .01))//(firstInterLoc != sliceInterLoc)	//If the first Bsp inter is not one of the subregion's border segments, reject it			{				//This shouldn't happen very often, and I'm not sure exactly what's going wrong, but one solution is to skip this slice attempt and try a different one.				keepGoing = true;				if (gDebug7)				{					Rect r;					GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);					EraseRect(&r);					//gMainWindow->DrawGrid();										Point scrollOffset = {0, 0};					vector<BSpline*> workingBSplines;					DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);										PenSize(1, 1);										ForeColor(cyanColor);										MoveTo(max(testPoint.h, 10.0), testPoint.v);					LineTo(0, testPoint.v);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qa = 1;				}								for (int i = 0; i < subregion->sliceIntersections.size(); i++)					delete subregion->sliceIntersections[i].intersection;				subregion->sliceIntersections.clear();								if (gDebug7)				{					PenSize(1, 1);										ForeColor(whiteColor);										MoveTo(max(testPoint.h, 10.0), testPoint.v);					LineTo(0, testPoint.v);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qa = 1;				}			}		}		else MyAssert(sliceInterLoc.h == 0);				if (gDebug7)		{			PenSize(1, 1);						ForeColor(redColor);			MoveTo(max(testPoint.h, 10.0), testPoint.v);			LineTo(0, testPoint.v);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qa = 1;						ForeColor(whiteColor);			MoveTo(max(testPoint.h, 10.0), testPoint.v);			LineTo(0, testPoint.v);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}				if (!keepGoing)		{			subregion->sliceFromPoint = testPoint;			return true;		}	}		//Couldn't find a slice.  This shouldn't every happen.	MyAssert(false);	//It isn't functionally impossible for the code to run to here, but it should be topologically impossible.  A slice should always be found.	return false;}BSpline* Drawing::FindSliceBoundary(Subregion* subregion, int sliceStartingDepth, bool checkingForDeeperSurfaces, vector<pair<WholeObject*, int> >* ownerSurfaces){	MyAssert(subregion->sliceIntersections.size() > 0);		//Weave the slice	int sliceEndingDepth = sliceStartingDepth;	BSpline* boundary = NULL;	bool foundOwnerSurface = false;	for (int i = 0; i < subregion->sliceIntersections.size(); i++)	{		MyAssert(subregion->sliceIntersections[i].intersection->GetType() == GenericIntersection::BSP_CUT ||				subregion->sliceIntersections[i].intersection->GetType() == GenericIntersection::CUT_CUT);				if (subregion->sliceIntersections[i].intersection->GetType() == GenericIntersection::CUT_CUT)			continue;				BspCutIntersection* bspSliceInter = (BspCutIntersection*)subregion->sliceIntersections[i].intersection;		if (!bspSliceInter->GetBsp())	//An intersection on an infinite boundary, just ignore it			continue;		/*		if (checkingForDeeperSurfaces)		{			BSpline* bsp = bspSliceInter->GetBsp();			for (int j = 0; j < ownerSurfaces->size(); j++)				if (find((*ownerSurfaces)[j].first->bsplines.begin(), (*ownerSurfaces)[j].first->bsplines.end(), bsp) != (*ownerSurfaces)[j].first->bsplines.end())				{					foundOwnerSurface = true;					break;				}							if (!foundOwnerSurface)				continue;		}		*/		int bspSliceIntersectionDepth = bspSliceInter->GetBsp()->GetArbitraryCurvePointDepth(bspSliceInter->GetCv(), bspSliceInter->GetSg(), bspSliceInter->GetLocation());		int edgeDirection = bspSliceInter->GetEdgeDirection();		if (sliceEndingDepth == bspSliceIntersectionDepth && edgeDirection == -1)		{			//This intersection marks the end of the slice, the BSpline to which the slice belongs			boundary = bspSliceInter->GetBsp();			break;		}		if (edgeDirection == 1 && bspSliceIntersectionDepth <= sliceEndingDepth)		{			sliceEndingDepth += edgeDirection;			//pointless -- bspSliceInter->SetBspOnTop(true);	//Seems redundant with the intersection's ctor, but actually it is necessary		}		else if (edgeDirection == -1 && bspSliceIntersectionDepth < sliceEndingDepth)		{			sliceEndingDepth += edgeDirection;			//pointless -- bspSliceInter->SetBspOnTop(true);	//Seems redundant with the intersection's ctor, but actually it is necessary		}		//pointless -- else bspSliceInter->SetBspOnTop(false);	//Seems redundant with the intersection's ctor, but actually it is necessary				if (checkingForDeeperSurfaces)		{			BSpline* bsp = bspSliceInter->GetBsp();			for (int j = 0; j < ownerSurfaces->size(); j++)				if (find((*ownerSurfaces)[j].first->bsplines.begin(), (*ownerSurfaces)[j].first->bsplines.end(), bsp) != (*ownerSurfaces)[j].first->bsplines.end())				{					foundOwnerSurface = true;					break;				}						if (!foundOwnerSurface && sliceEndingDepth < sliceStartingDepth)				sliceEndingDepth = sliceStartingDepth;		}			}		//If no boundary was found, check infinite boundaries	if (!boundary)	for (int i = 0; i < wholeObjects.size(); i++)		for (int j = 0; j < wholeObjects[i]->bgDepths.size(); j++)			if (wholeObjects[i]->bgDepths[j] == sliceEndingDepth)			{				MyAssert(wholeObjects[i]->bsplines.size() > 0);				boundary = wholeObjects[i]->bsplines[0];				break;			}		return boundary;}//Most of this function is virtually identical to DetermineSubregionColor().//They should be collapsed into a single function at some point, which would require some reorganization elsewhere.void Drawing::CalculateRequiredPredrawnSubregionsAndColor(vector<Subregion*>& subregions){	//For every subregion calculate the set of whole objects that contribute to it	for (int i = 0; i < subregions.size(); i++)	{		Subregion* subregion = subregions[i];	//еее				if (gDebug7)		{			ForeColor(blueColor);			subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			int qa = 1;		}				int deepestDepth = -1;		for (int j = 0; j < subregions[i]->sectionWODepths.size(); j++)			if (subregions[i]->sectionWODepths[j].second > deepestDepth)				deepestDepth = subregions[i]->sectionWODepths[j].second;				//Resize the vector and fill it with flags that will be used for MyAssertions later.		//The vector will be further expanded for deep layers that surround the region, but this is done later.		subregions[i]->layerSurfaceTraits.resize(deepestDepth + 1);		for (int j = 0; j < subregions[i]->layerSurfaceTraits.size(); j++)			subregions[i]->layerSurfaceTraits[j].first = NULL;				//Fill in the vector with the easy layers, those that directly bound the region		for (int j = 0; j < subregions[i]->sectionWODepths.size(); j++)		{			MyAssert(subregions[i]->layerSurfaceTraits[subregions[i]->sectionWODepths[j].second].first == NULL);			subregions[i]->layerSurfaceTraits[subregions[i]->sectionWODepths[j].second].first = subregions[i]->sectionWODepths[j].first;			subregions[i]->layerSurfaceTraits[subregions[i]->sectionWODepths[j].second].second = (subregions[i]->sectionWODepths[j].first->bsplines[0])->GetSurfaceTraits();		}				//Find a legal slice (one that starts within the region).		//Use the slice to find relevant surfaces that don't directly bound the region.		//if (FindLegalSlice(subregions[i]))		if (FindLegalSlice2(subregions[i]))		{			if (gDebug7)			{				ForeColor(cyanColor);								MoveTo(subregions[i]->sliceFromPoint.h, subregions[i]->sliceFromPoint.v);				LineTo(0, subregions[i]->sliceFromPoint.v);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qa = 1;			}						//Fill in the vector with the hard layers, those that do not directly bound the region			for (int j = 0; j < subregions[i]->layerSurfaceTraits.size(); j++)				if (subregions[i]->layerSurfaceTraits[j].first == NULL)	//Layer hasn't been found yet				{					//Slice outward (to the left arbitrarily) at the depth in question from a point known to be in the region										//Find the BSpline associated with the splice					BSpline* sliceBSpline = FindSliceBoundary(subregions[i], j, false, NULL);										//There are at least two approaches here.  One is to assume the drawing is properly vertically compacted.					//This means all layers should have a representative surface and sliceBSpline can be MyAsserted.					//The other is to let this slide, which means we simply skip over empty layers.					//Since I haven't properly implemented vertical compaction yet, we have to go with the second approach.										//MyAssert(sliceBSpline);										//Get the color of the BSpline					if (sliceBSpline)					{						WholeObject* wholeObject = NULL;						MyAssert(FindOrCreateWholeObjectForBSpline(sliceBSpline, wholeObject));						subregions[i]->layerSurfaceTraits[j].first = wholeObject;						subregions[i]->layerSurfaceTraits[j].second = sliceBSpline->GetSurfaceTraits();					}				}						//See note in the "hard layers" loop about this MyAssert			//for (int j = 0; j < subregions[i]->layerSurfaceTraits.size(); j++)			//	MyAssert(subregions[i]->[j].first != NULL);						//Add to the vector for deeper depths			int deepDepth = subregions[i]->layerSurfaceTraits.size();			while (true)			{				//Slice outward (to the left arbitrarily) at the depth in question from a point known to be in the region								//Find the BSpline associated with the splice				BSpline* sliceBSpline = NULL;				//if (subregions[i]->sectionBspDepths.size() > 0)				//	sliceBSpline = FindSliceBoundary(subregions[i], deepDepth, true, subregions[i]->sectionBspDepths[0].first);				//else sliceBSpline = FindSliceBoundary(subregions[i], deepDepth, false, NULL);				if (subregions[i]->sectionWODepths.size() > 0)					sliceBSpline = FindSliceBoundary(subregions[i], deepDepth, true, &subregions[i]->sectionWODepths);				else sliceBSpline = FindSliceBoundary(subregions[i], deepDepth, false, NULL);								if (!sliceBSpline)					break;								//Get the color of the BSpline				pair<WholeObject*, SurfaceTraits> oneLayerSurfaceTraits;				WholeObject* wholeObject = NULL;				MyAssert(FindOrCreateWholeObjectForBSpline(sliceBSpline, wholeObject));				oneLayerSurfaceTraits.first = wholeObject;				oneLayerSurfaceTraits.second = sliceBSpline->GetSurfaceTraits();				subregions[i]->layerSurfaceTraits.push_back(oneLayerSurfaceTraits);								deepDepth++;			}						subregions[i]->DeleteAllIntersections();		}				//еее DEBUG		for (int i = 0; i < intersections.size(); i++)			MyAssert(intersections[i]->GetType() != GenericIntersection::BSP_CUT || !((BspCutIntersection*)intersections[i])->GetCutIsSlice());				if (gDebug7)		{			ForeColor(whiteColor);			subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			ForeColor(blackColor);			subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);			int qa = 1;		}	}		//Now all subregions know all whole objects to contribute to themselves		//Find all subregions whose whole object requirements are subsets of the requirements of other subregions and create the appropriate relationships	for (int i = 0; i < subregions.size(); i++)	//Subregion that may require another subregion to be drawn first	{		Subregion* ssi = subregions[i];				if (gDebug7)		{			ForeColor(redColor);			subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			int qa = 1;		}				for (int j = 0; j < subregions.size(); j++)	//Subregion that may be required to be drawn before another subregion			if (i != j)	//Don't self-compare			{				Subregion* ssj = subregions[j];								if (gDebug7)				{					ForeColor(greenColor);					subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));					int qa = 1;				}								//If the first subregion is not a superset of the second subregion, then the second subregion cannot possibly be a subset of the first subregion				if (subregions[i]->layerSurfaceTraits.size() > subregions[j]->layerSurfaceTraits.size())				{					//For every whole object in the second subregion, see if it is in the first subregion.					//If not, then the second subregion is not a subset of the first subregion.					int k = 0;					for (k = 0; k < subregions[j]->layerSurfaceTraits.size(); k++)					{						//For every whole object in the first subregion, attempt to match it to the whole object in question from the second subregion						int m = 0;						for (m = 0; m < subregions[i]->layerSurfaceTraits.size(); m++)							if (subregions[j]->layerSurfaceTraits[k].first == subregions[i]->layerSurfaceTraits[m].first)								break;						if (m == subregions[i]->layerSurfaceTraits.size())							break;					}										//If all whole objects in the second subregion are in the first subregion, then the second subregion is a subset of the first subregion					if (k == subregions[j]->layerSurfaceTraits.size())					{						MyAssert(find(subregions[j]->requiredPredrawnSubregions.begin(), subregions[j]->requiredPredrawnSubregions.end(), subregions[i]) == subregions[j]->requiredPredrawnSubregions.end());						subregions[i]->requiredPredrawnSubregions.push_back(subregions[j]);					}				}								if (gDebug7)				{					ForeColor(whiteColor);					subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));					int qa = 1;				}			}					if (gDebug7)		{			ForeColor(whiteColor);			subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			int qa = 1;		}	}}bool Drawing::DetermineSubregionColor(Subregion* subregion, RGBColor& color){	//Make a sorted list of the colors paired with their reflectance, sorted by depth	vector<SurfaceTraits> layerSurfaceTraits;		//Find the deepest depth in the region	/*	int deepestDepth = -1;	for (int j = 0; j < subregion->sectionBspDepths.size(); j++)		if (subregion->sectionBspDepths[j].second > deepestDepth)			deepestDepth = subregion->sectionBspDepths[j].second;		//Resize the vector and fill it with flags that will be used for MyAssertions later.	//The vector will be further expanded for deep layers that surround the region, but this is done later.	layerSurfaceTraits.resize(deepestDepth + 1);	for (int j = 0; j < layerSurfaceTraits.size(); j++)		layerSurfaceTraits[j].interiorReflectance = -1;		//Fill in the vector with the easy layers, those that directly bound the region	for (int j = 0; j < subregion->sectionBspDepths.size(); j++)	{		MyAssert(layerSurfaceTraits[subregion->sectionBspDepths[j].second].interiorReflectance == -1);		layerSurfaceTraits[subregion->sectionBspDepths[j].second] = (subregion->sectionBspDepths[j].first)->GetSurfaceTraits();	}	*/	////////////////////////////////////	int deepestDepth = -1;	for (int j = 0; j < subregion->sectionWODepths.size(); j++)		if (subregion->sectionWODepths[j].second > deepestDepth)			deepestDepth = subregion->sectionWODepths[j].second;		//Resize the vector and fill it with flags that will be used for MyAssertions later.	//The vector will be further expanded for deep layers that surround the region, but this is done later.	layerSurfaceTraits.resize(deepestDepth + 1);	for (int j = 0; j < layerSurfaceTraits.size(); j++)		layerSurfaceTraits[j].interiorReflectance = -1;		//Fill in the vector with the easy layers, those that directly bound the region	for (int j = 0; j < subregion->sectionWODepths.size(); j++)	{		MyAssert(layerSurfaceTraits[subregion->sectionWODepths[j].second].interiorReflectance == -1);		layerSurfaceTraits[subregion->sectionWODepths[j].second] = (subregion->sectionWODepths[j].first->bsplines[0])->GetSurfaceTraits();	}		//Find a legal slice (one that starts within the region.	//Use the slice to find relevant surfaces that don't directly bound the region.	//if (FindLegalSlice(subregion))	if (FindLegalSlice2(subregion))	{		if (gDebug7)		{			ForeColor(cyanColor);						MoveTo(subregion->sliceFromPoint.h, subregion->sliceFromPoint.v);			LineTo(0, subregion->sliceFromPoint.v);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qa = 1;		}				//Fill in the vector with the hard layers, those that do not directly bound the region		for (int j = 0; j < layerSurfaceTraits.size(); j++)			if (layerSurfaceTraits[j].interiorReflectance == -1)	//Layer hasn't been found yet			{				//Slice outward (to the left arbitrarily) at the depth in question from a point known to be in the region								//Find the BSpline associated with the splice				BSpline* sliceBSpline = FindSliceBoundary(subregion, j, false, NULL);								//There are at least two approaches here.  One is to assume the drawing is properly vertically compacted.				//This means all layers should have a representative surface and sliceBSpline can be MyAsserted.				//The other is to let this slide, which means we simply skip over empty layers.				//Since I haven't properly implemented vertical compaction yet, we have to go with the second approach.								//MyAssert(sliceBSpline);								//Get the color of the BSpline				if (sliceBSpline)					layerSurfaceTraits[j] = sliceBSpline->GetSurfaceTraits();			}				//See note in the "hard layers" loop about this MyAssert		//for (int j = 0; j < layerSurfaceTraits.size(); j++)		//	MyAssert(layerSurfaceTraits[j].interiorReflectance != -1);				//Add to the vector for deeper depths		int deepDepth = layerSurfaceTraits.size();		while (true)		{			//Slice outward (to the left arbitrarily) at the depth in question from a point known to be in the region						//Find the BSpline associated with the splice			BSpline* sliceBSpline = NULL;			//if (subregion->sectionBspDepths.size() > 0)			//	sliceBSpline = FindSliceBoundary(subregion, deepDepth, true, subregion->sectionBspDepths[0].first);			//else sliceBSpline = FindSliceBoundary(subregion, deepDepth, false, NULL);			if (subregion->sectionWODepths.size() > 0)				sliceBSpline = FindSliceBoundary(subregion, deepDepth, true, &subregion->sectionWODepths);			else sliceBSpline = FindSliceBoundary(subregion, deepDepth, false, NULL);						if (!sliceBSpline)				break;						//Get the color of the BSpline			layerSurfaceTraits.push_back(sliceBSpline->GetSurfaceTraits());						deepDepth++;		}	}		//еее DEBUG	for (int i = 0; i < intersections.size(); i++)		MyAssert(intersections[i]->GetType() != GenericIntersection::BSP_CUT || !((BspCutIntersection*)intersections[i])->GetCutIsSlice());		if (layerSurfaceTraits.size() == 0)		return false;		//Calculate the contribution each layer makes to the final color and accumulate the final color	color.red = color.green = color.blue = 0;	double accumReflectance = 0;	//should sum to 1	for (int j = 0; j <= layerSurfaceTraits.size(); j++)	{		//See note in the "hard layers" loop about this		if (j < layerSurfaceTraits.size() && layerSurfaceTraits[j].interiorReflectance == -1)			continue;				double transmittanceAboveLayer = 1.0;		for (int k = 0; k < j; k++)			if (layerSurfaceTraits[k].interiorReflectance != -1)				transmittanceAboveLayer *= (1.0 - layerSurfaceTraits[k].interiorReflectance);				MyAssert(transmittanceAboveLayer >= 0 && transmittanceAboveLayer <= 1.0);				double transmittedReflectance;		if (j < layerSurfaceTraits.size())			transmittedReflectance = transmittanceAboveLayer * layerSurfaceTraits[j].interiorReflectance;		else transmittedReflectance = transmittanceAboveLayer;	//Background layer for the canvas				MyAssert(transmittedReflectance >= 0 && transmittedReflectance <= 1.0);				accumReflectance += transmittedReflectance;		MyAssert(accumReflectance <= 1.0);				if (j < layerSurfaceTraits.size())		{			int newVal = color.red + layerSurfaceTraits[j].interiorColor.red * transmittedReflectance;			MyAssert(newVal <= 65535);			color.red = newVal;						newVal = color.green + layerSurfaceTraits[j].interiorColor.green * transmittedReflectance;			MyAssert(newVal <= 65535);			color.green = newVal;						newVal = color.blue + layerSurfaceTraits[j].interiorColor.blue * transmittedReflectance;			MyAssert(newVal <= 65535);			color.blue = newVal;		}		else	//Background layer for the canvas		{			int newVal = color.red + (int)gColors.canvas.red * transmittedReflectance;			MyAssert(newVal <= 65535);			color.red = newVal;						newVal = color.green + (int)gColors.canvas.green * transmittedReflectance;			MyAssert(newVal <= 65535);			color.green = newVal;						newVal = color.blue + (int)gColors.canvas.blue * transmittedReflectance;			MyAssert(newVal <= 65535);			color.blue = newVal;		}	}	MyAssert(accumReflectance > .99 && accumReflectance <= 1.0);		return true;}//Returns true if the subregion has a color, false if it has not surface traits (no inwardly bounding surfaces)/*bool Drawing::DetermineSubregionColor2(Subregion* subregion, RGBColor& color){	if (subregion->layerSurfaceTraits.size() == 0)		return false;		//Calculate the contribution each layer makes to the final color and accumulate the final color	color.red = color.green = color.blue = 0;	double accumReflectance = 0;	//should sum to 1	for (int j = 0; j <= subregion->layerSurfaceTraits.size(); j++)	{		//See note in the "hard layers" loop about this		if (j < subregion->layerSurfaceTraits.size() && subregion->layerSurfaceTraits[j].second.interiorReflectance == -1)			continue;				double transmittanceAboveLayer = 1.0;		for (int k = 0; k < j; k++)			if (subregion->layerSurfaceTraits[k].second.interiorReflectance != -1)				transmittanceAboveLayer *= (1.0 - subregion->layerSurfaceTraits[k].second.interiorReflectance);				MyAssert(transmittanceAboveLayer >= 0 && transmittanceAboveLayer <= 1.0);				double transmittedReflectance;		if (j < subregion->layerSurfaceTraits.size())			transmittedReflectance = transmittanceAboveLayer * subregion->layerSurfaceTraits[j].second.interiorReflectance;		else transmittedReflectance = transmittanceAboveLayer;	//Background layer for the canvas				MyAssert(transmittedReflectance >= 0 && transmittedReflectance <= 1.0);				accumReflectance += transmittedReflectance;		MyAssert(accumReflectance <= 1.0);				if (j < subregion->layerSurfaceTraits.size())		{			int newVal = color.red + subregion->layerSurfaceTraits[j].second.interiorColor.red * transmittedReflectance;			MyAssert(newVal <= 65535);			color.red = newVal;						newVal = color.green + subregion->layerSurfaceTraits[j].second.interiorColor.green * transmittedReflectance;			MyAssert(newVal <= 65535);			color.green = newVal;						newVal = color.blue + subregion->layerSurfaceTraits[j].second.interiorColor.blue * transmittedReflectance;			MyAssert(newVal <= 65535);			color.blue = newVal;		}		else	//Background layer for the canvas		{			int newVal = color.red + (int)gColors.canvas.red * transmittedReflectance;			MyAssert(newVal <= 65535);			color.red = newVal;						newVal = color.green + (int)gColors.canvas.green * transmittedReflectance;			MyAssert(newVal <= 65535);			color.green = newVal;						newVal = color.blue + (int)gColors.canvas.blue * transmittedReflectance;			MyAssert(newVal <= 65535);			color.blue = newVal;		}	}	MyAssert(accumReflectance > .99 && accumReflectance <= 1.0);		return true;}*/void Drawing::DrawIntersections(MainWindow::ViewMode viewMode, Point scrollOffset, bool exportingPict){	FloatPoint fp;	Rect r;	for (vector<GenericIntersection*>::iterator i = intersections.begin(); i != intersections.end(); i++)	{		GenericIntersection* inter = *i;				//Round to the nearest pixel instead of merely rounding down		fp = inter->GetLocation();		if ((int)(fp.h * 10) % 10 >= 5)			fp.h++;		if ((int)(fp.v * 10) % 10 >= 5)			fp.v++;				if (fp.h < -99998)			fp.h = 0;				if (showCrossingStates && viewMode != MainWindow::SURFACE_MODE)		{			switch (inter->GetType())			{				case GenericIntersection::BSP_BSP:					BspBspIntersection* bspBspInter = (BspBspIntersection*)inter;										//Thick top segment					PenSize(3, 3);										BSpline* topBsp = bspBspInter->GetBsp1();					SurfaceTraits surfaceTraits = topBsp->GetSurfaceTraits();					RGBForeColor(&surfaceTraits.interiorColor);					int cv = bspBspInter->GetCv1();					int sg = bspBspInter->GetSg1();					vector<vector<FloatPoint>*>* curvePoints = topBsp->GetCurvePoints();					int cvsg = cv * BSpline::sNumSegmentsPerCurve + sg;					int totalCurvePoints = curvePoints->size() * BSpline::sNumSegmentsPerCurve;					int cvsgNext = (cvsg + 1) % totalCurvePoints;					int cvNext = cvsgNext / BSpline::sNumSegmentsPerCurve;					int sgNext = cvsgNext % BSpline::sNumSegmentsPerCurve;					MyAssert(cvNext < curvePoints->size() && sgNext < BSpline::sNumSegmentsPerCurve);					FloatPoint cvsgLoc = (*(*curvePoints)[cv])[sg];					FloatPoint cvsgNextLoc = (*(*curvePoints)[cvNext])[sgNext];					MoveTo(cvsgLoc.h - 1 + scrollOffset.h, cvsgLoc.v - 1 + scrollOffset.v);					LineTo(cvsgNextLoc.h - 1 + scrollOffset.h, cvsgNextLoc.v - 1 + scrollOffset.v);										//Extend the thick segment if it is too short					float cvSgLength = LineSegmentLength(cvsgLoc, cvsgNextLoc);					if (cvSgLength < 15)					{						float cvSgInterDist = LineSegmentLength(cvsgLoc, bspBspInter->GetLocation());						if (cvSgInterDist < cvSgLength / 2.0)	//Intersection is closer to curve segment start						{							int cvsgPrev = (cvsg + (totalCurvePoints - 1)) % totalCurvePoints;							int cvPrev = cvsgPrev / BSpline::sNumSegmentsPerCurve;							int sgPrev = cvsgPrev % BSpline::sNumSegmentsPerCurve;							MyAssert(cvPrev < curvePoints->size() && sgPrev < BSpline::sNumSegmentsPerCurve);							FloatPoint cvsgPrevLoc = (*(*curvePoints)[cvPrev])[sgPrev];							LineTo(cvsgPrevLoc.h - 1 + scrollOffset.h, cvsgPrevLoc.v - 1 + scrollOffset.v);							MoveTo(cvsgLoc.h - 1 + scrollOffset.h, cvsgLoc.v - 1 + scrollOffset.v);						}						else	//Intersection is closer to curve segment end						{							int cvsgNext2 = (cvsgNext + 1) % totalCurvePoints;							int cvNext2 = cvsgNext2 / BSpline::sNumSegmentsPerCurve;							int sgNext2 = cvsgNext2 % BSpline::sNumSegmentsPerCurve;							MyAssert(cvNext2 < curvePoints->size() && sgNext2 < BSpline::sNumSegmentsPerCurve);							FloatPoint cvsgLoc = (*(*curvePoints)[cv])[sg];							FloatPoint cvsgNext2Loc = (*(*curvePoints)[cvNext2])[sgNext2];							MoveTo(cvsgNextLoc.h - 1 + scrollOffset.h, cvsgNextLoc.v - 1 + scrollOffset.v);							LineTo(cvsgNext2Loc.h - 1 + scrollOffset.h, cvsgNext2Loc.v - 1 + scrollOffset.v);						}					}										PenSize(1, 1);										/*					//Invisible bottom segment					BSpline* botBsp = bspBspInter->GetBsp1();					RGBForeColor(&gColors.canvas);					int cv = bspBspInter->GetCv1();					int sg = bspBspInter->GetSg1();					vector<vector<FloatPoint>*>* curvePoints = botBsp->GetCurvePoints();					int cvsg = cv * BSpline::sNumSegmentsPerCurve + sg;					int cvsgNext = (cvsg + 1) % (curvePoints->size() * BSpline::sNumSegmentsPerCurve);					int cvNext = cvsgNext / BSpline::sNumSegmentsPerCurve;					int sgNext = cvsgNext % BSpline::sNumSegmentsPerCurve;					FloatPoint cvsgLoc = (*(*curvePoints)[cv])[sg];					FloatPoint cvsgNextLoc = (*(*curvePoints)[cvNext])[sgNext];					MoveTo(cvsgLoc.h, cvsgLoc.v);					LineTo(cvsgNextLoc.h, cvsgNextLoc.v);					*/					break;				case GenericIntersection::BSP_CUT:					BspCutIntersection* bspCutInter = (BspCutIntersection*)inter;					break;				case GenericIntersection::BSP_CUT_T:					BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)inter;					break;				case GenericIntersection::CUT_CUT:					CutCutIntersection* cutCutInter = (CutCutIntersection*)inter;					break;			}		}				SetRect(&r, (int)fp.h - (gPointRadius + 1), (int)fp.v - (gPointRadius + 1),					(int)fp.h + (gPointRadius + 1), (int)fp.v + (gPointRadius + 1));		OffsetRect(&r, scrollOffset.h, scrollOffset.v);				if (viewMode == MainWindow::SPLINE_MODE)		{			RGBForeColor(&gColors.intersection);						PaintOval(&r);		}		else if (viewMode == MainWindow::KNOT_MODE)		{			if (showCompSets)			{				int companionSetIndex = 0;				bool foundIt = false;				/*				for (companionSetIndex = 0; companionSetIndex < interCompanionPairSets.size(); companionSetIndex++)	//Loop through the sets				{					for (int pairIndex = 0; pairIndex < interCompanionPairSets[companionSetIndex]->size(); pairIndex++)	//Loop through the pairs of one set						if ((*interCompanionPairSets[companionSetIndex])[pairIndex].first == inter || (*interCompanionPairSets[companionSetIndex])[pairIndex].second == inter)						{							foundIt = true;							break;						}					if (foundIt)						break;				}				*/				for (companionSetIndex = 0; companionSetIndex < interCompanionSets.size(); companionSetIndex++)	//Loop through the sets					if (find(interCompanionSets[companionSetIndex]->begin(), interCompanionSets[companionSetIndex]->end(), inter) != interCompanionSets[companionSetIndex]->end())					{						foundIt = true;						break;					}								if (foundIt)				{					switch (companionSetIndex % 6)					{						case 0:	ForeColor(redColor);	break;						case 1:	ForeColor(greenColor);	break;						case 2:	ForeColor(blueColor);	break;						case 3:	ForeColor(magentaColor);	break;						case 4:	ForeColor(cyanColor);	break;						case 5:	ForeColor(blackColor);	break;					}										PaintOval(&r);				}			}		}				if (inter->GetPermanentHardConstraint())		{			if (!exportingPict)			{				r.left -= 4;				r.right += 4;				r.top -= 4;				r.bottom += 4;								ForeColor(redColor);				PenSize(2, 2);				FrameOval(&r);				PenSize(1, 1);			}			else			{				r.left -= 8;				r.right += 8;				r.top -= 8;				r.bottom += 8;								ForeColor(blackColor);				PenSize(3, 3);				FrameOval(&r);				PenSize(1, 1);			}		}				//еее		if (find(brandNewIntersections.begin(), brandNewIntersections.end(), inter) != brandNewIntersections.end())		{			r.left -= 4;			r.right += 4;			r.top -= 4;			r.bottom += 4;						ForeColor(greenColor);			PenSize(2, 2);			FrameOval(&r);			PenSize(1, 1);		}	}		//DrawIntersectionInfo(scrollOffset);}void Drawing::DrawIntersectionInfo(Point scrollOffset){	FloatPoint fp;		Str255 str;			TextSize(12);	TextFace(bold);			for (vector<GenericIntersection*>::iterator i = intersections.begin(); i != intersections.end(); i++)	{		fp = (*i)->GetLocation();				int obj1, obj2;		int idx1, idx2;		switch ((*i)->GetType())		{			case GenericIntersection::BSP_BSP:				BspBspIntersection* bspBspInter = (BspBspIntersection*)(*i);								obj1 = bspBspInter->GetBsp1Index();				obj2 = bspBspInter->GetBsp2Index();								if (!bspBspInter->SelfIntersection())				{					idx1 = bspBspInter->GetBsp1()->GetIntersectionIndex(bspBspInter);					idx2 = bspBspInter->GetBsp2()->GetIntersectionIndex(bspBspInter);				}				else if (bspBspInter->GetCv1() < bspBspInter->GetCv2() ||					(bspBspInter->GetCv1() == bspBspInter->GetCv2() && bspBspInter->GetSg1() < bspBspInter->GetSg2()))				{					idx1 = bspBspInter->GetBsp1()->GetIntersectionIndex(bspBspInter);					idx2 = bspBspInter->GetBsp2()->GetIntersectionIndex(bspBspInter, false);				}				else				{					idx1 = bspBspInter->GetBsp1()->GetIntersectionIndex(bspBspInter, false);					idx2 = bspBspInter->GetBsp2()->GetIntersectionIndex(bspBspInter);				}				break;			case GenericIntersection::BSP_CUT:				BspCutIntersection* bspCutInter = (BspCutIntersection*)(*i);								obj1 = bspCutInter->GetBspIndex();				obj2 = bspCutInter->GetCutIndex();								idx1 = bspCutInter->GetBsp()->GetIntersectionIndex(bspCutInter);				idx2 = bspCutInter->GetCut()->GetIntersectionIndex(bspCutInter);				break;			case GenericIntersection::BSP_CUT_T:				BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)(*i);								obj1 = bspCutTInter->GetBspIndex();				obj2 = bspCutTInter->GetCutIndex();								idx1 = bspCutTInter->GetBsp()->GetIntersectionIndex(bspCutTInter);				idx2 = bspCutTInter->GetCut()->GetIntersectionIndex(bspCutTInter);				break;			case GenericIntersection::CUT_CUT:				CutCutIntersection* cutCutInter = (CutCutIntersection*)(*i);								obj1 = cutCutInter->GetCut1Index();				obj2 = cutCutInter->GetCut2Index();								idx1 = cutCutInter->GetCut1()->GetIntersectionIndex(cutCutInter);				idx2 = cutCutInter->GetCut2()->GetIntersectionIndex(cutCutInter);				break;		}				switch(obj1 % 6)		{			case 0:	ForeColor(redColor);	break;			case 1:	ForeColor(greenColor);	break;			case 2:	ForeColor(blueColor);	break;			case 3:	ForeColor(magentaColor);	break;			case 4:	ForeColor(cyanColor);	break;			case 5:	ForeColor(blackColor);	break;		}				NumToString(idx1, str);		MoveTo(fp.h - StringWidth(str) / 2 + scrollOffset.h, fp.v - 6 + scrollOffset.v);		DrawString(str);				switch(obj2 % 6)		{			case 0:	ForeColor(redColor);	break;			case 1:	ForeColor(greenColor);	break;			case 2:	ForeColor(blueColor);	break;			case 3:	ForeColor(magentaColor);	break;			case 4:	ForeColor(cyanColor);	break;			case 5:	ForeColor(blackColor);	break;		}				NumToString(idx2, str);		MoveTo(fp.h - StringWidth(str) / 2 + scrollOffset.h, fp.v + 17 + scrollOffset.v);		DrawString(str);	}		TextFace(0);	TextSize(9);}void Drawing::FlashIntersections(vector<GenericIntersection*> flashInters){	SysBeep(1);		for (int i = 0; i < flashInters.size(); i++)		MyAssert(flashInters[i]->GetType() == GenericIntersection::BSP_BSP || flashInters[i]->GetType() == GenericIntersection::BSP_CUT);		int numFlashes = 3;	clock_t flashTimeSecs = .25;		Point scrollOffset = gMainWindow->CalcScrollOffset();	//If would be more efficient to retrieve the scroll offset without recalcing it, but for now...		SetPort(GetWindowPort(gMainWindow->GetWindow()));	PenSize(3, 3);	for (int flashCount = 0; flashCount < numFlashes; flashCount++)	{		Rect r;		FloatPoint intersectionLoc;				//RGBForeColor(&gColors.intersection);		ForeColor(redColor);		for (int i = 0; i < flashInters.size(); i++)		{			intersectionLoc = flashInters[i]->GetLocation();			if ((int)(intersectionLoc.h * 10) % 10 >= 5)				intersectionLoc.h++;			if ((int)(intersectionLoc.v * 10) % 10 >= 5)				intersectionLoc.v++;			int radius = (flashInters[i]->GetType() == GenericIntersection::BSP_BSP) ? 12 : 6;			SetRect(&r, max(intersectionLoc.h, 0.0) - radius, intersectionLoc.v - radius, max(intersectionLoc.h, 0.0) + radius, intersectionLoc.v + radius);			OffsetRect(&r, scrollOffset.h, scrollOffset.v);			FrameOval(&r);		}		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				clock_t startTime = clock();		while ((clock() - startTime) / CLOCKS_PER_SEC < flashTimeSecs);				RGBForeColor(&gColors.canvas);		for (int i = 0; i < flashInters.size(); i++)		{			intersectionLoc = flashInters[i]->GetLocation();			if ((int)(intersectionLoc.h * 10) % 10 >= 5)				intersectionLoc.h++;			if ((int)(intersectionLoc.v * 10) % 10 >= 5)				intersectionLoc.v++;			int radius = (flashInters[i]->GetType() == GenericIntersection::BSP_BSP) ? 12 : 6;			SetRect(&r, max(intersectionLoc.h, 0.0) - radius, intersectionLoc.v - radius, max(intersectionLoc.h, 0.0) + radius, intersectionLoc.v + radius);			OffsetRect(&r, scrollOffset.h, scrollOffset.v);			FrameOval(&r);		}		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				startTime = clock();		while ((clock() - startTime) / CLOCKS_PER_SEC < flashTimeSecs / 2);	}	PenSize(1, 1);}void Drawing::HilightIntersection(GenericIntersection* intersection, Point scrollOffset, MainWindow::ViewMode viewMode){	RGBForeColor(&gColors.intersection);	int compSetIndex = -1;	bool foundIt = false;	/*	vector<GenericIntersection*> toDrawInters;	toDrawInters.push_back(intersection);		//Find the companion set for the intersection	for (compSetIndex = 0; compSetIndex < interCompanionPairSets.size(); compSetIndex++)	{		for (int i = 0; i < interCompanionPairSets[compSetIndex]->size(); i++)			if ((*interCompanionPairSets[compSetIndex])[i].first == intersection || (*interCompanionPairSets[compSetIndex])[i].second == intersection)			{				foundIt = true;				break;			}		if (foundIt)			break;	}	//Find the minimal set of unique intersections in the companion set (intersections can be present in the set either once or twice)	if (foundIt)		for (int i = 0; i < interCompanionPairSets[compSetIndex]->size(); i++)		{			if (find(toDrawInters.begin(), toDrawInters.end(), (*interCompanionPairSets[compSetIndex])[i].first) == toDrawInters.end())				toDrawInters.push_back((*interCompanionPairSets[compSetIndex])[i].first);			if (find(toDrawInters.begin(), toDrawInters.end(), (*interCompanionPairSets[compSetIndex])[i].second) == toDrawInters.end())				toDrawInters.push_back((*interCompanionPairSets[compSetIndex])[i].second);		}		//Draw the intersections	for (int i = 0; i < toDrawInters.size(); i++)	{		FloatPoint interLoc = toDrawInters[i]->GetLocation();		if ((int)(interLoc.h * 10) % 10 >= 5)			interLoc.h++;		if ((int)(interLoc.v * 10) % 10 >= 5)			interLoc.v++;		Rect r;		SetRect(&r, interLoc.h - 9, interLoc.v - 9, interLoc.h + 8, interLoc.v + 8);		OffsetRect(&r, scrollOffset.h, scrollOffset.v);		PenSize(3, 3);		FrameOval(&r);		PenSize(1, 1);	}	*/	//Find the companion set for the intersection	for (compSetIndex = 0; compSetIndex < interCompanionSets.size(); compSetIndex++)	//Loop through the sets		if (find(interCompanionSets[compSetIndex]->begin(), interCompanionSets[compSetIndex]->end(), intersection) != interCompanionSets[compSetIndex]->end())		{			foundIt = true;			break;		}		//Draw the intersections	if (foundIt)	{		MyAssert(compSetIndex < interCompanionSets.size());		int numComps = interCompanionSets[compSetIndex]->size();	//debug		Rect r;		for (int i = 0; i < interCompanionSets[compSetIndex]->size(); i++)		{			MyAssert((*interCompanionSets[compSetIndex])[i]->GetType() == GenericIntersection::BSP_BSP || (*interCompanionSets[compSetIndex])[i]->GetType() == GenericIntersection::BSP_CUT);							FloatPoint interLoc = (*interCompanionSets[compSetIndex])[i]->GetLocation();			if ((int)(interLoc.h * 10) % 10 >= 5)				interLoc.h++;			if ((int)(interLoc.v * 10) % 10 >= 5)				interLoc.v++;						int radius = ((*interCompanionSets[compSetIndex])[i]->GetType() == GenericIntersection::BSP_BSP) ? 9 : 6;			SetRect(&r, max(interLoc.h, 0.0) - radius, interLoc.v - radius, max(interLoc.h, 0.0) + radius, interLoc.v + radius);						OffsetRect(&r, scrollOffset.h, scrollOffset.v);			PenSize(3, 3);			FrameOval(&r);			PenSize(1, 1);		}	}	else	{		FloatPoint interLoc = intersection->GetLocation();		if ((int)(interLoc.h * 10) % 10 >= 5)			interLoc.h++;		if ((int)(interLoc.v * 10) % 10 >= 5)			interLoc.v++;		Rect r;		SetRect(&r, interLoc.h - 9, interLoc.v - 9, interLoc.h + 8, interLoc.v + 8);		OffsetRect(&r, scrollOffset.h, scrollOffset.v);		PenSize(3, 3);		FrameOval(&r);		PenSize(1, 1);	}}void Drawing::HilightOverlappingSubsurface(GenericIntersection* intersection, Point scrollOffset, MainWindow::ViewMode viewMode){	//еееееееееееееееееееееееееееееееее	//There is MAJOR serious bug in this algorithm.  This algorithm finds companion overlapping subsurface corners by traversing a bspline.	//It should be traversing the surface however, turning in and out of cuts.  Surface boundary traversal has been	//implemented elsewhere in Druid and needs to be adapted to this algorithm.  As of 060309, this bug has not been fixed yet.	//This same bug is present in FindInterCompSetsForInters().	//еееееееееееееееееееееееееееееееее		int compSetIndex = -1;	bool foundIt = false;		//Find the companion set for the intersection	for (compSetIndex = 0; compSetIndex < interCompanionSets.size(); compSetIndex++)	//Loop through the sets		if (find(interCompanionSets[compSetIndex]->begin(), interCompanionSets[compSetIndex]->end(), intersection) != interCompanionSets[compSetIndex]->end())		{			foundIt = true;			break;		}	if (!foundIt)		return;	MyAssert(compSetIndex < interCompanionSets.size());		//Every point along the boundary will be collected into a list of points	vector<FloatPoint> osPoints;		//Find a member of the companion set from which to start the overlapping subsurface boundary traversal.	//Try to avoid starting from a BspBsp inter	/*	int firstInterIndex = -1;	bool keepGoing = false;	do	{		firstInterIndex++;		keepGoing = false;				if (firstInterIndex < interCompanionSets[compSetIndex]->size() && (*interCompanionSets[compSetIndex])[firstInterIndex]->SelfIntersection())		{			MyAssert((*interCompanionSets[compSetIndex])[firstInterIndex]->GetType() == GenericIntersection::BSP_BSP);			BspBspIntersection* bspBspInter = (BspBspIntersection*)(*interCompanionSets[compSetIndex])[firstInterIndex];						BSpline* bsp1a = bspBspInter->GetBsp1();			BSpline* bsp2a = bspBspInter->GetBsp2();			int cv1a = bspBspInter->GetCv1();			int cv2a = bspBspInter->GetCv2();			int sg1a = bspBspInter->GetSg1();			int sg2a = bspBspInter->GetSg2();						GenericIntersection* prev1 = bsp1a->FindPrevIntersection(bspBspInter, cv1a, sg1a);			GenericIntersection* next1 = bsp1a->FindNextIntersection(bspBspInter, cv1a, sg1a);			GenericIntersection* prev2 = bsp1a->FindPrevIntersection(bspBspInter, cv2a, sg2a);			GenericIntersection* next2 = bsp1a->FindNextIntersection(bspBspInter, cv2a, sg2a);						if (prev1 == bspBspInter || next1 == bspBspInter || prev2 == bspBspInter || next2 == bspBspInter)				keepGoing = true;		}	}	while (keepGoing);	*/	int firstInterIndex = 0;	while (firstInterIndex < (*interCompanionSets[compSetIndex]).size() &&		(*interCompanionSets[compSetIndex])[firstInterIndex]->GetType() != GenericIntersection::BSP_BSP)		firstInterIndex++;	if (firstInterIndex == (*interCompanionSets[compSetIndex]).size())		return;	//Probably a BspCut inter		//Keep track of which intersections have been visited during the boundary traversal	BspBspIntersection* startInter = (BspBspIntersection*)(*interCompanionSets[compSetIndex])[firstInterIndex];	vector<GenericIntersection*> intersVisited;	intersVisited.push_back(startInter);		if (gDebug)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);				Rect r;		FloatPoint loc = startInter->GetLocation();		SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);		PenSize(2, 2);		ForeColor(redColor);		FrameOval(&r);		PenSize(1, 1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		int qC = 1;	}		//If the starting inter is a self inter, initialize the prev inter in the traversal	GenericIntersection* lastInter = NULL;	if (startInter->SelfIntersection())	{		MyAssert(startInter->GetType() == GenericIntersection::BSP_BSP);				BSpline* bsp1b = startInter->GetBsp1();		BSpline* bsp2b = startInter->GetBsp2();		int cv1b = startInter->GetCv1();		int cv2b = startInter->GetCv2();		int sg1b = startInter->GetSg1();		int sg2b = startInter->GetSg2();		int occludedEdgeb = startInter->DetermineOccludedEdge();		MyAssert(occludedEdgeb == 3 || occludedEdgeb == 4);		/*		if (occludedEdgeb == 3)			lastInter = bsp2a->FindPrevIntersection(startInter, cv2a, sg2a);		else lastInter = bsp1a->FindPrevIntersection(startInter, cv1a, sg1a);		*/		if (occludedEdgeb == 3)			lastInter = bsp1b->FindPrevIntersection(startInter, cv1b, sg1b);		else lastInter = bsp2b->FindPrevIntersection(startInter, cv2b, sg2b);				//intersVisited.pop_back();		//intersVisited.push_back(lastInter);				if (gDebug)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));			Rect r;			FloatPoint loc = lastInter->GetLocation();			SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);			PenSize(2, 2);			ForeColor(magentaColor);			FrameOval(&r);			PenSize(1, 1);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			int qC = 1;		}	}		//Traverse the boundary	BSpline* lastTraversalBsp = NULL;	int leg = 0;	while (intersVisited.size() <= interCompanionSets[compSetIndex]->size())	{		vector<FloatPoint> intermediatePoints;					if (intersVisited.back()->GetType() == GenericIntersection::BSP_BSP)		{			BspBspIntersection* thisInter = (BspBspIntersection*)intersVisited.back();						BSpline* bsp1 = thisInter->GetBsp1();			BSpline* bsp2 = thisInter->GetBsp2();			int cv1 = thisInter->GetCv1();			int cv2 = thisInter->GetCv2();			int sg1 = thisInter->GetSg1();			int sg2 = thisInter->GetSg2();			int occludedEdge = thisInter->DetermineOccludedEdge();			MyAssert(occludedEdge == 3 || occludedEdge == 4);						if (occludedEdge == 3)	//Potentially occluded segments are 2 and 3			{				GenericIntersection* nextInter1 = thisInter;				int numTries = 0;				do	//Loop until the next companion is found				{					switch (nextInter1->GetType())					{						case GenericIntersection::BSP_BSP:							BspBspIntersection* nextBspBspInter1 = ((BspBspIntersection*)nextInter1);							if (!nextBspBspInter1->SelfIntersection())							{								if (nextBspBspInter1->GetBsp1() == bsp1)								{									cv1 = nextBspBspInter1->GetCv1();									sg1 = nextBspBspInter1->GetSg1();								}								else								{									cv1 = nextBspBspInter1->GetCv2();									sg1 = nextBspBspInter1->GetSg2();								}							}							else	//Self intersection							{								MyAssert(nextBspBspInter1->GetBsp1() == bsp1);								MyAssert(nextBspBspInter1->GetBsp1() == nextBspBspInter1->GetBsp2());																int nextCv1 = nextBspBspInter1->GetCv1();								int nextSg1 = nextBspBspInter1->GetSg1();								int nextCv2 = nextBspBspInter1->GetCv2();								int nextSg2 = nextBspBspInter1->GetSg2();																GenericIntersection* prev1 = bsp1->FindPrevIntersection(nextBspBspInter1, nextCv1, nextSg1);								GenericIntersection* next1 = bsp1->FindNextIntersection(nextBspBspInter1, nextCv1, nextSg1);								GenericIntersection* prev2 = bsp1->FindPrevIntersection(nextBspBspInter1, nextCv2, nextSg2);								GenericIntersection* next2 = bsp1->FindNextIntersection(nextBspBspInter1, nextCv2, nextSg2);								//MyAssert(next1 != lastInter && next2 != lastInter);	//Not sure if this is true								MyAssert(prev1 == lastInter || prev2 == lastInter);								if (numTries != 0)	//Traversing between corners (between members of the companion set)								{									if (prev1 == lastInter)									{										cv1 = nextCv1;										sg1 = nextSg1;									}									else									{										cv1 = nextCv2;										sg1 = nextSg2;									}								}								else	//Turning a corner								{									cv1 = nextCv1;									sg1 = nextSg1;								}							}							break;						case GenericIntersection::BSP_CUT:							cv1 = ((BspCutIntersection*)nextInter1)->GetCv();							sg1 = ((BspCutIntersection*)nextInter1)->GetSg();							break;						case GenericIntersection::BSP_CUT_T:							cv1 = ((BspCutTIntersection*)nextInter1)->GetCv();							sg1 = ((BspCutTIntersection*)nextInter1)->GetSg();							break;						default:							MyAssert(false);							break;					}										lastInter = nextInter1;					nextInter1 = bsp1->FindNextIntersection(nextInter1, cv1, sg1);										if (gDebug)					{						SetPort(GetWindowPort(gMainWindow->GetWindow()));						Rect r;						FloatPoint loc = nextInter1->GetLocation();						SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);						PenSize(2, 2);						ForeColor(greenColor);						FrameOval(&r);						PenSize(1, 1);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qC = 1;					}				} while (numTries++ < bsp1->GetNumIntersections() && find(interCompanionSets[compSetIndex]->begin(), interCompanionSets[compSetIndex]->end(), nextInter1) == interCompanionSets[compSetIndex]->end());				MyAssert(numTries < bsp1->GetNumIntersections());								bsp1->GetSectionPoints(thisInter, nextInter1, true, true, true, 1, intermediatePoints);				intersVisited.push_back(nextInter1);			}			else	//occludedEdge == 4, so potentially occluded segments are 1 and 4			{				GenericIntersection* nextInter2 = thisInter;				int numTries = 0;				do	//Loop until the next companion is found				{					switch (nextInter2->GetType())					{						case GenericIntersection::BSP_BSP:							BspBspIntersection* nextBspBspInter2 = ((BspBspIntersection*)nextInter2);							if (!nextBspBspInter2->SelfIntersection())							{								if (nextBspBspInter2->GetBsp2() == bsp2)								{									cv2 = nextBspBspInter2->GetCv2();									sg2 = nextBspBspInter2->GetSg2();								}								else								{									cv2 = nextBspBspInter2->GetCv1();									sg2 = nextBspBspInter2->GetSg1();								}							}							else	//Self intersection							{								MyAssert(nextBspBspInter2->GetBsp1() == bsp2);								MyAssert(nextBspBspInter2->GetBsp1() == nextBspBspInter2->GetBsp2());																int nextCv1b = nextBspBspInter2->GetCv1();								int nextSg1b = nextBspBspInter2->GetSg1();								int nextCv2b = nextBspBspInter2->GetCv2();								int nextSg2b = nextBspBspInter2->GetSg2();																GenericIntersection* prev1b = bsp2->FindPrevIntersection(nextBspBspInter2, nextCv1b, nextSg1b);								GenericIntersection* next1b = bsp2->FindNextIntersection(nextBspBspInter2, nextCv1b, nextSg1b);								GenericIntersection* prev2b = bsp2->FindPrevIntersection(nextBspBspInter2, nextCv2b, nextSg2b);								GenericIntersection* next2b = bsp2->FindNextIntersection(nextBspBspInter2, nextCv2b, nextSg2b);								//MyAssert(next1b != lastInter && next2b != lastInter);	//Not sure if this is true								MyAssert(prev1b == lastInter || prev2b == lastInter);								if (numTries != 0)	//Traversing between corners (between members of the companion set)								{									if (prev1b == lastInter)									{										cv2 = nextCv1b;										sg2 = nextSg1b;									}									else									{										cv2 = nextCv2b;										sg2 = nextSg2b;									}								}								else	//Turning a corner								{									cv2 = nextCv2b;									sg2 = nextSg2b;								}							}							break;						case GenericIntersection::BSP_CUT:							cv2 = ((BspCutIntersection*)nextInter2)->GetCv();							sg2 = ((BspCutIntersection*)nextInter2)->GetSg();							break;						case GenericIntersection::BSP_CUT_T:							cv2 = ((BspCutTIntersection*)nextInter2)->GetCv();							sg2 = ((BspCutTIntersection*)nextInter2)->GetSg();							break;						default:							MyAssert(false);							break;					}										lastInter = nextInter2;					nextInter2 = bsp2->FindNextIntersection(nextInter2, cv2, sg2);										if (gDebug)					{						SetPort(GetWindowPort(gMainWindow->GetWindow()));						Rect r;						FloatPoint loc = nextInter2->GetLocation();						SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);						PenSize(2, 2);						ForeColor(cyanColor);						FrameOval(&r);						PenSize(1, 1);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qC = 1;					}				} while (numTries++ < bsp2->GetNumIntersections() && find(interCompanionSets[compSetIndex]->begin(), interCompanionSets[compSetIndex]->end(), nextInter2) == interCompanionSets[compSetIndex]->end());				MyAssert(numTries < bsp2->GetNumIntersections());								bsp2->GetSectionPoints(thisInter, nextInter2, false, false, true, 1, intermediatePoints);				intersVisited.push_back(nextInter2);			}		}		else		{			MyAssert(intersVisited.back()->GetType() == GenericIntersection::BSP_CUT);			BspCutIntersection* thisInter = (BspCutIntersection*)intersVisited.back();						BSpline* bsp = thisInter->GetBsp();			int cv = thisInter->GetCv();			int sg = thisInter->GetSg();						GenericIntersection* nextInter = thisInter;			int numTries = 0;			do			{				lastInter = nextInter;				nextInter = bsp->FindNextIntersection(nextInter, cv, sg);			} while (numTries++ < bsp->GetNumIntersections() && find(interCompanionSets[compSetIndex]->begin(), interCompanionSets[compSetIndex]->end(), nextInter) == interCompanionSets[compSetIndex]->end());			MyAssert(numTries < bsp->GetNumIntersections());						bsp->GetSectionPoints(thisInter, nextInter, true, true, true, 1, intermediatePoints);			intersVisited.push_back(nextInter);		}				for (int i = 0; i < intermediatePoints.size(); i++)		{			osPoints.push_back(FloatPoint(intermediatePoints[i].h, intermediatePoints[i].v));						if (gDebug && i > 0)			{				PenSize(3, 3);								switch (leg % 7)				{					case 0:	ForeColor(redColor);	break;					case 1:	ForeColor(greenColor);	break;					case 2:	ForeColor(blueColor);	break;					case 3:	ForeColor(yellowColor);	break;					case 4:	ForeColor(magentaColor);	break;					case 5:	ForeColor(cyanColor);	break;					case 6:	ForeColor(blackColor);	break;				}				MoveTo(intermediatePoints[i - 1].h + scrollOffset.h, intermediatePoints[i - 1].v + scrollOffset.v);				LineTo(intermediatePoints[i].h + scrollOffset.h, intermediatePoints[i].v + scrollOffset.v);								PenSize(1, 1);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qC = 1;			}		}				leg++;	}		//Set a color for shading the overlapping subsurface	HSVColor h1, h2;	RGB2HSV(&gColors.canvas, &h1);	h2.hue = h1.hue;	h2.saturation = (h1.saturation > 32768) ? max(((int)h1.saturation - 10000), 0) : min(((int)h1.saturation + 10000), 65535);	h2.value = (h1.value > 32768) ? max(((int)h1.value - 10000), 0) : min(((int)h1.value + 10000), 65535);	RGBColor c;	HSV2RGB(&h2, &c);	RGBForeColor(&c);		//Paint the polygon	PolyHandle poly = OpenPoly();	MoveTo(osPoints[0].h, osPoints[0].v);	for (int i = 1; i < osPoints.size(); i++)		LineTo(osPoints[i].h, osPoints[i].v);	ClosePoly();	OffsetPoly(poly, scrollOffset.h, scrollOffset.v);	if (viewMode == MainWindow::SPLINE_MODE || viewMode == MainWindow::KNOT_MODE)	{		//Pattern pat;		//PenPat(GetQDGlobalsLightGray(&pat));		PaintPoly(poly);		//PenPat(GetQDGlobalsBlack(&pat));	}	else	//surface mode	{		PenSize(2, 2);		//FramePoly(poly);		PenSize(1, 1);	}	KillPoly(poly);		if (gDebug)	{		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		int qC = 1;	}}void Drawing::DrawPostscriptDrawing(short fRefNum, MainWindow::ViewMode viewMode, Point canvasSize){	MyAssert(viewMode != MainWindow::SPLINE_MODE);		if (viewMode == MainWindow::SPLINE_MODE || viewMode == MainWindow::KNOT_MODE)	{		/*string st;		st += "/Times-Roman findfont\n";		st += "12 scalefont\n";		st += "setfont\n";		long strLen = st.length();		OSErr err = FSWrite(fRefNum, &strLen, st.c_str());		*/		for (vector<BSpline*>::iterator i = bsplines.begin(); i != bsplines.end(); i++)			(*i)->DrawPostscriptBSpline(fRefNum, viewMode, canvasSize, showDepths);				if (showCuts)			for (vector<BSplineToBSplineCut*>::iterator i = bsplinePairCuts.begin(); i != bsplinePairCuts.end(); i++)			{				//Find the whole object for the Cut				int wholeObjectIndex = -1;				for (int j = 0; j < wholeObjects.size(); j++)					if (find(wholeObjects[j]->bsplines.begin(), wholeObjects[j]->bsplines.end(), (*i)->GetBsp1()) != wholeObjects[j]->bsplines.end())					{						wholeObjectIndex = j;						break;					}								//Find the color for the whole object				SurfaceTraits surfaceTraits;				bool foundIt = false;				if (wholeObjectIndex != -1)				{					for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)						if (wholeObjects[wholeObjectIndex]->bsplines[j]->GetWindingNumber() > 0)						{							surfaceTraits = wholeObjects[wholeObjectIndex]->bsplines[j]->GetSurfaceTraits();							foundIt = true;							break;						}					if (!foundIt)					{						for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)							if (wholeObjects[wholeObjectIndex]->bsplines[j]->GetWindingNumber() == 0)							{								surfaceTraits = wholeObjects[wholeObjectIndex]->bsplines[j]->GetSurfaceTraits();								foundIt = true;								break;							}					}					if (!foundIt)					{						for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)							if (wholeObjects[wholeObjectIndex]->bsplines[j]->GetWindingNumber() < 0)							{								surfaceTraits = wholeObjects[wholeObjectIndex]->bsplines[j]->GetSurfaceTraits();								foundIt = true;								break;							}					}					MyAssert(foundIt);				}				else				{					surfaceTraits.interiorColor.red = surfaceTraits.interiorColor.green = surfaceTraits.interiorColor.blue = 0;	//0 is reserved as a "flag" for an illegal boundary					surfaceTraits.interiorReflectance = 1.0;					surfaceTraits.borderColor.red = surfaceTraits.interiorColor.red;					surfaceTraits.borderColor.green = surfaceTraits.interiorColor.green;					surfaceTraits.borderColor.blue = surfaceTraits.interiorColor.blue;					surfaceTraits.borderReflectance = surfaceTraits.interiorReflectance;					surfaceTraits.borderThickness = 1.0;				}								(*i)->DrawPostscriptCut(fRefNum, surfaceTraits.interiorColor, viewMode, canvasSize, showDepths);			}	}	else if (viewMode == MainWindow::SURFACE_MODE)	{		string st;		//st += "0.001 setlinewidth\n";		long strLen;// = st.length();		OSErr err;// = FSWrite(fRefNum, &strLen, st.c_str());				vector<Subregion*> subregions;		CollectAllSubregions(subregions, NULL, canvasSize, true);				CalculateRequiredPredrawnSubregionsAndColor(subregions);				//Draw each surface		for (int i = 0; i < subregions.size(); i++)		{			RGBColor subregionColor;			if (!DetermineSubregionColor(subregions[i], subregionColor))				continue;						FloatPoint prevPoint = subregions[i]->points[0];						ostringstream oss;			oss << (double)prevPoint.h / canvasSize.h;			oss << " ";			oss << (double)(canvasSize.v - prevPoint.v) / canvasSize.v;			oss << " moveto\n";						for (int j = 1; j <= subregions[i]->points.size(); j++)			{				FloatPoint thisPoint = subregions[i]->points[j % subregions[i]->points.size()];								oss << (double)thisPoint.h / canvasSize.h;				oss << " ";				oss << (double)(canvasSize.v - thisPoint.v) / canvasSize.v;				oss << " lineto\n";								prevPoint = thisPoint;			}						oss << "closepath\n";						oss << ((double)subregionColor.red / 65535.0);			oss << " ";			oss << ((double)subregionColor.green / 65535.0);			oss << " ";			oss << ((double)subregionColor.blue / 65535.0);						oss << " setrgbcolor\n";						oss << "fill\n";						st = oss.str();			strLen = st.length();			err = FSWrite(fRefNum, &strLen, st.c_str());		}				//Destroy the subregions		for (int i = 0; i < subregions.size(); i++)			delete subregions[i];				//Hilight the depth 0 edges		for (int i = 0; i < bsplines.size(); i++)			bsplines[i]->OutlinePostscriptDepthZeroSections(fRefNum, canvasSize);	}}void Drawing::DrawPostscriptIntersections(short fRefNum, MainWindow::ViewMode viewMode, Point canvasSize){	string st;	long strLen;	OSErr err;		FloatPoint fp;	Rect r;	for (vector<GenericIntersection*>::iterator i = intersections.begin(); i != intersections.end(); i++)	{		GenericIntersection* inter = *i;				//Round to the nearest pixel instead of merely rounding down		fp = inter->GetLocation();		if ((int)(fp.h * 10) % 10 >= 5)			fp.h++;		if ((int)(fp.v * 10) % 10 >= 5)			fp.v++;				if (fp.h < -99998)			fp.h = 0;				if (showCrossingStates && viewMode != MainWindow::SURFACE_MODE)		{			ostringstream oss;						switch (inter->GetType())			{				case GenericIntersection::BSP_BSP:					BspBspIntersection* bspBspInter = (BspBspIntersection*)inter;										//Thick top segment					ostringstream lineThicknessOss;					lineThicknessOss << .006;					st = lineThicknessOss.str();					st += " setlinewidth\n";										BSpline* topBsp = bspBspInter->GetBsp1();					SurfaceTraits surfaceTraits = topBsp->GetSurfaceTraits();										oss << ((double)surfaceTraits.interiorColor.red / 65535.0);					oss << " ";					oss << ((double)surfaceTraits.interiorColor.green / 65535.0);					oss << " ";					oss << ((double)surfaceTraits.interiorColor.blue / 65535.0);										oss << " setrgbcolor\n";										int cv = bspBspInter->GetCv1();					int sg = bspBspInter->GetSg1();					vector<vector<FloatPoint>*>* curvePoints = topBsp->GetCurvePoints();					int cvsg = cv * BSpline::sNumSegmentsPerCurve + sg;					int totalCurvePoints = curvePoints->size() * BSpline::sNumSegmentsPerCurve;					int cvsgNext = (cvsg + 1) % totalCurvePoints;					int cvNext = cvsgNext / BSpline::sNumSegmentsPerCurve;					int sgNext = cvsgNext % BSpline::sNumSegmentsPerCurve;					MyAssert(cvNext < curvePoints->size() && sgNext < BSpline::sNumSegmentsPerCurve);					FloatPoint cvsgLoc = (*(*curvePoints)[cv])[sg];					FloatPoint cvsgNextLoc = (*(*curvePoints)[cvNext])[sgNext];										oss << (double)cvsgLoc.h / canvasSize.h;					oss << " ";					oss << (double)(canvasSize.v - cvsgLoc.v) / canvasSize.v;					oss << " moveto\n";										oss << (double)cvsgNextLoc.h / canvasSize.h;					oss << " ";					oss << (double)(canvasSize.v - cvsgNextLoc.v) / canvasSize.v;					oss << " lineto\n";										oss << "stroke\n";										//Extend the thick segment if it is too short					float cvSgLength = LineSegmentLength(cvsgLoc, cvsgNextLoc);					if (cvSgLength < 15)					{						float cvSgInterDist = LineSegmentLength(cvsgLoc, bspBspInter->GetLocation());						if (cvSgInterDist < cvSgLength / 2.0)	//Intersection is closer to curve segment start						{							int cvsgPrev = (cvsg + (totalCurvePoints - 1)) % totalCurvePoints;							int cvPrev = cvsgPrev / BSpline::sNumSegmentsPerCurve;							int sgPrev = cvsgPrev % BSpline::sNumSegmentsPerCurve;							MyAssert(cvPrev < curvePoints->size() && sgPrev < BSpline::sNumSegmentsPerCurve);							FloatPoint cvsgPrevLoc = (*(*curvePoints)[cvPrev])[sgPrev];														oss << (double)cvsgPrevLoc.h / canvasSize.h;							oss << " ";							oss << (double)(canvasSize.v - cvsgPrevLoc.v) / canvasSize.v;							oss << " moveto\n";														oss << (double)cvsgLoc.h / canvasSize.h;							oss << " ";							oss << (double)(canvasSize.v - cvsgLoc.v) / canvasSize.v;							oss << " lineto\n";														oss << "stroke\n";						}						else	//Intersection is closer to curve segment end						{							int cvsgNext2 = (cvsgNext + 1) % totalCurvePoints;							int cvNext2 = cvsgNext2 / BSpline::sNumSegmentsPerCurve;							int sgNext2 = cvsgNext2 % BSpline::sNumSegmentsPerCurve;							MyAssert(cvNext2 < curvePoints->size() && sgNext2 < BSpline::sNumSegmentsPerCurve);							FloatPoint cvsgLoc = (*(*curvePoints)[cv])[sg];							FloatPoint cvsgNext2Loc = (*(*curvePoints)[cvNext2])[sgNext2];														oss << (double)cvsgNextLoc.h / canvasSize.h;							oss << " ";							oss << (double)(canvasSize.v - cvsgNextLoc.v) / canvasSize.v;							oss << " moveto\n";														oss << (double)cvsgNext2Loc.h / canvasSize.h;							oss << " ";							oss << (double)(canvasSize.v - cvsgNext2Loc.v) / canvasSize.v;							oss << " lineto\n";														oss << "stroke\n";						}					}										/*					//Invisible bottom segment					BSpline* botBsp = bspBspInter->GetBsp1();					RGBForeColor(&gColors.canvas);					int cv = bspBspInter->GetCv1();					int sg = bspBspInter->GetSg1();					vector<vector<FloatPoint>*>* curvePoints = botBsp->GetCurvePoints();					int cvsg = cv * BSpline::sNumSegmentsPerCurve + sg;					int cvsgNext = (cvsg + 1) % (curvePoints->size() * BSpline::sNumSegmentsPerCurve);					int cvNext = cvsgNext / BSpline::sNumSegmentsPerCurve;					int sgNext = cvsgNext % BSpline::sNumSegmentsPerCurve;					FloatPoint cvsgLoc = (*(*curvePoints)[cv])[sg];					FloatPoint cvsgNextLoc = (*(*curvePoints)[cvNext])[sgNext];					MoveTo(cvsgLoc.h, cvsgLoc.v);														oss << (double)cvsgLoc.h / canvasSize.h;							oss << " ";							oss << (double)(canvasSize.v - cvsgLoc.v) / canvasSize.v;							oss << " moveto\n";														oss << (double)cvsgNextLoc.h / canvasSize.h;							oss << " ";							oss << (double)(canvasSize.v - cvsgNextLoc.v) / canvasSize.v;							oss << " lineto\n";					*/					break;				case GenericIntersection::BSP_CUT:					BspCutIntersection* bspCutInter = (BspCutIntersection*)inter;					break;				case GenericIntersection::BSP_CUT_T:					BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)inter;					break;				case GenericIntersection::CUT_CUT:					CutCutIntersection* cutCutInter = (CutCutIntersection*)inter;					break;			}						st += oss.str();			strLen = st.length();			err = FSWrite(fRefNum, &strLen, st.c_str());		}		/*		ostringstream oss;		oss << (double)fp.h / canvasSize.h;		oss << " ";		oss << ((double)(canvasSize.v - fp.v) / canvasSize.v;		oss << " ";		oss << (double)gPointRadius;		oss << " ";		oss << (double)0;		oss << " ";		oss << (double)360;		oss << " arc\n";		oss << "closepath\n";				st = oss.str();		strLen = st.length();		err = FSWrite(fRefNum, &strLen, st.c_str());		*/		if (viewMode == MainWindow::SPLINE_MODE)		{			ostringstream oss;						//====================================			//Move this outside the viewMode if statement if/when the knot mode branch below is implemented.			//This will make the code here match DrawIntersections()						oss << (double)fp.h / canvasSize.h;			oss << " ";			oss << (double)(canvasSize.v - fp.v) / canvasSize.v;			oss << " ";			oss << (double)gPointRadius;			oss << " ";			oss << (double)0;			oss << " ";			oss << (double)360;			oss << " arc\n";			oss << "closepath\n";						//====================================						oss << ((double)gColors.intersection.red / 65535.0);			oss << " ";			oss << ((double)gColors.intersection.green / 65535.0);			oss << " ";			oss << ((double)gColors.intersection.blue / 65535.0);						oss << " setrgbcolor\n";						oss << "fill\n";						st = oss.str();			strLen = st.length();			err = FSWrite(fRefNum, &strLen, st.c_str());		}		else if (viewMode == MainWindow::KNOT_MODE)		{			if (showCompSets)			{				int companionSetIndex = 0;				bool foundIt = false;				/*				for (companionSetIndex = 0; companionSetIndex < interCompanionPairSets.size(); companionSetIndex++)	//Loop through the sets				{					for (int pairIndex = 0; pairIndex < interCompanionPairSets[companionSetIndex]->size(); pairIndex++)	//Loop through the pairs of one set						if ((*interCompanionPairSets[companionSetIndex])[pairIndex].first == inter || (*interCompanionPairSets[companionSetIndex])[pairIndex].second == inter)						{							foundIt = true;							break;						}					if (foundIt)						break;				}				*/				for (companionSetIndex = 0; companionSetIndex < interCompanionSets.size(); companionSetIndex++)	//Loop through the sets					if (find(interCompanionSets[companionSetIndex]->begin(), interCompanionSets[companionSetIndex]->end(), inter) != interCompanionSets[companionSetIndex]->end())					{						foundIt = true;						break;					}								if (foundIt)				{					ostringstream lineThicknessOss;					lineThicknessOss << .001;					st = lineThicknessOss.str();					st += " setlinewidth\n";										ostringstream oss;										oss << (double)fp.h / canvasSize.h;					oss << " ";					oss << (double)(canvasSize.v - fp.v) / canvasSize.v;					oss << " ";					oss << ((double)(gPointRadius * 2.0) / canvasSize.h);					oss << " ";					oss << (double)0;					oss << " ";					oss << (double)360;					oss << " arc\n";					oss << "closepath\n";										switch (companionSetIndex % 6)					{						case 0:	oss << (double)1 << " " << (double)0 << " " << (double)0;	break;						case 1:	oss << (double)0 << " " << (double)1 << " " << (double)0;	break;						case 2:	oss << (double)0 << " " << (double)0 << " " << (double)1;	break;						case 3:	oss << (double)1 << " " << (double)1 << " " << (double)0;	break;						case 4:	oss << (double)1 << " " << (double)0 << " " << (double)1;	break;						case 5:	oss << (double)0 << " " << (double)1 << " " << (double)1;	break;					}										oss << " setrgbcolor\n";										oss << "fill\n";										st += oss.str();					strLen = st.length();					err = FSWrite(fRefNum, &strLen, st.c_str());				}			}		}				if (inter->GetPermanentHardConstraint())		{			ostringstream lineThicknessOss;			lineThicknessOss << .006;			st = lineThicknessOss.str();			st += " setlinewidth\n";						ostringstream oss;						oss << (double)fp.h / canvasSize.h;			oss << " ";			oss << (double)(canvasSize.v - fp.v) / canvasSize.v;			oss << " ";			oss << ((double)(gPointRadius * 5.0) / canvasSize.h);			oss << " ";			oss << (double)0;			oss << " ";			oss << (double)360;			oss << " arc\n";			oss << "closepath\n";						oss << (double)0;			oss << " ";			oss << (double)0;			oss << " ";			oss << (double)0;						oss << " setrgbcolor\n";						oss << "stroke\n";						st += oss.str();			strLen = st.length();			err = FSWrite(fRefNum, &strLen, st.c_str());		}			}}#pragma mark -		void Drawing::DumpFileData(short fRefNum, double fileVersion){	Drawing* restore = new Drawing(*this);		vector<CutInfo> cutInfos;	for (int i = 0; i < bsplinePairCuts.size(); i++)	{		CutInfo cutInfo;					cutInfo.bsp1Index = GetBSplineIndex(bsplinePairCuts[i]->GetBsp1());		cutInfo.bsp2Index = bsplinePairCuts[i]->GetBsp2() ? GetBSplineIndex(bsplinePairCuts[i]->GetBsp2()) : -1;		cutInfo.cv1 = bsplinePairCuts[i]->GetCv1();		cutInfo.cv2 = bsplinePairCuts[i]->GetCv2();		cutInfo.sg1 = bsplinePairCuts[i]->GetSg1();		cutInfo.sg2 = bsplinePairCuts[i]->GetSg2();					cutInfos.push_back(cutInfo);	}		while (bsplinePairCuts.size() > 0)		RemoveCut(bsplinePairCuts.back(), false);		string st;	long strLen;	OSErr err;		//Add the number of BSpline segments per curve	ostringstream oss1;	oss1 << BSpline::sNumSegmentsPerCurve << "\n";		oss1 << "BSplines========================================\n";		//Add the number of BSplines	oss1 << bsplines.size() << "\n";		st = oss1.str();	strLen = st.length();	err = FSWrite(fRefNum, &strLen, st.c_str());		//Add the BSplines	for (int i = 0; i < bsplines.size(); i++)	{		ostringstream oss;		oss << "BSpline-" << i << "-==========\n";		st = oss.str();		long strLen = st.length();		OSErr err = FSWrite(fRefNum, &strLen, st.c_str());				bsplines[i]->DumpFileData(fRefNum);	}		ostringstream oss4;	oss4 << "Cuts========================================\n";		//Add the number of BSplines	oss4 << cutInfos.size() << "\n";		st = oss4.str();	strLen = st.length();	err = FSWrite(fRefNum, &strLen, st.c_str());		//Add the Cuts	for (int i = 0; i < cutInfos.size(); i++)	{		ostringstream oss;		oss << "Cut-" << i << "-==========\n";				oss << "  " << cutInfos[i].bsp1Index << " " << cutInfos[i].bsp2Index << "\n";				//Add the curves and segs		oss << "  " << cutInfos[i].cv1 << " " << cutInfos[i].cv2 << " " << cutInfos[i].sg1 << " " << cutInfos[i].sg2 << "\n";				st = oss.str();		long strLen = st.length();		OSErr err = FSWrite(fRefNum, &strLen, st.c_str());	}		ostringstream oss2;	/*	oss2 << "Prev_Cuts========================================\n";		//Add the number of Prev Cuts	oss2 << prevCuts.size() << "\n";		//Add the Prev Cuts	for (int i = 0; i < prevCuts.size(); i++)	{		oss2 << "  " << GetBSplineIndex(prevCuts[i]->bsp1) << " " << GetBSplineIndex(prevCuts[i]->bsp2) << "\n";		oss2 << "  " << prevCuts[i]->cv1 << " " << prevCuts[i]->cv2 << " " << prevCuts[i]->sg1 << " " << prevCuts[i]->sg2 << "\n";	}	*/	oss2 << "Intersections========================================\n";		//Add the number of Intersections	int numBspBspInters = 0;	for (int i = 0; i < intersections.size(); i++)		if (intersections[i]->GetType() == GenericIntersection::BSP_BSP)			numBspBspInters++;	oss2 << numBspBspInters << "\n";		st = oss2.str();	strLen = st.length();	err = FSWrite(fRefNum, &strLen, st.c_str());		//Add the Intersections	for (int i = 0; i < intersections.size(); i++)		if (intersections[i]->GetType() == GenericIntersection::BSP_BSP)		{			ostringstream oss;			oss << "Intersection-" << i << "-==========\n";			st = oss.str();			long strLen = st.length();			OSErr err = FSWrite(fRefNum, &strLen, st.c_str());						intersections[i]->DumpFileData(fRefNum, fileVersion);		}		ostringstream oss3;	oss3 << "Intersection_Companion_Sets========================================\n";		//Add the number of Companion Sets	oss3 << interCompanionPairSets.size() << "\n";		//Add the Companion Sets	for (int i = 0; i < interCompanionPairSets.size(); i++)	{		oss3 << "  " << interCompanionPairSets[i]->size() << "\n";		for (int j = 0; j < interCompanionPairSets[i]->size(); j++)			oss3 << "    " << GetIntersectionIndex((*interCompanionPairSets[i])[j].first) << " " << GetIntersectionIndex((*interCompanionPairSets[i])[j].second) << "\n";	}		st = oss3.str();	strLen = st.length();	err = FSWrite(fRefNum, &strLen, st.c_str());		*this = *restore;	delete restore;}void Drawing::LoadFileData(istringstream& iss, double fileVersion){	//Destroy the present drawing		//Delete and remove all BSplines	for (int i = 0; i < bsplines.size(); i++)		delete bsplines[i];	bsplines.clear();		//Delete and remove all Cuts	for (int i = 0; i < bsplinePairCuts.size(); i++)		delete bsplinePairCuts[i];	bsplinePairCuts.clear();		//Delete and remove all PrevCuts	for (int i = 0; i < prevCuts.size(); i++)		delete prevCuts[i];	prevCuts.clear();		//Delete and remove all Intersections	for (int i = 0; i < intersections.size(); i++)		delete intersections[i];	intersections.clear();		//Delete and remove all Companion Sets	for (int i = 0; i < interCompanionPairSets.size(); i++)		delete interCompanionPairSets[i];	interCompanionPairSets.clear();		//Delete and remove all Whole Objects	for (int i = 0; i < wholeObjects.size(); i++)		delete wholeObjects[i];	wholeObjects.clear();		ClearBrandNewIntersections();		//===================================================================================		string separator;		//Load the number of BSpline segments per curve	iss >> BSpline::sNumSegmentsPerCurve;		iss >> separator;		//Load the number of BSplines	int numBSplines;	iss >> numBSplines;	bsplines.resize(numBSplines);		//Load the BSplines	for (int i = 0; i < numBSplines; i++)	{		iss >> separator;		BSpline* newBsp = new BSpline(this);		bsplines[i] = newBsp;		newBsp->LoadFileData(iss, fileVersion);				WholeObject* wo;		FindOrCreateWholeObjectForBSpline(newBsp, wo, -1);	}		iss >> separator;		//Load the number of Cuts	int numCuts;	iss >> numCuts;	vector<CutInfo> cutInfos;	//Only used by some file versions		//Load the Cuts	if (fileVersion == 1.0 || fileVersion == 1.1)	{		bsplinePairCuts.resize(numCuts);		for (int i = 0; i < numCuts; i++)		{			iss >> separator;			BSplineToBSplineCut* newCut = new BSplineToBSplineCut(this);			newCut->InitSectionDepths(0);			bsplinePairCuts[i] = newCut;			newCut->LoadFileData(iss, fileVersion);		}	}	else if (fileVersion == 1.2)	{		for (int i = 0; i < numCuts; i++)		{			CutInfo cutInfo;						iss >> separator;						iss >> cutInfo.bsp1Index >> cutInfo.bsp2Index;			MyAssert(cutInfo.bsp1Index < bsplines.size() && (cutInfo.bsp2Index < bsplines.size() || cutInfo.bsp2Index == -1));						iss >> cutInfo.cv1 >> cutInfo.cv2 >> cutInfo.sg1 >> cutInfo.sg2;						cutInfos.push_back(cutInfo);		}	}		iss >> separator;		//Load the number of Intersections	int numInters;	iss >> numInters;	intersections.resize(numInters);		//Load the Intersections	for (int i = 0; i < numInters; i++)	{int iii = i;		iss >> separator;				//Read the intersection type		int interType;		iss >> interType;				GenericIntersection* inter;		switch ((GenericIntersection::IntersectionType)interType)		{			case GenericIntersection::BSP_BSP:				inter = new BspBspIntersection(this);				break;			case GenericIntersection::BSP_CUT:				MyAssert(fileVersion == 1.0 || fileVersion == 1.1);				inter = new BspCutIntersection(this);				break;			case GenericIntersection::BSP_CUT_T:				MyAssert(fileVersion == 1.0 || fileVersion == 1.1);				inter = new BspCutTIntersection(this);				break;			case GenericIntersection::CUT_CUT:				MyAssert(fileVersion == 1.0 || fileVersion == 1.1);				inter = new CutCutIntersection(this);				break;		}		intersections[i] = inter;		inter->LoadFileData(iss, fileVersion);	}	iss >> separator;		//Load the number of Companion Sets	/*	int numCompSets;	iss >> numCompSets;	interCompanionPairSets.resize(numCompSets);		//Load the Companion Sets	for (int i = 0; i < numCompSets; i++)	{		vector<pair<GenericIntersection*, GenericIntersection*> >* compSet = new vector<pair<GenericIntersection*, GenericIntersection*> >;				int compSetSize;		iss >> compSetSize;		compSet->resize(compSetSize);		for (int j = 0; j < compSetSize; j++)		{			int inter1Index, inter2Index;			iss >> inter1Index >> inter2Index;			MyAssert(inter1Index < intersections.size() && inter2Index < intersections.size());			(*compSet)[j].first = intersections[inter1Index];			(*compSet)[j].second = intersections[inter2Index];		}				interCompanionPairSets[i] = compSet;	}	*/	MyAssert(interCompanionPairSets.size() == 0);	//This is no longer used, it should always be empty (delete it from the code at some future point).		//===================================================================================		//Now that everything is loaded, rebuild some things		//Reinsert the intersections	for (int i = 0; i < intersections.size(); i++)	{		int index1, index2;		switch (intersections[i]->GetType())		{			case GenericIntersection::BSP_BSP:				BspBspIntersection* bspBspInter = (BspBspIntersection*)intersections[i];								index1 = bspBspInter->GetBsp1Index();				index2 = bspBspInter->GetBsp2Index();								//Add the new intersection to its corresponding BSplines				//Don't equalize the number of sections however.  This was done when the BSpline was created.				bsplines[index1]->AddIntersection(bspBspInter->GetCv1(), bspBspInter->GetSg1(), bspBspInter, false);				bsplines[index2]->AddIntersection(bspBspInter->GetCv2(), bspBspInter->GetSg2(), bspBspInter, false);				break;			case GenericIntersection::BSP_CUT:				MyAssert(fileVersion == 1.0 || fileVersion == 1.1);				BspCutIntersection* bspCutInter = (BspCutIntersection*)intersections[i];								index1 = bspCutInter->GetBspIndex();				index2 = bspCutInter->GetCutIndex();								//Add the new intersection to its corresponding BSpline and Cut				//Don't equalize the number of sections however.  This was done when the BSpline was created.				bsplines[index1]->AddIntersection(bspCutInter->GetCv(), bspCutInter->GetSg(), bspCutInter, false);				bsplinePairCuts[index2]->AddIntersection(bspCutInter, true, false);				break;			case GenericIntersection::BSP_CUT_T:				MyAssert(fileVersion == 1.0 || fileVersion == 1.1);				BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)intersections[i];								index1 = bspCutTInter->GetBsp() ? bspCutTInter->GetBspIndex() : -1;				index2 = bspCutTInter->GetCutIndex();								//Add the new intersection to its corresponding BSpline and Cut				//Don't equalize the number of sections however.  This was done when the BSpline was created.				if (index1 != -1)					bsplines[index1]->AddIntersection(bspCutTInter->GetCv(), bspCutTInter->GetSg(), bspCutTInter, false);				bsplinePairCuts[index2]->AddIntersection(bspCutTInter, false, false);				break;			case GenericIntersection::CUT_CUT:				MyAssert(fileVersion == 1.0 || fileVersion == 1.1);				CutCutIntersection* cutCutInter = (CutCutIntersection*)intersections[i];								index1 = cutCutInter->GetCut1Index();				index2 = cutCutInter->GetCut2Index();								//Add the new intersection to its corresponding Cuts				bsplinePairCuts[index1]->AddIntersection(cutCutInter, true, false);				bsplinePairCuts[index2]->AddIntersection(cutCutInter, true, false);				break;		}	}		for (int i = 0; i < bsplines.size(); i++)		bsplines[i]->MakeIntersectionList();		//Verify that this Drawing's new intersections have the appropriate BSpline and Cut pointers and indexes	for (int i = 0; i < intersections.size(); i++)	{		MyAssert(intersections[i]->GetDrawing() == this);		switch (intersections[i]->GetType())		{			case GenericIntersection::BSP_BSP:				BspBspIntersection* bspBspInter = (BspBspIntersection*)intersections[i];								MyAssert(bspBspInter->GetBsp1() == bsplines[bspBspInter->GetBsp1Index()]);				MyAssert(bspBspInter->GetBsp2() == bsplines[bspBspInter->GetBsp2Index()]);				break;			case GenericIntersection::BSP_CUT:				MyAssert(fileVersion == 1.0 || fileVersion == 1.1);				BspCutIntersection* bspCutInter = (BspCutIntersection*)intersections[i];								MyAssert(bspCutInter->GetBsp() == bsplines[bspCutInter->GetBspIndex()]);				MyAssert(bspCutInter->GetCut() == bsplinePairCuts[bspCutInter->GetCutIndex()]);				break;			case GenericIntersection::BSP_CUT_T:				MyAssert(fileVersion == 1.0 || fileVersion == 1.1);				BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)intersections[i];								if (bspCutTInter->GetBsp())					MyAssert(bspCutTInter->GetBsp() == bsplines[bspCutTInter->GetBspIndex()]);				MyAssert(bspCutTInter->GetCut() == bsplinePairCuts[bspCutTInter->GetCutIndex()]);				break;			case GenericIntersection::CUT_CUT:				MyAssert(fileVersion == 1.0 || fileVersion == 1.1);				CutCutIntersection* cutCutInter = (CutCutIntersection*)intersections[i];								MyAssert(cutCutInter->GetCut1() == bsplinePairCuts[cutCutInter->GetCut1Index()]);				MyAssert(cutCutInter->GetCut2() == bsplinePairCuts[cutCutInter->GetCut2Index()]);				break;		}	}		for (int i = 0; i < cutInfos.size(); i++)	{		CutInfo cutInfo1 = cutInfos[i];	//debug				MyAssert(cutInfos[i].bsp1Index >= 0 && cutInfos[i].bsp1Index < bsplines.size());		MyAssert(cutInfos[i].bsp2Index == -1 || (cutInfos[i].bsp2Index >= 0 && cutInfos[i].bsp2Index < bsplines.size()));		BSpline *bsp1 = bsplines[cutInfos[i].bsp1Index];		BSpline *bsp2 = (cutInfos[i].bsp2Index != -1) ? bsplines[cutInfos[i].bsp2Index] : NULL;				int initSectionDepth = bsp1->GetArbitraryCurveSegCenterDepth(cutInfos[i].cv1, cutInfos[i].sg1);		BSplineToBSplineCut* testCut = new BSplineToBSplineCut(this, bsp1, bsp2, cutInfos[i].cv1, cutInfos[i].sg1, cutInfos[i].cv2, cutInfos[i].sg2, initSectionDepth);		int cutEndingDepth = -1;		bool goodCut = TestCut(testCut, cutEndingDepth);		if (goodCut)			GroupBSplineAndSaveBSplineToBSplineCut(bsp1, testCut, cutEndingDepth);		else		{			testCut->NullAllBspsAndCuts();			DeleteBSplineToBSplineCut(testCut);		}	}		bool legalLabeling = true;	for (int i = 0; i < bsplines.size(); i++)		if (!bsplines[i]->GetAllIntersectionsLegal(false))		{			legalLabeling = false;			break;		}	if (legalLabeling)		FindWholeObjects2(bsplines);			VerifyWholeObjects();	for (int i = 0; i < bsplinePairCuts.size(); i++)		bsplinePairCuts[i]->VerifyBackupsMatchPresent();		ClearBrandNewIntersections();		FindBSplineSectionMaxPossibleDepthsV4();}#pragma mark -void Drawing::SetAllIntersectionsNoHardConstraint(){	for (vector<GenericIntersection*>::iterator i = intersections.begin(); i != intersections.end(); i++)		(*i)->SetHardConstraint(false);}void Drawing::SetAllSectionsNoHardConstraint(){	for (vector<BSpline*>::iterator i = bsplines.begin(); i != bsplines.end(); i++)		(*i)->SetAllSectionsNoHardConstraint();	for (vector<BSplineToBSplineCut*>::iterator i = bsplinePairCuts.begin(); i != bsplinePairCuts.end(); i++)		(*i)->SetAllSectionsNoHardConstraint();}void Drawing::VerifyLegalIntersections(){	//This test can legally fail for incomplete shapes such as figure-eights	for (int i = 0; i < bsplines.size(); i++)		MyAssert(bsplines[i]->GetAllIntersectionsLegal(true));	for (int i = 0; i < bsplinePairCuts.size(); i++)		MyAssert(bsplinePairCuts[i]->GetAllIntersectionsLegal(true));}		bool Drawing::VerifyLegalLabeling(){	//еее	for (vector<BSpline*>::iterator i = bsplines.begin(); i != bsplines.end(); i++)	{		vector<int>* sd = (*i)->GetSectionDepths();		int *d = new int[sd->size()];		for (int i = 0; i < sd->size(); i++)			d[i] = (*sd)[i];		delete [] d;	}		for (vector<BSpline*>::iterator i = bsplines.begin(); i != bsplines.end(); i++)		if (!(*i)->VerifyLegalLabeling())			return false;		return true;}void Drawing::VerifyWholeObjects(){	for (int i = 0; i < wholeObjects.size(); i++)	{		WholeObject* wo = wholeObjects[i];				for (int j = 0; j > wo->bsplines.size(); j++)			MyAssert(!wo->bsplines[j]->dtored);				if (wo->bgDepths.size() == 0)	//A whole object with a finite solid boundary		{			int numZeroSolids = 0;			int numPosSolids = 0;			for (int j = 0; j < wo->bsplines.size(); j++)				if (wo->bsplines[j]->GetWindingNumber() == 0)					numZeroSolids++;				else if (wo->bsplines[j]->GetWindingNumber() > 0)					numPosSolids++;			//MyAssert(numPosSolids <= 1);	//Not necessarily true			if (numPosSolids == 0)	//Must be some kind of figure-eight				MyAssert(numZeroSolids > 0);		}		else	//A whole object with an infinite solid boundary		{			int numZeroSolids = 0;			int numPosSolids = 0;			for (int j = 0; j < wo->bsplines.size(); j++)				if (wo->bsplines[j]->GetWindingNumber() == 0)					numZeroSolids++;				else if (wo->bsplines[j]->GetWindingNumber() > 0)					numPosSolids++;			MyAssert(numZeroSolids == 0);	//Not sure about this, pretty sure though.  How can a figure-eight be embedded in an infinite solid?			MyAssert(numPosSolids == 0);		}				vector<BSpline*> checkedBSplines;		MyAssert(ConnectedHole(wo->bsplines[0], checkedBSplines, NULL));	}}vector<GenericIntersection*> Drawing::FindInterNeighbors(GenericIntersection* inter){	vector<GenericIntersection*> neighbors;		BSpline* bsp;	BSplineToBSplineCut* cut;	int cv, sg;	GenericIntersection* neighbor;		switch (inter->GetType())	{		case GenericIntersection::BSP_BSP:			BspBspIntersection* bspBspInter = (BspBspIntersection*)inter;						bsp = bspBspInter->GetBsp1();			cv = bspBspInter->GetCv1();			sg = bspBspInter->GetSg1();						neighbor = bsp->FindPrevIntersection(inter, cv, sg);			if (find(neighbors.begin(), neighbors.end(), neighbor) == neighbors.end())				neighbors.push_back(neighbor);						neighbor = bsp->FindNextIntersection(inter, cv, sg);			if (find(neighbors.begin(), neighbors.end(), neighbor) == neighbors.end())				neighbors.push_back(neighbor);						bsp = bspBspInter->GetBsp2();			cv = bspBspInter->GetCv2();			sg = bspBspInter->GetSg2();						neighbor = bsp->FindPrevIntersection(inter, cv, sg);			if (find(neighbors.begin(), neighbors.end(), neighbor) == neighbors.end())				neighbors.push_back(neighbor);						neighbor = bsp->FindNextIntersection(inter, cv, sg);			if (find(neighbors.begin(), neighbors.end(), neighbor) == neighbors.end())				neighbors.push_back(neighbor);			break;		case GenericIntersection::BSP_CUT:			BspCutIntersection* bspCutInter = (BspCutIntersection*)inter;						bsp = bspCutInter->GetBsp();			cv = bspCutInter->GetCv();			sg = bspCutInter->GetSg();			neighbor = bsp->FindPrevIntersection(inter, cv, sg);			if (find(neighbors.begin(), neighbors.end(), neighbor) == neighbors.end())				neighbors.push_back(neighbor);			neighbor = bsp->FindNextIntersection(inter, cv, sg);			if (find(neighbors.begin(), neighbors.end(), neighbor) == neighbors.end())				neighbors.push_back(neighbor);						cut = bspCutInter->GetCut();			neighbor = cut->FindPrevIntersection(inter);			if (find(neighbors.begin(), neighbors.end(), neighbor) == neighbors.end())				neighbors.push_back(neighbor);			neighbor = cut->FindNextIntersection(inter);			if (find(neighbors.begin(), neighbors.end(), neighbor) == neighbors.end())				neighbors.push_back(neighbor);			break;		case GenericIntersection::BSP_CUT_T:			BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)inter;						if (bspCutTInter->GetBsp())			{				bsp = bspCutTInter->GetBsp();				cv = bspCutTInter->GetCv();				sg = bspCutTInter->GetSg();				neighbor = bsp->FindPrevIntersection(inter, cv, sg);				if (find(neighbors.begin(), neighbors.end(), neighbor) == neighbors.end())					neighbors.push_back(neighbor);				neighbor = bsp->FindNextIntersection(inter, cv, sg);				if (find(neighbors.begin(), neighbors.end(), neighbor) == neighbors.end())					neighbors.push_back(neighbor);			}						cut = bspCutTInter->GetCut();			neighbor = bspCutTInter->GetAtStart() ? cut->FindNextIntersection(inter) : cut->FindPrevIntersection(inter);			if (find(neighbors.begin(), neighbors.end(), neighbor) == neighbors.end())				neighbors.push_back(neighbor);			break;		case GenericIntersection::CUT_CUT:			CutCutIntersection* cutCutInter = (CutCutIntersection*)inter;						cut = cutCutInter->GetCut1();			neighbor = cut->FindPrevIntersection(inter);			if (find(neighbors.begin(), neighbors.end(), neighbor) == neighbors.end())				neighbors.push_back(neighbor);			neighbor = cut->FindNextIntersection(inter);			if (find(neighbors.begin(), neighbors.end(), neighbor) == neighbors.end())				neighbors.push_back(neighbor);						cut = cutCutInter->GetCut2();			neighbor = cut->FindPrevIntersection(inter);			if (find(neighbors.begin(), neighbors.end(), neighbor) == neighbors.end())				neighbors.push_back(neighbor);			neighbor = cut->FindNextIntersection(inter);			if (find(neighbors.begin(), neighbors.end(), neighbor) == neighbors.end())				neighbors.push_back(neighbor);			break;	}		return neighbors;}//Find the smallest graph distance from every intersection in the drawing to any intersection in contentionvoid Drawing::FindAllIntersectionContentionDistances(vector<GenericIntersection*> contentiousInters, vector<pair<GenericIntersection*, int> >& interDists){	interDists.clear();		int dist = 0;		vector<GenericIntersection*> horizonInters;	for (int i = 0; i < contentiousInters.size(); i++)	{		horizonInters.push_back(contentiousInters[i]);		interDists.push_back(pair<GenericIntersection*, int>(contentiousInters[i], dist));	}		Rect r;	PenSize(2, 2);	if (gDebug10)	{		for (int i = 0; i < interDists.size(); i++)		{			FloatPoint intersectionLoc = interDists[i].first->GetLocation();			int interDist = interDists[i].second;			SetRect(&r, max(intersectionLoc.h, 0.0) - (interDist + 10), intersectionLoc.v - (interDist + 10), max(intersectionLoc.h, 0.0) + (interDist + 10), intersectionLoc.v + (interDist + 10));			ForeColor(blackColor);			FrameRect(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int k = 1;		}		int k = 1;	}		dist++;	vector<GenericIntersection*> nextHorizonInters;	//while (interDists.size() < intersections.size())	//This won't work if there are disconnected components in the drawing	while (horizonInters.size() > 0)	{		nextHorizonInters.clear();				MyAssert(horizonInters.size() > 0);				if (gDebug10)		{			for (int i = 0; i < horizonInters.size(); i++)			{				FloatPoint intersectionLoc = horizonInters[i]->GetLocation();				SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);				ForeColor(redColor);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int k = 1;			}			int k = 1;		}				for (int i = 0; i < horizonInters.size(); i++)		{			vector<GenericIntersection*> oneHorizonInterNeighbors = FindInterNeighbors(horizonInters[i]);			for (int j = 0; j < oneHorizonInterNeighbors.size(); j++)			{				bool interAlreadyInList = false;				for (int k = 0; k < interDists.size(); k++)					if (interDists[k].first == oneHorizonInterNeighbors[j])					{						interAlreadyInList = true;						break;					}				if (!interAlreadyInList)				{					interDists.push_back(pair<GenericIntersection*, int>(oneHorizonInterNeighbors[j], dist));					if (find(nextHorizonInters.begin(), nextHorizonInters.end(), oneHorizonInterNeighbors[j]) == nextHorizonInters.end())						nextHorizonInters.push_back(oneHorizonInterNeighbors[j]);				}			}		}				if (gDebug10)		{			for (int i = 0; i < interDists.size(); i++)			{				FloatPoint intersectionLoc = interDists[i].first->GetLocation();				int interDist = interDists[i].second;				SetRect(&r, max(intersectionLoc.h, 0.0) - (interDist + 10), intersectionLoc.v - (interDist + 10), max(intersectionLoc.h, 0.0) + (interDist + 10), intersectionLoc.v + (interDist + 10));				ForeColor(blackColor);				FrameRect(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int k = 1;			}			int k = 1;		}				if (gDebug10)		{			for (int i = 0; i < nextHorizonInters.size(); i++)			{				FloatPoint intersectionLoc = nextHorizonInters[i]->GetLocation();				SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);				ForeColor(greenColor);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int k = 1;			}			int k = 1;		}				horizonInters.clear();		for (int i = 0; i < nextHorizonInters.size(); i++)			horizonInters.push_back(nextHorizonInters[i]);				dist++;				MyAssert(interDists.size() <= intersections.size());	}		PenSize(1, 1);}void Drawing::DrawContentionIntersectionDistances(vector<pair<GenericIntersection*, int> > interDists){	SetPort(GetWindowPort(gMainWindow->GetWindow()));	ForeColor(blackColor);	TextSize(18);	TextFace(bold);		for (int i = 0; i < interDists.size(); i++)	{		FloatPoint loc = interDists[i].first->GetLocation();		MoveTo(loc.h + 5, loc.v + 5);		Str255 str;		NumToString(interDists[i].second, str);		DrawString(str);	}	QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		TextSize(9);	TextFace(0);}/*bool Drawing::FindBSplineSectionMaxPossibleDepths(){	//clock_t startTime = clock();		for (int i = 0; i < bsplines.size(); i++)		bsplines[i]->InitSectionMaxPossibleDepths();	//Set the max depths to 0		if (gDebug8)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));		PenSize(2, 2);	}		bool changeMade = true;	int counter = 0;	while (changeMade)	{		if (counter++ > 100)			return false;				changeMade = false;		//Iterate over all the intersections		for (int i = 0; i < intersections.size(); i++)		{			Rect r;			if (gDebug8)			{				FloatPoint intersectionLoc = intersections[i]->GetLocation();				SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);				ForeColor(blackColor);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qy = 1;			}						switch (intersections[i]->GetType())			{				case GenericIntersection::BSP_BSP:					BspBspIntersection* bspBspInter = (BspBspIntersection*)intersections[i];										int cv1 = bspBspInter->GetCv1();					int cv2 = bspBspInter->GetCv2();					int sg1 = bspBspInter->GetSg1();					int sg2 = bspBspInter->GetSg2();										//Get the four depths					int topPrevDepth = bspBspInter->GetBsp1()->GetMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv1, sg1);					int topNextDepth = bspBspInter->GetBsp1()->GetMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv1, sg1);					int botPrevDepth = bspBspInter->GetBsp2()->GetMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv2, sg2);					int botNextDepth = bspBspInter->GetBsp2()->GetMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv2, sg2);										int occludedEdge = bspBspInter->DetermineOccludedEdge();										//Set the two unoccluded edges to the deeper of the two unoccluded edges.					//Set the two occluded edges to one deeper than the same value.					int deeperUnoccludedDepth;					if (occludedEdge == 3)					{						deeperUnoccludedDepth = max(topPrevDepth, botNextDepth);												if (topPrevDepth != botNextDepth || topNextDepth != deeperUnoccludedDepth + 1 || botPrevDepth != deeperUnoccludedDepth + 1)						{							if (bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv1, sg1, deeperUnoccludedDepth, bspBspInter->GetBsp2()))								changeMade = true;							if (bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv2, sg2, deeperUnoccludedDepth, bspBspInter->GetBsp1()))								changeMade = true;														if (bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv1, sg1, deeperUnoccludedDepth + 1, bspBspInter->GetBsp2()))								changeMade = true;							if (bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv2, sg2, deeperUnoccludedDepth + 1, bspBspInter->GetBsp1()))								changeMade = true;						}					}					else	//occludedEdge == 4					{						deeperUnoccludedDepth = max(topNextDepth, botPrevDepth);												if (topNextDepth != botPrevDepth || topPrevDepth != deeperUnoccludedDepth + 1 || botNextDepth != deeperUnoccludedDepth + 1)						{							if (bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv1, sg1, deeperUnoccludedDepth, bspBspInter->GetBsp2()))								changeMade = true;							if (bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv2, sg2, deeperUnoccludedDepth, bspBspInter->GetBsp1()))								changeMade = true;														if (bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv1, sg1, deeperUnoccludedDepth + 1, bspBspInter->GetBsp2()))								changeMade = true;							if (bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv2, sg2, deeperUnoccludedDepth + 1, bspBspInter->GetBsp1()))								changeMade = true;						}					}					break;				case GenericIntersection::BSP_CUT:					break;				case GenericIntersection::BSP_CUT_T:					break;				case GenericIntersection::CUT_CUT:					break;			}						if (gDebug8)			{				FloatPoint intersectionLoc = intersections[i]->GetLocation();				SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);				ForeColor(whiteColor);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qy = 1;			}		}	}		PenSize(1, 1);		if (gDebug8)	{		MyAssert(!dtored);				SetPort(GetWindowPort(gMainWindow->GetWindow()));		Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qy = 1;	}		//Pick the "best" section for BSpline, the section with the shallowest max possible depth	for (int i = 0; i < bsplines.size(); i++)		bsplines[i]->PickShallowestAndDeepestMaxPossibleSection();		//clock_t elapsedTime = clock() - startTime;	//long elapsedTime100ths = elapsedTime / (CLOCKS_PER_SEC / 100);		return true;}bool Drawing::FindBSplineSectionMaxPossibleDepthsV2(){	if (gDebug8)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));		PenSize(2, 2);	}		for (int i = 0; i < bsplines.size(); i++)		bsplines[i]->InitSectionMaxPossibleDepths();	//Set the max depths to 0		//Iterate over all the intersections	for (int i = 0; i < intersections.size(); i++)	{		if (intersections[i]->GetType() != GenericIntersection::BSP_BSP)			continue;				if (gDebug8)		{			Rect r;			FloatPoint intersectionLoc = intersections[i]->GetLocation();			SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);			ForeColor(blackColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qy = 1;		}				BspBspIntersection* bspBspInter = (BspBspIntersection*)intersections[i];				int occludedEdge = bspBspInter->DetermineOccludedEdge();		if (occludedEdge == 3)		{			for (int j = 0; j < bsplines.size(); j++)				bsplines[j]->InitSectionsIncrementedAlready();			bspBspInter->GetBsp1()->SetSectionIncrementedAlreadyBeforeIntersection(bspBspInter, bspBspInter->GetCv1(), bspBspInter->GetSg1());			bspBspInter->GetBsp2()->SetSectionIncrementedAlreadyAfterIntersection(bspBspInter, bspBspInter->GetCv1(), bspBspInter->GetSg1());			bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthAfterIntersection(0, bspBspInter, bspBspInter->GetCv1(), bspBspInter->GetSg1(), bspBspInter->GetBsp2());						if (gDebug8)			{				SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;				GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);				EraseRect(&r);								PenSize(1, 1);				Point scrollOffset = {0, 0};				vector<BSpline*> workingBSplines;				DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, workingBSplines, NULL);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				PenSize(2, 2);								int qy = 1;			}						for (int j = 0; j < bsplines.size(); j++)				bsplines[j]->InitSectionsIncrementedAlready();			bspBspInter->GetBsp1()->SetSectionIncrementedAlreadyBeforeIntersection(bspBspInter, bspBspInter->GetCv1(), bspBspInter->GetSg1());			bspBspInter->GetBsp2()->SetSectionIncrementedAlreadyAfterIntersection(bspBspInter, bspBspInter->GetCv1(), bspBspInter->GetSg1());			bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthBeforeIntersection(0, bspBspInter, bspBspInter->GetCv2(), bspBspInter->GetSg2(), bspBspInter->GetBsp1());						if (gDebug8)			{				SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;				GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);				EraseRect(&r);								PenSize(1, 1);				Point scrollOffset = {0, 0};				vector<BSpline*> workingBSplines;				DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, workingBSplines, NULL);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				PenSize(2, 2);								int qy = 1;			}		}		else	//occludedEdge == 4		{			for (int j = 0; j < bsplines.size(); j++)				bsplines[j]->InitSectionsIncrementedAlready();			bspBspInter->GetBsp1()->SetSectionIncrementedAlreadyAfterIntersection(bspBspInter, bspBspInter->GetCv1(), bspBspInter->GetSg1());			bspBspInter->GetBsp2()->SetSectionIncrementedAlreadyBeforeIntersection(bspBspInter, bspBspInter->GetCv1(), bspBspInter->GetSg1());			bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthBeforeIntersection(0, bspBspInter, bspBspInter->GetCv1(), bspBspInter->GetSg1(), bspBspInter->GetBsp2());						if (gDebug8)			{				SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;				GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);				EraseRect(&r);								PenSize(1, 1);				Point scrollOffset = {0, 0};				vector<BSpline*> workingBSplines;				DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, workingBSplines, NULL);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				PenSize(2, 2);								int qy = 1;			}						for (int j = 0; j < bsplines.size(); j++)				bsplines[j]->InitSectionsIncrementedAlready();			bspBspInter->GetBsp1()->SetSectionIncrementedAlreadyAfterIntersection(bspBspInter, bspBspInter->GetCv1(), bspBspInter->GetSg1());			bspBspInter->GetBsp2()->SetSectionIncrementedAlreadyBeforeIntersection(bspBspInter, bspBspInter->GetCv1(), bspBspInter->GetSg1());			bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthAfterIntersection(0, bspBspInter, bspBspInter->GetCv2(), bspBspInter->GetSg2(), bspBspInter->GetBsp1());						if (gDebug8)			{				SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;				GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);				EraseRect(&r);								PenSize(1, 1);				Point scrollOffset = {0, 0};				vector<BSpline*> workingBSplines;				DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, workingBSplines, NULL);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				PenSize(2, 2);								int qy = 1;			}		}				if (gDebug8)		{			Rect r;			FloatPoint intersectionLoc = intersections[i]->GetLocation();			SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);			ForeColor(whiteColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qy = 1;		}	}		for (int i = 0; i < bsplines.size(); i++)		bsplines[i]->HalveSectionMaxPossibleDepths();		//Pick the "best" section for BSpline, the section with the shallowest max possible depth	for (int i = 0; i < bsplines.size(); i++)		bsplines[i]->PickShallowestAndDeepestMaxPossibleSection();		PenSize(1, 1);		if (gDebug8)	{		MyAssert(!dtored);				SetPort(GetWindowPort(gMainWindow->GetWindow()));		Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, workingBSplines, NULL);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qy = 1;	}		return true;	//еее Need to detect impossible labelings here!}*/bool Drawing::FindBSplineSectionMaxPossibleDepthsV3(){	//clock_t startTime = clock();		for (int i = 0; i < bsplines.size(); i++)		bsplines[i]->InitSectionMaxPossibleDepths();	//Set the max depths to 0		if (gDebug8)	{		MyAssert(!dtored);				PenSize(1, 1);		SetPort(GetWindowPort(gMainWindow->GetWindow()));		Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		PenSize(2, 2);				int qy = 1;	}		//Two passes	//First pass find basic max depth assignments where every intersection has the same value for the	//two unoccluded segments and one more than that value for the two potentially occluded segments.	//Then push each segment that is inwardly bounded by two different boundaries down by one.	//Then repeat the first pass again (without the extra push).	for (int pass = 0; pass < 2; pass++)	{		bool changeMade = true;		int counter = 0;		while (changeMade)		{			if (counter++ > 100)				return false;						changeMade = false;			//Iterate over all the intersections			for (int i = 0; i < intersections.size(); i++)			{				Rect r;				if (gDebug8)				{					FloatPoint intersectionLoc = intersections[i]->GetLocation();					SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);					ForeColor(blackColor);					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qy = 1;				}								int cv, sg;				int bspPrevDepth, bspNextDepth;				int deeperDepth;				switch (intersections[i]->GetType())				{					case GenericIntersection::BSP_BSP:						BspBspIntersection* bspBspInter = (BspBspIntersection*)intersections[i];												int cv1 = bspBspInter->GetCv1();						int cv2 = bspBspInter->GetCv2();						int sg1 = bspBspInter->GetSg1();						int sg2 = bspBspInter->GetSg2();												//Get the four depths						int topPrevDepth = bspBspInter->GetBsp1()->GetMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv1, sg1);						int topNextDepth = bspBspInter->GetBsp1()->GetMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv1, sg1);						int botPrevDepth = bspBspInter->GetBsp2()->GetMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv2, sg2);						int botNextDepth = bspBspInter->GetBsp2()->GetMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv2, sg2);												int occludedEdge = bspBspInter->DetermineOccludedEdge();												//Find deepest "governing" (defined below) depth of the four edges.						//Set the two unoccluded edges to the same depth.						//Set the two occluded edges to one deeper than the unoccluded edges.						int deeperUnoccludedDepth, deeperOccludedDepth, unoccludedDepthAssignment;						if (occludedEdge == 3)						{							deeperUnoccludedDepth = max(topPrevDepth, botNextDepth);							deeperOccludedDepth = max(topNextDepth, botPrevDepth);														if (deeperOccludedDepth <= deeperUnoccludedDepth + 1)	//Unoccluded max depths "govern" the max depth assignments								unoccludedDepthAssignment = deeperUnoccludedDepth;							else unoccludedDepthAssignment = deeperOccludedDepth - 1;	//Occluded max depths "govern" the max depth assignments														if (topPrevDepth != botNextDepth || topNextDepth != deeperUnoccludedDepth + 1 || botPrevDepth != deeperUnoccludedDepth + 1)							{								if (bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv1, sg1, unoccludedDepthAssignment))									changeMade = true;								if (bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv2, sg2, unoccludedDepthAssignment))									changeMade = true;																if (bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv1, sg1, unoccludedDepthAssignment + 1))									changeMade = true;								if (bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv2, sg2, unoccludedDepthAssignment + 1))									changeMade = true;							}						}						else	//occludedEdge == 4						{							deeperUnoccludedDepth = max(topNextDepth, botPrevDepth);							deeperOccludedDepth = max(topPrevDepth, botNextDepth);														if (deeperOccludedDepth <= deeperUnoccludedDepth + 1)	//Unoccluded max depths "govern" the max depth assignments								unoccludedDepthAssignment = deeperUnoccludedDepth;							else unoccludedDepthAssignment = deeperOccludedDepth - 1;	//Occluded max depths "govern" the max depth assignments														if (topNextDepth != botPrevDepth || topPrevDepth != deeperUnoccludedDepth + 1 || botNextDepth != deeperUnoccludedDepth + 1)							{								if (bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv1, sg1, unoccludedDepthAssignment))									changeMade = true;								if (bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv2, sg2, unoccludedDepthAssignment))									changeMade = true;																if (bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv1, sg1, unoccludedDepthAssignment + 1))									changeMade = true;								if (bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv2, sg2, unoccludedDepthAssignment + 1))									changeMade = true;							}						}						break;					case GenericIntersection::BSP_CUT:						BspCutIntersection* bspCutInter = (BspCutIntersection*)intersections[i];												cv = bspCutInter->GetCv();						sg = bspCutInter->GetSg();												//Get the two depths						bspPrevDepth = bspCutInter->GetBsp()->GetMaxPossibleSectionDepthBeforeIntersection(bspCutInter, cv, sg);						bspNextDepth = bspCutInter->GetBsp()->GetMaxPossibleSectionDepthAfterIntersection(bspCutInter, cv, sg);												deeperDepth = max(bspPrevDepth, bspNextDepth);												if (bspPrevDepth != deeperDepth)						{							if (bspCutInter->GetBsp()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspCutInter, cv, sg, deeperDepth))								changeMade = true;						}						if (bspNextDepth != deeperDepth)						{							if (bspCutInter->GetBsp()->IncrementMaxPossibleSectionDepthAfterIntersection(bspCutInter, cv, sg, deeperDepth))								changeMade = true;						}						break;					case GenericIntersection::BSP_CUT_T:						BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)intersections[i];												if (!bspCutTInter->GetBsp())							break;												cv = bspCutTInter->GetCv();						sg = bspCutTInter->GetSg();												//Get the two depths						bspPrevDepth = bspCutTInter->GetBsp()->GetMaxPossibleSectionDepthBeforeIntersection(bspCutTInter, cv, sg);						bspNextDepth = bspCutTInter->GetBsp()->GetMaxPossibleSectionDepthAfterIntersection(bspCutTInter, cv, sg);												deeperDepth = max(bspPrevDepth, bspNextDepth);												if (bspPrevDepth != deeperDepth)						{							if (bspCutTInter->GetBsp()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspCutTInter, cv, sg, deeperDepth))								changeMade = true;						}						if (bspNextDepth != deeperDepth)						{							if (bspCutTInter->GetBsp()->IncrementMaxPossibleSectionDepthAfterIntersection(bspCutTInter, cv, sg, deeperDepth))								changeMade = true;						}						break;					case GenericIntersection::CUT_CUT:						break;				}								if (gDebug8)				{					FloatPoint intersectionLoc = intersections[i]->GetLocation();					SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);					ForeColor(whiteColor);					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qy = 1;				}			}		}				if (gDebug8)		{			MyAssert(!dtored);						PenSize(1, 1);			SetPort(GetWindowPort(gMainWindow->GetWindow()));			Rect r;			GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);			EraseRect(&r);						Point scrollOffset = {0, 0};			vector<BSpline*> workingBSplines;			DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			PenSize(2, 2);						int qy = 1;		}				if (pass == 0)		{			//Push each segment that is inwardly bounded by two different boundaries down by one			for (int i = 0; i < bsplines.size(); i++)				bsplines[i]->PushDoublyInwardBoundSectionsDownOne();						if (gDebug8)			{				MyAssert(!dtored);								PenSize(1, 1);				SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;				GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);				EraseRect(&r);								Point scrollOffset = {0, 0};				vector<BSpline*> workingBSplines;				DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				PenSize(2, 2);								int qy = 1;			}		}	}		PenSize(1, 1);		if (gDebug8)	{		MyAssert(!dtored);				SetPort(GetWindowPort(gMainWindow->GetWindow()));		Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qy = 1;	}		//Pick the "best" section for BSpline, the section with the shallowest max possible depth	for (int i = 0; i < bsplines.size(); i++)		bsplines[i]->PickShallowestAndDeepestMaxPossibleSection();		//clock_t elapsedTime = clock() - startTime;	//long elapsedTime100ths = elapsedTime / (CLOCKS_PER_SEC / 100);		return true;}bool Drawing::FindBSplineSectionMaxPossibleDepthsV4(){	/*	if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pBeginning max poss sect depths");				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}	clock_t startTime = clock();	*/	for (int i = 0; i < bsplines.size(); i++)		bsplines[i]->InitSectionMaxPossibleDepths();	//Set the max depths to 0	for (int i = 0; i < bsplinePairCuts.size(); i++)		bsplinePairCuts[i]->InitSectionMaxPossibleDepths();	//Set the max depths to 0		if (gDebug8)	{		MyAssert(!dtored);				PenSize(1, 1);		SetPort(GetWindowPort(gMainWindow->GetWindow()));		Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		PenSize(2, 2);				int qy = 1;	}		bool changeMade = true;	int counter = 0;	while (changeMade)	{		if (counter++ > 100)			return false;				changeMade = false;		//Iterate over all the intersections		for (int i = 0; i < intersections.size(); i++)		{			if (gDebug8)			{				SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;				GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);				EraseRect(&r);								Point scrollOffset = {0, 0};				vector<BSpline*> workingBSplines;				DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				PenSize(2, 2);								FloatPoint intersectionLoc = intersections[i]->GetLocation();				SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);				ForeColor(blackColor);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qy = 1;			}						int cv, sg;			int topPrevDepth, topNextDepth, botPrevDepth, botNextDepth;			int bspPrevDepth, bspNextDepth, cutPrevDepth, cutNextDepth, cutDepth;			int deeperDepth, deeperUnoccludedDepth;			int occludedEdge;			bool immediateChangeMade = false;	//debug only			switch (intersections[i]->GetType())			{				case GenericIntersection::BSP_BSP:					BspBspIntersection* bspBspInter = (BspBspIntersection*)intersections[i];										int cv1 = bspBspInter->GetCv1();					int cv2 = bspBspInter->GetCv2();					int sg1 = bspBspInter->GetSg1();					int sg2 = bspBspInter->GetSg2();										//Get the four depths					topPrevDepth = bspBspInter->GetBsp1()->GetMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv1, sg1);					topNextDepth = bspBspInter->GetBsp1()->GetMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv1, sg1);					botPrevDepth = bspBspInter->GetBsp2()->GetMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv2, sg2);					botNextDepth = bspBspInter->GetBsp2()->GetMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv2, sg2);										occludedEdge = bspBspInter->DetermineOccludedEdge();										if (occludedEdge == 3)	//Potentially occluded edges are topNext and botPrev					{						if (topNextDepth != topPrevDepth + 1)	//Top needs change						{							if (topNextDepth < topPrevDepth + 1)	//TopNext needs to be pushed down								bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv1, sg1, topPrevDepth + 1);							else	//TopPrev needs to be pushed down							{								MyAssert(topNextDepth > topPrevDepth + 1);								bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv1, sg1, topNextDepth - 1);							}							immediateChangeMade = changeMade = true;						}												if (botNextDepth != botPrevDepth - 1)	//Bottom needs change						{							if (botNextDepth < botPrevDepth - 1)	//BotNext needs to be pushed down								bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv2, sg2, botPrevDepth - 1);							else	//BotPrev needs to be pushed down							{								MyAssert(botNextDepth > botPrevDepth - 1);								bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv2, sg2, botNextDepth + 1);							}							immediateChangeMade = changeMade = true;						}												//Once both edges are legal with respect to their own two halves, make them legal with respect to each other as well						topPrevDepth = bspBspInter->GetBsp1()->GetMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv1, sg1);						botNextDepth = bspBspInter->GetBsp2()->GetMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv2, sg2);						if (topPrevDepth != botNextDepth)						{							deeperUnoccludedDepth = max(topPrevDepth, botNextDepth);														if (topPrevDepth < deeperUnoccludedDepth)							{								bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv1, sg1, deeperUnoccludedDepth);								bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv1, sg1, deeperUnoccludedDepth + 1);							}							else							{								MyAssert(botNextDepth < deeperUnoccludedDepth);								bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv2, sg2, deeperUnoccludedDepth + 1);								bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv2, sg2, deeperUnoccludedDepth);							}														immediateChangeMade = changeMade = true;						}					}					else	//occludedEdge == 4		//Potentially occluded edges are topPrev and botNext					{						if (topNextDepth != topPrevDepth - 1)	//Top needs change						{							if (topNextDepth < topPrevDepth - 1)	//TopNext needs to be pushed down								bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv1, sg1, topPrevDepth - 1);							else	//TopPrev needs to be pushed down							{								MyAssert(topNextDepth > topPrevDepth - 1);								bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv1, sg1, topNextDepth + 1);							}							immediateChangeMade = changeMade = true;						}												if (botNextDepth != botPrevDepth + 1)	//Bottom needs change						{							if (botNextDepth < botPrevDepth + 1)	//BotNext needs to be pushed down								bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv2, sg2, botPrevDepth + 1);							else	//BotPrev needs to be pushed down							{								MyAssert(botNextDepth > botPrevDepth + 1);								bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv2, sg2, botNextDepth - 1);							}							immediateChangeMade = changeMade = true;						}												//Once both edges are legal with respect to their own two halves, make them legal with respect to each other as well						topNextDepth = bspBspInter->GetBsp1()->GetMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv1, sg1);						botPrevDepth = bspBspInter->GetBsp2()->GetMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv2, sg2);						if (topNextDepth != botPrevDepth)						{							deeperUnoccludedDepth = max(topNextDepth, botPrevDepth);														if (topNextDepth < deeperUnoccludedDepth)							{								bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv1, sg1, deeperUnoccludedDepth + 1);								bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv1, sg1, deeperUnoccludedDepth);							}							else							{								MyAssert(botPrevDepth < deeperUnoccludedDepth);								bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspBspInter, cv2, sg2, deeperUnoccludedDepth);								bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthAfterIntersection(bspBspInter, cv2, sg2, deeperUnoccludedDepth + 1);							}														immediateChangeMade = changeMade = true;						}					}					break;				case GenericIntersection::BSP_CUT:					BspCutIntersection* bspCutInter = (BspCutIntersection*)intersections[i];										cv = bspCutInter->GetCv();					sg = bspCutInter->GetSg();										//Get the four depths					bspPrevDepth = bspCutInter->GetBsp()->GetMaxPossibleSectionDepthBeforeIntersection(bspCutInter, cv, sg);					bspNextDepth = bspCutInter->GetBsp()->GetMaxPossibleSectionDepthAfterIntersection(bspCutInter, cv, sg);					cutPrevDepth = bspCutInter->GetCut()->GetMaxPossibleSectionDepthBeforeIntersection(bspCutInter);					cutNextDepth = bspCutInter->GetCut()->GetMaxPossibleSectionDepthAfterIntersection(bspCutInter);										occludedEdge = bspCutInter->DetermineOccludedEdgeIgnoreTopBottom();										deeperDepth = max(bspPrevDepth, bspNextDepth);										if (bspPrevDepth != deeperDepth)					{						if (bspCutInter->GetBsp()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspCutInter, cv, sg, deeperDepth))							immediateChangeMade = changeMade = true;					}					if (bspNextDepth != deeperDepth)					{						if (bspCutInter->GetBsp()->IncrementMaxPossibleSectionDepthAfterIntersection(bspCutInter, cv, sg, deeperDepth))							immediateChangeMade = changeMade = true;					}										if (occludedEdge == 1)	//Cut is occluded on the start side of the intersection					{						if (cutPrevDepth != cutNextDepth + 1)						{							if (cutPrevDepth < cutNextDepth + 1)	//CutPrev needs to be pushed down								MyAssert(bspCutInter->GetCut()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspCutInter, cutNextDepth + 1));							else	//CutNext needs to be pushed down							{								MyAssert(cutPrevDepth > cutNextDepth + 1);								MyAssert(bspCutInter->GetCut()->IncrementMaxPossibleSectionDepthAfterIntersection(bspCutInter, cutPrevDepth - 1));							}							immediateChangeMade = changeMade = true;						}					}					else //occludedEdge == 2	//Cut is occluded on the end side of the intersection					{						MyAssert(occludedEdge == 2);						if (cutPrevDepth != cutNextDepth - 1)						{							if (cutPrevDepth < cutNextDepth - 1)	//CutPrev needs to be pushed down								MyAssert(bspCutInter->GetCut()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspCutInter, cutNextDepth - 1));							else	//CutNext needs to be pushed down							{								MyAssert(cutPrevDepth > cutNextDepth - 1);								MyAssert(bspCutInter->GetCut()->IncrementMaxPossibleSectionDepthAfterIntersection(bspCutInter, cutPrevDepth + 1));							}							immediateChangeMade = changeMade = true;						}					}					break;				case GenericIntersection::BSP_CUT_T:					BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)intersections[i];										if (!bspCutTInter->GetBsp())						break;										cv = bspCutTInter->GetCv();					sg = bspCutTInter->GetSg();										//Get the three depths					bspPrevDepth = bspCutTInter->GetBsp()->GetMaxPossibleSectionDepthBeforeIntersection(bspCutTInter, cv, sg);					bspNextDepth = bspCutTInter->GetBsp()->GetMaxPossibleSectionDepthAfterIntersection(bspCutTInter, cv, sg);					if (bspCutTInter->GetAtStart())						cutDepth = bspCutTInter->GetCut()->GetMaxPossibleSectionDepthAfterIntersection(bspCutTInter);					else cutDepth = bspCutTInter->GetCut()->GetMaxPossibleSectionDepthBeforeIntersection(bspCutTInter);										deeperDepth = max(max(bspPrevDepth, bspNextDepth), cutDepth);										if (bspPrevDepth != deeperDepth)					{						if (bspCutTInter->GetBsp()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspCutTInter, cv, sg, deeperDepth))							immediateChangeMade = changeMade = true;					}					if (bspNextDepth != deeperDepth)					{						if (bspCutTInter->GetBsp()->IncrementMaxPossibleSectionDepthAfterIntersection(bspCutTInter, cv, sg, deeperDepth))							immediateChangeMade = changeMade = true;					}					if (cutDepth != deeperDepth)					{						if (bspCutTInter->GetAtStart())							MyAssert(bspCutTInter->GetCut()->IncrementMaxPossibleSectionDepthAfterIntersection(bspCutTInter, deeperDepth));						else MyAssert(bspCutTInter->GetCut()->IncrementMaxPossibleSectionDepthBeforeIntersection(bspCutTInter, deeperDepth));						immediateChangeMade = changeMade = true;					}					break;				case GenericIntersection::CUT_CUT:					CutCutIntersection* cutCutInter = (CutCutIntersection*)intersections[i];										//Get the four depths					topPrevDepth = cutCutInter->GetCut1()->GetMaxPossibleSectionDepthBeforeIntersection(cutCutInter);					topNextDepth = cutCutInter->GetCut1()->GetMaxPossibleSectionDepthAfterIntersection(cutCutInter);					botPrevDepth = cutCutInter->GetCut2()->GetMaxPossibleSectionDepthBeforeIntersection(cutCutInter);					botNextDepth = cutCutInter->GetCut2()->GetMaxPossibleSectionDepthAfterIntersection(cutCutInter);										deeperDepth = max(topPrevDepth, topNextDepth);										if (topPrevDepth != deeperDepth)					{						MyAssert(cutCutInter->GetCut1()->IncrementMaxPossibleSectionDepthBeforeIntersection(cutCutInter, deeperDepth));						immediateChangeMade = changeMade = true;					}					if (topNextDepth != deeperDepth)					{						MyAssert(cutCutInter->GetCut1()->IncrementMaxPossibleSectionDepthAfterIntersection(cutCutInter, deeperDepth));						immediateChangeMade = changeMade = true;					}										deeperDepth = max(botPrevDepth, botNextDepth);										if (botPrevDepth != deeperDepth)					{						MyAssert(cutCutInter->GetCut2()->IncrementMaxPossibleSectionDepthBeforeIntersection(cutCutInter, deeperDepth));						immediateChangeMade = changeMade = true;					}					if (botNextDepth != deeperDepth)					{						MyAssert(cutCutInter->GetCut2()->IncrementMaxPossibleSectionDepthAfterIntersection(cutCutInter, deeperDepth));						immediateChangeMade = changeMade = true;					}					break;			}						if (gDebug8)			{								SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;				GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);				EraseRect(&r);								Point scrollOffset = {0, 0};				vector<BSpline*> workingBSplines;				DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				PenSize(2, 2);								if (immediateChangeMade)				{					FloatPoint intersectionLoc = intersections[i]->GetLocation();					SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);					ForeColor(redColor);					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qy = 1;				}								FloatPoint intersectionLoc = intersections[i]->GetLocation();				SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);				ForeColor(whiteColor);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qy = 1;			}		}	}		PenSize(1, 1);		if (gDebug8)	{		MyAssert(!dtored);				SetPort(GetWindowPort(gMainWindow->GetWindow()));		Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qy = 1;	}		//Pick the "best" section for BSpline, the section with the shallowest max possible depth	for (int i = 0; i < bsplines.size(); i++)		bsplines[i]->PickShallowestAndDeepestMaxPossibleSection();	/*	clock_t timeUsed = clock() - startTime;	if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pSeconds used: ");				Str255 str1;				long double timeUsedSecs = timeUsed / CLOCKS_PER_SEC;		FloatToPascal(timeUsedSecs, 3, str1);		DrawString(str1);				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}	*/	return true;}void Drawing::RandomizeCrossingStates(){	for (int j = 0; j < 10; j++)	//Really shouldn't do anything useful, but what the heck		for (int i = 0; i < intersections.size(); i++)				if (RandZeroInt(2) == 0)					intersections[i]->FlipTopBottom();}void Drawing::SortBSplineCrossingStates(){	for (int i = 0; i < intersections.size(); i++)	{		switch (intersections[i]->GetType())		{			case GenericIntersection::BSP_BSP:				BspBspIntersection* bspBspInter = (BspBspIntersection*)intersections[i];				BSpline* bsp1 = bspBspInter->GetBsp1();				BSpline* bsp2 = bspBspInter->GetBsp2();				int bsp1index = GetBSplineIndex(bsp1);				int bsp2index = GetBSplineIndex(bsp2);								if (bsp1index < bsp2index)					intersections[i]->FlipTopBottom();				break;			case GenericIntersection::BSP_CUT:				BspCutIntersection* bspCutInter = (BspCutIntersection*)intersections[i];				break;			case GenericIntersection::BSP_CUT_T:				BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)intersections[i];				break;			case GenericIntersection::CUT_CUT:				CutCutIntersection* cutCutInter = (CutCutIntersection*)intersections[i];				break;		}	}}bool Drawing::FlipAndLabel(int intersectionPoint){	MyAssert(interCompanionPairSets.size() == 0);	//This is no longer used, it should always be empty (delete it from the code at some future point).		ClearAnalysisWindow();		if (gDebug14)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pBeginning flip and label");				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}		if (gDebug5)	{		gMainWindow->WriteLogData(string("Separator"), string("---------------"));				//Find the companion set for the intersection		int compSetIndex = -1;		bool foundIt = false;		for (compSetIndex = 0; compSetIndex < interCompanionSets.size(); compSetIndex++)	//Loop through the sets			if (find(interCompanionSets[compSetIndex]->begin(), interCompanionSets[compSetIndex]->end(), intersections[intersectionPoint]) != interCompanionSets[compSetIndex]->end())			{				foundIt = true;				break;			}		if (foundIt)		{			stringstream ss;			ss << interCompanionSets[compSetIndex]->size();			gMainWindow->WriteLogData(string("CSEC_Size"), ss.str());		}		else gMainWindow->WriteLogData(string("CSEC_Size"), string("no_CSEC_found"));				stringstream ss1;		ss1 << intersections.size();		gMainWindow->WriteLogData(string("Total_Inters"), ss1.str());				gMainWindow->WriteSearchParametersToLog();				FloatPoint interLoc = intersections[intersectionPoint]->GetLocation();		stringstream ss2;		ss2 << intersectionPoint << "\t" << interLoc.h << "\t" << interLoc.v;		gMainWindow->WriteLogData(string("Intersection"), ss2.str());				InitAnalysisWindow();	}		gMouseTerminated = false;	while (Button());	mouseDownAtStartOfAttempt = Button();	SetPort(GetWindowPort(gMainWindow->GetWindow()));	GetMouse(&mouseLocAtStartOfAttempt);	mouseSensitive = false;		clock_t startTime = clock();		bool result;		if (gLabelingMethod == 0)		result = FlipAndLabelUsingTreeSearch(intersectionPoint);	else if (gLabelingMethod == 1)		result = FlipAndLabelUsingUniqueCompSet(intersectionPoint);		clock_t timeUsed = clock() - startTime;	if (gDebug5)	{		InitAnalysisWindow();				IncrementTextV();		MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pTotal seconds used: ");				Str255 str1;		string string1;				long double timeUsedSecs = timeUsed / CLOCKS_PER_SEC;		FloatToPascal(timeUsedSecs, 5, str1);		DrawString(str1);				PascalToString(str1, string1);		gMainWindow->WriteLogData(string("Total_time"), string1);		InitAnalysisWindow();				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}		return result;}bool Drawing::FlipAndLabelUsingTreeSearch(int intersectionPoint){	if (gDebug14)	{		InitAnalysisWindow();				IncrementTextV();		MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pBeginning flip and tree search labeling");				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}		clock_t timeStarted = clock();		//Flip the intersection	FlipIntersection(intersectionPoint);		MyAssert(intersections[intersectionPoint]->GetType() == GenericIntersection::BSP_BSP);	BspBspIntersection* bspBspInter = (BspBspIntersection*)intersections[intersectionPoint];	MyAssert(bspBspInter->GetHardConstraint());		//Start a list of "touched bsplines".  The tree search will have to fully traverse all touched bsplines before a node is called a "leaf".	vector<int> touchedBSplineIndexes;	BSpline* bsp1 = bspBspInter->GetBsp1();	BSpline* bsp2 = bspBspInter->GetBsp2();		UpdateTouchedBSplines(GetBSplineIndex(bsp1), touchedBSplineIndexes);	UpdateTouchedBSplines(GetBSplineIndex(bsp2), touchedBSplineIndexes);		if (gDepthEnumerationMethod != 0)		if (!FindBSplineSectionMaxPossibleDepthsV4())		{			ClearBrandNewIntersections();			SetAllIntersectionsNoHardConstraint();			SetAllSectionsNoHardConstraint();			return false;		}		//Calculate the horizon distance of every intersection to the flipped intersection	if (gTreeSearchMethod == 1)	{		vector<GenericIntersection*> contentiousInters;		contentiousInters.push_back(bspBspInter);		gInterDists.clear();		FindAllIntersectionContentionDistances(contentiousInters, gInterDists);		if (gDebug)			DrawContentionIntersectionDistances(gInterDists);	}		int numPossibleDepths;	GenericIntersection* nextBspFirstInter = NULL;	if (gDepthEnumerationMethod == 0)	{		//The number of possible depths for a bspline is half the number of intersections in its group		vector<GenericIntersection*> groupInters = GetOneBSplineGroupIntersections(bsplines[touchedBSplineIndexes[0]]);		if (groupInters.size() == 0)			groupInters = bsplines[touchedBSplineIndexes[0]]->GetIntersections();		int totalInters = groupInters.size();		for (int ii = 0; ii < groupInters.size(); ii++)			if (groupInters[ii]->SelfIntersection() || groupInters[ii]->GetType() == GenericIntersection::BSP_CUT_T)				totalInters--;		numPossibleDepths = max(2, totalInters / 2);				//nextBspFirstInter = intersections[intersectionPoint];				nextBspFirstInter = bsp1->GetFirstIntersection();		MyAssert(nextBspFirstInter);	}	else if (gDepthEnumerationMethod == 1)	{		int startingSection = bsp1->GetDeepestMaxPossibleSection();		numPossibleDepths = bsp1->GetMaxPossibleSectionDepth(startingSection) + 1;		vector<GenericIntersection*> inters = bsp1->GetIntersections();		nextBspFirstInter = inters[startingSection];	}	else if (gDepthEnumerationMethod == 2)	{		int startingSection = bsp1->GetShallowestMaxPossibleSection();		numPossibleDepths = bsp1->GetMaxPossibleSectionDepth(startingSection) + 1;		vector<GenericIntersection*> inters = bsp1->GetIntersections();		nextBspFirstInter = inters[startingSection];	}	MyAssert(!nextBspFirstInter->GetDtored());		PenSize(2, 2);		if (gDebug)	{		int k = 1;	}	Rect r;		WriteSearchParameters();	SetPort(GetWindowPort(gMainWindow->GetWindow()));		sTreeWalk = sTreeWalk2 = sTreeWalk3 = 0;	labelingStartTime = clock();	bool timeLimitReached = false;	int minFlipDelta = 999999, minDepthDelta = 999999;	int accumFlipDelta = 1, accumDepthDelta = 0;	Drawing* minDeltaLeaf = NULL;		bool passMask[2] = { true, true };	if (gCompanionSetMethod == 0)		passMask[0] = false;	if (gCompanionSetMethod == 2)		passMask[1] = false;	MyAssert(passMask[0] || passMask[1]);	//int numPasses = (gCompanionSetMethod != 1) ? 1 : 2;	//int firstPass = (gCompanionSetMethod != 0) ? 0 : 1;	//MyAssert(!(numPasses == 2 && firstPass == 1));		//Find the companion set	MyAssert(interCompanionPairSets.size() == 0);	int compSetIndex = -1;	bool foundIt = false;	/*	for (compSetIndex = 0; compSetIndex < interCompanionPairSets.size(); compSetIndex++)	{		for (int i = 0; i < interCompanionPairSets[compSetIndex]->size(); i++)			if ((*interCompanionPairSets[compSetIndex])[i].first == bspBspInter || (*interCompanionPairSets[compSetIndex])[i].second == bspBspInter)			{				foundIt = true;				break;			}		if (foundIt)			break;	}	*/	//Find the companion set for the intersection	for (compSetIndex = 0; compSetIndex < interCompanionSets.size(); compSetIndex++)	//Loop through the sets		if (find(interCompanionSets[compSetIndex]->begin(), interCompanionSets[compSetIndex]->end(), bspBspInter) != interCompanionSets[compSetIndex]->end())		{			foundIt = true;			break;		}		if (foundIt)		MyAssert(compSetIndex < interCompanionSets.size());//interCompanionPairSets.size());	else if (compSetIndex == interCompanionSets.size())//interCompanionPairSets.size())	{		compSetIndex = -1;		passMask[0] = false;	//If there are no companion sets and the comp set method is 2, this will result in both passes being masked false, so no search will occurr, which makes sense for comp set method 2		//numPasses = 1;	}		vector<GenericIntersection*> compSetInters;	//vector<GenericIntersection*> compSetInters;	if (compSetIndex != -1)	{		/*		//Find the minimal set of unique intersections in the companion set (intersections can be present in the set either once or twice)		for (int i = 0; i < interCompanionPairSets[compSetIndex]->size(); i++)		{			if ((*interCompanionPairSets[compSetIndex])[i].first != bspBspInter &&				find(compSetInters.begin(), compSetInters.end(), (*interCompanionPairSets[compSetIndex])[i].first) == compSetInters.end())				compSetInters.push_back((*interCompanionPairSets[compSetIndex])[i].first);			if ((*interCompanionPairSets[compSetIndex])[i].second != bspBspInter &&				find(compSetInters.begin(), compSetInters.end(), (*interCompanionPairSets[compSetIndex])[i].second) == compSetInters.end())				compSetInters.push_back((*interCompanionPairSets[compSetIndex])[i].second);		}		*/		compSetInters = *interCompanionSets[compSetIndex];		for (vector<GenericIntersection*>::iterator i = compSetInters.begin(); i != compSetInters.end(); i++)			if (*i == bspBspInter)			{				compSetInters.erase(i);				break;			}	}		int companionSetMethod = gCompanionSetMethod;		//First pass: flip and constrain companions	//Second pass: don't flip or constrain companions	int originalAccumDelta = accumFlipDelta;	for (int pass = 0/*firstPass*/; pass < 2/*numPasses + firstPass*/; pass++)	{		if (gDebug14)		{			InitAnalysisWindow();						MoveTo(5, IncrementTextV() * 10 + 5);			DrawString("\pPass ");			Str255 str1;			NumToString(pass, str1);			DrawString(str1);						if (!passMask[pass])			DrawString("\p SKIPPED");						QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);			SetPort(GetWindowPort(gMainWindow->GetWindow()));		}				if (!passMask[pass])			continue;				if (pass == 0)			gCompanionSetMethod = 2;		else if (pass == 1)			gCompanionSetMethod = 0;		else MyAssert(false);				VerifyNothingDtored();		IncrementTextV();		gTextH = 0;				accumFlipDelta = originalAccumDelta;				if (/*gCompanionSetMethod != 0 && */pass == 0 && compSetIndex != -1)		{MyAssert(gCompanionSetMethod != 0);			//Add the comp inters to the accumFlipDelta			accumFlipDelta += compSetInters.size();			if (accumFlipDelta >= minFlipDelta)			{				if (gDebug)				{					FloatPoint intersectionLoc = bspBspInter->GetLocation();					SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 1, intersectionLoc.v + 10);					ForeColor(blackColor);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qMethod2 = 1;				}								break;			}						//Flip and constrain each intersection in the companion set			for (int i = 0; i < compSetInters.size(); i++)			{				compSetInters[i]->FlipTopBottom();				compSetInters[i]->SetHardConstraint(true);								if (gDebug)				{					FloatPoint interLoc = compSetInters[i]->GetLocation();					SetRect(&r, interLoc.h - 10, interLoc.v - 10, interLoc.h + 10, interLoc.v + 10);					ForeColor(magentaColor);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qt = 1;										SetRect(&r, interLoc.h - 10, interLoc.v - 10, interLoc.h + 10, interLoc.v + 10);					ForeColor(redColor);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										qt = 1;				}			}		}				//Iterative deepening.		//Continually reenter the tree with an increasing horizon of flippable intersections.		int maxHorizon = (gTreeSearchMethod == 0) ? 999999 : gInterDists[gInterDists.size() - 1].second;		gHorizon = 0;		while (gHorizon <= maxHorizon)		{			if (gDebug12 && gHorizon != 0)			{				InitAnalysisWindow();								MoveTo(gTextH++ * 7 + 5, gTextV * 10 + 5);				DrawString("\p+");								GetPortBounds(GetWindowPort(gAnalysisWindow), &r);				if (gTextH * 7 + 5 > r.right - 10)				{					gTextH = 0;					IncrementTextV();				}								QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);				SetPort(GetWindowPort(gMainWindow->GetWindow()));			}						for (int i = 0; i < numPossibleDepths; i++)			{				MyAssert(!timeLimitReached);								Drawing* nextLevelLeaf = NULL;				bool oneBetterSolutionFound;				switch (pass)				//switch (gCompanionSetMethod)				{					case 1:					//case 0:						oneBetterSolutionFound = CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod0(0, i, nextBspFirstInter->GetLocation(), touchedBSplineIndexes[0],																											touchedBSplineIndexes, nextLevelLeaf,																											minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																											timeLimitReached);						break;					/*case 1:						oneBetterSolutionFound = CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod1(0, i, nextBspFirstInter->GetLocation(), touchedBSplineIndexes[0],																											touchedBSplineIndexes, nextLevelLeaf,																											minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																											timeLimitReached);						break;*/					case 0:					//case 2:						oneBetterSolutionFound = CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod2(0, i, nextBspFirstInter->GetLocation(), touchedBSplineIndexes[0],																											touchedBSplineIndexes, nextLevelLeaf,																											minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																											timeLimitReached);						break;				}								if (!oneBetterSolutionFound)					MyAssert(!nextLevelLeaf);				else	//better solution found				{					if (minDeltaLeaf)						delete minDeltaLeaf;					MyAssert(nextLevelLeaf);					minDeltaLeaf = nextLevelLeaf;				}								if (timeLimitReached)					break;								if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)// && accumDepthDelta >= minDepthDelta)				//if (accumFlipDelta > minFlipDelta || (minFlipDelta != 999999 && accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))	// еее Not sure about this					break;			}						if (timeLimitReached)				break;						if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)// && accumDepthDelta >= minDepthDelta)			//if (accumFlipDelta > minFlipDelta || (minFlipDelta != 999999 && accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))	// еее Not sure about this				break;						if (gTreeSearchMethod != 1)				break;						gHorizon++;		}				//Undo the companion set changes		if (/*gCompanionSetMethod != 0 && */pass == 0 && compSetIndex != -1)		{MyAssert(gCompanionSetMethod != 0);			//Flip and unconstrain each intersection in the companion set			for (int i = 0; i < compSetInters.size(); i++)			{				compSetInters[i]->FlipTopBottom();				compSetInters[i]->SetHardConstraint(false);								if (gDebug)				{					FloatPoint interLoc = compSetInters[i]->GetLocation();					SetRect(&r, interLoc.h - 10, interLoc.v - 10, interLoc.h + 10, interLoc.v + 10);					ForeColor(whiteColor);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qt = 1;				}			}		}				if (gDebug14)		{			InitAnalysisWindow();						if (minDeltaLeaf)			{				MoveTo(5, IncrementTextV() * 10 + 5);				DrawString("\pSolution after pass, delta: ");				Str255 str1;				NumToString(minFlipDelta, str1);				DrawString(str1);				NumToString(minDepthDelta, str1);				DrawString("\p/");				DrawString(str1);			}			else			{				MoveTo(5, IncrementTextV() * 10 + 5);				DrawString("\pFailed to find a solution this pass");			}						QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);			SetPort(GetWindowPort(gMainWindow->GetWindow()));		}				if (timeLimitReached)			break;	}			gCompanionSetMethod = companionSetMethod;		clock_t searchTimeUsed = clock() - timeStarted;		PenSize(1, 1);		if (minDeltaLeaf)	{		if (gDebug5)		{			InitAnalysisWindow();			MoveTo(5, IncrementTextV() * 10 + 5);			DrawString("\pSolution, delta: ");			Str255 str1;			NumToString(minFlipDelta, str1);			DrawString(str1);			NumToString(minDepthDelta, str1);			DrawString("\p/");			DrawString(str1);		}				MyAssert(!dtored);		MyAssert(!minDeltaLeaf->dtored);				vector<BSpline*> minDeltaLeafBSplines = minDeltaLeaf->bsplines;		for (int i = 0; i < touchedBSplineIndexes.size(); i++)			MyAssert(minDeltaLeafBSplines[touchedBSplineIndexes[i]]->GetAllIntersectionsLegal(true));				*this = *minDeltaLeaf;				for (int i = 0; i < touchedBSplineIndexes.size(); i++)			MyAssert(bsplines[touchedBSplineIndexes[i]]->GetAllIntersectionsLegal(true));				VerticallyCompactDrawing();				for (int i = 0; i < touchedBSplineIndexes.size(); i++)			MyAssert(bsplines[touchedBSplineIndexes[i]]->GetAllIntersectionsLegal(true));				NormalizeDepths();				for (int i = 0; i < touchedBSplineIndexes.size(); i++)			MyAssert(bsplines[touchedBSplineIndexes[i]]->GetAllIntersectionsLegal(true));				vector<BSpline*> testBSplines;		MyAssert(intersections[intersectionPoint]->GetType() == GenericIntersection::BSP_BSP);		BspBspIntersection* intersection = (BspBspIntersection*)intersections[intersectionPoint];		testBSplines.push_back(intersection->GetBsp1());		if (!(intersection->SelfIntersection()))			testBSplines.push_back(intersection->GetBsp2());				for (int i = 0; i < touchedBSplineIndexes.size(); i++)			MyAssert(bsplines[touchedBSplineIndexes[i]]->GetAllIntersectionsLegal(true));				//I'm not clear on why or whether it should be necessary to refind whole objects after performing a flip, at least as long as companion sets are honored.		//Actually, one reason, although this is overkill, is to reassign the infinite background depths to the infinite whole objects.		//FindWholeObjects2(testBSplines, true, false);	//I thought I could just do this on testBSplines, but it loses cuts.		//FindWholeObjects2(bsplines, true, false);	//I wouldn't have thought it should be necessary to do this on all bsplines, but cuts get lost if we only search on the testBSplines list.				for (int i = 0; i < touchedBSplineIndexes.size(); i++)			MyAssert(bsplines[touchedBSplineIndexes[i]]->GetAllIntersectionsLegal(true));				delete minDeltaLeaf;	}	else	{		FlipIntersection(intersectionPoint);				if (gDebug5)		{			InitAnalysisWindow();						MoveTo(5, IncrementTextV() * 10 + 5);			DrawString("\pFailed to find a solution");						QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);			SetPort(GetWindowPort(gMainWindow->GetWindow()));		}	}		clock_t totalTimeUsed = clock() - timeStarted;	clock_t cleanupTimeUsed = totalTimeUsed - searchTimeUsed;		ClearBrandNewIntersections();	SetAllIntersectionsNoHardConstraint();	SetAllSectionsNoHardConstraint();		if (gDebug5)	{		InitAnalysisWindow();				IncrementTextV();		MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pSeconds used: ");				Str255 str1;		string string1, string2;				long double searchTimeSecs = searchTimeUsed / CLOCKS_PER_SEC;		FloatToPascal(searchTimeSecs, 3, str1);		DrawString(str1);				PascalToString(str1, string1);				DrawString("\p    ");		string1 += "\t";				long double cleanupTimeSecs = cleanupTimeUsed / CLOCKS_PER_SEC;		FloatToPascal(cleanupTimeSecs, 3, str1);		DrawString(str1);				PascalToString(str1, string2);		string1 += string2;				DrawString("\p    ");		string1 += "\t";				long double totalTimeSecs = totalTimeUsed / CLOCKS_PER_SEC;		FloatToPascal(totalTimeSecs, 3, str1);		DrawString(str1);				PascalToString(str1, string2);		string1 += string2;				if (!minDeltaLeaf)			gMainWindow->WriteLogData(string("Search_failure"), string("NO SOLUTION FOUND"));				gMainWindow->WriteLogData(string("Running_times"), string1);		gMainWindow->AddRunningTime(searchTimeSecs, sTreeWalk2);		InitAnalysisWindow();				//==========================				string1.clear();				MoveTo(5, IncrementTextV() * 10 + 5);				DrawString("\pNodes visited: ");		NumToString(sTreeWalk, str1);		PascalToString(str1, string1);		DrawString(str1);				DrawString("\p     ");		string1 += "\t";				NumToString(sTreeWalk2, str1);		PascalToString(str1, string2);		string1 += string2;		DrawString(str1);				DrawString("\p     ");		string1 += "\t";				NumToString(sTreeWalk3, str1);		PascalToString(str1, string2);		string1 += string2;		DrawString(str1);				gMainWindow->WriteLogData(string("Nodes_visited"), string1);		InitAnalysisWindow();				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}		return (minDeltaLeaf != NULL);		//===========================================================================================================================		//Convert the drawing to a minimal fast representation	//MinimalDrawing* minimalDrawing = new MinimalDrawing(this);}bool Drawing::FlipAndLabelUsingUniqueCompSet(int intersectionPoint){	WriteSearchParameters();	SetPort(GetWindowPort(gMainWindow->GetWindow()));		clock_t timeStarted = clock();		//Get the intersection	MyAssert(intersectionPoint >= 0 && intersectionPoint < intersections.size());	GenericIntersection* intersection = intersections[intersectionPoint];	MyAssert(intersection->GetType() == GenericIntersection::BSP_BSP);	BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;		//Find the companion set for the intersection	int compSetIndex = -1;	bool foundIt = false;	/*	for (compSetIndex = 0; compSetIndex < interCompanionPairSets.size(); compSetIndex++)	{		for (int i = 0; i < interCompanionPairSets[compSetIndex]->size(); i++)			if ((*interCompanionPairSets[compSetIndex])[i].first == bspBspInter || (*interCompanionPairSets[compSetIndex])[i].second == bspBspInter)			{				foundIt = true;				break;			}		if (foundIt)			break;	}	*/	//Find the companion set for the intersection	for (compSetIndex = 0; compSetIndex < interCompanionSets.size(); compSetIndex++)	//Loop through the sets		if (find(interCompanionSets[compSetIndex]->begin(), interCompanionSets[compSetIndex]->end(), intersection) != interCompanionSets[compSetIndex]->end())		{			foundIt = true;			break;		}		if (!foundIt && gDebug5)	{		InitAnalysisWindow();		MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pIntersection is not in a companion set");		MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pIntersection could not be flipped");				return false;	}	//MyAssert(compSetIndex >= 0 && compSetIndex < interCompanionPairSets.size());	MyAssert(compSetIndex >= 0 && compSetIndex < interCompanionSets.size());	/*	//Find the minimal set of unique intersections in the companion set (intersections can be present in the set either once or twice)	vector<BspBspIntersection*> compSetInters;	for (int i = 0; i < interCompanionPairSets[compSetIndex]->size(); i++)	{		if (find(compSetInters.begin(), compSetInters.end(), (*interCompanionPairSets[compSetIndex])[i].first) == compSetInters.end())			compSetInters.push_back((BspBspIntersection*)(*interCompanionPairSets[compSetIndex])[i].first);		if (find(compSetInters.begin(), compSetInters.end(), (*interCompanionPairSets[compSetIndex])[i].second) == compSetInters.end())			compSetInters.push_back((BspBspIntersection*)(*interCompanionPairSets[compSetIndex])[i].second);	}	MyAssert(find(compSetInters.begin(), compSetInters.end(), bspBspInter) != compSetInters.end());	vector<BspBspIntersection*>* compSetInters1 = &compSetInters;	*/	vector<GenericIntersection*>* compSetInters1 = (vector<GenericIntersection*>*)interCompanionSets[compSetIndex];		//For every intersection in the companion set, check if the top and bottom boundaries of the intersection have a surface between them.	//If this is true for any intersection in the companion set, the intersections cannot be flipped.	BSpline* bsp1 = bspBspInter->GetBsp1();	vector<GenericIntersection*> gapInters;	for (int i = 0; i < compSetInters1->size(); i++)	{		if ((*compSetInters1)[i]->GetType() == GenericIntersection::BSP_BSP)		{			BspBspIntersection* bspBspInter = (BspBspIntersection*)(*compSetInters1)[i];						BSpline* bsp1 = bspBspInter->GetBsp1();			BSpline* bsp2 = bspBspInter->GetBsp2();			int cv1 = bspBspInter->GetCv1();			int cv2 = bspBspInter->GetCv2();			int sg1 = bspBspInter->GetSg1();			int sg2 = bspBspInter->GetSg2();						int depth1before = bsp1->GetSectionDepthBeforeIntersection(bspBspInter, cv1, sg1);			int depth1after = bsp1->GetSectionDepthAfterIntersection(bspBspInter, cv1, sg1);			int depth2before = bsp2->GetSectionDepthBeforeIntersection(bspBspInter, cv2, sg2);			int depth2after = bsp2->GetSectionDepthAfterIntersection(bspBspInter, cv2, sg2);						MyAssert(depth1before == depth1after);			MyAssert(fabs(depth2before - depth2after) == 1);			int topBottomDepthDiff = min(depth2before, depth2after) - depth1before;			MyAssert(topBottomDepthDiff >= 0);						if (topBottomDepthDiff != 0)				gapInters.push_back(bspBspInter);		}		/*else	//BspCut inter in the comp set.  This shouldn't be a candidate for gap checking since cuts are supposed to be invisible to the user.		{			MyAssert((*compSetInters1)[i]->GetType() == GenericIntersection::BSP_CUT);			BspCutIntersection* bspCutInter = (BspCutIntersection*)(*compSetInters1)[i];						BSpline* bsp = bspCutInter->GetBsp();			BSplineToBSplineCut* cut = bspCutInter->GetCut();			int cv = bspCutInter->GetCv();			int sg = bspCutInter->GetSg();						int depth1before1 = bsp->GetSectionDepthBeforeIntersection(bspCutInter, cv, sg);			int depth1after1 = bsp->GetSectionDepthAfterIntersection(bspCutInter, cv, sg);			int depth2before1 = cut->GetSectionDepthBeforeIntersection(bspCutInter);			int depth2after1 = cut->GetSectionDepthAfterIntersection(bspCutInter);						if (bspCutInter->GetBspOnTop())			{				MyAssert(depth1before1 == depth1after1);				MyAssert(fabs(depth2before1 - depth2after1) == 1);				int topBottomDepthDiff = min(depth2before1, depth2after1) - depth1before1;				MyAssert(topBottomDepthDiff >= 0);								if (topBottomDepthDiff != 0)					gapInters.push_back(bspCutInter);			}			else			{				MyAssert(depth1before1 == depth1after1);				MyAssert(depth2before1 == depth2after1);				int topBottomDepthDiff1 = depth2before1 - depth1before1;				MyAssert(topBottomDepthDiff1 < 0);								if (topBottomDepthDiff1 != -1)					gapInters.push_back(bspCutInter);			}		}*/	}	if (gapInters.size() > 0)	{		if (gDebug5)		{			InitAnalysisWindow();			MoveTo(5, IncrementTextV() * 10 + 5);			DrawString("\pCompanion set has a gap");			MoveTo(5, IncrementTextV() * 10 + 5);			DrawString("\pCompanion set could not be flipped");		}				FlashIntersections(gapInters);		DoIntersectionGapError();		return false;	}		Drawing* backup = new Drawing(*this);	SetAllSectionsNoHardConstraint();		//Flip all the intersections in the companion set.	//At the same time, constrain the unoccluded segments of each intersection.	int intersFlipped = 0;	for (int i = 0; i < compSetInters1->size(); i++)	{		if ((*compSetInters1)[i]->GetType() == GenericIntersection::BSP_BSP)		{			BspBspIntersection* bspBspInter = (BspBspIntersection*)(*compSetInters1)[i];			BSpline* bsp1 = bspBspInter->GetBsp1();			BSpline* bsp2 = bspBspInter->GetBsp2();			int cv1 = bspBspInter->GetCv1();			int cv2 = bspBspInter->GetCv2();			int sg1 = bspBspInter->GetSg1();			int sg2 = bspBspInter->GetSg2();						int occludedEdge = bspBspInter->DetermineOccludedEdge();			MyAssert(occludedEdge == 3 || occludedEdge == 4);						if (occludedEdge == 3)	//Potentially occluded segments are 2 and 3			{				bsp1->SetSectionDepthConstraintBeforeIntersection(bspBspInter, cv1, sg1, true);				bsp2->SetSectionDepthConstraintAfterIntersection(bspBspInter, cv2, sg2, true);			}			else	//occludedEdge == 4, so potentially occluded segments are 1 and 4			{				bsp1->SetSectionDepthConstraintAfterIntersection(bspBspInter, cv1, sg1, true);				bsp2->SetSectionDepthConstraintBeforeIntersection(bspBspInter, cv2, sg2, true);			}						bspBspInter->FlipTopBottom();			intersFlipped++;		}		else		{			MyAssert((*compSetInters1)[i]->GetType() == GenericIntersection::BSP_CUT);			BspCutIntersection* bspCutInter = (BspCutIntersection*)(*compSetInters1)[i];			BSpline* bsp = bspCutInter->GetBsp();			BSplineToBSplineCut* cut = bspCutInter->GetCut();			int cv = bspCutInter->GetCv();			int sg = bspCutInter->GetSg();						int occludedEdge = bspCutInter->DetermineOccludedEdgeIgnoreTopBottom();			MyAssert(occludedEdge == 1 || occludedEdge == 2);						if (occludedEdge == 1)	//Potentially occluded segment is cut before intersection			{				cut->SetSectionDepthConstraintAfterIntersection(bspCutInter, true);			}			else	//occludedEdge == 2, so potentially occluded segment is cut after intersection			{				cut->SetSectionDepthConstraintBeforeIntersection(bspCutInter, true);			}						bspCutInter->FlipTopBottom();			intersFlipped++;		}	}	MyAssert(intersFlipped == compSetInters1->size());		//Start a queue that will collect intersections that need to have their four segment depths cleaned up.	//Seed the queue with the intersections from the companion set.	list<GenericIntersection*> cleanUpInters;	for (int i = 0; i < compSetInters1->size(); i++)		cleanUpInters.push_back((*compSetInters1)[i]);		if (gDebug)	{		PenSize(2, 2);		ForeColor(yellowColor);		for (list<GenericIntersection*>::iterator iter = cleanUpInters.begin(); iter != cleanUpInters.end(); iter++)		{			FloatPoint intersectionLoc = (*iter)->GetLocation();			Rect r;			SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}				int qB = 1;				ForeColor(whiteColor);		for (list<GenericIntersection*>::iterator iter = cleanUpInters.begin(); iter != cleanUpInters.end(); iter++)		{			FloatPoint intersectionLoc = (*iter)->GetLocation();			Rect r;			SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}	}		clock_t timeStarted1 = clock();		//Loop through the queue fixing each intersection's four segment depths and propagating through the drawing.	//Don't add an intersection to the queue more than once.	bool successfulLabeling = false;	int segDepthsChanged = 0;	PenSize(2, 2);	for (list<GenericIntersection*>::iterator iter = cleanUpInters.begin(); iter != cleanUpInters.end(); iter++)	{		GenericIntersection* inter = *iter;				if (gDebug)		{			FloatPoint intersectionLoc = (*iter)->GetLocation();			Rect r;			SetRect(&r, max(intersectionLoc.h, 0.0) - 15, intersectionLoc.v - 15, max(intersectionLoc.h, 0.0) + 15, intersectionLoc.v + 15);			ForeColor(blackColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qB = 1;		}				//So long as there are nonBspCut inters remaining in the list, postpone BspCut inters until the end of the list		if (inter->GetType() == GenericIntersection::BSP_CUT)		{			bool skipIt = false;			list<GenericIntersection*>::iterator iter1 = iter;			iter1++;			for (; iter1 != cleanUpInters.end(); iter1++)				if ((*iter1)->GetType() != GenericIntersection::BSP_CUT)				{					skipIt = true;					break;				}			if (skipIt)			{				if (gDebug)				{					FloatPoint intersectionLoc = (*iter)->GetLocation();					Rect r;					SetRect(&r, max(intersectionLoc.h, 0.0) - 15, intersectionLoc.v - 15, max(intersectionLoc.h, 0.0) + 15, intersectionLoc.v + 15);					ForeColor(cyanColor);					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qB = 1;										ForeColor(whiteColor);					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				}								cleanUpInters.push_back(*iter);				continue;			}		}				if (gDebug)		{			FloatPoint intersectionLoc = (*iter)->GetLocation();			Rect r;			SetRect(&r, max(intersectionLoc.h, 0.0) - 15, intersectionLoc.v - 15, max(intersectionLoc.h, 0.0) + 15, intersectionLoc.v + 15);			ForeColor(blueColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qB = 1;		}				list<GenericIntersection*>::iterator prevEnd = cleanUpInters.end();		prevEnd--;				switch (inter->GetType())		{			case GenericIntersection::BSP_BSP:				successfulLabeling = FixIntersectionSegmentDepths((BspBspIntersection*)inter, cleanUpInters, segDepthsChanged);				break;			case GenericIntersection::BSP_CUT:				successfulLabeling = FixIntersectionSegmentDepths((BspCutIntersection*)inter, cleanUpInters, segDepthsChanged);				break;			case GenericIntersection::BSP_CUT_T:				successfulLabeling = FixIntersectionSegmentDepths((BspCutTIntersection*)inter, cleanUpInters, segDepthsChanged);				break;			case GenericIntersection::CUT_CUT:				successfulLabeling = FixIntersectionSegmentDepths((CutCutIntersection*)inter, cleanUpInters, segDepthsChanged);				break;		}				if (gDebug)		{			FloatPoint intersectionLoc = inter->GetLocation();			Rect r;			SetRect(&r, max(intersectionLoc.h, 0.0) - 15, intersectionLoc.v - 15, max(intersectionLoc.h, 0.0) + 15, intersectionLoc.v + 15);			if (successfulLabeling)				ForeColor(greenColor);			else ForeColor(redColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qB = 1;						ForeColor(whiteColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}				if (!successfulLabeling)		{			vector<GenericIntersection*> flashInters;			for (list<GenericIntersection*>::iterator iter1 = cleanUpInters.begin(); iter1 != cleanUpInters.end(); iter1++)				if (((*iter1)->GetType() == GenericIntersection::BSP_BSP || (*iter1)->GetType() == GenericIntersection::BSP_CUT) &&					find(flashInters.begin(), flashInters.end(), *iter1) == flashInters.end() &&					find(compSetInters1->begin(), compSetInters1->end(), *iter1) == compSetInters1->end())				{					//Find the companion set for the intersection					int compSetIndex1 = 0;					foundIt = false;					for (compSetIndex1 = 0; compSetIndex1 < interCompanionSets.size(); compSetIndex1++)	//Loop through the sets						if (find(interCompanionSets[compSetIndex1]->begin(), interCompanionSets[compSetIndex1]->end(), *iter1) != interCompanionSets[compSetIndex1]->end())						{							foundIt = true;							break;						}					//MyAssert(foundIt);					if (foundIt)						MyAssert(compSetIndex1 < interCompanionSets.size());										if (foundIt)						for (int i = 0; i < interCompanionSets[compSetIndex1]->size(); i++)							flashInters.push_back((*interCompanionSets[compSetIndex1])[i]);					else flashInters.push_back(*iter1);				}						FlashIntersections(flashInters);			DoIntersectionFlipConstraintError();						break;		}				if (gDebug)		{			ForeColor(yellowColor);			list<GenericIntersection*>::iterator iter1 = prevEnd;			iter1++;			for (; iter1 != cleanUpInters.end(); iter1++)			{				FloatPoint intersectionLoc = (*iter1)->GetLocation();				Rect r;				SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			}						int qB = 1;						ForeColor(whiteColor);			iter1 = prevEnd;			iter1++;			for (; iter1 != cleanUpInters.end(); iter1++)			{				FloatPoint intersectionLoc = (*iter1)->GetLocation();				Rect r;				SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			}		}	}	PenSize(1, 1);		clock_t flipTimeUsed1 = clock() - timeStarted1;	clock_t flipTimeUsed = clock() - timeStarted;	/*	if (gDebug5)	{		InitAnalysisWindow();		MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pQueue length: ");		Str255 str1;		NumToString(cleanUpInters.size(), str1);		DrawString(str1);	}	*/	if (successfulLabeling)	{		VerticallyCompactDrawing();		NormalizeDepths();				if (gDebug)			for (int i = 0; i < interCompanionSets.size(); i++)				if (interCompanionSets[i]->size() > 0)				{					SetPort(GetWindowPort(gMainWindow->GetWindow()));										Rect r;					GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);					EraseRect(&r);					//gMainWindow->DrawGrid();										Point scrollOffset = {0, 0};					vector<BSpline*> workingBSplines;					DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);										PenSize(2, 2);					ForeColor(yellowColor);					for (int j = 0; j < interCompanionSets[i]->size(); j++)					{						FloatPoint loc = (*interCompanionSets[i])[j]->GetLocation();						SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);						FrameOval(&r);					}					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);					int dg3 = 1;										ForeColor(whiteColor);					for (int j = 0; j < interCompanionSets[i]->size(); j++)					{						FloatPoint loc = (*interCompanionSets[i])[j]->GetLocation();						SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);						FrameOval(&r);					}					PenSize(1, 1);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				}				//I'm not clear on why or whether it should be necessary to refind whole objects after performing a flip, at least as long as companion sets are honored.		//Actually, one reason, although this is overkill, is to reassign the infinite background depths to the infinite whole objects.		//FindWholeObjects2(testBSplines, true, false);	//I thought I could just do this on testBSplines, but it loses cuts.		//FindWholeObjects2(bsplines, true, false);	//I wouldn't have thought it should be necessary to do this on all bsplines, but cuts get lost if we only search on the testBSplines list.				if (gDebug)			for (int i = 0; i < interCompanionSets.size(); i++)				if (interCompanionSets[i]->size() > 0)				{					SetPort(GetWindowPort(gMainWindow->GetWindow()));										Rect r;					GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);					EraseRect(&r);					//gMainWindow->DrawGrid();										Point scrollOffset = {0, 0};					vector<BSpline*> workingBSplines;					DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);										PenSize(2, 2);					ForeColor(blackColor);					for (int j = 0; j < interCompanionSets[i]->size(); j++)					{						FloatPoint loc = (*interCompanionSets[i])[j]->GetLocation();						SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);						FrameOval(&r);					}					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);					int dg3 = 1;										ForeColor(whiteColor);					for (int j = 0; j < interCompanionSets[i]->size(); j++)					{						FloatPoint loc = (*interCompanionSets[i])[j]->GetLocation();						SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);						FrameOval(&r);					}					PenSize(1, 1);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				}	}	else	{		if (gDebug5)		{			InitAnalysisWindow();			MoveTo(5, IncrementTextV() * 10 + 5);			DrawString("\pIntersection flip hit unresolvable constraint");			MoveTo(5, IncrementTextV() * 10 + 5);			DrawString("\pIntersection could not be flipped");		}				*this = *backup;	}	delete backup;		clock_t totalTimeUsed = clock() - timeStarted;	clock_t cleanupTimeUsed = totalTimeUsed - flipTimeUsed;		ClearBrandNewIntersections();	SetAllIntersectionsNoHardConstraint();	SetAllSectionsNoHardConstraint();		if (gDebug5)	{		InitAnalysisWindow();				IncrementTextV();		MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pSeconds used: ");				Str255 str1;		string string1, string2;				long double flipTimeSecs = flipTimeUsed / CLOCKS_PER_SEC;		FloatToPascal(flipTimeSecs, 5, str1);		DrawString(str1);				PascalToString(str1, string1);		/*		long double flipTimeSecs1 = flipTimeUsed1 / CLOCKS_PER_SEC;		FloatToPascal(flipTimeSecs1, 5, str1);		DrawString("\p    ");		DrawString(str1);		*/		DrawString("\p    ");		string1 += "\t";				long double cleanupTimeSecs = cleanupTimeUsed / CLOCKS_PER_SEC;		FloatToPascal(cleanupTimeSecs, 5, str1);		DrawString(str1);				PascalToString(str1, string2);		string1 += string2;				DrawString("\p    ");		string1 += "\t";				long double totalTimeSecs = totalTimeUsed / CLOCKS_PER_SEC;		FloatToPascal(totalTimeSecs, 5, str1);		DrawString(str1);				PascalToString(str1, string2);		string1 += string2;				if (!successfulLabeling)			gMainWindow->WriteLogData(string("Search_failure"), string("NO SOLUTION FOUND"));				gMainWindow->WriteLogData(string("Running_times"), string1);		gMainWindow->AddRunningTime(flipTimeSecs, 0);		InitAnalysisWindow();				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}		return successfulLabeling;}bool Drawing::FixIntersectionSegmentDepths(BspBspIntersection* intersection, list<GenericIntersection*>& cleanUpInters, int& segDepthsChanged){	BSpline* bsp1 = intersection->GetBsp1();	BSpline* bsp2 = intersection->GetBsp2();	int cv1 = intersection->GetCv1();	int cv2 = intersection->GetCv2();	int sg1 = intersection->GetSg1();	int sg2 = intersection->GetSg2();		int depth1before = bsp1->GetSectionDepthBeforeIntersection(intersection, cv1, sg1);	int depth1after = bsp1->GetSectionDepthAfterIntersection(intersection, cv1, sg1);	int depth2before = bsp2->GetSectionDepthBeforeIntersection(intersection, cv2, sg2);	int depth2after = bsp2->GetSectionDepthAfterIntersection(intersection, cv2, sg2);	/*	MyAssert(depth1before == depth1after);	MyAssert(fabs(depth2before - depth2after) == 1);	int topBottomDepthDiff = min(depth2before, depth2after) - depth1before;	MyAssert(topBottomDepthDiff >= 0);	*/	int occludedEdge = intersection->DetermineOccludedEdge();	MyAssert(occludedEdge == 3 || occludedEdge == 4);		bool constraint1before = bsp1->GetSectionDepthConstraintBeforeIntersection(intersection, cv1, sg1);	bool constraint1after = bsp1->GetSectionDepthConstraintAfterIntersection(intersection, cv1, sg1);	bool constraint2before = bsp2->GetSectionDepthConstraintBeforeIntersection(intersection, cv2, sg2);	bool constraint2after = bsp2->GetSectionDepthConstraintAfterIntersection(intersection, cv2, sg2);	//MyAssert(constraint1before || constraint1after || constraint2before || constraint2after);		//Make the top boundary's segments legal with respect to each other	if (depth1after != depth1before)	{		if (constraint1before)		{			if (constraint1after)				return false;			bsp1->SetSectionDepthAfterIntersection(intersection, cv1, sg1, depth1before);			segDepthsChanged++;			GenericIntersection* adjacentInter = bsp1->FindNextIntersection(intersection, cv1, sg1);			if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())			{				cleanUpInters.push_back(adjacentInter);								if (gDebug)				{					FloatPoint intersectionLoc = adjacentInter->GetLocation();					Rect r;					SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);					ForeColor(redColor);					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qB = 1;										ForeColor(whiteColor);					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										qB = 1;				}			}		}		else		{			bsp1->SetSectionDepthBeforeIntersection(intersection, cv1, sg1, depth1after);			segDepthsChanged++;			GenericIntersection* adjacentInter = bsp1->FindPrevIntersection(intersection, cv1, sg1);			if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())			{				cleanUpInters.push_back(adjacentInter);								if (gDebug)				{					FloatPoint intersectionLoc = adjacentInter->GetLocation();					Rect r;					SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);					ForeColor(redColor);					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qB = 1;										ForeColor(whiteColor);					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										qB = 1;				}			}		}	}		if (occludedEdge == 3)	//Potentially occluded segments are 2 and 3	{		//Make the bottom boundary's segments legal with respect to each other		if (depth2before != depth2after + 1)		{			if (constraint2before)			{				if (constraint2after)					return false;				bsp2->SetSectionDepthAfterIntersection(intersection, cv2, sg2, depth2before - 1);				segDepthsChanged++;				GenericIntersection* adjacentInter = bsp2->FindNextIntersection(intersection, cv2, sg2);				if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())				{					cleanUpInters.push_back(adjacentInter);										if (gDebug)					{						FloatPoint intersectionLoc = adjacentInter->GetLocation();						Rect r;						SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);						ForeColor(greenColor);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qB = 1;												ForeColor(whiteColor);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												qB = 1;					}				}			}			else			{				bsp2->SetSectionDepthBeforeIntersection(intersection, cv2, sg2, depth2after + 1);				segDepthsChanged++;				GenericIntersection* adjacentInter = bsp2->FindPrevIntersection(intersection, cv2, sg2);				if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())				{					cleanUpInters.push_back(adjacentInter);										if (gDebug)					{						FloatPoint intersectionLoc = adjacentInter->GetLocation();						Rect r;						SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);						ForeColor(greenColor);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qB = 1;												ForeColor(whiteColor);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												qB = 1;					}				}			}		}				depth1before = bsp1->GetSectionDepthBeforeIntersection(intersection, cv1, sg1);		depth1after = bsp1->GetSectionDepthAfterIntersection(intersection, cv1, sg1);		depth2before = bsp2->GetSectionDepthBeforeIntersection(intersection, cv2, sg2);		depth2after = bsp2->GetSectionDepthAfterIntersection(intersection, cv2, sg2);				if (depth1before != depth1after)		{			//Quick, lazy solution.  Perhaps there is a way to fix this and keep going.  Not sure.			//Note that this occurs in two places in this function.				MyAssert(intersection->SelfIntersection());			return false;		}				MyAssert(depth1before == depth1after);		MyAssert(fabs(depth2before - depth2after) == 1);				//Make the top and bottom boundaries legal with respect to each other		if (depth2after < depth1before)		{			if ((constraint1before || constraint1after) && (constraint2before || constraint2after))				return false;			if (!constraint1before && !constraint1after)	//Top is unconstrained, so push the top			{				if (depth1before > depth2after)				{					bsp1->SetSectionDepthBeforeIntersection(intersection, cv1, sg1, depth2after);					segDepthsChanged++;					GenericIntersection* adjacentInter = bsp1->FindPrevIntersection(intersection, cv1, sg1);					if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())					{						cleanUpInters.push_back(adjacentInter);												if (gDebug)						{							FloatPoint intersectionLoc = adjacentInter->GetLocation();							Rect r;							SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);							ForeColor(blueColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int qB = 1;														ForeColor(whiteColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														qB = 1;						}					}				}				if (depth1after > depth2after)				{					bsp1->SetSectionDepthAfterIntersection(intersection, cv1, sg1, depth2after);					segDepthsChanged++;					GenericIntersection* adjacentInter = bsp1->FindNextIntersection(intersection, cv1, sg1);					if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())					{						cleanUpInters.push_back(adjacentInter);												if (gDebug)						{							FloatPoint intersectionLoc = adjacentInter->GetLocation();							Rect r;							SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);							ForeColor(blueColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int qB = 1;														ForeColor(whiteColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														qB = 1;						}					}				}			}			else	//Bottom is unconstrained, so push the bottom			{				if (depth2before < depth1before + 1)				{					bsp2->SetSectionDepthBeforeIntersection(intersection, cv2, sg2, depth1before + 1);					segDepthsChanged++;					GenericIntersection* adjacentInter = bsp2->FindPrevIntersection(intersection, cv2, sg2);					if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())					{						cleanUpInters.push_back(adjacentInter);												if (gDebug)						{							FloatPoint intersectionLoc = adjacentInter->GetLocation();							Rect r;							SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);							ForeColor(blueColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int qB = 1;														ForeColor(whiteColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														qB = 1;						}					}				}				if (depth2after < depth1before)				{					bsp2->SetSectionDepthAfterIntersection(intersection, cv2, sg2, depth1before);					segDepthsChanged++;					GenericIntersection* adjacentInter = bsp2->FindNextIntersection(intersection, cv2, sg2);					if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())					{						cleanUpInters.push_back(adjacentInter);												if (gDebug)						{							FloatPoint intersectionLoc = adjacentInter->GetLocation();							Rect r;							SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);							ForeColor(blueColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int qB = 1;														ForeColor(whiteColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														qB = 1;						}					}				}			}		}	}	else	//occludedEdge == 4, so potentially occluded segments are 1 and 4	{		//Make the bottom boundary's segments legal with respect to each other		if (depth2after != depth2before + 1)		{			if (constraint2before)			{				if (constraint2after)					return false;				bsp2->SetSectionDepthAfterIntersection(intersection, cv2, sg2, depth2before + 1);				segDepthsChanged++;				GenericIntersection* adjacentInter = bsp2->FindNextIntersection(intersection, cv2, sg2);				if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())				{					cleanUpInters.push_back(adjacentInter);										if (gDebug)					{						FloatPoint intersectionLoc = adjacentInter->GetLocation();						Rect r;						SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);						ForeColor(greenColor);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qB = 1;												ForeColor(whiteColor);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												qB = 1;					}				}			}			else			{				bsp2->SetSectionDepthBeforeIntersection(intersection, cv2, sg2, depth2after - 1);				segDepthsChanged++;				GenericIntersection* adjacentInter = bsp2->FindPrevIntersection(intersection, cv2, sg2);				if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())				{					cleanUpInters.push_back(adjacentInter);										if (gDebug)					{						FloatPoint intersectionLoc = adjacentInter->GetLocation();						Rect r;						SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);						ForeColor(greenColor);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qB = 1;												ForeColor(whiteColor);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												qB = 1;					}				}			}		}				depth1before = bsp1->GetSectionDepthBeforeIntersection(intersection, cv1, sg1);		depth1after = bsp1->GetSectionDepthAfterIntersection(intersection, cv1, sg1);		depth2before = bsp2->GetSectionDepthBeforeIntersection(intersection, cv2, sg2);		depth2after = bsp2->GetSectionDepthAfterIntersection(intersection, cv2, sg2);				if (depth1before != depth1after)		{			//Quick, lazy solution.  Perhaps there is a way to fix this and keep going.  Not sure.			//Note that this occurs in two places in this function.				MyAssert(intersection->SelfIntersection());			return false;		}				MyAssert(depth1before == depth1after);		MyAssert(fabs(depth2before - depth2after) == 1);				//Make the top and bottom boundaries legal with respect to each other		if (depth2before < depth1before)		{			if ((constraint1before || constraint1after) && (constraint2before || constraint2after))				return false;			if (!constraint1before && !constraint1after)	//Top is unconstrained, so push the top			{				if (depth1before > depth2before)				{					bsp1->SetSectionDepthBeforeIntersection(intersection, cv1, sg1, depth2before);					segDepthsChanged++;					GenericIntersection* adjacentInter = bsp1->FindPrevIntersection(intersection, cv1, sg1);					if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())					{						cleanUpInters.push_back(adjacentInter);												if (gDebug)						{							FloatPoint intersectionLoc = adjacentInter->GetLocation();							Rect r;							SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);							ForeColor(blueColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int qB = 1;														ForeColor(whiteColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														qB = 1;						}					}				}				if (depth1after > depth2before)				{					bsp1->SetSectionDepthAfterIntersection(intersection, cv1, sg1, depth2before);					segDepthsChanged++;					GenericIntersection* adjacentInter = bsp1->FindNextIntersection(intersection, cv1, sg1);					if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())					{						cleanUpInters.push_back(adjacentInter);												if (gDebug)						{							FloatPoint intersectionLoc = adjacentInter->GetLocation();							Rect r;							SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);							ForeColor(blueColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int qB = 1;														ForeColor(whiteColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														qB = 1;						}					}				}			}			else	//Bottom is unconstrained, so push the bottom			{				if (depth2before < depth1before)				{					bsp2->SetSectionDepthBeforeIntersection(intersection, cv2, sg2, depth1before);					segDepthsChanged++;					GenericIntersection* adjacentInter = bsp2->FindPrevIntersection(intersection, cv2, sg2);					if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())					{						cleanUpInters.push_back(adjacentInter);												if (gDebug)						{							FloatPoint intersectionLoc = adjacentInter->GetLocation();							Rect r;							SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);							ForeColor(blueColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int qB = 1;														ForeColor(whiteColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														qB = 1;						}					}				}				if (depth2after < depth1before + 1)				{					bsp2->SetSectionDepthAfterIntersection(intersection, cv2, sg2, depth1before + 1);					segDepthsChanged++;					GenericIntersection* adjacentInter = bsp2->FindNextIntersection(intersection, cv2, sg2);					if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())					{						cleanUpInters.push_back(adjacentInter);												if (gDebug)						{							FloatPoint intersectionLoc = adjacentInter->GetLocation();							Rect r;							SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);							ForeColor(blueColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int qB = 1;														ForeColor(whiteColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														qB = 1;						}					}				}			}		}	}		bsp1->SetSectionDepthConstraintBeforeIntersection(intersection, cv1, sg1, true);	bsp1->SetSectionDepthConstraintAfterIntersection(intersection, cv1, sg1, true);	bsp2->SetSectionDepthConstraintBeforeIntersection(intersection, cv2, sg2, true);	bsp2->SetSectionDepthConstraintAfterIntersection(intersection, cv2, sg2, true);		return true;}bool Drawing::FixIntersectionSegmentDepths(BspCutIntersection* intersection, list<GenericIntersection*>& cleanUpInters, int& segDepthsChanged){	//Make two attempts.  On the first attempt, clean up the depths but don't flip the intersection.  On the second attempt, flip the intersection first and then clean up the depths.		BSpline* bsp = intersection->GetBsp();	BSplineToBSplineCut* cut = intersection->GetCut();	int cv = intersection->GetCv();	int sg = intersection->GetSg();		int originalDepthBspBefore = bsp->GetSectionDepthBeforeIntersection(intersection, cv, sg);	int originalDepthBspAfter = bsp->GetSectionDepthAfterIntersection(intersection, cv, sg);	int originalDepthCutBefore = cut->GetSectionDepthBeforeIntersection(intersection);	int originalDepthCutAfter = cut->GetSectionDepthAfterIntersection(intersection);		vector<GenericIntersection*> newCleanUpInters;		for (int pass = 0; pass < 2; pass++)	{		//On the second pass, make sure the depths are restored from the first pass		bsp->SetSectionDepthBeforeIntersection(intersection, cv, sg, originalDepthBspBefore);		bsp->SetSectionDepthAfterIntersection(intersection, cv, sg, originalDepthBspAfter);		cut->SetSectionDepthBeforeIntersection(intersection, originalDepthCutBefore);		cut->SetSectionDepthAfterIntersection(intersection, originalDepthCutAfter);				//Flip the intersection on the second pass		if (pass == 1)			intersection->FlipTopBottom();				int depthBspBefore = bsp->GetSectionDepthBeforeIntersection(intersection, cv, sg);		int depthBspAfter = bsp->GetSectionDepthAfterIntersection(intersection, cv, sg);		int depthCutBefore = cut->GetSectionDepthBeforeIntersection(intersection);		int depthCutAfter = cut->GetSectionDepthAfterIntersection(intersection);				int occludedEdge = intersection->DetermineOccludedEdge();		MyAssert(occludedEdge == -1 || occludedEdge == 1 || occludedEdge == 2);				bool constraintBspBefore = bsp->GetSectionDepthConstraintBeforeIntersection(intersection, cv, sg);		bool constraintBspAfter = bsp->GetSectionDepthConstraintAfterIntersection(intersection, cv, sg);		bool constraintCutBefore = cut->GetSectionDepthConstraintBeforeIntersection(intersection);		bool constraintCutAfter = cut->GetSectionDepthConstraintAfterIntersection(intersection);		//MyAssert(constraintBspBefore || constraintBspAfter || constraintCutBefore || constraintCutAfter);				//Make the bsp's boundary segments legal with respect to each other		if (depthBspBefore != depthBspAfter)		{			if (constraintBspBefore)			{				if (constraintBspAfter)					continue;				bsp->SetSectionDepthAfterIntersection(intersection, cv, sg, depthBspBefore);				segDepthsChanged++;				GenericIntersection* adjacentInter = bsp->FindNextIntersection(intersection, cv, sg);				if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())					newCleanUpInters.push_back(adjacentInter);				}			else			{				bsp->SetSectionDepthBeforeIntersection(intersection, cv, sg, depthBspAfter);				segDepthsChanged++;				GenericIntersection* adjacentInter = bsp->FindPrevIntersection(intersection, cv, sg);				if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())					newCleanUpInters.push_back(adjacentInter);			}		}				if (occludedEdge == -1)	//Cut on top		{			//Make the cut's boundary segments legal with respect to each other			if (depthCutBefore != depthCutAfter)			{				if (constraintCutBefore)				{					if (constraintCutAfter)						continue;					cut->SetSectionDepthAfterIntersection(intersection, depthCutBefore);					segDepthsChanged++;					GenericIntersection* adjacentInter = cut->FindNextIntersection(intersection);					if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())						newCleanUpInters.push_back(adjacentInter);				}				else				{					cut->SetSectionDepthBeforeIntersection(intersection, depthCutAfter);					segDepthsChanged++;					GenericIntersection* adjacentInter = cut->FindPrevIntersection(intersection);					if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())						newCleanUpInters.push_back(adjacentInter);				}			}						depthBspBefore = bsp->GetSectionDepthBeforeIntersection(intersection, cv, sg);			depthBspAfter = bsp->GetSectionDepthAfterIntersection(intersection, cv, sg);			depthCutBefore = cut->GetSectionDepthBeforeIntersection(intersection);			depthCutAfter = cut->GetSectionDepthAfterIntersection(intersection);						MyAssert(depthBspBefore == depthBspAfter);			MyAssert(depthCutBefore == depthCutAfter);						//Make the bsp's and cut's boundaries legal with respect to each other			if (depthBspBefore < depthCutBefore + 1)			{				if ((constraintBspBefore || constraintBspAfter) && (constraintCutBefore || constraintCutAfter))					continue;				if (!constraintBspBefore && !constraintBspAfter)	//Bsp is unconstrained, so push the bsp				{					if (depthBspBefore < depthCutBefore + 1)					{						bsp->SetSectionDepthBeforeIntersection(intersection, cv, sg, depthCutBefore + 1);						segDepthsChanged++;						GenericIntersection* adjacentInter = bsp->FindPrevIntersection(intersection, cv, sg);						if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())							newCleanUpInters.push_back(adjacentInter);					}					if (depthBspAfter < depthCutBefore + 1)					{						bsp->SetSectionDepthAfterIntersection(intersection, cv, sg, depthCutBefore + 1);						segDepthsChanged++;						GenericIntersection* adjacentInter = bsp->FindNextIntersection(intersection, cv, sg);						if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())							newCleanUpInters.push_back(adjacentInter);					}				}				else	//Cut is unconstrained, so push the cut				{					if (depthCutBefore > depthBspBefore - 1)					{						cut->SetSectionDepthBeforeIntersection(intersection, depthBspBefore - 1);						segDepthsChanged++;						GenericIntersection* adjacentInter = cut->FindPrevIntersection(intersection);						if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())							newCleanUpInters.push_back(adjacentInter);					}					if (depthCutAfter > depthCutBefore - 1)					{						cut->SetSectionDepthAfterIntersection(intersection, depthBspBefore - 1);						segDepthsChanged++;						GenericIntersection* adjacentInter = cut->FindNextIntersection(intersection);						if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())							newCleanUpInters.push_back(adjacentInter);					}				}			}		}		else if (occludedEdge == 1)	//Cut end 1 occluded		{			//Make the cut's boundary segments legal with respect to each other			if (depthCutBefore != depthCutAfter + 1)			{				if (constraintCutBefore)				{					if (constraintCutAfter)						continue;					cut->SetSectionDepthAfterIntersection(intersection, depthCutBefore - 1);					segDepthsChanged++;					GenericIntersection* adjacentInter = cut->FindNextIntersection(intersection);					if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())						newCleanUpInters.push_back(adjacentInter);				}				else				{					cut->SetSectionDepthBeforeIntersection(intersection, depthCutAfter + 1);					segDepthsChanged++;					GenericIntersection* adjacentInter = cut->FindPrevIntersection(intersection);					if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())						newCleanUpInters.push_back(adjacentInter);				}			}						depthBspBefore = bsp->GetSectionDepthBeforeIntersection(intersection, cv, sg);			depthBspAfter = bsp->GetSectionDepthAfterIntersection(intersection, cv, sg);			depthCutBefore = cut->GetSectionDepthBeforeIntersection(intersection);			depthCutAfter = cut->GetSectionDepthAfterIntersection(intersection);						MyAssert(depthBspBefore == depthBspAfter);			MyAssert(depthCutBefore == depthCutAfter + 1);						//Make the bsp's and cut's boundaries legal with respect to each other			if (depthCutAfter < depthBspBefore)			{				if ((constraintBspBefore || constraintBspAfter) && (constraintCutBefore || constraintCutAfter))					continue;				if (!constraintBspBefore && !constraintBspAfter)	//Bsp is unconstrained, so push the bsp				{					if (depthBspBefore > depthCutAfter)					{						bsp->SetSectionDepthBeforeIntersection(intersection, cv, sg, depthCutAfter);						segDepthsChanged++;						GenericIntersection* adjacentInter = bsp->FindPrevIntersection(intersection, cv, sg);						if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())							newCleanUpInters.push_back(adjacentInter);					}					if (depthBspAfter > depthCutAfter)					{						bsp->SetSectionDepthAfterIntersection(intersection, cv, sg, depthCutAfter);						segDepthsChanged++;						GenericIntersection* adjacentInter = bsp->FindNextIntersection(intersection, cv, sg);						if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())							newCleanUpInters.push_back(adjacentInter);					}				}				else	//Cut is unconstrained, so push the cut				{					if (depthCutBefore < depthBspBefore + 1)					{						cut->SetSectionDepthBeforeIntersection(intersection, depthBspBefore + 1);						segDepthsChanged++;						GenericIntersection* adjacentInter = cut->FindPrevIntersection(intersection);						if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())							newCleanUpInters.push_back(adjacentInter);					}					if (depthCutAfter < depthBspBefore)					{						cut->SetSectionDepthAfterIntersection(intersection, depthBspBefore);						segDepthsChanged++;						GenericIntersection* adjacentInter = cut->FindNextIntersection(intersection);						if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())							newCleanUpInters.push_back(adjacentInter);					}				}			}		}		else	//Cut end 2 occluded		{			MyAssert(occludedEdge == 2);			//Make the cut's boundary segments legal with respect to each other			if (depthCutBefore != depthCutAfter - 1)			{				if (constraintCutBefore)				{					if (constraintCutAfter)						continue;					cut->SetSectionDepthAfterIntersection(intersection, depthCutBefore + 1);					segDepthsChanged++;					GenericIntersection* adjacentInter = cut->FindNextIntersection(intersection);					if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())						newCleanUpInters.push_back(adjacentInter);				}				else				{					cut->SetSectionDepthBeforeIntersection(intersection, depthCutAfter - 1);					segDepthsChanged++;					GenericIntersection* adjacentInter = cut->FindPrevIntersection(intersection);					if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())						newCleanUpInters.push_back(adjacentInter);				}			}						depthBspBefore = bsp->GetSectionDepthBeforeIntersection(intersection, cv, sg);			depthBspAfter = bsp->GetSectionDepthAfterIntersection(intersection, cv, sg);			depthCutBefore = cut->GetSectionDepthBeforeIntersection(intersection);			depthCutAfter = cut->GetSectionDepthAfterIntersection(intersection);						MyAssert(depthBspBefore == depthBspAfter);			MyAssert(depthCutBefore == depthCutAfter - 1);						//Make the bsp's and cut's boundaries legal with respect to each other			if (depthCutBefore < depthBspBefore)			{				if ((constraintBspBefore || constraintBspAfter) && (constraintCutBefore || constraintCutAfter))					continue;				if (!constraintBspBefore && !constraintBspAfter)	//Bsp is unconstrained, so push the bsp				{					if (depthBspBefore > depthCutBefore)					{						bsp->SetSectionDepthBeforeIntersection(intersection, cv, sg, depthCutBefore);						segDepthsChanged++;						GenericIntersection* adjacentInter = bsp->FindPrevIntersection(intersection, cv, sg);						if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())							newCleanUpInters.push_back(adjacentInter);					}					if (depthBspAfter > depthCutBefore)					{						bsp->SetSectionDepthAfterIntersection(intersection, cv, sg, depthCutBefore);						segDepthsChanged++;						GenericIntersection* adjacentInter = bsp->FindNextIntersection(intersection, cv, sg);						if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())							newCleanUpInters.push_back(adjacentInter);					}				}				else	//Cut is unconstrained, so push the cut				{					if (depthCutBefore < depthBspBefore)					{						cut->SetSectionDepthBeforeIntersection(intersection, depthBspBefore);						segDepthsChanged++;						GenericIntersection* adjacentInter = cut->FindPrevIntersection(intersection);						if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())							newCleanUpInters.push_back(adjacentInter);					}					if (depthCutAfter < depthBspBefore + 1)					{						cut->SetSectionDepthAfterIntersection(intersection, depthBspBefore + 1);						segDepthsChanged++;						GenericIntersection* adjacentInter = cut->FindNextIntersection(intersection);						if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())							newCleanUpInters.push_back(adjacentInter);					}				}			}		}				for (int i = 0; i < newCleanUpInters.size(); i++)			if (find(cleanUpInters.begin(), cleanUpInters.end(), newCleanUpInters[i]) == cleanUpInters.end())				cleanUpInters.push_back(newCleanUpInters[i]);				bsp->SetSectionDepthConstraintBeforeIntersection(intersection, cv, sg, true);		bsp->SetSectionDepthConstraintAfterIntersection(intersection, cv, sg, true);		cut->SetSectionDepthConstraintBeforeIntersection(intersection, true);		cut->SetSectionDepthConstraintAfterIntersection(intersection, true);				return true;	}		return false;	//Both passes failed.  Intersection could not be made legal with or without a flip.}bool Drawing::FixIntersectionSegmentDepths(BspCutTIntersection* intersection, list<GenericIntersection*>& cleanUpInters, int& segDepthsChanged){	BSpline* bsp = intersection->GetBsp();	BSplineToBSplineCut* cut = intersection->GetCut();	int cv = intersection->GetCv();	int sg = intersection->GetSg();		BSplineToBSplineCut *prevInfiniteCut = NULL, *nextInfiniteCut = NULL;	BspCutTIntersection *prevInfiniteInter = NULL, *nextInfiniteInter = NULL;		int depthBspBefore = -1, depthBspAfter = -1;	bool constraintBspBefore = false, constraintBspAfter = false;	if (bsp)	{		depthBspBefore = bsp->GetSectionDepthBeforeIntersection(intersection, cv, sg);		depthBspAfter = bsp->GetSectionDepthAfterIntersection(intersection, cv, sg);		constraintBspBefore = bsp->GetSectionDepthConstraintBeforeIntersection(intersection, cv, sg);		constraintBspAfter = bsp->GetSectionDepthConstraintAfterIntersection(intersection, cv, sg);	}	else	//No bsp, this is a BspCutT intersection at an infinite boundary	{		prevInfiniteInter = FindPrevInfiniteSolidCut(intersection);		nextInfiniteInter = FindNextInfiniteSolidCut(intersection);		prevInfiniteCut = prevInfiniteInter->GetCut();		nextInfiniteCut = nextInfiniteInter->GetCut();		depthBspBefore = prevInfiniteCut->GetSectionDepthBeforeIntersection(prevInfiniteInter);		depthBspAfter = nextInfiniteCut->GetSectionDepthBeforeIntersection(nextInfiniteInter);		constraintBspBefore = prevInfiniteCut->GetSectionDepthConstraintBeforeIntersection(prevInfiniteInter);		constraintBspAfter = nextInfiniteCut->GetSectionDepthConstraintBeforeIntersection(nextInfiniteInter);	}		bool cutAtStart = intersection->GetAtStart();	int depthCut = cutAtStart ? cut->GetSectionDepthAfterIntersection(intersection) : cut->GetSectionDepthBeforeIntersection(intersection);		bool constraintCut = cutAtStart ? cut->GetSectionDepthConstraintAfterIntersection(intersection) : cut->GetSectionDepthConstraintBeforeIntersection(intersection);	//MyAssert(constraintBspBefore || constraintBspAfter || constraintCut);		//Make all three depths match	int constrainedDepth = -1;	if (constraintBspBefore)		constrainedDepth = depthBspBefore;	if (constraintBspAfter)	{			if (constrainedDepth != -1 && depthBspAfter != constrainedDepth)			return false;		constrainedDepth = depthBspAfter;	}	if (constraintCut)	{			if (constrainedDepth != -1 && depthCut != constrainedDepth)			return false;		constrainedDepth = depthCut;	}		if (bsp)	{		if (depthBspBefore != constrainedDepth)		{			MyAssert(!constraintBspBefore);			bsp->SetSectionDepthBeforeIntersection(intersection, cv, sg, constrainedDepth);			segDepthsChanged++;			GenericIntersection* adjacentInter = bsp->FindPrevIntersection(intersection, cv, sg);			if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())				cleanUpInters.push_back(adjacentInter);		}				if (depthBspAfter != constrainedDepth)		{			MyAssert(!constraintBspAfter);			bsp->SetSectionDepthAfterIntersection(intersection, cv, sg, constrainedDepth);			segDepthsChanged++;			GenericIntersection* adjacentInter = bsp->FindNextIntersection(intersection, cv, sg);			if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())				cleanUpInters.push_back(adjacentInter);		}		}	else	//No bsp, this is a BspCutT intersection at an infinite boundary	{		if (depthBspBefore != constrainedDepth)		{			prevInfiniteCut->SetSectionDepthBeforeIntersection(prevInfiniteInter, constrainedDepth);			segDepthsChanged++;			if (find(cleanUpInters.begin(), cleanUpInters.end(), prevInfiniteInter) == cleanUpInters.end())				cleanUpInters.push_back(prevInfiniteInter);			GenericIntersection* adjacentInter = prevInfiniteCut->FindPrevIntersection(prevInfiniteInter);			if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())				cleanUpInters.push_back(adjacentInter);		}				if (depthBspAfter != constrainedDepth)		{			nextInfiniteCut->SetSectionDepthBeforeIntersection(nextInfiniteInter, constrainedDepth);			segDepthsChanged++;			if (find(cleanUpInters.begin(), cleanUpInters.end(), nextInfiniteInter) == cleanUpInters.end())				cleanUpInters.push_back(nextInfiniteInter);			GenericIntersection* adjacentInter = nextInfiniteCut->FindPrevIntersection(nextInfiniteInter);			if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())				cleanUpInters.push_back(adjacentInter);		}	}		if (depthCut != constrainedDepth)	{		MyAssert(!constraintCut);		cutAtStart ? cut->SetSectionDepthAfterIntersection(intersection, constrainedDepth) : cut->SetSectionDepthBeforeIntersection(intersection, constrainedDepth);		segDepthsChanged++;		GenericIntersection* adjacentInter = cutAtStart ? cut->FindNextIntersection(intersection) : cut->FindPrevIntersection(intersection);		if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())			cleanUpInters.push_back(adjacentInter);		}		if (bsp)		bsp->SetSectionDepthConstraintBeforeIntersection(intersection, cv, sg, true);	else prevInfiniteCut->SetSectionDepthConstraintBeforeIntersection(prevInfiniteInter, true);	if (bsp)		bsp->SetSectionDepthConstraintAfterIntersection(intersection, cv, sg, true);	else nextInfiniteCut->SetSectionDepthConstraintBeforeIntersection(nextInfiniteInter, true);	cutAtStart ? cut->SetSectionDepthConstraintAfterIntersection(intersection, true) : cut->SetSectionDepthConstraintBeforeIntersection(intersection, true);		if (bsp)	{		depthBspBefore = bsp->GetSectionDepthBeforeIntersection(intersection, cv, sg);		depthBspAfter = bsp->GetSectionDepthAfterIntersection(intersection, cv, sg);	}	else	{		depthBspBefore = prevInfiniteCut->GetSectionDepthBeforeIntersection(prevInfiniteInter);		depthBspAfter = nextInfiniteCut->GetSectionDepthBeforeIntersection(nextInfiniteInter);	}	depthCut = cutAtStart ? cut->GetSectionDepthAfterIntersection(intersection) : cut->GetSectionDepthBeforeIntersection(intersection);		MyAssert(depthBspAfter == depthBspBefore && depthCut == depthBspBefore);		return true;}bool Drawing::FixIntersectionSegmentDepths(CutCutIntersection* intersection, list<GenericIntersection*>& cleanUpInters, int& segDepthsChanged){	BSplineToBSplineCut* cut1 = intersection->GetCut1();	BSplineToBSplineCut* cut2 = intersection->GetCut2();		int depthCut1before = cut1->GetSectionDepthBeforeIntersection(intersection);	int depthCut1after = cut1->GetSectionDepthAfterIntersection(intersection);	int depthCut2before = cut2->GetSectionDepthBeforeIntersection(intersection);	int depthCut2after = cut2->GetSectionDepthAfterIntersection(intersection);		bool constraintCut1before = cut1->GetSectionDepthConstraintBeforeIntersection(intersection);	bool constraintCut1after = cut1->GetSectionDepthConstraintAfterIntersection(intersection);	bool constraintCut2before = cut2->GetSectionDepthConstraintBeforeIntersection(intersection);	bool constraintCut2after = cut2->GetSectionDepthConstraintAfterIntersection(intersection);	//MyAssert(constraintCut1before || constraintCut1after || constraintCut2before || constraintCut2after);		//Make the first cut's boundary segments legal with respect to each other	if (depthCut1before != depthCut1after)	{		if (constraintCut1before)		{			if (constraintCut1after)				return false;			cut1->SetSectionDepthAfterIntersection(intersection, depthCut1before);			segDepthsChanged++;			GenericIntersection* adjacentInter = cut1->FindNextIntersection(intersection);			if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())				cleanUpInters.push_back(adjacentInter);		}		else		{			cut1->SetSectionDepthBeforeIntersection(intersection, depthCut1before);			segDepthsChanged++;			GenericIntersection* adjacentInter = cut1->FindPrevIntersection(intersection);			if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())				cleanUpInters.push_back(adjacentInter);		}	}		//Make the second cut's boundary segments legal with respect to each other	if (depthCut2before != depthCut2after)	{		if (constraintCut2before)		{			if (constraintCut2after)				return false;			cut2->SetSectionDepthAfterIntersection(intersection, depthCut2before);			segDepthsChanged++;			GenericIntersection* adjacentInter = cut2->FindNextIntersection(intersection);			if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())				cleanUpInters.push_back(adjacentInter);		}		else		{			cut2->SetSectionDepthBeforeIntersection(intersection, depthCut2before);			segDepthsChanged++;			GenericIntersection* adjacentInter = cut2->FindPrevIntersection(intersection);			if (find(cleanUpInters.begin(), cleanUpInters.end(), adjacentInter) == cleanUpInters.end())				cleanUpInters.push_back(adjacentInter);		}	}		depthCut1before = cut1->GetSectionDepthBeforeIntersection(intersection);	depthCut1after = cut1->GetSectionDepthAfterIntersection(intersection);	depthCut2before = cut2->GetSectionDepthBeforeIntersection(intersection);	depthCut2after = cut2->GetSectionDepthAfterIntersection(intersection);		MyAssert(depthCut1before == depthCut1after);	MyAssert(depthCut2before == depthCut2after);		cut1->SetSectionDepthConstraintBeforeIntersection(intersection, true);	cut1->SetSectionDepthConstraintAfterIntersection(intersection, true);	cut2->SetSectionDepthConstraintBeforeIntersection(intersection, true);	cut2->SetSectionDepthConstraintAfterIntersection(intersection, true);		return true;}void Drawing::CreateInspectionIntersectionList(list<GenericIntersection*>& inspectionIntersections){	vector<GenericIntersection*> accum;		//Find the flipped intersection	for (vector<GenericIntersection*>::iterator i = intersections.begin(); i != intersections.end(); i++)	{		MyAssert(!(*i)->GetDtored());				if ((*i)->GetHardConstraint())			accum.push_back(*i);	}		//Find all presently illegal intersections	for (vector<GenericIntersection*>::iterator i = intersections.begin(); i != intersections.end(); i++)	{		MyAssert(!(*i)->GetDtored());				//Don't add the same intersection to the list more than once		if (find(accum.begin(), accum.end(), *i) != accum.end())			continue;				bool intersectionLegal = (*i)->IntersectionLegal();				if (!intersectionLegal)			accum.push_back(*i);	}		//Next add any new intersections to the list.  Do this second, so new intersections all occur after flipped and illegal intersections in the list.	for (vector<GenericIntersection*>::iterator i = brandNewIntersections.begin(); i != brandNewIntersections.end(); i++)	{		MyAssert(!(*i)->GetDtored());				//Don't add the same intersection to the list more than once		if (find(accum.begin(), accum.end(), *i) != accum.end())			continue;				accum.push_back(*i);	}		//Randomly mix the list	vector<int> usedIndexes;	for (int i = 0; i < accum.size(); i++)	{		int index;		/*do		{			index = RandZeroInt(accum.size());		} while (find(usedIndexes.begin(), usedIndexes.end(), index) != usedIndexes.end());		usedIndexes.push_back(index);		*/		index = i;	//еее				inspectionIntersections.push_back(accum[index]);	}}//Return true if successfulbool Drawing::CreateLegalLabeling(vector<BSpline*> testBSplines, bool initMouseSensitive){	MyAssert(interCompanionPairSets.size() == 0);	//This is no longer used, it should always be empty (delete it from the code at some future point).		for (int i = 0; i < wholeObjects.size(); i++)		for (int j = 0; j < wholeObjects[i]->bspCutTinters.size(); j++)			MyAssert(!wholeObjects[i]->bspCutTinters[j]->GetDtored());		ClearAnalysisWindow();		if (gDebug14)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pBeginning labeling");				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}		gMouseTerminated = false;		mouseDownAtStartOfAttempt = Button();	SetPort(GetWindowPort(gMainWindow->GetWindow()));	GetMouse(&mouseLocAtStartOfAttempt);	mouseSensitive = initMouseSensitive;		clock_t startTime = clock();		bool result;		if (gLabelingMethod == 0)		result = CreateLegalLabelingUsingTreeSearch(testBSplines, initMouseSensitive);	else if (gLabelingMethod == 1)	{		//Remember the test bspline indexes		/*		vector<int> testBSplineIndexes;		for (int i = 0; i < testBSplines.size(); i++)		{			int bsplineIndex = GetBSplineIndex(testBSplines[i]);			testBSplineIndexes.push_back(bsplineIndex);		}				if (!CreateLegalLabelingUsingUniqueCompSet(testBSplines, initMouseSensitive) && TestForMouseTermination())		{			if (gDebug5)			{				InitAnalysisWindow();								IncrementTextV();				MoveTo(5, IncrementTextV() * 10 + 5);				DrawString("\pDirect labeling failed, trying search");								QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);				SetPort(GetWindowPort(gMainWindow->GetWindow()));			}						testBSplines.clear();			for (int i = 0; i < testBSplineIndexes.size(); i++)				testBSplines.push_back(bsplines[testBSplineIndexes[i]]);						return CreateLegalLabelingUsingTreeSearch(testBSplines, initMouseSensitive);		}		*/				///////////////////////////////////////////////////////////////////////////				FindInterCompSetsForUnlabeledDrawing();				if (!TestForMouseTermination())			result = false;		else result = CreateLegalLabelingUsingTreeSearch(testBSplines, initMouseSensitive);	}		clock_t timeUsed = clock() - startTime;	if (gDebug5)	{		InitAnalysisWindow();				IncrementTextV();		MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pTotal seconds used: ");				Str255 str1;				long double timeUsedSecs = timeUsed / CLOCKS_PER_SEC;		FloatToPascal(timeUsedSecs, 3, str1);		DrawString(str1);				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}		if (gTestLogOn)	{		//ofstream ofs;		//ofs.open("testData", ofstream::app);		//if (ofs)		//{			long double timeUsedSecs = timeUsed / CLOCKS_PER_SEC;			/*ofs*/(*gOutputFileStream) << timeUsedSecs;			if (!result)				/*ofs*/(*gOutputFileStream) << "\tTIMEOUT";			/*ofs*/(*gOutputFileStream) << endl;		//	ofs.close();		//}				SetPort(GetWindowPort(gDataLogWindow));		Rect r;		GetPortBounds(GetWindowPort(gDataLogWindow), &r);		if (gLogLine == 0)			EraseRect(&r);		TextSize(18);		ForeColor(blackColor);		MoveTo(10, 30 + gLogLine++ * 30);		DrawString("\pLog item added");		QDFlushPortBuffer(GetWindowPort(gDataLogWindow), NULL);	}		return result;}//Return true if successfulbool Drawing::CreateLegalLabelingUsingTreeSearch(vector<BSpline*> testBSplines, bool initMouseSensitive){	if (gDebug14)	{		InitAnalysisWindow();				IncrementTextV();		MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pBeginning tree search labeling");				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}		//Sometimes we want to refind the cuts before labeling.  The main reason is that the cuts may have become illegal and now we can't label subject to them.	//However, if new intersections were just created, it will impossible to refind the cuts, which means they will be absent during labeling.	//What is the solution?!	//FindWholeObjects2(testBSplines);		clock_t timeStarted = clock();		VerifyNothingDtored();		if (gDepthEnumerationMethod != 0)		if (!FindBSplineSectionMaxPossibleDepthsV4())		{			ClearBrandNewIntersections();			SetAllIntersectionsNoHardConstraint();			SetAllSectionsNoHardConstraint();			return false;		}		if (gDebug)	{		PenSize(1, 1);				MyAssert(!dtored);				SetPort(GetWindowPort(gMainWindow->GetWindow()));				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qt = 1;	}		WriteSearchParameters();		SetPort(GetWindowPort(gMainWindow->GetWindow()));	PenSize(2, 2);		//Potentionally two passes.  If the first pass fails, find (and ditch) the bad cuts and touched comp sets, then try to label again on the second pass.	int numPasses = 1;	Drawing* minDeltaLeaf;	bool noIntersectionsToLabel = false;	for (int pass = 0; pass < numPasses; pass++)	{		if (gDebug14)		{			InitAnalysisWindow();						MoveTo(5, IncrementTextV() * 10 + 5);			DrawString("\pPass ");			Str255 str1;			NumToString(pass, str1);			DrawString(str1);						QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);			SetPort(GetWindowPort(gMainWindow->GetWindow()));		}				VerifyNothingDtored();		IncrementTextV();				//Start a list of "touched bsplines".  The tree search will have to fully traverse all touched bsplines before a node is called a "leaf".		vector<int> touchedBSplineIndexes;		list<GenericIntersection*> inspectionIntersections;		CreateInspectionIntersectionList(inspectionIntersections);				//Calculate the horizon distance of every intersection to any inspection intersection		if (gTreeSearchMethod == 1 && inspectionIntersections.size() > 0)		{			vector<GenericIntersection*> contentiousInters;			for (list<GenericIntersection*>::iterator iter = inspectionIntersections.begin(); iter != inspectionIntersections.end(); iter++)				contentiousInters.push_back(*iter);			gInterDists.clear();			FindAllIntersectionContentionDistances(contentiousInters, gInterDists);			//if (gDebug)			//	DrawContentionIntersectionDistances(gInterDists);		}				if (inspectionIntersections.size() == 0)		{			noIntersectionsToLabel = true;						if (gDebug5)			{				InitAnalysisWindow();								MoveTo(5, IncrementTextV() * 10 + 5);				DrawString("\pNo intersections in contention");				MoveTo(5, IncrementTextV() * 10 + 5);				DrawString("\pNo labeling search performed");								QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);				SetPort(GetWindowPort(gMainWindow->GetWindow()));			}		}				BSpline* bsp;		for (list<GenericIntersection*>::iterator i = inspectionIntersections.begin(); i != inspectionIntersections.end(); i++)		{			switch ((*i)->GetType())			{				case GenericIntersection::BSP_BSP:					BspBspIntersection* bspBspInter = (BspBspIntersection*)(*i);										bsp = bspBspInter->GetBsp1();					UpdateTouchedBSplines(GetBSplineIndex(bsp), touchedBSplineIndexes);										bsp = bspBspInter->GetBsp2();					UpdateTouchedBSplines(GetBSplineIndex(bsp), touchedBSplineIndexes);					break;				case GenericIntersection::BSP_CUT:					BspCutIntersection* bspCutInter = (BspCutIntersection*)(*i);										bsp = bspCutInter->GetBsp();					UpdateTouchedBSplines(GetBSplineIndex(bsp), touchedBSplineIndexes);					break;				case GenericIntersection::BSP_CUT_T:					BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)(*i);										bsp = bspCutTInter->GetBsp();					if (bsp)						UpdateTouchedBSplines(GetBSplineIndex(bsp), touchedBSplineIndexes);					break;				case GenericIntersection::CUT_CUT:					//Nothing to do here					break;			}		}				//On subsequent passes, there may be no "touched" bsplines because all the relevant intersections may have been deleted				sTreeWalk = sTreeWalk2 = sTreeWalk3 = 0;		labelingStartTime = clock();		bool timeLimitReached = false;		int minFlipDelta = 999999, minDepthDelta = 999999;		int accumFlipDelta = 0, accumDepthDelta = 0;		minDeltaLeaf = NULL;				//Cycle through the touched BSplines		for (int i = 0; i < touchedBSplineIndexes.size(); i++)		{			int iii = i;						int numPossibleDepths;			GenericIntersection* nextBspFirstInter = NULL;			if (gDepthEnumerationMethod == 0)			{				vector<GenericIntersection*> groupInters = GetOneBSplineGroupIntersections(bsplines[touchedBSplineIndexes[i]]);				if (groupInters.size() == 0)					groupInters = bsplines[touchedBSplineIndexes[i]]->GetIntersections();				int totalInters = groupInters.size();				for (int ii = 0; ii < groupInters.size(); ii++)					if (groupInters[ii]->SelfIntersection() || groupInters[ii]->GetType() == GenericIntersection::BSP_CUT_T)						totalInters--;				numPossibleDepths = max(2, totalInters / 2);								BSpline* nextBsp = bsplines[touchedBSplineIndexes[i]];				nextBspFirstInter = nextBsp->GetFirstIntersection();				MyAssert(nextBspFirstInter);			}			else if (gDepthEnumerationMethod == 1)			{				int startingSection = bsplines[touchedBSplineIndexes[i]]->GetDeepestMaxPossibleSection();				numPossibleDepths = bsplines[touchedBSplineIndexes[i]]->GetMaxPossibleSectionDepth(startingSection) + 1;				vector<GenericIntersection*> inters = bsplines[touchedBSplineIndexes[i]]->GetIntersections();				nextBspFirstInter = inters[startingSection];			}			else if (gDepthEnumerationMethod == 2)			{				int startingSection = bsplines[touchedBSplineIndexes[i]]->GetShallowestMaxPossibleSection();				numPossibleDepths = bsplines[touchedBSplineIndexes[i]]->GetMaxPossibleSectionDepth(startingSection) + 1;				vector<GenericIntersection*> inters = bsplines[touchedBSplineIndexes[i]]->GetIntersections();				nextBspFirstInter = inters[startingSection];			}			MyAssert(!nextBspFirstInter->GetDtored());						SetPort(GetWindowPort(gMainWindow->GetWindow()));			PenSize(2, 2);						//Iterative deepening.			//Continually reenter the tree with an increasing horizon of flippable intersections.			int maxHorizon = (gTreeSearchMethod == 0) ? 999999 : gInterDists[gInterDists.size() - 1].second;			gHorizon = 0;			while (gHorizon <= maxHorizon)			{				if (gDebug12 && gHorizon != 0)				{					InitAnalysisWindow();										MoveTo(gTextH++ * 7 + 5, gTextV * 10 + 5);					DrawString("\p+");										Rect r;					GetPortBounds(GetWindowPort(gAnalysisWindow), &r);					if (gTextH * 7 + 5 > r.right - 10)					{						gTextH = 0;						IncrementTextV();					}										QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);					SetPort(GetWindowPort(gMainWindow->GetWindow()));				}								for (int j = 0; j < numPossibleDepths; j++)				{					int jjj = j;										Drawing* nextLevelLeaf = NULL;										bool oneBetterSolutionFound;					switch (gCompanionSetMethod)					{						case 0:							oneBetterSolutionFound = CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod0(0, j, nextBspFirstInter->GetLocation(), touchedBSplineIndexes[i],																												touchedBSplineIndexes, nextLevelLeaf,																												minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																												timeLimitReached);							break;						case 1:							oneBetterSolutionFound = CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod1(0, j, nextBspFirstInter->GetLocation(), touchedBSplineIndexes[i],																												touchedBSplineIndexes, nextLevelLeaf,																												minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																												timeLimitReached);							break;						case 2:							oneBetterSolutionFound = CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod2(0, j, nextBspFirstInter->GetLocation(), touchedBSplineIndexes[i],																												touchedBSplineIndexes, nextLevelLeaf,																												minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																												timeLimitReached);							break;					}										if (!oneBetterSolutionFound)						MyAssert(!nextLevelLeaf);					else	//better solution found					{						MyAssert(nextLevelLeaf);						vector<BSpline*> nextLevelLeafBSplines = nextLevelLeaf->bsplines;						bool MyAssertIt = false;						for (int ii = 0; ii < touchedBSplineIndexes.size(); ii++)							MyAssert(nextLevelLeafBSplines[touchedBSplineIndexes[ii]]->GetAllIntersectionsLegal(MyAssertIt));												if (minDeltaLeaf)							delete minDeltaLeaf;						MyAssert(nextLevelLeaf);						minDeltaLeaf = nextLevelLeaf;					}										if (timeLimitReached)						break;										if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)// && accumDepthDelta >= minDepthDelta)					//if (accumFlipDelta > minFlipDelta || (minFlipDelta != 999999 && accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))						break;				}								if (timeLimitReached)					break;								if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)// && accumDepthDelta >= minDepthDelta)				//if (accumFlipDelta > minFlipDelta || (minFlipDelta != 999999 && accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))					break;								if (gTreeSearchMethod != 1)					break;								gHorizon++;			}						if (timeLimitReached)				break;						if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)// && accumDepthDelta >= minDepthDelta)			//if (accumFlipDelta > minFlipDelta || (minFlipDelta != 999999 && accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))				break;		}				MyAssert(!dtored);				//Take the best solution and do it		if (minDeltaLeaf)		{			if (gDebug5)			{				InitAnalysisWindow();				IncrementTextV();				MoveTo(5, IncrementTextV() * 10 + 5);				DrawString("\pSolution, delta: ");				Str255 str1;				NumToString(minFlipDelta, str1);				DrawString(str1);				NumToString(minDepthDelta, str1);				DrawString("\p/");				DrawString(str1);			}						MyAssert(!dtored);			MyAssert(!minDeltaLeaf->dtored);						vector<BSpline*> minDeltaLeafBSplines = minDeltaLeaf->bsplines;			for (int i = 0; i < touchedBSplineIndexes.size(); i++)				MyAssert(minDeltaLeafBSplines[touchedBSplineIndexes[i]]->GetAllIntersectionsLegal(true));						ClearBrandNewIntersections();			minDeltaLeaf->ClearBrandNewIntersections();						//Remember the test bspline indexes			vector<int> testBSplineIndexes;			for (int i = 0; i < testBSplines.size(); i++)			{				int bsplineIndex = GetBSplineIndex(testBSplines[i]);				testBSplineIndexes.push_back(bsplineIndex);			}						*this = *minDeltaLeaf;						//Move the test bspline pointers over			for (int i = 0; i < testBSplines.size(); i++)			{				MyAssert(testBSplineIndexes[i] < bsplines.size());				testBSplines[i] = bsplines[testBSplineIndexes[i]];			}						for (int i = 0; i < touchedBSplineIndexes.size(); i++)				MyAssert(bsplines[touchedBSplineIndexes[i]]->GetAllIntersectionsLegal(true));						VerticallyCompactDrawing();						for (int i = 0; i < touchedBSplineIndexes.size(); i++)				MyAssert(bsplines[touchedBSplineIndexes[i]]->GetAllIntersectionsLegal(true));						NormalizeDepths();						for (int i = 0; i < touchedBSplineIndexes.size(); i++)				MyAssert(bsplines[touchedBSplineIndexes[i]]->GetAllIntersectionsLegal(true));						delete minDeltaLeaf;		}		else if (pass == 0 && touchedBSplineIndexes.size() > 0)		{			//No solution found the first time.  Refind the objects and cuts (which will remove any invalid cuts) and try again.			/*			numPasses = 2;						//Ditch the relevant comp sets			for (list<GenericIntersection*>::iterator i = inspectionIntersections.begin(); i != inspectionIntersections.end(); i++)			{				vector<GenericIntersection*> inters;				switch ((*i)->GetType())				{					case GenericIntersection::GenericIntersection::BSP_BSP:						inters = ((BspBspIntersection*)(*i))->GetBsp1()->GetIntersections();						for (int j = 0; j < inters.size(); j++)							RemoveCompanionPairsForIntersection(inters[j]);						inters = ((BspBspIntersection*)(*i))->GetBsp2()->GetIntersections();						for (int j = 0; j < inters.size(); j++)							RemoveCompanionPairsForIntersection(inters[j]);						break;					case GenericIntersection::GenericIntersection::BSP_CUT:						inters = ((BspCutIntersection*)(*i))->GetBsp()->GetIntersections();						for (int j = 0; j < inters.size(); j++)							RemoveCompanionPairsForIntersection(inters[j]);						inters = ((BspCutIntersection*)(*i))->GetCut()->GetIntersections();						for (int j = 0; j < inters.size(); j++)							RemoveCompanionPairsForIntersection(inters[j]);						break;					case GenericIntersection::GenericIntersection::BSP_CUT_T:						inters = ((BspCutTIntersection*)(*i))->GetBsp()->GetIntersections();						for (int j = 0; j < inters.size(); j++)							RemoveCompanionPairsForIntersection(inters[j]);						inters = ((BspCutTIntersection*)(*i))->GetCut()->GetIntersections();						for (int j = 0; j < inters.size(); j++)							RemoveCompanionPairsForIntersection(inters[j]);						break;					case GenericIntersection::GenericIntersection::CUT_CUT:						inters = ((CutCutIntersection*)(*i))->GetCut1()->GetIntersections();						for (int j = 0; j < inters.size(); j++)							RemoveCompanionPairsForIntersection(inters[j]);						inters = ((CutCutIntersection*)(*i))->GetCut2()->GetIntersections();						for (int j = 0; j < inters.size(); j++)							RemoveCompanionPairsForIntersection(inters[j]);						break;				}			}			*/		}				if (!minDeltaLeaf && gDebug5)		{				InitAnalysisWindow();						MoveTo(5, IncrementTextV() * 10 + 5);			DrawString("\pFailed to find a solution");						QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);			SetPort(GetWindowPort(gMainWindow->GetWindow()));		}				//There are situations where we have to find the cuts and objects even though no legal solution was found		VerifyNothingDtored();		FindWholeObjects2(testBSplines);	}		clock_t searchTimeUsed = clock() - timeStarted;		PenSize(1, 1);		ClearBrandNewIntersections();	SetAllIntersectionsNoHardConstraint();	SetAllSectionsNoHardConstraint();		for (int i = 0; i < wholeObjects.size(); i++)		for (int j = 0; j < wholeObjects[i]->bspCutTinters.size(); j++)			MyAssert(!wholeObjects[i]->bspCutTinters[j]->GetDtored());		clock_t totalTimeUsed = clock() - timeStarted;	clock_t cleanupTimeUsed = totalTimeUsed - searchTimeUsed;		if (gDebug5)	{		InitAnalysisWindow();				IncrementTextV();		MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pSeconds used: ");				Str255 str1;				long double searchTimeSecs = searchTimeUsed / CLOCKS_PER_SEC;		FloatToPascal(searchTimeSecs, 3, str1);		DrawString(str1);				DrawString("\p    ");				long double cleanupTimeSecs = cleanupTimeUsed / CLOCKS_PER_SEC;		FloatToPascal(cleanupTimeSecs, 3, str1);		DrawString(str1);				DrawString("\p    ");				long double totalTimeSecs = totalTimeUsed / CLOCKS_PER_SEC;		FloatToPascal(totalTimeSecs, 3, str1);		DrawString(str1);				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pNodes visited: ");		NumToString(sTreeWalk, str1);		DrawString(str1);		DrawString("\p     ");		NumToString(sTreeWalk2, str1);		DrawString(str1);		DrawString("\p     ");		NumToString(sTreeWalk3, str1);		DrawString(str1);				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));				if (gTestLogOn)		{			//ofstream ofs;			//ofs.open("testData", ofstream::app);			//if (ofs)			//{				/*ofs*/(*gOutputFileStream) << bsplines.size() << "\t" << intersections.size() << "\t" << sTreeWalk2 << "\t" << searchTimeSecs << "\t";			//	ofs.close();			//}		}	}		//Return true if successful	return (minDeltaLeaf != NULL || noIntersectionsToLabel);}//Return true if successfulbool Drawing::CreateLegalLabelingUsingUniqueCompSet(vector<BSpline*> testBSplines, bool initMouseSensitive){	if (gDebug14)	{		InitAnalysisWindow();				IncrementTextV();		MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pBeginning direct labeling");				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}		WriteSearchParameters();	SetPort(GetWindowPort(gMainWindow->GetWindow()));		VerifyNothingDtored();	ClearBrandNewIntersections();	SetAllIntersectionsNoHardConstraint();	SetAllSectionsNoHardConstraint();		clock_t timeStarted = clock();		FindInterCompSetsForUnlabeledDrawing();		if (!TestForMouseTermination())		return false;		IncrementTextV();		Drawing* backup = new Drawing(*this);	SetAllSectionsNoHardConstraint();		//FindWholeObjects2(testBSplines);	//Sorta, kinda necessary, especially for bsplines with no intersections		//Find and fix any illegal companion sets (which should be confined to testBSplines)	int intersFlipped = 0;	PenSize(2, 2);	for (int i = 0; i < interCompanionSets.size(); i++)	{		MyAssert(interCompanionSets[i]->size() > 0);				if (gDebug)		{			for (int j = 0; j < interCompanionSets[i]->size(); j++)			{				FloatPoint intersectionLoc = (*interCompanionSets[i])[j]->GetLocation();				Rect r;				SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);				ForeColor(cyanColor);				FrameOval(&r);			}			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			int qD = 1;						for (int j = 0; j < interCompanionSets[i]->size(); j++)			{				FloatPoint intersectionLoc = (*interCompanionSets[i])[j]->GetLocation();				Rect r;				SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);				ForeColor(whiteColor);				FrameOval(&r);			}			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			qD = 1;		}				//Check if the companion set is a self-intersection companion set and handle such sets differently		if ((*interCompanionSets[i])[0]->GetType() == GenericIntersection::BSP_BSP)		{			BspBspIntersection* inter = (BspBspIntersection*)(*interCompanionSets[i])[0];			BSpline *bsp1 = inter->GetBsp1();			BSpline *bsp2 = inter->GetBsp2();			WholeObject *wo1a = FindWholeObjectForBSpline(bsp1);			WholeObject *wo2a = FindWholeObjectForBSpline(bsp2);			MyAssert(wo1a && wo2a);			if (wo1a != wo2a)	//Nonself-intersecting companion set			{				//Take "votes" on which whole object should be on top for the companion set, then force the entire companion set to conform to the majority				int numWo1aOnTop = 0;				WholeObject *wo1, *wo2;				for (int j = 0; j < interCompanionSets[i]->size(); j++)					if ((*interCompanionSets[i])[j]->GetType() == GenericIntersection::BSP_BSP)					{						inter = (BspBspIntersection*)(*interCompanionSets[i])[j];						bsp1 = inter->GetBsp1();						bsp2 = inter->GetBsp2();						wo1 = FindWholeObjectForBSpline(inter->GetBsp1());						wo2 = FindWholeObjectForBSpline(inter->GetBsp2());						MyAssert((wo1 == wo1a && wo2 == wo2a) || (wo1 == wo2a && wo2 == wo1a));						if (wo1 == wo1a)							numWo1aOnTop++;					}								WholeObject *compSetTopWO = (numWo1aOnTop >= interCompanionSets[i]->size() / 2) ? wo1a : wo2a;								//Go through the intersections in the comp set, instantiating the majority vote winner chosen above				for (int j = 0; j < interCompanionSets[i]->size(); j++)					if ((*interCompanionSets[i])[j]->GetType() == GenericIntersection::BSP_BSP)					{						inter = (BspBspIntersection*)(*interCompanionSets[i])[j];												if (gDebug)						{							FloatPoint intersectionLoc = inter->GetLocation();							Rect r;							SetRect(&r, max(intersectionLoc.h, 0.0) - 10, intersectionLoc.v - 10, max(intersectionLoc.h, 0.0) + 10, intersectionLoc.v + 10);							ForeColor(greenColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int qD = 1;														ForeColor(whiteColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														qD = 1;						}												bsp1 = inter->GetBsp1();						bsp2 = inter->GetBsp2();						wo1 = FindWholeObjectForBSpline(inter->GetBsp1());						if (wo1 != compSetTopWO)						{							inter->FlipTopBottom();							intersFlipped++;						}					}			}			else	//Self-intersection companion set			{				MyAssert(false);	//Not implemented yet			}		}		else	//BspCut companion		{			MyAssert(false);	//Not implemented yet		}	}		//Start a queue that will collect intersections that need to have their four segment depths cleaned up.	//Seed the queue with all intersections on the test bsplines.	list<GenericIntersection*> cleanUpInters;	for (int i = 0; i < testBSplines.size(); i++)	{		vector<GenericIntersection*> inters = testBSplines[i]->GetIntersections();		for (int j = 0; j < inters.size(); j++)			if (inters[j]->GetType() == GenericIntersection::BSP_BSP && find(cleanUpInters.begin(), cleanUpInters.end(), inters[j]) == cleanUpInters.end())				cleanUpInters.push_back(inters[j]);	}		//Loop through the queue fixing each intersection's four segment depths and propagating through the drawing.	//Don't add an intersection to the queue more than once.	bool successfulLabeling = false;	int segDepthsChanged = 0;	for (list<GenericIntersection*>::iterator iter = cleanUpInters.begin(); iter != cleanUpInters.end(); iter++)	{		GenericIntersection* inter = *iter;				if (gDebug)		{			FloatPoint intersectionLoc = (*iter)->GetLocation();			Rect r;			SetRect(&r, max(intersectionLoc.h, 0.0) - 15, intersectionLoc.v - 15, max(intersectionLoc.h, 0.0) + 15, intersectionLoc.v + 15);			ForeColor(blackColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qD = 1;		}				switch (inter->GetType())		{			case GenericIntersection::BSP_BSP:				successfulLabeling = FixIntersectionSegmentDepths((BspBspIntersection*)inter, cleanUpInters, segDepthsChanged);				break;			case GenericIntersection::BSP_CUT:				successfulLabeling = FixIntersectionSegmentDepths((BspCutIntersection*)inter, cleanUpInters, segDepthsChanged);				break;			case GenericIntersection::BSP_CUT_T:				successfulLabeling = FixIntersectionSegmentDepths((BspCutTIntersection*)inter, cleanUpInters, segDepthsChanged);				break;			case GenericIntersection::CUT_CUT:				successfulLabeling = FixIntersectionSegmentDepths((CutCutIntersection*)inter, cleanUpInters, segDepthsChanged);				break;		}				if (gDebug)		{			FloatPoint intersectionLoc = inter->GetLocation();			Rect r;			SetRect(&r, max(intersectionLoc.h, 0.0) - 15, intersectionLoc.v - 15, max(intersectionLoc.h, 0.0) + 15, intersectionLoc.v + 15);			ForeColor(whiteColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qD = 1;		}				if (!successfulLabeling)			break;	}	PenSize(1, 1);		if (successfulLabeling)	{		VerticallyCompactDrawing();		NormalizeDepths();				VerifyNothingDtored();		FindWholeObjects2(testBSplines);		FindInterCompSetsForUnlabeledDrawing();	}	else	{		if (gDebug5)		{			InitAnalysisWindow();			MoveTo(5, IncrementTextV() * 10 + 5);			DrawString("\pLabeling attempt hit unresolvable constraint");			MoveTo(5, IncrementTextV() * 10 + 5);			DrawString("\pDrawing could not be labeled");		}				*this = *backup;	}	delete backup;		clock_t totalTimeUsed = clock() - timeStarted;		ClearBrandNewIntersections();	SetAllIntersectionsNoHardConstraint();	SetAllSectionsNoHardConstraint();		for (int i = 0; i < wholeObjects.size(); i++)		for (int j = 0; j < wholeObjects[i]->bspCutTinters.size(); j++)			MyAssert(!wholeObjects[i]->bspCutTinters[j]->GetDtored());		if (gDebug5)	{		InitAnalysisWindow();				IncrementTextV();		MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pSeconds used: ");				Str255 str1;				long double timeUsedSecs = totalTimeUsed / CLOCKS_PER_SEC;		FloatToPascal(timeUsedSecs, 3, str1);		DrawString(str1);				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pIntersections flipped: ");		NumToString(intersFlipped, str1);		DrawString(str1);				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pSegment depths changed: ");		NumToString(segDepthsChanged, str1);		DrawString(str1);				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}		return successfulLabeling;}void Drawing::ClearLabeling(){	ClearDepths();		for (int i = 0; i < wholeObjects.size(); i++)		delete wholeObjects[i];	wholeObjects.clear();		for (int i = 0; i < bsplinePairCuts.size(); i++)		delete bsplinePairCuts[i];	bsplinePairCuts.clear();		for (int i = 0; i < prevCuts.size(); i++)		delete prevCuts[i];	prevCuts.clear();}void Drawing::ClearDepths(){	for (vector<BSpline*>::iterator i = bsplines.begin(); i != bsplines.end(); i++)		(*i)->MakeAllDepthsZero();		for (vector<BSplineToBSplineCut*>::iterator i = bsplinePairCuts.begin(); i != bsplinePairCuts.end(); i++)		(*i)->MakeAllDepthsZero();}void Drawing::ClearOneIntersectionLabeling(int intersectionPoint){	MyAssert(intersections[intersectionPoint]->GetType() == GenericIntersection::BSP_BSP);	BspBspIntersection* bspBspInter = (BspBspIntersection*)intersections[intersectionPoint];		int occludedEdge = bspBspInter->DetermineOccludedEdge();	MyAssert(occludedEdge == 3 || occludedEdge == 4);		BSpline* bsp;	int cv, sg;		bsp = bspBspInter->GetBsp1();	cv = bspBspInter->GetCv1();	sg = bspBspInter->GetSg1();	if (occludedEdge == 3)		bsp->SetSectionDepthAfterIntersection(bspBspInter, cv, sg, bsp->GetSectionDepthBeforeIntersection(bspBspInter, cv, sg));	else bsp->SetSectionDepthBeforeIntersection(bspBspInter, cv, sg, bsp->GetSectionDepthAfterIntersection(bspBspInter, cv, sg));		bsp = bspBspInter->GetBsp2();	cv = bspBspInter->GetCv2();	sg = bspBspInter->GetSg2();	if (occludedEdge == 3)		bsp->SetSectionDepthBeforeIntersection(bspBspInter, cv, sg, bsp->GetSectionDepthAfterIntersection(bspBspInter, cv, sg));	else bsp->SetSectionDepthAfterIntersection(bspBspInter, cv, sg, bsp->GetSectionDepthBeforeIntersection(bspBspInter, cv, sg));}