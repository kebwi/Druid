#include "Grid.h"#include "GWorldWrapper.h"#include "trigConstants.h"#include "Colors.h"#include "PascalStringUtil.h"#include <math.h>#include <algorithm.h>#include <string>#include <sstream>using namespace::std;//******************************************************************************//Extern Globalsextern Colors gColors;//******************************************************************************//Global Declarations//******************************************************************************//Function Prototypes	//	In external files		//	main.cppvoid MyAssert(bool condition);#pragma mark -Grid::Grid(Point canvasSize) :	gridType(RECTANGULAR_GRID), gridSpacing(50), polarSymmetry(2), gww(NULL){	GenerateGrid(canvasSize);}Grid::Grid(const Grid& grid) :	gridType(grid.gridType), gridSpacing(grid.gridSpacing), polarSymmetry(grid.polarSymmetry), gww(NULL){	if (&grid == this)		return;		*this = grid;}Grid::~Grid(){	if (gww)		delete gww;}const Grid& Grid::operator=(const Grid& grid){	if (&grid == this)		return *this;		gridType = grid.gridType;	gridSpacing = grid.gridSpacing;	polarSymmetry = grid.polarSymmetry;		Rect dim = grid.gww->GetDim();	Point canvasSize = { dim.bottom, dim.right };	GenerateGrid(canvasSize);		return *this;}Grid::GridType Grid::GetGridType(){	return gridType;}int Grid::GetGridSpacing(){	return gridSpacing;}void Grid::SetRectangularGrid(){	if (gridType == RECTANGULAR_GRID)		return;		gridType = RECTANGULAR_GRID;	GenerateGrid();}void Grid::SetPolarGrid(){	if (gridType == POLAR_GRID)		return;		gridType = POLAR_GRID;	GenerateGrid();}#pragma mark -void Grid::GenerateGrid(){	Rect dim = gww->GetDim();	Point canvasSize = { dim.bottom, dim.right };	GenerateGrid(canvasSize);}void Grid::GenerateGrid(Point canvasSize){	Rect bounds = { 0, 0, canvasSize.v, canvasSize.h };	if (!gww)		gww = new GWorldWrapper(32, bounds, -1);	else gww->UpdateGWorldFromRect(bounds);		polarGridPoints.clear();		gww->StartUsingGWorld();	Rect dim = gww->GetDim();	RGBForeColor(&gColors.canvas);	PaintRect(&dim);	gww->FinishUsingGWorld();		if (gridType == RECTANGULAR_GRID)		GenerateRectangularGrid(canvasSize);	else if (gridType == POLAR_GRID)		GeneratePolarGrid(canvasSize);}void Grid::DrawGrid(WindowRef window, Point canvasSize, Point scrollOffset){	MyAssert(gww);		Rect bounds;	GetPortBounds(GetWindowPort(window), &bounds);		Rect srcRect, destRect;		srcRect = bounds;	srcRect.right -= 15;	srcRect.bottom -= 15;		if (srcRect.right > canvasSize.h)		srcRect.right = canvasSize.h;	if (srcRect.bottom > canvasSize.v)		srcRect.bottom = canvasSize.v;		destRect = srcRect;		if (scrollOffset.h < 0)		OffsetRect(&srcRect, -scrollOffset.h, 0);	else if (scrollOffset.h > 0)		OffsetRect(&destRect, scrollOffset.h, 0);		if (scrollOffset.v < 0)		OffsetRect(&srcRect, 0, -scrollOffset.v);	else if (scrollOffset.v > 0)		OffsetRect(&destRect, 0, scrollOffset.v);		SetPort(GetWindowPort(window));	ForeColor(blackColor);	gww->CopyWorldBits(srcRect, destRect, GetWindowPort(window));		//Write numbers on the axes	Rect dim = gww->GetDim();	int lastVplot = 0, lastHplot = 0;	Str255 str;	TextFont(FMGetFontFamilyFromName("\pHelvetica"));	TextFace(0);	TextSize(9);	if (gridType == RECTANGULAR_GRID)	{		//Loop over the rows		for (int y = gridSpacing; y < canvasSize.v; y += gridSpacing)		{			int vCoord = y;			if (vCoord > dim.bottom - dim.top)				break;						//Loop over the columns			for (int x = gridSpacing; x < canvasSize.h; x += gridSpacing)			{				int hCoord = x;				if (hCoord > dim.right - dim.left)					break;								//Write numbers along the axis				if (y == gridSpacing && x - lastHplot >= 64)				{					NumToString(x, str);					MoveTo(hCoord + 2 + scrollOffset.h, 12);					DrawString(str);					MoveTo(hCoord + 2 + scrollOffset.h, bounds.bottom - 15 - 2);					DrawString(str);										lastHplot = x;				}			}						//Write numbers along the axis			if (y - lastVplot >= 64)			{				NumToString(y, str);				MoveTo(2, vCoord - 2 + scrollOffset.v);				DrawString(str);				MoveTo(bounds.right - 15 - StringWidth(str) - 2, vCoord - 2 + scrollOffset.v);				DrawString(str);								lastVplot = y;			}		}	}	else if (gridType == POLAR_GRID)	{	}}void Grid::DrawPostscriptGrid(short fRefNum, Point canvasSize){	if (gridType == RECTANGULAR_GRID)		DrawPostscriptRectangularGrid(fRefNum, canvasSize);	else if (gridType == POLAR_GRID)		DrawPostscriptPolarGrid(fRefNum, canvasSize);}void Grid::GenerateRectangularGrid(Point canvasSize){	Rect dim = gww->GetDim();	gww->StartUsingGWorld();		Str255 str;		TextFont(FMGetFontFamilyFromName("\pHelvetica"));	TextSize(9);		int lastVplot = 0, lastHplot = 0;		RGBColor g;	g.red = g.green = g.blue = 16384;	RGBForeColor(&g);		//Loop over the rows	for (int y = gridSpacing; y < canvasSize.v; y += gridSpacing)	{		int vCoord = y;		if (vCoord > dim.bottom - dim.top)			break;				//Loop over the columns		for (int x = gridSpacing; x < canvasSize.h; x += gridSpacing)		{			int hCoord = x;			if (hCoord > dim.right - dim.left)				break;						MoveTo(hCoord, vCoord);			Line(0, 0);						//Write numbers along the axis			/*if (y == gridSpacing && x - lastHplot >= 64)			{				NumToString(x, str);				MoveTo(hCoord + 2, 12);				DrawString(str);				MoveTo(hCoord + 2, canvasSize.v - 2);				DrawString(str);								lastHplot = x;			}*/		}				//Write numbers along the axis		/*if (y - lastVplot >= 64)		{			NumToString(y, str);			MoveTo(2, vCoord - 2);			DrawString(str);			MoveTo(canvasSize.h - StringWidth(str) - 2, vCoord - 2);			DrawString(str);						lastVplot = y;		}*/	}		gww->FinishUsingGWorld();}void Grid::GeneratePolarGrid(Point canvasSize){	gww->StartUsingGWorld();		//Find the world center	Point center;	center.h = canvasSize.h / 2;	center.v = canvasSize.v / 2;		int verticalOffset = 0;		//Find half the world's diagonal (the furthest point from the center)	int halfCanvasDiagonal = sqrt(center.h * center.h + (center.v + verticalOffset) * (center.v + verticalOffset));		RGBColor g;	g.red = g.green = g.blue = 16384;	RGBColor g1;	g1.red = g1.green = g1.blue = 45000;//32768;	RGBColor g2;	g2.red = g2.green = g2.blue = 40000;		//Loop over the radii	int radiusCounter = 0;	for (int radius = 0; radius <= halfCanvasDiagonal; radius += gridSpacing)	{		double angleIncrement = (radius != 0) ? (PiTimes2 / ((double)polarSymmetry * 32.0)) : PiTimes2;		if (radius != 0)		{			double arc = (double)radius * angleIncrement;			while (arc < gridSpacing)			{				angleIncrement *= 2.0;				arc = (double)radius * angleIncrement;			}		}				int spacer = 4;		int counter = 0;				//Loop over the angles		for (double angle = 0; angle < PiTimes2 - .01; angle += angleIncrement)		{			int hCoord = center.h + cos(angle) * radius;			int vCoord = center.v + sin(angle) * radius + verticalOffset;						if (radiusCounter % 8 == 0 && counter % (spacer * 2) == 0)			{				RGBForeColor(&g2);				Rect r = { 0, 0, 5, 5 };				OffsetRect(&r, hCoord - 2, vCoord - 2);				FrameOval(&r);			}			else if (radiusCounter % 4 == 0 && counter % spacer == 0)			{				RGBForeColor(&g1);				Rect r = { 0, 0, 3, 3 };				OffsetRect(&r, hCoord - 1, vCoord - 1);				PaintOval(&r);			}			else			{				RGBForeColor(&g);				MoveTo(hCoord, vCoord);				Line(0, 0);			}			counter++;						Point pt = { vCoord, hCoord };			polarGridPoints.push_back(pt);		}				radiusCounter++;	}		gww->FinishUsingGWorld();}void Grid::DrawPostscriptRectangularGrid(short fRefNum, Point canvasSize){	string st;	string num;		st += "0.0005 setlinewidth\n";	st += ".5 .5 .5 setrgbcolor\n";		int lastVplot = 0, lastHplot = 0;		for (int y = gridSpacing; y < canvasSize.v; y += gridSpacing)	{		int vCoord = y;		for (int x = gridSpacing; x < canvasSize.h; x += gridSpacing)		{			int hCoord = x;						ostringstream oss;			oss << (double)(hCoord - 1) / canvasSize.h;			oss << " ";			oss << (double)(canvasSize.v - vCoord) / canvasSize.v;			oss << " moveto\n";						oss << (double)(hCoord + 1) / canvasSize.h;			oss << " ";			oss << (double)(canvasSize.v - vCoord) / canvasSize.v;			oss << " lineto\n";						oss << "stroke\n";						oss << (double)hCoord / canvasSize.h;			oss << " ";			oss << (double)(canvasSize.v - (vCoord - 1)) / canvasSize.v;			oss << " moveto\n";						oss << (double)hCoord / canvasSize.h;			oss << " ";			oss << (double)(canvasSize.v - (vCoord + 1)) / canvasSize.v;			oss << " lineto\n";						oss << "stroke\n";						st += oss.str();						//Write numbers along the axis			if (y == gridSpacing && x - lastHplot >= 64)			{				ostringstream oss;				oss << "/Times-Roman findfont\n";				oss << ".01 scalefont\n";				oss << "setfont\n";				oss << "newpath\n";				oss << (double)(hCoord + 2) / canvasSize.h;				oss << " ";				oss << (double)(canvasSize.v - 12) / canvasSize.v;				oss << " moveto\n";				oss << "(";				oss << (double)x;				oss << ") show\n";								st += oss.str();								lastHplot = x;			}		}				//Write numbers along the axis		if (y - lastVplot >= 64)		{			ostringstream oss;			oss << "/Times-Roman findfont\n";			oss << ".01 scalefont\n";			oss << "setfont\n";			oss << "newpath\n";			oss << (double)6 / canvasSize.h;			oss << " ";			oss << (double)(canvasSize.v - (vCoord - 2)) / canvasSize.v;			oss << " moveto\n";			oss << "(";			oss << (double)y;			oss << ") show\n";						st += oss.str();						lastVplot = y;		}	}		long strLen = st.length();	OSErr err = FSWrite(fRefNum, &strLen, st.c_str());}void Grid::DrawPostscriptPolarGrid(short fRefNum, Point canvasSize){}#pragma mark -void Grid::SnapToGrid(Point& p){	if (gridType == RECTANGULAR_GRID)	{		int halfModSize = gridSpacing / 2;				if (p.h % gridSpacing < halfModSize)			p.h -= p.h % gridSpacing;		else p.h = (p.h + gridSpacing) - (p.h % gridSpacing);				if (p.v % gridSpacing < halfModSize)			p.v -= p.v % gridSpacing;		else p.v = (p.v + gridSpacing) - (p.v % gridSpacing);	}	else if (gridType == POLAR_GRID)	{		double distSquared, minDistSquared = 999999;		Point minDistPoint = { 0, 0 };		for (int i = 0; i < polarGridPoints.size(); i++)		{			distSquared = ((p.h - polarGridPoints[i].h) * (p.h - polarGridPoints[i].h)) +						((p.v - polarGridPoints[i].v) * (p.v - polarGridPoints[i].v));			if (distSquared < minDistSquared)			{				minDistSquared = distSquared;				minDistPoint = polarGridPoints[i];			}		}		if (minDistSquared != 999999)			p = minDistPoint;	}}bool Grid::ChangeGridSettings(){	IBNibRef theNib;	OSStatus err = CreateNibReference(CFSTR("main"), &theNib);  	if (!err) 	{		//Create the window		WindowRef window;		CreateWindowFromNib(theNib, CFSTR("GridSettingsDlog"), &window);				ControlID inID = { 'grid', 3 };		ControlRef controlRef;		err = GetControlByID(window, &inID, &controlRef);				switch (gridType)		{			case RECTANGULAR_GRID:	SetControl32BitValue(controlRef, 1);	break;			case POLAR_GRID:	SetControl32BitValue(controlRef, 2);	break;		}				inID.id = 4;		err = GetControlByID(window, &inID, &controlRef);				Str255 str255;		NumToString(gridSpacing, str255);				char charStr[128];		PascalToC(str255, charStr);		Size bufferSize = str255[0], readSize;				err = SetControlData(controlRef, kControlEditTextPart, kControlEditTextTextTag, bufferSize, charStr);				inID.id = 5;		err = GetControlByID(window, &inID, &controlRef);				switch (polarSymmetry)		{			case 2:	SetControl32BitValue(controlRef, 1);	break;			case 3:	SetControl32BitValue(controlRef, 2);	break;			case 5:	SetControl32BitValue(controlRef, 3);	break;			case 7:	SetControl32BitValue(controlRef, 4);	break;		}				ShowWindow(window);				InstallStandardEventHandler(GetWindowEventTarget(window));				EventTypeSpec dlogEventList[] = {{kEventClassControl, kEventControlHit}};				//We shouldn't have to pass the window in through the userdata,		//but there is a problem otherwise so we are forced to until we solve the problem.		//See AboutBoxHandler() for more on this.		pair<Grid*, WindowRef> *par = new pair<Grid*, WindowRef>(this, window);		InstallWindowEventHandler(window, NewEventHandlerUPP(GridSettingsHandler), 1, dlogEventList, (void*)par, NULL);				cancel = false;		RunAppModalLoopForWindow(window);		delete par;				if (!cancel)		{			inID.id = 3;			ControlRef controlRef;			err = GetControlByID(window, &inID, &controlRef);						long gridTypeVal = GetControl32BitValue(controlRef);			switch (gridTypeVal)			{				case 1:	gridType = RECTANGULAR_GRID;	break;				case 2:	gridType = POLAR_GRID;	break;			}						inID.id = 4;			err = GetControlByID(window, &inID, &controlRef);						Size outSize;			err = GetControlDataSize(controlRef, kControlEditTextPart, kControlEditTextTextTag, &outSize);						char charStr[128];			Size bufferSize = 128, readSize;						err = GetControlData(controlRef, kControlEditTextPart, kControlEditTextTextTag, bufferSize, charStr, &readSize);			charStr[readSize] = '\0';						CtoPascal(charStr, str255);			StringToNum(str255, &gridSpacing);			if (gridSpacing < 2)				gridSpacing = 2;			else if (gridSpacing > 256)				gridSpacing = 256;						inID.id = 5;			err = GetControlByID(window, &inID, &controlRef);			long polarSymmetryMenuItem = GetControl32BitValue(controlRef);						switch (polarSymmetryMenuItem)			{				case 1:	polarSymmetry = 2;	break;				case 2:	polarSymmetry = 3;	break;				case 3:	polarSymmetry = 5;	break;				case 4:	polarSymmetry = 7;	break;			}						GenerateGrid();		}				DisposeWindow(window);	}}pascal OSStatus Grid::GridSettingsHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){	pair<Grid*, WindowRef> *par = (pair<Grid*, WindowRef>*)userData;	WindowRef           window = par->second;//NULL;	UInt32              whatHappened;	//OSStatus err = GetEventParameter(theEvent, kEventParamWindowRef, typeWindowRef,	//					NULL, sizeof(WindowRef), NULL, &window);	//err = GetEventParameter(theEvent, kEventParamDirectObject, typeWindowRef,	//					NULL, sizeof(WindowRef), NULL, &window);       whatHappened = GetEventKind(theEvent);		//http://developer.apple.com/documentation/Carbon/Conceptual/carbon_porting_guide/cpg_newtechstruct/chapter_5_section_6.html		switch (whatHappened)	{		case kEventControlHit:			ControlRef controlRef;			GetEventParameter(theEvent, kEventParamDirectObject, typeControlRef,								NULL, sizeof(ControlRef), NULL, &controlRef);						ControlID itemID;			GetControlID(controlRef, &itemID);						switch (itemID.id)			{				case 1:					QuitAppModalLoopForWindow(window);					break;				case 2:					par->first->cancel = true;					QuitAppModalLoopForWindow(window);					break;				case 3:					break;			}			break;	}		//This makes dialog items "work", like highlight buttons while the mouse is pressed over a button and hilighting text fields when they are clicked in, etc.	//CallNextEventHandler(nextHandler, theEvent);		return noErr;}