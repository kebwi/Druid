#ifndef __SUBBOUNDARIES__#define __SUBBOUNDARIES__#include "FloatPoint.h"//******************************************************************************//Extern Globals//******************************************************************************//Global Declarations//******************************************************************************//Function Prototypes	//	In external files		//	main.cppvoid MyAssert(bool condition);class GenericIntersection;class BSpline;class BSplineToBSplineCut;class WholeObject;#pragma mark -struct LineSegCurveIntersection{	BSpline* bspline;	int crv, seg;	FloatPoint location;	double lineSegStartDistance;	int edgeDirection;		/*operator<(LineSegCurveIntersection& o)	{		return lineSegStartDistance < o.lineSegStartDistance;	}*/};class LineSegCurveIntersectionSort{	public:		const bool operator()(const LineSegCurveIntersection& o1, const LineSegCurveIntersection& o2) const		{			return (o1.lineSegStartDistance < o2.lineSegStartDistance);		}};struct CutIntersection{	GenericIntersection* intersection;	WholeObject* crossingWholeObject;	double distFromStart;		CutIntersection() : intersection(NULL), crossingWholeObject(NULL), distFromStart(-1)	{ }};class CutIntersectionSort{	public:		const bool operator()(const CutIntersection& o1, const CutIntersection& o2) const		{			return (o1.distFromStart < o2.distFromStart);		}};class TraversedSection{	public:		GenericIntersection *startInter, *endInter;		bool traversalOnTop;		bool traverseForward;		int enteredCutForwards;	//Only used for cut sections		//0: false, 1: true, -1: ignore				TraversedSection() : startInter(NULL), endInter(NULL), traversalOnTop(true), traverseForward(true), enteredCutForwards(-1)		{ }				TraversedSection(GenericIntersection *si, GenericIntersection *ei, bool tot, bool tf, bool ecf) :			startInter(si), endInter(ei), traversalOnTop(tot), traverseForward(tf), enteredCutForwards(ecf)		{ }				const bool operator==(const TraversedSection& ts)		{			return (startInter == ts.startInter && endInter == ts.endInter && traversalOnTop == ts.traversalOnTop &&					traverseForward == ts.traverseForward && (enteredCutForwards == -1 || enteredCutForwards == ts.enteredCutForwards));		}};class OrientedBoundarySection{	public:		BSpline* bsp;		BSplineToBSplineCut* cut;		WholeObject* infiniteWO;	//Only used for a section on the infinite BSpline of an infinite surface		GenericIntersection *startInter, *endInter;		int startCv, startSg, endCv, endSg;		int startInfiniteWOsection, endInfiniteWOsection;	//Only used for a section on the infinite BSpline of an infinite surface		int subboundaryIndex;		bool traverseForward;				OrientedBoundarySection();				OrientedBoundarySection(BSpline* bspI, BSplineToBSplineCut* cutI, WholeObject* iwoI, GenericIntersection *si, GenericIntersection *ei, int scv, int ssg, int sich, bool tf);				const bool operator==(const OrientedBoundarySection& obs);				bool Opposite(const OrientedBoundarySection& obs);};class UnorientedBoundarySection{	public:		BSpline* bsp;		BSplineToBSplineCut* cut;		WholeObject* infiniteWO;	//Only used for a section on the infinite BSpline of an infinite surface		GenericIntersection *startInter, *endInter;		int startCv, startSg, endCv, endSg;		int startInfiniteWOsection, endInfiniteWOsection;	//Only used for a section on the infinite BSpline of an infinite surface		int subboundaryIndex;		unsigned long hashKey;		bool hashKeyGenerated;				//Unoriented boundary sections are always arranged with a forward traversal from startInter to endInter				UnorientedBoundarySection();				UnorientedBoundarySection(BSpline* bspI, BSplineToBSplineCut* cutI, WholeObject* iwoI, GenericIntersection *ia, GenericIntersection *ib, int scv, int ssg, int sich, bool polarity);						UnorientedBoundarySection(const OrientedBoundarySection& obs);				const bool operator==(const UnorientedBoundarySection& ubs);				//int FindSubboundarySection();				bool EqualObs(const OrientedBoundarySection& obs);				unsigned long GetHashKey();				bool operator()(UnorientedBoundarySection ubs1, UnorientedBoundarySection ubs2) const;};#endif