#include "TextGenerator.h"#include "MainWindow.h"#include "BSpline.h"#include "FloatPoint.h"#include "Enums.h"#include <Controls.h>#include <ControlDefinitions.h>#include <string.h>//******************************************************************************//Extern Globalsextern TextGenerator *gTextGenerator;extern MainWindow *gMainWindow;//******************************************************************************//Global DeclarationsEventLoopTimerRef TextGenerator::sUpdateTextTimer = NULL;//******************************************************************************//Function Prototypes	//	In external files		//	main.cppvoid MyAssert(bool condition);#pragma mark -TextGenerator::TextGenerator() : window(NULL), currentFontSizeCommandID('Z048'), filterDegenerates(true), fontMenuHierarchicalItems(NULL){}TextGenerator::~TextGenerator(){}#pragma mark -void TextGenerator::RunDialog(){	gMainWindow->FreezeMouseMovedEvents();		IBNibRef theNib;	OSStatus err = CreateNibReference(CFSTR("main"), &theNib);	if (!err) 	{		//Create the window		CreateWindowFromNib(theNib, CFSTR("TextGeneratorDlog"), &window);				InstallStandardEventHandler(GetWindowEventTarget(window));				EventTypeSpec dlogEventList[] = {{kEventClassControl, kEventControlHit}};				InstallWindowEventHandler(window, NewEventHandlerUPP(TextGeneratorHandler), 1, dlogEventList, (void*)this, NULL);				//================================================				ControlID inID = { 'txgn', 3 };		ControlRef controlRef;		GetControlByID(window, &inID, &controlRef);		fontMenuCurrentMenuRef = GetControlPopupMenuHandle(controlRef);		fontMenuID = GetMenuID(fontMenuCurrentMenuRef);		fontMenuCurrentMenuItem = (MenuItemIndex)-1;				DeleteMenuItem(fontMenuCurrentMenuRef, 1);				// Create the standard font menu		err = CreateStandardFontMenu(fontMenuCurrentMenuRef, 0, 1000, /*kHierarchicalFontMenuOption*/0, &numHierarchicalItems);				// Remember where all the submenus are		BuildFontMenuParentItemArray();				ItemCount numItems = CountMenuItems(fontMenuCurrentMenuRef);		SetControlMaximum(controlRef, numItems);				//================================================				inID.id = 5;		err = GetControlByID(window, &inID, &controlRef);				ControlEditTextValidationUPP controlEditTextValidationUPP = NewControlEditTextValidationUPP(EditTextValidationProc);			err = SetControlData(controlRef, kControlEntireControl, kControlEditTextValidationProcTag, (Size)sizeof(ControlEditTextValidationUPP), &controlEditTextValidationUPP);				ControlKeyFilterUPP controlKeyFilterUPP = NewControlKeyFilterUPP(ControlKeyFilterProc);			err = SetControlData(controlRef, kControlEntireControl, kControlEditTextKeyFilterTag, (Size)sizeof(ControlKeyFilterUPP), &controlKeyFilterUPP);				ShowWindow(window);				//================================================				char								startingFontName[] = "Geneva";		int									startingFontSize = 100;		ATSUFontID                          initFont;				verify_noerr( ATSUFindFontFromName(startingFontName, strlen(startingFontName), kFontFullName, kFontNoPlatform, kFontNoScript, kFontNoLanguage, &initFont) );	    FindAndSelectFont(initFont);				verify_noerr( ATSUCreateStyle(&style) );				textString = new UniChar[4];		textString[0] = 't';		textString[1] = 'e';		textString[2] = 'x';		textString[3] = 't';		textLength = 4;//sizeof(textString) / sizeof(UniChar);		verify_noerr( ATSUCreateTextLayoutWithTextPtr(textString, kATSUFromTextBeginning, kATSUToTextEnd, textLength, 1, &textLength, &style, &layout) );				font = initFont;		fontSize = Long2Fix(startingFontSize);				UpdateATSUIStyle();				Size bufferSize = 128;		char cStr[128];		UniCharToCstring(textString, cStr);		int len = 0;		while (cStr[len] != '\0')			len++;		//len++;	//Don't do this because we don't want to add the null character to the edit text				inID.id = 5;		GetControlByID(window, &inID, &controlRef);		err = SetControlData(controlRef, kControlEditTextPart, kControlEditTextTextTag, len, cStr);				//================================================				RedrawEditText();				cancel = false;		RunAppModalLoopForWindow(window);				DisposeWindow(window);		window = NULL;				DisposeControlEditTextValidationUPP(controlEditTextValidationUPP);		DisposeControlKeyFilterUPP(controlKeyFilterUPP);				if (!cancel)		{			int len = 0;			while (textString[len++]);			len--;			textLength = len;//sizeof(textString) / sizeof(UniChar);			verify_noerr( ATSUCreateTextLayoutWithTextPtr(textString, kATSUFromTextBeginning, kATSUToTextEnd, textLength, 1, &textLength, &style, &layout) );						generateBSplines = true;			RenderGlyphs(true);						generateBSplines = false;		}			    verify_noerr( ATSUDisposeStyle(style) );	    verify_noerr( ATSUDisposeTextLayout(layout) );	}		gMainWindow->ResumeMouseMovedEvents();}pascal OSStatus TextGenerator::TextGeneratorHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){	TextGenerator*      textGenerator = (TextGenerator*)userData;	WindowRef			window = NULL;	UInt32              whatHappened;	OSErr				err;		err = GetEventParameter(theEvent, kEventParamWindowRef, typeWindowRef,						NULL, sizeof(WindowRef), NULL, &window);    								whatHappened = GetEventKind(theEvent);		//http://developer.apple.com/documentation/Carbon/Conceptual/carbon_porting_guide/cpg_newtechstruct/chapter_5_section_6.html		switch (whatHappened)	{		case kEventControlHit:			{				ControlRef controlRef;				GetEventParameter(theEvent, kEventParamDirectObject, typeControlRef,									NULL, sizeof(ControlRef), NULL, &controlRef);								ControlID itemID;				GetControlID(controlRef, &itemID);								switch (itemID.id)				{					case 1:						QuitAppModalLoopForWindow(textGenerator->window);						break;					case 2:						textGenerator->cancel = true;						QuitAppModalLoopForWindow(textGenerator->window);						break;					case 3:						{							ControlID inID = { 'txgn', 3 };							ControlRef controlRef;							err = GetControlByID(textGenerator->window, &inID, &controlRef);														short cMax = GetControlMaximum(controlRef);														long menuItem = GetControl32BitValue(controlRef);														//Size bufferSize = 1, readSize;							//err = GetControlData(controlRef, kControlMenuPart, kControlPopupButtonMenuIDTag, bufferSize, &menuItem, &readSize);														MenuRef menuRef = GetControlPopupMenuHandle(controlRef);							textGenerator->SelectAndGetFont(menuRef, menuItem);							textGenerator->RedrawEditText();						}						break;					case 4:						{							ControlID inID = { 'txgn', 4 };							ControlRef controlRef;							err = GetControlByID(textGenerator->window, &inID, &controlRef);														long menuItem = GetControl32BitValue(controlRef);														//Size bufferSize = 1, readSize;							//err = GetControlData(controlRef, kControlMenuPart, kControlPopupButtonMenuIDTag, bufferSize, &menuItem, &readSize);														long fontSize = menuItem * 100;							textGenerator->SetFontSize(Long2Fix(fontSize));							textGenerator->RedrawEditText();						}						break;					case 5:						{							//kEventClassTextInput and kEventTextInputUnicodeText														//kControlEditTextValidationProc and kControlEditTextKeyFilter														Size outSize;							err = GetControlDataSize(controlRef, kControlEditTextPart, kControlEditTextTextTag, &outSize);														char charStr[128];							Size bufferSize = 128, readSize;														err = GetControlData(controlRef, kControlEditTextPart, kControlEditTextTextTag, bufferSize, charStr, &readSize);							if (err == noErr)							{								charStr[readSize] = '\0';								textGenerator->CstringToUniChar(charStr, textGenerator->textString);								textGenerator->RedrawEditText();							}						}						CallNextEventHandler(nextHandler, theEvent);						break;				}			}			break;	}		//This makes dialog items "work", like highlight buttons while the mouse is pressed over a button and hilighting text fields when they are clicked in, etc.	//CallNextEventHandler(nextHandler, theEvent);		return noErr;}pascal void TextGenerator::EditTextValidationProc(ControlRef controlRef){}pascal ControlKeyFilterResult TextGenerator::ControlKeyFilterProc(ControlRef theControl, SInt16 *keyCode, SInt16 *charCode, EventModifiers *modifiers){	Size outSize;	OSErr err = GetControlDataSize(theControl, kControlEditTextPart, kControlEditTextTextTag, &outSize);		char charStr[128];	Size bufferSize = 128, readSize;		err = GetControlData(theControl, kControlEditTextPart, kControlEditTextTextTag, bufferSize, charStr, &readSize);	if (err == noErr)	{		char c = *charCode;		if (c != '\34' && c != '\35' && c != '\36' && c != '\37')	//Ignore arrow keys		{			if (!sUpdateTextTimer)				InstallEventLoopTimer(GetMainEventLoop(), 0, .1 * kEventDurationSecond,									NewEventLoopTimerUPP(UpdateTextTimerHandler), (void*)theControl, &sUpdateTextTimer);		}				return kControlKeyFilterPassKey;	}		return kControlKeyFilterPassKey;//kControlKeyFilterBlockKey;}pascal void TextGenerator::UpdateTextTimerHandler(EventLoopTimerRef theTimer, void* userData){	MyAssert(theTimer == sUpdateTextTimer);		ControlRef controlRef = (ControlRef)userData;		Size outSize;	OSErr err = GetControlDataSize(controlRef, kControlEditTextPart, kControlEditTextTextTag, &outSize);		char charStr[128];	Size bufferSize = 128, readSize;		err = GetControlData(controlRef, kControlEditTextPart, kControlEditTextTextTag, bufferSize, charStr, &readSize);	if (err == noErr)	{		charStr[readSize] = '\0';		gTextGenerator->CstringToUniChar(charStr, gTextGenerator->textString);		gTextGenerator->RedrawEditText();	}		RemoveEventLoopTimer(theTimer);	sUpdateTextTimer = NULL;}void TextGenerator::RedrawEditText(){	Size bufferSize = 128;	char cStr[128];	UniCharToCstring(textString, cStr);	int len = 0;	while (cStr[len] != '\0')		len++;	//len++;	//Don't do this because we don't want to add the null character to the edit text		ControlID inID = { 'txgn', 5 };	ControlRef controlRef;	GetControlByID(window, &inID, &controlRef);	//OSErr err = SetControlData(controlRef, kControlEditTextPart, kControlEditTextTextTag, len, cStr);		DrawControls(window);		len = 0;	while (cStr[len] != '\0')		len++;	textLength = len;//sizeof(textString) / sizeof(UniChar);	verify_noerr( ATSUCreateTextLayoutWithTextPtr(textString, kATSUFromTextBeginning, kATSUToTextEnd, textLength, 1, &textLength, &style, &layout) );		generateBSplines = false;	gMainWindow->Redraw();}void TextGenerator::UniCharToStr255(UniChar* uniCharStr, Str255& str255){	int len = 0;	while (uniCharStr[len] != '\0')		len++;	if (len > 254)		len = 254;		str255[0] = len;	for (int i = 0; i < len; i++)		str255[i + 1] = uniCharStr[i];}void TextGenerator::UniCharToCstring(UniChar* uniCharStr, char* cStr){	int len = 0;	while (uniCharStr[len] != '\0')		len++;	if (len > 127)		len = 127;		for (int i = 0; i < len; i++)		cStr[i] = uniCharStr[i];	cStr[len] = '\0';}void TextGenerator::Str255ToUniChar(Str255 str255, UniChar*& uniCharStr){	delete [] uniCharStr;	uniCharStr = new UniChar[str255[0] + 1];	for (int i = 0; i < str255[0]; i++)		uniCharStr[i] = str255[i + 1];	uniCharStr[str255[0]] = '\0';}void TextGenerator::CstringToUniChar(char* cStr, UniChar*& uniCharStr){	int len = 0;	while (cStr[len] != '\0')		len++;		delete [] uniCharStr;	uniCharStr = new UniChar[len + 1];	for (int i = 0; i < len; i++)		uniCharStr[i] = cStr[i];	uniCharStr[len] = '\0';}#pragma mark -// Builds and attaches the font menu in the specified menu//OSStatus TextGenerator::InstallFontMenu(MenuID menuID){	OSStatus status;	// Initialize globals	fontMenuID = menuID;	//InsertMenu(GetMenu(fontMenuID), -1);	fontMenuCurrentMenuRef = GetMenuRef(fontMenuID);	fontMenuCurrentMenuItem = (MenuItemIndex)-1;	// Create the standard font menu	status = CreateStandardFontMenu(fontMenuCurrentMenuRef, 0, 1000, /*kHierarchicalFontMenuOption*/0, &numHierarchicalItems);	if ( status != noErr) return status;	// Remember where all the submenus are	BuildFontMenuParentItemArray();	return status;}// Creates a global array containing information about the submenus in the hierarchical font menu.// This information is then used by GetFontMenuParentItem.//void TextGenerator::BuildFontMenuParentItemArray(void){    ItemCount               numItems;    int                     i, currentIndex;    MenuRef                 theSubMenu;    // Build an array of item indexes which have hierarchical menus -- used in GetFontMenuParentItem (see below)    //fontMenuHierarchicalItems = (MenuItemIndex *) malloc(sizeof(MenuItemIndex) * numHierarchicalItems);	if (fontMenuHierarchicalItems)		delete [] fontMenuHierarchicalItems;	fontMenuHierarchicalItems = new MenuItemIndex[numHierarchicalItems];	    currentIndex = 0;    numItems = CountMenuItems(GetMenuRef(fontMenuID));    for (i=1; i <= numItems; i++) {        verify_noerr( GetMenuItemHierarchicalMenu(GetMenuRef(fontMenuID), i, &theSubMenu) );        if ( theSubMenu != NULL ) {            fontMenuHierarchicalItems[currentIndex++] = i;        }    }    check( currentIndex == numHierarchicalItems );     // Make sure we found the right number}// Gets the parent item of a font in a submenu.  Returns zero if not found.//MenuItemIndex TextGenerator::GetFontMenuParentItem(MenuRef inMenu){    MenuRef                 theSubMenu;    int                     i;        for(i=0; i < numHierarchicalItems; i++) {        verify_noerr( GetMenuItemHierarchicalMenu(GetMenuRef(fontMenuID), fontMenuHierarchicalItems[i], &theSubMenu) );        if ( theSubMenu == inMenu ) {            return fontMenuHierarchicalItems[i];        }    }    return 0;}// Handles changes to the font menu//void TextGenerator::SelectAndGetFont(MenuRef theMenu, MenuItemIndex theItem){    MenuRef                 parentMenuRef;    MenuItemIndex           parentMenuItem;    FMFontFamily            theFMFontFamily;    FMFontStyle             theFMFontStyle;    // Uncheck the previous item (if any)    if (fontMenuCurrentMenuItem != (MenuItemIndex)-1) {        CheckMenuItem(fontMenuCurrentMenuRef, fontMenuCurrentMenuItem, false);        if ( GetMenuID(fontMenuCurrentMenuRef) > fontMenuID ) {		// Sub-menus will have MenuIDs starting at fontMenuID + 1            parentMenuRef = GetMenuRef(fontMenuID);            parentMenuItem = GetFontMenuParentItem(fontMenuCurrentMenuRef);            if ( parentMenuItem > 0 ) {                SetItemMark(parentMenuRef, parentMenuItem, kMenuNoMark);            }        }    }    // Check the new item    CheckMenuItem(theMenu, theItem, true);    if ( GetMenuID(theMenu) > fontMenuID ) {							// Sub-menus will have MenuIDs starting at fontMenuID + 1        parentMenuRef = GetMenuRef(fontMenuID);        parentMenuItem = GetFontMenuParentItem(theMenu);        if ( parentMenuItem > 0 ) {            SetItemMark(parentMenuRef, parentMenuItem, kMenuDashMark);        }    }        // Store the current item in the globals for future reference    fontMenuCurrentMenuRef = theMenu;    fontMenuCurrentMenuItem = theItem;    // Return the proper font    verify_noerr( GetFontFamilyFromMenuSelection(fontMenuCurrentMenuRef, fontMenuCurrentMenuItem, &theFMFontFamily, &theFMFontStyle) );    verify_noerr( FMGetFontFromFontFamilyInstance(theFMFontFamily, theFMFontStyle, &font, NULL) );    	UpdateATSUIStyle();}void TextGenerator::SetFontSize(Fixed newFontSize){	fontSize = newFontSize;    UpdateATSUIStyle();}// Walks the font menu, finds and selects the specified font// Returns false if the font could not be found//Boolean TextGenerator::FindAndSelectFont(FMFont iFont){    FMFontFamily            theFMFontFamily;    FMFontStyle             theFMFontStyle;    FMFont					currentFont;    ItemCount               numItems, numSubItems;    MenuRef                 theSubMenu = NULL;    MenuItemIndex			parentMenuItem, i, j;    Boolean					found = false;    // Loop over all the parent menu items (outer loop)    numItems = CountMenuItems(GetMenuRef(fontMenuID));    for (i=1; i <= numItems; i++) {        // Check to see if this item is hierarchical        verify_noerr( GetMenuItemHierarchicalMenu(GetMenuRef(fontMenuID), i, &theSubMenu) );        if ( theSubMenu != NULL ) {            // Loop over all the submenu items (inner loop)            numSubItems = CountMenuItems(theSubMenu);            for (j=1; j <= numSubItems; j++) {                verify_noerr( GetFontFamilyFromMenuSelection(theSubMenu, j, &theFMFontFamily, &theFMFontStyle) );                verify_noerr( FMGetFontFromFontFamilyInstance(theFMFontFamily, theFMFontStyle, &currentFont, NULL) );                                if (currentFont == iFont) {                    found = true;                    break;                }            } // End of inner loop        }        else {            verify_noerr( GetFontFamilyFromMenuSelection(GetMenuRef(fontMenuID), i, &theFMFontFamily, &theFMFontStyle) );            verify_noerr( FMGetFontFromFontFamilyInstance(theFMFontFamily, theFMFontStyle, &currentFont, NULL) );                        if (currentFont == iFont) {                found = true;            }        }        if (found) break;    } // End of outer loop            // If the font was found, check its menu item (uncheck the previous one, if there is one)    //    if (found) {        // Uncheck the previous item (if any)        if (fontMenuCurrentMenuItem != (MenuItemIndex)-1) {            CheckMenuItem(fontMenuCurrentMenuRef, fontMenuCurrentMenuItem, false);            if ( GetMenuID(fontMenuCurrentMenuRef) > fontMenuID ) {		// Sub-menus will have MenuIDs starting at fontMenuID + 1                parentMenuItem = GetFontMenuParentItem(fontMenuCurrentMenuRef);                if ( parentMenuItem > 0 ) {                    SetItemMark(GetMenuRef(fontMenuID), parentMenuItem, kMenuNoMark);                }            }        }            // Check the new item        if (theSubMenu != NULL) {            fontMenuCurrentMenuRef = theSubMenu;            fontMenuCurrentMenuItem = j;            SetItemMark(GetMenuRef(fontMenuID), i, kMenuDashMark);        }        else {            fontMenuCurrentMenuRef = GetMenuRef(fontMenuID);            fontMenuCurrentMenuItem = i;        }        CheckMenuItem(fontMenuCurrentMenuRef, fontMenuCurrentMenuItem, true);    }    return found;}// Updates the ATSUI style to the current font and size//void TextGenerator::UpdateATSUIStyle(){    ATSUAttributeTag                    tags[3];    ByteCount                           sizes[3];    ATSUAttributeValuePtr               values[3];    tags[0] = kATSUFontTag;    sizes[0] = sizeof(ATSUFontID);    values[0] = &font;        tags[1] = kATSUSizeTag;    sizes[1] = sizeof(Fixed);    values[1] = &fontSize;        verify_noerr(ATSUSetAttributes(style, 2, tags, sizes, values) );}#pragma mark -bool TextGenerator::GetFilterDegenerates(){	return filterDegenerates;}bool TextGenerator::GetGenerateBSplines(){	return generateBSplines;}void TextGenerator::AddNewControlPointSet(){	vector<FloatPoint> newControlPointSet;	glyphControlPoints.push_back(newControlPointSet);}vector<FloatPoint>* TextGenerator::GetPresentGlyphControlPoints(){	return &glyphControlPoints.back();}vector<vector<FloatPoint> > TextGenerator::GetGlyphControlPoints(){	return glyphControlPoints;}void TextGenerator::ClearGlyphControlPoints(){	for (int i = 0; i < glyphControlPoints.size(); i++)		glyphControlPoints[i].clear();	glyphControlPoints.clear();}#pragma mark -void TextGenerator::RenderGlyphs(bool ignoreDialogVisibility){	if (!ignoreDialogVisibility && (!window || !IsWindowVisible(window)))		return;		GlyphRecord						    *glyphRecordArray;	ItemCount							numGlyphs;	ATSQuadraticNewPathUPP              newPathProc;	ATSQuadraticLineUPP                 lineProc;	ATSQuadraticCurveUPP                curveProc;	ATSQuadraticClosePathUPP            closePathProc;	CurveCallbackData                   data;	OSStatus                            status;	int                                 i;	Fixed penX, penY;		Point loc = { 350, 50 };	penX = Long2Fix(loc.h);	penY = Long2Fix(loc.v);	// Create the Quadratic callbacks	newPathProc = NewATSQuadraticNewPathUPP(QuadraticNewPathProc);	lineProc = NewATSQuadraticLineUPP(QuadraticLineProc);	curveProc = NewATSQuadraticCurveUPP(QuadraticCurveProc);	closePathProc = NewATSQuadraticClosePathUPP(QuadraticClosePathProc);	// Get the array of glyph information	GetGlyphIDsAndPositions(layout, kATSUFromTextBeginning, kATSUToTextEnd, &glyphRecordArray, &numGlyphs);	// Begin a CG path for the outlines and set the stroke color to red	//if (gUseCG) CGContextSetRGBStrokeColor(gContext, 1.0, 0.0, 0.0, 1.0); else ForeColor(redColor);	//if (gUseCG) CGContextBeginPath(gContext);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	ForeColor(redColor);		ClearGlyphControlPoints();		// Loop over all the glyphs	data.windowHeight = 700;//windowHeight; // Needed for flipping the y-coordinate between CG and QD space	for (i = 0; i < numGlyphs; i++)	{		// Set up the absolute origin of the glyph		data.origin.x = Fix2X(penX) + glyphRecordArray[i].relativeOrigin.x;		data.origin.y = Fix2X(penY) + glyphRecordArray[i].relativeOrigin.y;		// Reset state for quadratic drawing (the callbacks only do a MoveTo on the very first segment)		data.first = true;		// If this is a deleted glyph (-1), don't draw it.  Otherwise, go ahead.		if ( glyphRecordArray[i].glyphID != kATSDeletedGlyphcode )		{			verify_noerr( ATSUGlyphGetQuadraticPaths(style, glyphRecordArray[i].glyphID, newPathProc, lineProc, curveProc, closePathProc, &data, &status) );		}	}	// Free the array of glyph information	delete [] glyphRecordArray;	// Dispose of the Quadratic callbacks	DisposeATSQuadraticNewPathUPP(newPathProc);	DisposeATSQuadraticLineUPP(lineProc);	DisposeATSQuadraticCurveUPP(curveProc);	DisposeATSQuadraticClosePathUPP(closePathProc);		if (generateBSplines)	{		for (int i = 0; i < glyphControlPoints.size(); i++)			if (glyphControlPoints[i].size() > 2)//0)	//For some reason, some fonts create empty paths, so skip those paths				gMainWindow->CreateBSplineFromControlPointList(glyphControlPoints[i]);		gMainWindow->CreateLegalLabeling();	}		ClearGlyphControlPoints();		//QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);}void TextGenerator::GetGlyphIDsAndPositions(ATSUTextLayout iLayout, UniCharArrayOffset iStart, UniCharCount iLength, GlyphRecord **oGlyphRecordArray, ItemCount *oNumGlyphs){    ATSUGlyphInfoArray					*theGlyphInfoArrayPtr;    ByteCount							theArraySize;    int									i;        // Get the GlyphInfoArray    verify_noerr( ATSUGetGlyphInfo(iLayout, iStart, iLength, &theArraySize, NULL) );    //theGlyphInfoArrayPtr = (ATSUGlyphInfoArray *) malloc(theArraySize + sizeof(ItemCount) + sizeof(ATSUTextLayout));    theGlyphInfoArrayPtr = (ATSUGlyphInfoArray*)(new char[theArraySize + sizeof(ItemCount) + sizeof(ATSUTextLayout)]);    verify_noerr( ATSUGetGlyphInfo(iLayout, iStart, iLength, &theArraySize, theGlyphInfoArrayPtr) );    // Build the array of GlyphRecords    *oGlyphRecordArray = new GlyphRecord[theGlyphInfoArrayPtr->numGlyphs];    *oNumGlyphs = theGlyphInfoArrayPtr->numGlyphs;        for (i=0; i < *oNumGlyphs; i++) {        // Fill in the glyphID        (*oGlyphRecordArray)[i].glyphID = theGlyphInfoArrayPtr->glyphs[i].glyphID;            // Set up the relative origin of the glyph        //        // The ideal position is the x coordinate of the glyph, relative to the beginning of the line        // The deltaY is the y coordinate of the glyph, relative to the baseline        //        (*oGlyphRecordArray)[i].relativeOrigin.x = theGlyphInfoArrayPtr->glyphs[i].idealX;		// These older APIs return float values        (*oGlyphRecordArray)[i].relativeOrigin.y = 0.0 - theGlyphInfoArrayPtr->glyphs[i].deltaY; // 		"		"		"		"    }            // Free the GlyphInfoArray    delete theGlyphInfoArrayPtr;}#pragma mark -pascal OSStatus TextGenerator::QuadraticLineProc(const Float32Point *pt1, const Float32Point *pt2, void *callBackDataPtr){    // Adjust the points according to the glyph origin    float x1 = ((CurveCallbackData *)callBackDataPtr)->origin.x + pt1->x;    float y1 = ((CurveCallbackData *)callBackDataPtr)->origin.y + pt1->y;    float x2 = ((CurveCallbackData *)callBackDataPtr)->origin.x + pt2->x;    float y2 = ((CurveCallbackData *)callBackDataPtr)->origin.y + pt2->y;    // Beginning of degenerate filter    if ( ! (gTextGenerator->GetFilterDegenerates() && (x1 == x2) && (y1 == y2)) ) {        // Draw a line according to the points       // Use QuickDraw        MoveTo(x1, y1);        LineTo(x2, y2);        QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	    		if (gTextGenerator->GetGenerateBSplines())		{			vector<FloatPoint>* glyphControlPoints = gTextGenerator->GetPresentGlyphControlPoints();			FloatPoint newControlPoint(x1, y1);			glyphControlPoints->push_back(newControlPoint);		}    } // End of degenerate filter    return noErr;}// Handles a curve drawing operation for quadratic (TrueType) outlines//// The curve is a quadratic patch specified by a start point (pt1), and end point (pt2), and a single control point (controlPt)//pascal OSStatus TextGenerator::QuadraticCurveProc(const Float32Point *pt1, const Float32Point *controlPt, const Float32Point *pt2, void *callBackDataPtr){    // Adjust the points according to the glyph origin    float x1 = ((CurveCallbackData *)callBackDataPtr)->origin.x + pt1->x;    float y1 = ((CurveCallbackData *)callBackDataPtr)->origin.y + pt1->y;    float x2 = ((CurveCallbackData *)callBackDataPtr)->origin.x + pt2->x;    float y2 = ((CurveCallbackData *)callBackDataPtr)->origin.y + pt2->y;    float cpx = ((CurveCallbackData *)callBackDataPtr)->origin.x + controlPt->x;    float cpy = ((CurveCallbackData *)callBackDataPtr)->origin.y + controlPt->y;    // Draw a curve according to the points    // Use QuickDraw to simply draw a "connect the dots" representation of the curve    MoveTo(x1, y1);    LineTo(x2, y2);    QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);    	if (gTextGenerator->GetGenerateBSplines())	{		vector<FloatPoint>* glyphControlPoints = gTextGenerator->GetPresentGlyphControlPoints();		FloatPoint newControlPoint(x1, y1);		glyphControlPoints->push_back(newControlPoint);	}    return noErr;}// Handles a new path operation for quadratic (TrueType) outlines//pascal OSStatus TextGenerator::QuadraticNewPathProc(void * callBackDataPtr){	((CurveCallbackData *)callBackDataPtr)->first = true;		if (gTextGenerator->GetGenerateBSplines())		gTextGenerator->AddNewControlPointSet();	return noErr;}// Handles a close path operation for quadratic (TrueType) outlines//pascal OSStatus TextGenerator::QuadraticClosePathProc(void * callBackDataPtr){    ((CurveCallbackData *)callBackDataPtr)->first = true;    //segmentCount = 0;    //lineToCount = 0;    //curveToCount = 0;    return noErr;}//=======================================================================================//=======================================================================================//=======================================================================================/*void ControlRef::EnableValueChangeEvents(){	optional<bool> alreadyEnabled = GetOptionalProperty<controlProperty_ValueChangeEventsEnabled>();	if (alreadyEnabled and *alreadyEnabled)		return;	// Set up validation hooks	SetData<controlEditTextValidationProc>(EditFieldValueChanged_ValidationProc);	SetData<controlEditTextKeyFilter>(EditFieldValueChanged_FilterProc);	SetProperty<controlProperty_ValueChangeEventsEnabled>(true);} // ControlRef::EnableValueChangeEventspascal ControlKeyFilterResult EditFieldValueChanged_FilterProc(																::ControlRef               inControl, 																SInt16*                    ,//inKeyCode																SInt16*                    ,//inCharCode 																EventModifiers*)			//inModifiers{		BEGIN_EXCEPTION_GUARD		{			PostEditFieldValueChangedEvent(inControl);		} catch (...) {		LogCurrentException();	} END_EXCEPTION_GUARD;	return kControlKeyFilterPassKey;} // EditFieldValueChanged_FilterProcpascal void EditFieldValueChanged_ValidationProc(::ControlRef inControl){	BEGIN_EXCEPTION_GUARD	{		PostEditFieldValueChangedEvent(inControl);	}	catch (...)	{		LogCurrentException();	} END_EXCEPTION_GUARD;} // EditFieldValueChange_FilterProcbool PostEditFieldValueChangedEvent(U::ControlRef inControl){	U::Event event(U::Event::Create(eventClass_Utilities, kEventControlValueFieldChanged));	event.SetParameter<U::eventParamPostTarget>(inControl);	event.SetDirectObject<eventClass_Utilities, 	kEventControlValueFieldChanged>(inControl);	U::EventQueueRef::GetMain().Post(event, kEventPriorityHigh);	return false;} // PostValueChangedEvent*/