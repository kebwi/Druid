#include "BspCutTIntersection.h"#include "BSpline.h"#include "BSplineToBSplineCut.h"#include "Drawing.h"#include "trigConstants.h"#include <math.h>#include <vector.h>#include <algorithm.h>#include <string>#include <sstream>using namespace::std;//******************************************************************************//Extern Globals//******************************************************************************//Function Prototypes	//	In this file	//	In external files		//	main.cppvoid MyAssert(bool condition);		//lineEquations.cppdouble LineSegmentAngle(FloatPoint p1, FloatPoint p2);int LineCrossLineDirection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2);#pragma mark -BspCutTIntersection::BspCutTIntersection(Drawing* theDrawing) : GenericIntersection(GenericIntersection::BSP_CUT_T, theDrawing),	bsp(NULL), cut(NULL), infiniteWholeObject(NULL), bspIndex(-1), cutIndex(-1),	cv(-1), seg(-1), infiniteWOsection(-1), edgeDirection(0), interAtStart(true){}BspCutTIntersection::BspCutTIntersection(Drawing* theDrawing, FloatPoint locInit, BSpline *initBsp, BSplineToBSplineCut *initCut,										int initBspIndex, int initCutIndex, int initCv, int initSg, int initInfiniteWOsection, int initEdgeDirection, bool initInterAtStart) :	GenericIntersection(GenericIntersection::BSP_CUT_T, theDrawing, locInit),	bsp(initBsp), cut(initCut), infiniteWholeObject(NULL), bspIndex(initBspIndex), cutIndex(initCutIndex),	cv(initCv), seg(initSg), infiniteWOsection(initInfiniteWOsection), edgeDirection(initEdgeDirection), interAtStart(initInterAtStart){	MyAssert(!dtored);	//MyAssert(bsp);	MyAssert(cut);}BspCutTIntersection::BspCutTIntersection(BspCutTIntersection& intersection, Drawing* d, BSpline *initBsp, BSplineToBSplineCut *initCut) :	GenericIntersection(intersection, d){	bspIndex = intersection.bspIndex;	cutIndex = intersection.cutIndex;	cv = intersection.cv;	seg = intersection.seg;	infiniteWOsection = intersection.infiniteWOsection;	edgeDirection = intersection.edgeDirection;	interAtStart = intersection.interAtStart;		bsp = initBsp;	cut = initCut;	infiniteWholeObject = NULL;		//MyAssert(bsp);	MyAssert(!dtored);}BspCutTIntersection::~BspCutTIntersection(){	MyAssert(!dtored);		if (bsp)		bsp->RemoveIntersection(cv, (GenericIntersection*)this);	MyAssert(!dtored);		if (cut)		cut->RemoveIntersection((GenericIntersection*)this, true, false);	MyAssert(!dtored);		if (infiniteWholeObject)	{		MyAssert(!infiniteWholeObject->dtored);		drawing->RemoveWholeObjectBspCutTInter(infiniteWholeObject, this);	}		//dtored will be set true in the GenericIntersection dtor}BSpline* BspCutTIntersection::GetBsp(){	MyAssert(!dtored);	return bsp;}BSplineToBSplineCut* BspCutTIntersection::GetCut(){	MyAssert(!dtored);	return cut;}WholeObject* BspCutTIntersection::GetInfiniteWholeObject(){	if (infiniteWholeObject)		MyAssert(!infiniteWholeObject->dtored);		//MyAssert(infiniteWholeObject);	//Is this assert really necessary?	return infiniteWholeObject;}int BspCutTIntersection::GetBspIndex(){	MyAssert(!dtored);	return bspIndex;}int BspCutTIntersection::GetCutIndex(){	MyAssert(!dtored);	return cutIndex;}int BspCutTIntersection::GetWOIndex(){	MyAssert(!dtored);	if (!infiniteWholeObject)		return -1;	return drawing->GetWholeObjectIndex(infiniteWholeObject);}int BspCutTIntersection::GetCv(){	MyAssert(!dtored);	return cv;}int BspCutTIntersection::GetSg(){	MyAssert(!dtored);	return seg;}int BspCutTIntersection::GetInfiniteWOsection(){	if (infiniteWholeObject)		MyAssert(!infiniteWholeObject->dtored);		MyAssert(!dtored);	return infiniteWOsection;}int BspCutTIntersection::GetEdgeDirection(){	MyAssert(!dtored);	return edgeDirection;}bool BspCutTIntersection::GetAtStart(){	return interAtStart;}bool BspCutTIntersection::SelfIntersection(){	MyAssert(!dtored);	return false;}#pragma mark -void BspCutTIntersection::FlipTopBottom(){	MyAssert(!dtored);}//-1:none, no other responseint BspCutTIntersection::DetermineOccludedEdge(){	MyAssert(!dtored);		return -1;}bool BspCutTIntersection::IntersectionLegal(){	MyAssert(!dtored);		if (!bsp)		return true;	//Assume this is at the end of an infinite cut		//Get the relevant depths at the intersection	int bspEnd1D = bsp->GetSectionDepthBeforeIntersection(this, cv, seg);	int bspEnd2D = bsp->GetSectionDepthAfterIntersection(this, cv, seg);	int cutD = interAtStart ? cut->GetSectionDepthAfterIntersection(this) : cut->GetSectionDepthBeforeIntersection(this);		//Check the depths for legality	if (bspEnd1D != bspEnd2D)		return false;		if (cutD != bspEnd1D)		return false;		return true;}void BspCutTIntersection::IncreaseCurve(){	MyAssert(!dtored);		cv++;		if (interAtStart)		cut->IncreaseCurveStart();	else cut->IncreaseCurveEnd();}void BspCutTIntersection::DecreaseCurve(){	MyAssert(!dtored);		cv--;		if (interAtStart)		cut->DecreaseCurveStart();	else cut->DecreaseCurveEnd();}void BspCutTIntersection::IncrementInfiniteWOsection(){	if (infiniteWholeObject)		MyAssert(!infiniteWholeObject->dtored);		MyAssert(!dtored);	MyAssert(infiniteWOsection != -1);	infiniteWOsection++;}#pragma mark -void BspCutTIntersection::SetAtStart(bool atStart){	interAtStart = atStart;}void BspCutTIntersection::RecalcStartEndLocs(){	MyAssert(!dtored);	MyAssert(cut);		if (interAtStart)		cut->RecalcStartLoc();	else cut->RecalcEndLoc();}void BspCutTIntersection::SetLocToCutStartOrEndLoc(){	location = interAtStart ? cut->GetStart() : cut->GetEnd();}void BspCutTIntersection::RecalcEdgeDirection(){	vector<vector<FloatPoint>*> curvePoints = *(bsp->GetCurvePoints());		int nextCurve, nextSeg;	nextSeg = seg + 1;	if (nextSeg < BSpline::sNumSegmentsPerCurve)		nextCurve = cv;	else	{		nextSeg = 0;		nextCurve = (cv + 1) % curvePoints.size();	}		FloatPoint cvPt1 = (*curvePoints[cv])[seg];	FloatPoint cvPt2 = (*curvePoints[nextCurve])[nextSeg];		FloatPoint lnPt1 = cut->GetStart();	FloatPoint lnPt2 = cut->GetEnd();		edgeDirection = LineCrossLineDirection(lnPt1, lnPt2, cvPt1, cvPt2);	MyAssert(edgeDirection != 0);}void BspCutTIntersection::DecreaseBspIndex(){	MyAssert(!dtored);	bspIndex--;}void BspCutTIntersection::DecreaseCutIndex(){	MyAssert(!dtored);	cutIndex--;}void BspCutTIntersection::SetCurveAndSeg(int newCv, int newSg){	MyAssert(!dtored);	cv = newCv;	seg = newSg;}void BspCutTIntersection::SetInfiniteWOsection(int newInfiniteWOsection){	if (infiniteWholeObject)		MyAssert(!infiniteWholeObject->dtored);		MyAssert(!dtored);	infiniteWOsection = newInfiniteWOsection;}void BspCutTIntersection::SetNullBsp(){	MyAssert(!dtored);		if (infiniteWholeObject)		MyAssert(!infiniteWholeObject->dtored);		bsp = NULL;	bspIndex = -1;	cv = -1;	seg = -1;}void BspCutTIntersection::SetNullCut(){	MyAssert(!dtored);		if (infiniteWholeObject)		MyAssert(!infiniteWholeObject->dtored);		cut = NULL;}void BspCutTIntersection::SetCut(BSplineToBSplineCut* theCut, int theCutIndex){	MyAssert(theCut && theCutIndex >= 0);	cut = theCut;	cutIndex = theCutIndex;}void BspCutTIntersection::SetInfiniteWholeObject(WholeObject* wo){	if (infiniteWholeObject)		MyAssert(!infiniteWholeObject->dtored);		MyAssert(!interAtStart);	MyAssert(!bsp);	MyAssert(cut);	MyAssert(cv == -1 && seg == -1);	if (wo)		MyAssert(!infiniteWholeObject);	else	{		MyAssert(infiniteWholeObject);	}		infiniteWholeObject = wo;		if (infiniteWholeObject)		MyAssert(!infiniteWholeObject->dtored);}#pragma mark -		void BspCutTIntersection::DumpFileData(short fRefNum, double fileVersion){	MyAssert(false);	//File version 1.2 only writes BspBsp inters to file	MyAssert(!dtored);		string st;	ostringstream oss;		oss << "  " << GenericIntersection::BSP_CUT_T << "\n";		oss << "  " << location.h << " " << location.v << "\n";		oss << "  " << bspIndex << " " << cutIndex << "\n";	oss << "  " << cv << " " << seg << "\n";	oss << "  " << infiniteWOsection << "\n";	//Kind of silly to institute changes to this intersection's file dump since file version 1.2 only writes BspBsp inters to file, but whatever	oss << "  " << (interAtStart ? 1 : 0) << " " << edgeDirection << "\n";		st += oss.str();	long strLen = st.length();	OSErr err = FSWrite(fRefNum, &strLen, st.c_str());}void BspCutTIntersection::LoadFileData(istringstream& iss, double fileVersion){	MyAssert(fileVersion == 1.0 || fileVersion == 1.1);	//File version 1.2 only writes BspBsp inters to file		//The intersection was already read off the stream		iss >> location.h >> location.v;		iss >> bspIndex >> cutIndex;	vector<BSpline*> bsplines = drawing->GetBSplines();	MyAssert(bspIndex < bsplines.size() || bspIndex == -1);	bsp = (bspIndex != -1) ? bsplines[bspIndex] : NULL;	vector<BSplineToBSplineCut*> cuts = drawing->GetCuts();	MyAssert(cutIndex < cuts.size());	cut = cuts[cutIndex];		iss >> cv >> seg;		if (fileVersion == 1.2)	//This should never occur, see note at top of function	{		MyAssert(false);		iss >> infiniteWOsection;	}		int interAtStartInt;	iss >> interAtStartInt >> edgeDirection;	interAtStart = (interAtStartInt != 0);}