#include "BSpline.h"#include "BSplineToBSplineCut.h"#include "MainWindow.h"#include "GenericIntersection.h"#include "BspBspIntersection.h"#include "BspCutIntersection.h"#include "BspCutTIntersection.h"#include "Drawing.h"#include "Colors.h"#include "trigConstants.h"#include <math.h>#include <algorithm.h>#include <vector.h>#include <utility.h>	//for pair#include <string>#include <sstream>using namespace::std;//******************************************************************************//Extern Globalsextern WindowPtr gAnalysisWindow;	//еееextern int gPointRadius;extern Colors gColors;extern bool gDebug;extern bool gDebug8;extern MainWindow* gMainWindow;extern Drawing* gDrawing;	//еееextern bool gDebug13;	//еее//******************************************************************************//Global Declarationsint gFindPointDist = 4;int gDataLine = 10;	//еееint gLastDiffInt1Seg1 = 0, gLastDiffInt1Seg2 = 0, gLastDiffInt2Seg1 = 0, gLastDiffInt2Seg2 = 0;int BSpline::sNumSegmentsPerCurve = 32;bool BSpline::sShadeWithArrows = false;int BSpline::sShadeSize = 5;//5;	//For arrows, 15 is good.  For hashes, 5 is good for normal use, 15 is good for printoutsdouble BSpline::sArrowHeadAngle = 3.0 * PiOver4;int BSpline::sBoundarySectionBspSpacing = 100;//******************************************************************************//Function Prototypes	//	In this file	//	In external files		//	main.cppvoid MyAssert(bool condition);		//lineEquations.cppdouble LineSegmentLength(FloatPoint p1, FloatPoint p2);double LineSegmentAngle(FloatPoint p1, FloatPoint p2);FloatPoint ProjectPointAtAngle(FloatPoint origin, double angle, double segLength);int PointLineSegmentDistance(FloatPoint point, FloatPoint p1, FloatPoint p2, double &pointLineDist);bool LineSegmentIntersection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2, FloatPoint &intersection);int LineCrossLineDirection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2);bool LineSegmentIntersection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2,							FloatPoint &intersection, double& lineSegInter1, double& lineSegInter2);#pragma mark -BSpline::BSpline(Drawing* theDrawing) : drawing(theDrawing), degree(3), windingNumber(0),	dtored(false), shallowestMaxPossibleSection(-1), deepestMaxPossibleSection(-1){	surfaceTraits.interiorColor.red = surfaceTraits.interiorColor.green = surfaceTraits.interiorColor.blue = 1;	//0 is reserved as a "flag" for an illegal boundary	surfaceTraits.interiorReflectance = 1.0;	surfaceTraits.borderColor.red = surfaceTraits.interiorColor.red;	surfaceTraits.borderColor.green = surfaceTraits.interiorColor.green;	surfaceTraits.borderColor.blue = surfaceTraits.interiorColor.blue;	surfaceTraits.borderReflectance = surfaceTraits.interiorReflectance;	surfaceTraits.borderThickness = 1.0;		sectionDepths.push_back(0);	sectionDepthConstraints.push_back(false);}//Argument can't be const.  Geez!  Something to do with STL.BSpline::BSpline(BSpline& bsp, Drawing* d, bool basicCopyOnly){	MyAssert(!bsp.dtored);		long t = TickCount();		//Copy the easy stuff	drawing = d;	degree = bsp.degree;	windingNumber = bsp.windingNumber;	surfaceTraits = bsp.surfaceTraits;		dtored = bsp.dtored;		if (basicCopyOnly)	{		sectionDepths.push_back(0);		sectionDepthConstraints.push_back(false);		shallowestMaxPossibleSection = deepestMaxPossibleSection = -1;		return;	}		int vectorSize = bsp.controlPoints.size();	int vectorSize2;		//Resize the vectors	controlPoints.resize(vectorSize);	curvePoints.resize(vectorSize);	curveIntersections.resize(vectorSize);	curvesToRecalc.resize(vectorSize);	curvesToReintersect.resize(vectorSize);		t = TickCount();		for (int i = 0; i < vectorSize; i++)	{		//Control points		controlPoints[i] = bsp.controlPoints[i];				//Curve points		vector<FloatPoint> *bspCp =  bsp.curvePoints[i];		vectorSize2 = bspCp->size();		vector<FloatPoint> *cp = new vector<FloatPoint>;		cp->resize(vectorSize2);		for (int j = 0; j < vectorSize2; j++)			(*cp)[j] = (*bspCp)[j];		curvePoints[i] = cp;				//Curve intersections		curveIntersections[i] = new vector<GenericIntersection*>;				//Recalc		curvesToRecalc[i] = false;				//Reintersect		curvesToReintersect[i] = false;	}		vectorSize = bsp.prevCurvePoints.size();	prevCurvePoints.resize(vectorSize);	for (int i = 0; i < vectorSize; i++)	{		//Prev curve points		vector<FloatPoint> *bspPcp =  bsp.prevCurvePoints[i];		vectorSize2 = bspPcp->size();		vector<FloatPoint> *pcp = new vector<FloatPoint>;		pcp->resize(vectorSize2);		for (int j = 0; j < vectorSize2; j++)			(*pcp)[j] = (*bspPcp)[j];		prevCurvePoints[i] = pcp;	}		//Section depths	vectorSize = bsp.sectionDepths.size();	sectionDepths.resize(vectorSize);	for (int i = 0; i < vectorSize; i++)		sectionDepths[i] = bsp.sectionDepths[i];		//Max possible section depths	vectorSize = bsp.maxPossibleSectionDepths.size();	maxPossibleSectionDepths.resize(vectorSize);	for (int i = 0; i < vectorSize; i++)		maxPossibleSectionDepths[i] = bsp.maxPossibleSectionDepths[i];		shallowestMaxPossibleSection = bsp.shallowestMaxPossibleSection;	deepestMaxPossibleSection = bsp.deepestMaxPossibleSection;		//Section depth constraints		vectorSize = bsp.sectionDepthConstraints.size();	sectionDepthConstraints.resize(vectorSize);	for (int i = 0; i < vectorSize; i++)		sectionDepthConstraints[i] = bsp.sectionDepthConstraints[i];		//Intersection curve segments	intersectionCurveSegments.resize(bsp.intersectionCurveSegments.size());	for (int i = 0; i < bsp.intersectionCurveSegments.size(); i++)		intersectionCurveSegments[i] = bsp.intersectionCurveSegments[i];}BSpline::~BSpline(){	MyAssert(!dtored);		Destroy();	dtored = true;}#pragma mark -void BSpline::Destroy(){	//Control points	controlPoints.clear();		//Curve points	for (vector<vector<FloatPoint>*>::iterator i = curvePoints.begin(); i != curvePoints.end(); i++)		delete *i;	curvePoints.clear();	for (vector<vector<FloatPoint>*>::iterator i = prevCurvePoints.begin(); i != prevCurvePoints.end(); i++)		delete *i;	prevCurvePoints.clear();		//Curve intersections	vector<GenericIntersection*> selfIntersections;	for (int i = 0; i < curveIntersections.size(); i++)	{		for (vector<GenericIntersection*>::iterator j = curveIntersections[i]->begin(); j != curveIntersections[i]->end(); j++)		{			bool dontDelete = false;						if ((*j)->SelfIntersection())	//If the intersection is a self-intersection, don't delete it twice, only delete it the second time				if (find(selfIntersections.begin(), selfIntersections.end(), *j) == selfIntersections.end())				{					selfIntersections.push_back(*j);					dontDelete = true;				}						if ((*j)->GetType() == GenericIntersection::BSP_BSP)				((BspBspIntersection*)*j)->SetNullBsp(this);			if ((*j)->GetType() == GenericIntersection::BSP_CUT)				((BspCutIntersection*)*j)->SetNullBsp();			if ((*j)->GetType() == GenericIntersection::BSP_CUT_T)				((BspCutTIntersection*)*j)->SetNullBsp();						if (!dontDelete)				delete *j;		}				delete curveIntersections[i];	}	curveIntersections.clear();		//Recalc curves	curvesToRecalc.clear();		//Reintersect curves	curvesToReintersect.clear();		//Section depths	sectionDepths.clear();		//Min section depth constraints	sectionDepthConstraints.clear();}void BSpline::AddIntersection(int curve, int curveSegment, GenericIntersection* intersection, bool equalizeSections){	MyAssert(!intersection->GetDtored());	MyAssert(curve < curveIntersections.size());		vector<GenericIntersection*> prevIntersections;		//Find the sorted position in the list of intersections for this curve where the new intersection sould be inserted.	//This sorted position is based on the sorted list of segments within the curve, and based on the length along a	//single segment for intersections with matching segments.	vector<GenericIntersection*>::iterator iter;	vector<GenericIntersection*>* cints = curveIntersections[curve];	for (iter = curveIntersections[curve]->begin(); iter != curveIntersections[curve]->end(); iter++)	{		int cs = -1;				switch ((*iter)->GetType())		{			case GenericIntersection::BSP_BSP:				BspBspIntersection* bspBspInter = (BspBspIntersection*)*iter;				if (!bspBspInter->SelfIntersection())				{					if (bspBspInter->GetBsp1() == this)					{						MyAssert(bspBspInter->GetCv1() == curve);						cs = bspBspInter->GetSg1();					}					else					{						MyAssert(bspBspInter->GetBsp2() == this);						MyAssert(bspBspInter->GetCv2() == curve);						cs = bspBspInter->GetSg2();					}				}				else	//Self intersection				{					if (bspBspInter->GetCv1() == curve && bspBspInter->GetCv2() != curve)						cs = bspBspInter->GetSg1();					else if (bspBspInter->GetCv2() == curve && bspBspInter->GetCv1() != curve)						cs = bspBspInter->GetSg2();					else	//Same curve					{						int cv1 = bspBspInter->GetCv1();						int cv2 = bspBspInter->GetCv2();						MyAssert(cv1 == cv2);						int sg1 = bspBspInter->GetSg1();						int sg2 = bspBspInter->GetSg2();						MyAssert(sg1 != sg2);												if (find(prevIntersections.begin(), prevIntersections.end(), *iter) == prevIntersections.end())							cs = min(sg1, sg2);	//Take earlier occurrance						else cs = max(sg1, sg2);	//Take later occurrance												prevIntersections.push_back(*iter);					}				}				break;			case GenericIntersection::BSP_CUT:				BspCutIntersection* bspCutInter = (BspCutIntersection*)*iter;				if (bspCutInter->GetBsp() == this)				{					MyAssert(bspCutInter->GetCv() == curve);					cs = bspCutInter->GetSg();				}				else				{					MyAssert(bspCutInter->GetBsp() == this);					MyAssert(bspCutInter->GetCv() == curve);					cs = bspCutInter->GetSg();				}				break;			case GenericIntersection::BSP_CUT_T:				BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)*iter;				if (bspCutTInter->GetBsp() == this)				{					MyAssert(bspCutTInter->GetCv() == curve);					cs = bspCutTInter->GetSg();				}				else				{					MyAssert(bspCutTInter->GetBsp() == this);					MyAssert(bspCutTInter->GetCv() == curve);					cs = bspCutTInter->GetSg();				}				break;		}				MyAssert(cs != -1);				if (cs > curveSegment)			break;				//еее		double iterLineSegLen = LineSegmentLength((*iter)->GetLocation(), (*curvePoints[curve])[curveSegment]);		double interLineSegLen = LineSegmentLength(intersection->GetLocation(), (*curvePoints[curve])[curveSegment]);				if (cs == curveSegment &&			LineSegmentLength((*iter)->GetLocation(), (*curvePoints[curve])[curveSegment]) >			LineSegmentLength(intersection->GetLocation(), (*curvePoints[curve])[curveSegment]))		{			break;		}	}		curveIntersections[curve]->insert(iter, intersection);		if (equalizeSections)	{		if (MakeIntersectionList())		{			if (allIntersections.size() > 1)			{				//Find the new intersection's position in the new intersection list				int prevSectionDepth = sectionDepths[sectionDepths.size() - 1];								vector<GenericIntersection*>::iterator interIter = allIntersections.begin();				vector<int>::iterator sectionDepthIter = sectionDepths.begin();				vector<bool>::iterator sectionDepthConstIter = sectionDepthConstraints.begin();								while (interIter != allIntersections.end() && *interIter != intersection)				{					prevSectionDepth = *sectionDepthIter;										interIter++;					sectionDepthIter++;					sectionDepthConstIter++;				}				MyAssert(interIter != allIntersections.end());								//Insert a new section for the intersection				sectionDepths.insert(sectionDepthIter, prevSectionDepth);				sectionDepthConstraints.insert(sectionDepthConstIter, false);			}						//int *d = new int[sectionDepths.size()];			//for (int i = 0; i < sectionDepths.size(); i++)			//	d[i] = sectionDepths[i];						MyAssert(!EqualizeNumberOfSections());			//if (allIntersections.size() > 1)			//	MyAssert(!EqualizeNumberOfSections());			//else MyAssert(!EqualizeNumberOfSections());		}	}		if (equalizeSections)	{		VerifyNumSectionsMatchesNumInters();		VerifyTotalIntersMatchesCurveInters();	}}void BSpline::RemoveIntersection(int curve, GenericIntersection* intersection, bool equalizeSections, int deleteDir){	//MyAssert(find(allIntersections.begin(), allIntersections.end(), intersection) != allIntersections.end());	if (find(allIntersections.begin(), allIntersections.end(), intersection) == allIntersections.end())		return;	//This can happen when opening a file		if (equalizeSections)	{		//Decrement the number of sections, but keep the number of sections at one, even if there are no intersections		//if (allIntersections.size() > 2)		if (sectionDepths.size() > 1)		{			//Find the intersection's position in the intersection list			vector<GenericIntersection*>::iterator interIter = allIntersections.begin();			vector<int>::iterator sectionDepthIter = sectionDepths.begin();			vector<bool>::iterator sectionDepthConstIter = sectionDepthConstraints.begin();						int sectionPos = 0;	//еее DEBUG			while (interIter < allIntersections.end() && *interIter != intersection)			{				interIter++;				sectionDepthIter++;				sectionDepthConstIter++;								sectionPos++;			}			MyAssert(interIter < allIntersections.end());						//еее DEBUG			//This test doesn't work when the entire drawing is being deleted			/*			if (intersection->GetType() == GenericIntersection::BSP_CUT_T)			{				if (sectionPos > 0)					MyAssert(sectionDepths[sectionPos - 1] == sectionDepths[sectionPos]);				else MyAssert(sectionDepths[sectionDepths.size() - 1] == sectionDepths[sectionPos]);			}			*/						//By default, the behavior of this routine is the delete the section after the intersection in question			//If specified, delete the preceeding section instead			if (deleteDir == -1)			{				if (sectionDepthIter != sectionDepths.begin())					sectionDepthIter--;				else sectionDepthIter = sectionDepths.end() - 1;								if (sectionDepthConstIter != sectionDepthConstraints.begin())					sectionDepthConstIter--;				else sectionDepthConstIter = sectionDepthConstraints.end() - 1;			}						//Remove a section for the intersection			sectionDepths.erase(sectionDepthIter);			sectionDepthConstraints.erase(sectionDepthConstIter);		}	}		//Remove the intersection	bool deleteAllInstances = true;	//Always true for self intersections, never true otherwise		if (!intersection->SelfIntersection())	{		MyAssert(curve < curveIntersections.size());		bool intersectionFound = false;		for (vector<GenericIntersection*>::iterator i = curveIntersections[curve]->begin(); i != curveIntersections[curve]->end(); i++)			if (*i == intersection)			{				//Only free the pointer in the list pointing to the intersection.				//No need to delete the actual intersection object since it is being				//destroyed elsewhere (this function gets called from the Intersection's dtor).				curveIntersections[curve]->erase(i);				intersectionFound = true;				break;			}				MyAssert(intersectionFound || intersection->GetType() != GenericIntersection::BSP_BSP);				deleteAllInstances = false;	}		if (deleteAllInstances)	{		//Loop through the curves		for (vector<vector<GenericIntersection*>*>::iterator i = curveIntersections.begin(); i != curveIntersections.end(); i++)		{			bool reachedEnd = false;			while (!reachedEnd)			{				reachedEnd = true;				//Loop through the intersections on one curve				for (vector<GenericIntersection*>::iterator j = (*i)->begin(); j != (*i)->end(); j++)					if (*j == intersection)	//If the intersection matches, erase it					{						(*i)->erase(j);						reachedEnd = false;	//Retry this list again						break;					}			}		}	}		if (equalizeSections)	{		if (MakeIntersectionList())		{			EqualizeNumberOfSections();			//if (allIntersections.size() > 1)			//	MyAssert(!EqualizeNumberOfSections());			//else MyAssert(EqualizeNumberOfSections());		}	}		if (equalizeSections)	{		VerifyNumSectionsMatchesNumInters();		VerifyTotalIntersMatchesCurveInters();	}}void BSpline::MoveIntersection(GenericIntersection* intersection, int oldCurve, int oldSeg, int newCurve, int newSeg, int whichHalf){	VerifyNumSectionsMatchesNumInters();		//Remove the intersection	if (intersection->GetType() != GenericIntersection::BSP_BSP || !((BspBspIntersection*)intersection)->SelfIntersection())	{		MyAssert(oldCurve < curveIntersections.size());		bool intersectionFound = false;		for (vector<GenericIntersection*>::iterator i = curveIntersections[oldCurve]->begin(); i != curveIntersections[oldCurve]->end(); i++)			if (*i == intersection)			{				curveIntersections[oldCurve]->erase(i);				intersectionFound = true;				break;			}				MyAssert(intersectionFound);	}	else	//Self intersection	{		//If the intersection is on the old curve only once, erase the one instance		int numFinds = 0;		for (vector<GenericIntersection*>::iterator i = curveIntersections[oldCurve]->begin(); i != curveIntersections[oldCurve]->end(); i++)			if (*i == intersection)				numFinds++;		MyAssert(numFinds == 1 || numFinds == 2);		if (numFinds == 1)		{			for (vector<GenericIntersection*>::iterator i = curveIntersections[oldCurve]->begin(); i != curveIntersections[oldCurve]->end(); i++)				if (*i == intersection)				{					curveIntersections[oldCurve]->erase(i);					break;				}		}		else	//Multiple instances on one curve		{			BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;			bool useFirstFind = true;						if (whichHalf == 1)	//The top edge changed				useFirstFind = (oldSeg < bspBspInter->GetSg2());			else	//The bottom edge changed				useFirstFind = (oldSeg < bspBspInter->GetSg1());						MyAssert(oldCurve < curveIntersections.size());			int numFinds = 0;			bool intersectionFound = false;			for (vector<GenericIntersection*>::iterator i = curveIntersections[oldCurve]->begin(); i != curveIntersections[oldCurve]->end(); i++)				if (*i == intersection)				{					if (useFirstFind || numFinds == 1)					{						curveIntersections[oldCurve]->erase(i);						intersectionFound = true;						break;					}										numFinds++;				}						MyAssert(intersectionFound);		}	}		//Add the intersection	MyAssert(newCurve < curveIntersections.size());		vector<GenericIntersection*> prevIntersections;		vector<GenericIntersection*>::iterator iter;	for (iter = curveIntersections[newCurve]->begin(); iter != curveIntersections[newCurve]->end(); iter++)	{		int cs = -1;				switch ((*iter)->GetType())		{			case GenericIntersection::BSP_BSP:				BspBspIntersection* bspBspInter = (BspBspIntersection*)*iter;				if (!bspBspInter->SelfIntersection())				{					if (bspBspInter->GetBsp1() == this)					{						MyAssert(bspBspInter->GetCv1() == newCurve);						cs = bspBspInter->GetSg1();					}					else					{						MyAssert(bspBspInter->GetBsp2() == this);						MyAssert(bspBspInter->GetCv2() == newCurve);						cs = bspBspInter->GetSg2();					}				}				else	//Self intersection				{					if (bspBspInter->GetCv1() == newCurve && bspBspInter->GetCv2() != newCurve)						cs = bspBspInter->GetSg1();					else if (bspBspInter->GetCv2() == newCurve && bspBspInter->GetCv1() != newCurve)						cs = bspBspInter->GetSg2();					else	//Same curve					{						if (find(prevIntersections.begin(), prevIntersections.end(), *iter) == prevIntersections.end())							cs = bspBspInter->GetSg1();						else cs = bspBspInter->GetSg2();						prevIntersections.push_back(*iter);					}				}				break;			case GenericIntersection::BSP_CUT:				BspCutIntersection* bspCutInter = (BspCutIntersection*)*iter;				MyAssert(bspCutInter->GetCv() == newCurve);				cs = bspCutInter->GetSg();				break;			case GenericIntersection::BSP_CUT_T:				BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)*iter;				MyAssert(bspCutTInter->GetCv() == newCurve);				cs = bspCutTInter->GetSg();				break;		}				MyAssert(cs != -1);				if (cs > newSeg)			break;				if (cs == newSeg &&			LineSegmentLength((*iter)->GetLocation(), (*curvePoints[newCurve])[newSeg]) >			LineSegmentLength(intersection->GetLocation(), (*curvePoints[newCurve])[newSeg]))			break;	}		curveIntersections[newCurve]->insert(iter, intersection);		VerifyNumSectionsMatchesNumInters();}void BSpline::CheckSegmentIntersectionOrder(GenericIntersection* intersection){	VerifyNumSectionsMatchesNumInters();	VerifyTotalIntersMatchesCurveInters();		if (!intersection->SelfIntersection())	{		int curve;		switch (intersection->GetType())		{			case GenericIntersection::BSP_BSP:				curve = (((BspBspIntersection*)intersection)->GetBsp1() == this) ? ((BspBspIntersection*)intersection)->GetCv1() : ((BspBspIntersection*)intersection)->GetCv2();				break;			case GenericIntersection::BSP_CUT:				curve = ((BspCutIntersection*)intersection)->GetCv();				break;			case GenericIntersection::BSP_CUT_T:				curve = ((BspCutTIntersection*)intersection)->GetCv();				break;		}				vector<GenericIntersection*>* oneCurveIntersections = curveIntersections[curve];				MyAssert(oneCurveIntersections->size() > 0);		if (oneCurveIntersections->size() == 1)			return;				//Make a list of the intersections on this curve		vector<GenericIntersection*> oneCurveIntersectionsPre;		for (int i = 0; i < oneCurveIntersections->size(); i++)			if (find(oneCurveIntersectionsPre.begin(), oneCurveIntersectionsPre.end(), (*oneCurveIntersections)[i]) == oneCurveIntersectionsPre.end())				oneCurveIntersectionsPre.push_back((*oneCurveIntersections)[i]);				//Remove the intersections on this curve		while (oneCurveIntersections->size() > 0)			RemoveIntersection(curve, (*oneCurveIntersections)[0], false);				//Add the intersections on this curve back.  This will properly sort them.		for (int i = 0; i < oneCurveIntersectionsPre.size(); i++)		{			switch (oneCurveIntersectionsPre[i]->GetType())			{				case GenericIntersection::BSP_BSP:					BspBspIntersection* bspBspInter1 = (BspBspIntersection*)oneCurveIntersectionsPre[i];					if (!bspBspInter1->SelfIntersection())					{						if (bspBspInter1->GetBsp1() == this)							AddIntersection(curve, bspBspInter1->GetSg1(), oneCurveIntersectionsPre[i], false);						else AddIntersection(curve, bspBspInter1->GetSg2(), oneCurveIntersectionsPre[i], false);					}					else	//Self intersection					{						//if (bspBspInter1->GetCv1() == curve)							AddIntersection(bspBspInter1->GetCv1(), bspBspInter1->GetSg1(), oneCurveIntersectionsPre[i], false);						//if (bspBspInter1->GetCv2() == curve)							AddIntersection(bspBspInter1->GetCv2(), bspBspInter1->GetSg2(), oneCurveIntersectionsPre[i], false);					}					break;				case GenericIntersection::BSP_CUT:					AddIntersection(curve, ((BspCutIntersection*)oneCurveIntersectionsPre[i])->GetSg(), oneCurveIntersectionsPre[i], false);					break;				case GenericIntersection::BSP_CUT_T:					AddIntersection(curve, ((BspCutTIntersection*)oneCurveIntersectionsPre[i])->GetSg(), oneCurveIntersectionsPre[i], false);					break;			}		}	}	else	//Self intersection	{		//еее		//Not implemented yet	}		VerifyNumSectionsMatchesNumInters();	VerifyTotalIntersMatchesCurveInters();}#pragma mark -int BSpline::GetBSplineIndex(){	return drawing->GetBSplineIndex(this);}vector<FloatPoint> BSpline::GetControlPoints(){	return controlPoints;}FloatPoint BSpline::GetControlPointPosition(int controlPointIndex){	return controlPoints[controlPointIndex];}int BSpline::FindControlPoint(FloatPoint point){	int dist, minDist = 999999;	int minDistControlPointIndex = -1;	for (int i = 0; i < controlPoints.size(); i++)	{		//Find the distance from the point to the control point		dist = max(fabs(point.h - controlPoints[i].h), fabs(point.v - controlPoints[i].v));		if (dist < minDist)		{			minDist = dist;			minDistControlPointIndex = i;		}	}		if (minDist <= gFindPointDist)		return minDistControlPointIndex;		return -1;}int BSpline::FindControlBoundarySegment(FloatPoint point){	double dist, minDist = 999999;	int minDistControlSegIndex = -1;	for (int i = 0; i < controlPoints.size(); i++)	{		bool pointWithinSegment = PointLineSegmentDistance(point, controlPoints[i],								controlPoints[(i + 1) % controlPoints.size()], dist);				if (pointWithinSegment && dist < minDist)		{			minDist = dist;			minDistControlSegIndex = i;		}	}		if (minDist <= gFindPointDist)		return minDistControlSegIndex;		return -1;}int BSpline::FindCurveSegment(FloatPoint point){	double dist, minDist = 999999;	int minDistCurveSegIndex = -1;	FloatPoint end1, end2;		for (int i = 0; i < curvePoints.size(); i++)		for (int j = 0; j < sNumSegmentsPerCurve; j++)		{			end1 = (*curvePoints[i])[j];			if (j < sNumSegmentsPerCurve - 1)				end2 = (*curvePoints[i])[j + 1];			else end2 = (*curvePoints[(i + 1) % curvePoints.size()])[0];						bool pointWithinSegment = PointLineSegmentDistance(point, end1, end2, dist);						if (pointWithinSegment && dist < minDist)			{				minDist = dist;				minDistCurveSegIndex = i * sNumSegmentsPerCurve + j;			}		}		if (minDist <= gFindPointDist)		return minDistCurveSegIndex;		return -1;}int BSpline::GetNumControlPoints(){	return controlPoints.size();}int BSpline::GetNumIntersections(){	return allIntersections.size();}int BSpline::GetDegree(){	return degree;}int BSpline::GetWindingNumber(){	return windingNumber;}SurfaceTraits BSpline::GetSurfaceTraits(){	return surfaceTraits;}vector<GenericIntersection*> BSpline::GetIntersections(){	return allIntersections;}GenericIntersection* BSpline::GetIntersectionFromIndex(int interIndex){	return allIntersections[interIndex];}GenericIntersection* BSpline::GetFirstIntersection(){	//Return the first intersection of any kind, or NULL if there are no intersections	if (allIntersections.size() > 0)		return allIntersections[0];	else return NULL;}GenericIntersection* BSpline::GetFirstBspBspIntersection(){	//Return the first BspBsp intersection, or NULL if there isn't one	int index = 0;	while (index < allIntersections.size() && allIntersections[index]->GetType() != GenericIntersection::BSP_BSP)		index++;		if (index < allIntersections.size())		return allIntersections[index];	else return NULL;}vector<vector<FloatPoint>* >* BSpline::GetCurvePoints(){	return &curvePoints;}vector<vector<FloatPoint>* >* BSpline::GetPrevCurvePoints(){	return &prevCurvePoints;}FloatPoint BSpline::GetCurvePoint(int curve, int segment){	if (segment == sNumSegmentsPerCurve)	{		curve++;		if (curve == curvePoints.size())			curve = 0;		segment = 0;	}		return (*curvePoints[curve])[segment];}vector<bool> BSpline::GetCurvesToRecalc()	//еее DEBUG{	return curvesToRecalc;}vector<bool> BSpline::GetCurvesToReintersect(){	return curvesToReintersect;}void BSpline::GetIntersectionSeg(GenericIntersection* intersection, int curve, int& seg){	MyAssert(intersection);	if (!intersection->SelfIntersection())	{		switch (intersection->GetType())		{			case GenericIntersection::BSP_BSP:				seg = (((BspBspIntersection*)intersection)->GetBsp1() == this) ? ((BspBspIntersection*)intersection)->GetSg1() : ((BspBspIntersection*)intersection)->GetSg2();				break;			case GenericIntersection::BSP_CUT:				seg = ((BspCutIntersection*)intersection)->GetSg();				break;			case GenericIntersection::BSP_CUT_T:				seg = ((BspCutTIntersection*)intersection)->GetSg();				break;		}	}	else	{		BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;		if (bspBspInter->GetCv1() == curve)			seg = bspBspInter->GetSg1();		else if (bspBspInter->GetCv2() == curve)			seg = bspBspInter->GetSg2();		else MyAssert(false);	}}void BSpline::GetIntersectionCurveAndSeg(vector<GenericIntersection*>& intersectionsVisitedAlready, GenericIntersection* intersection, int& crv, int& seg){	if (!intersection->SelfIntersection())	{		switch (intersection->GetType())		{			case GenericIntersection::BSP_BSP:				crv = (((BspBspIntersection*)intersection)->GetBsp1() == this) ? ((BspBspIntersection*)intersection)->GetCv1() : ((BspBspIntersection*)intersection)->GetCv2();				seg = (((BspBspIntersection*)intersection)->GetBsp1() == this) ? ((BspBspIntersection*)intersection)->GetSg1() : ((BspBspIntersection*)intersection)->GetSg2();				break;			case GenericIntersection::BSP_CUT:				crv = ((BspCutIntersection*)intersection)->GetCv();				seg = ((BspCutIntersection*)intersection)->GetSg();				break;			case GenericIntersection::BSP_CUT_T:				crv = ((BspCutTIntersection*)intersection)->GetCv();				seg = ((BspCutTIntersection*)intersection)->GetSg();				break;		}	}	else	//Self Intersection	{		BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;		//For self intersections, use the earlier section the first time the intersection		//is visited and the later section the second time the intersection is visited		if (find(intersectionsVisitedAlready.begin(), intersectionsVisitedAlready.end(), bspBspInter) == intersectionsVisitedAlready.end())		{			if (bspBspInter->GetCv1() < bspBspInter->GetCv2())			{				crv = bspBspInter->GetCv1();				seg = bspBspInter->GetSg1();			}			else if (bspBspInter->GetCv1() > bspBspInter->GetCv2())			{				crv = bspBspInter->GetCv2();				seg = bspBspInter->GetSg2();			}			else if (bspBspInter->GetSg1() < bspBspInter->GetSg2())			{				crv = bspBspInter->GetCv1();				seg = bspBspInter->GetSg1();			}			else if (bspBspInter->GetSg1() > bspBspInter->GetSg2())			{				crv = bspBspInter->GetCv2();				seg = bspBspInter->GetSg2();			}			else MyAssert(false);	//self intersection is on the same segment of the same curve!						intersectionsVisitedAlready.push_back(bspBspInter);		}		else		{			if (bspBspInter->GetCv1() < bspBspInter->GetCv2())			{				crv = bspBspInter->GetCv2();				seg = bspBspInter->GetSg2();			}			else if (bspBspInter->GetCv1() > bspBspInter->GetCv2())			{				crv = bspBspInter->GetCv1();				seg = bspBspInter->GetSg1();			}			else if (bspBspInter->GetSg1() < bspBspInter->GetSg2())			{				crv = bspBspInter->GetCv2();				seg = bspBspInter->GetSg2();			}			else if (bspBspInter->GetSg1() > bspBspInter->GetSg2())			{				crv = bspBspInter->GetCv1();				seg = bspBspInter->GetSg1();			}			else MyAssert(false);	//self intersection is on the same segment of the same curve!		}	}}int BSpline::GetArbitraryCurvePointDepth(int curve, int segment, FloatPoint interLoc){	if (allIntersections.size() == 0)		return sectionDepths[0];		//If the curve segment doesn't have any intersections, it's easy.  Just find out which section that curve segment is in.	bool foundMatch = false;	//for (int i = 0; i < allIntersections.size(); i++)	MyAssert(curve < curveIntersections.size());	for (int i = 0; i < curveIntersections[curve]->size(); i++)	{		MyAssert((*curveIntersections[curve])[i]);				int seg = 0;		GetIntersectionSeg((*curveIntersections[curve])[i], curve, seg);				if (seg == segment)		{			foundMatch = true;			break;		}	}		if (!foundMatch)	//The curve segment has no intersections, so do it the easy way	{		//Search through the intersections until an intersection is found after the curve segment.		//The section in question will be right before that intersection.		int firstInterAfterInquiryInter = 0;		int crv, seg;		vector<GenericIntersection*> intersectionsVisitedAlready;		for (firstInterAfterInquiryInter = 0; firstInterAfterInquiryInter < allIntersections.size(); firstInterAfterInquiryInter++)		{			GetIntersectionCurveAndSeg(intersectionsVisitedAlready, allIntersections[firstInterAfterInquiryInter], crv, seg);						if (crv > curve || (crv == curve && seg > segment))				break;		}				if (firstInterAfterInquiryInter == allIntersections.size())	//If the arbitrary intersection is after the last intersection		{			firstInterAfterInquiryInter = 0;			intersectionsVisitedAlready.clear();			GetIntersectionCurveAndSeg(intersectionsVisitedAlready, allIntersections[firstInterAfterInquiryInter], crv, seg);		}				int section = GetSectionBeforeIntersection(allIntersections[firstInterAfterInquiryInter], crv, seg);		return sectionDepths[section];	}	else	//The curve segment has at least one intersection, so do it the hard way	{		//Find the distance from the arbitrary intersection to the beginning of the segment		double arbInterDist = LineSegmentLength(interLoc, (*curvePoints[curve])[segment]);				//Find the intersections near the arbitrary intersection on the segment		GenericIntersection* lastInterBeforeArbInter = NULL;		GenericIntersection* firstInterAfterArbInter = NULL;		double lastInterBeforeArbInterDist = -1;		double firstInterAfterArbInterDist = 999999;				for (int i = 0; i < curveIntersections[curve]->size(); i++)		{			int seg;			GetIntersectionSeg((*curveIntersections[curve])[i], curve, seg);						if (seg == segment)			{				double interDist = LineSegmentLength((*curveIntersections[curve])[i]->GetLocation(), (*curvePoints[curve])[segment]);				if (interDist <= arbInterDist && interDist >= lastInterBeforeArbInterDist)				{					lastInterBeforeArbInterDist = interDist;					lastInterBeforeArbInter = (*curveIntersections[curve])[i];				}				else if (interDist >= arbInterDist && interDist <= firstInterAfterArbInterDist)				{					firstInterAfterArbInterDist = interDist;					firstInterAfterArbInter = (*curveIntersections[curve])[i];				}			}		}				MyAssert(lastInterBeforeArbInter || firstInterAfterArbInter);				//If there is an intersection directly preceeding the arbitrary intersection, use that intersection to find the section.		//Else use the intersection directly postceeding the arbitrary intersection instead.				if (lastInterBeforeArbInter)		{			int section = GetSectionAfterIntersection(lastInterBeforeArbInter, curve, segment);			return sectionDepths[section];		}		else		{			int section = GetSectionBeforeIntersection(firstInterAfterArbInter, curve, segment);			return sectionDepths[section];		}	}}int BSpline::GetArbitraryCurveSegCenterDepth(int curve, int segment){	//Find the center point of the segment	FloatPoint segCenter;		int nextCurve, nextSeg;	nextSeg = segment + 1;	if (nextSeg < sNumSegmentsPerCurve)		nextCurve = curve;	else	{		nextSeg = 0;		nextCurve = (curve + 1) % curvePoints.size();	}		segCenter.h = ((*curvePoints[curve])[segment].h + (*curvePoints[nextCurve])[nextSeg].h) / 2;	segCenter.v = ((*curvePoints[curve])[segment].v + (*curvePoints[nextCurve])[nextSeg].v) / 2;		//Use a different function to do most of the work	return GetArbitraryCurvePointDepth(curve, segment, segCenter);}bool BSpline::IntersectionIsFirstOccurance(GenericIntersection* intersection, int curve, int seg){	if (intersection->GetType() != GenericIntersection::BSP_BSP)		return true;		if (!intersection->SelfIntersection())		return true;		BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;			bool result = true;		MyAssert((curve == bspBspInter->GetCv1() && seg == bspBspInter->GetSg1()) ||			(curve == bspBspInter->GetCv2() && seg == bspBspInter->GetSg2()));		if (bspBspInter->GetCv1() == curve && bspBspInter->GetSg1() == seg)	{		if (bspBspInter->GetCv1() > bspBspInter->GetCv2())			result = false;		else if (bspBspInter->GetCv1() == bspBspInter->GetCv2() && bspBspInter->GetSg1() > bspBspInter->GetSg2())			result = false;	}	else	{		if (bspBspInter->GetCv2() > bspBspInter->GetCv1())			result = false;		else if (bspBspInter->GetCv2() == bspBspInter->GetCv1() && bspBspInter->GetSg2() > bspBspInter->GetSg1())			result = false;	}		return result;}int BSpline::GetSectionBeforeIntersection(GenericIntersection* intersection, int curve, int seg){	MyAssert(find(allIntersections.begin(), allIntersections.end(), intersection) != allIntersections.end());		int intersectionIndex = GetSectionAfterIntersection(intersection, curve, seg);		intersectionIndex = (intersectionIndex + (sectionDepths.size() - 1)) % sectionDepths.size();		return intersectionIndex;}int BSpline::GetSectionAfterIntersection(GenericIntersection* intersection, int curve, int seg){	MyAssert(find(allIntersections.begin(), allIntersections.end(), intersection) != allIntersections.end());		int numIts = IntersectionIsFirstOccurance(intersection, curve, seg) ? 1 : 2;		//GenericIntersection** inters = new GenericIntersection*[allIntersections.size()];	//for (int i = 0; i < allIntersections.size(); i++)	//	inters[i] = allIntersections[i];		int intersectionIndex = -1;	for (int i = 0; i < numIts; i++)		for (intersectionIndex++; intersectionIndex < allIntersections.size(); intersectionIndex++)			if (allIntersections[intersectionIndex] == intersection)				break;		MyAssert(intersectionIndex != allIntersections.size());	MyAssert(intersectionIndex < sectionDepths.size());		//delete [] inters;		return intersectionIndex;}int BSpline::GetSectionDepthBeforeIntersection(GenericIntersection* intersection, int curve, int seg){	int sectionIndex = GetSectionBeforeIntersection(intersection, curve, seg);		MyAssert(sectionIndex < sectionDepths.size());	return sectionDepths[sectionIndex];}int BSpline::GetSectionDepthAfterIntersection(GenericIntersection* intersection, int curve, int seg){	int sectionIndex = GetSectionAfterIntersection(intersection, curve, seg);		MyAssert(sectionIndex < sectionDepths.size());	return sectionDepths[sectionIndex];}int BSpline::GetMaxPossibleSectionDepthBeforeIntersection(GenericIntersection* intersection, int curve, int seg){	int sectionIndex = GetSectionBeforeIntersection(intersection, curve, seg);		MyAssert(sectionIndex < maxPossibleSectionDepths.size());	return maxPossibleSectionDepths[sectionIndex];}int BSpline::GetMaxPossibleSectionDepthAfterIntersection(GenericIntersection* intersection, int curve, int seg){	int sectionIndex = GetSectionAfterIntersection(intersection, curve, seg);		MyAssert(sectionIndex < maxPossibleSectionDepths.size());	return maxPossibleSectionDepths[sectionIndex];}int BSpline::GetShallowestMaxPossibleSection(){	MyAssert(shallowestMaxPossibleSection != -1);	return shallowestMaxPossibleSection;}int BSpline::GetDeepestMaxPossibleSection(){	MyAssert(deepestMaxPossibleSection != -1);	return deepestMaxPossibleSection;}int BSpline::GetMaxPossibleSectionDepth(int section){	MyAssert(section < maxPossibleSectionDepths.size());	return maxPossibleSectionDepths[section];}vector<int>* BSpline::GetSectionDepths(){	return &sectionDepths;}void BSpline::GetSectionPoints(GenericIntersection* startInter, GenericIntersection* endInter, bool traverseFromTop, bool traverseToTop, bool stopAtFirstOccurrence,									int traverseDir, vector<FloatPoint>& intermediatePoints){	MyAssert(find(allIntersections.begin(), allIntersections.end(), startInter) != allIntersections.end());	MyAssert(find(allIntersections.begin(), allIntersections.end(), endInter) != allIntersections.end());		//Find the intersection's location in the intersection list	//Only used for an assert	//Doesn't work for self intersections	/*	int interIndex = 0;	while (interIndex < allIntersections.size() && allIntersections[interIndex] != startInter)		interIndex++;	MyAssert(interIndex < allIntersections.size());	if (traverseDir == 1)		MyAssert(allIntersections[(interIndex + 1) % allIntersections.size()] == endInter);	else MyAssert(allIntersections[(interIndex + (allIntersections.size() - 1)) % allIntersections.size()] == endInter);	*/	int totalCurveSegments = curvePoints.size() * sNumSegmentsPerCurve;		//Get the curve and segment at the starting position	int cvStart, sgStart;	switch (startInter->GetType())	{		case GenericIntersection::BSP_BSP:			if (traverseFromTop)			{				cvStart = ((BspBspIntersection*)startInter)->GetCv1();				sgStart = ((BspBspIntersection*)startInter)->GetSg1();			}			else			{				cvStart = ((BspBspIntersection*)startInter)->GetCv2();				sgStart = ((BspBspIntersection*)startInter)->GetSg2();			}			break;		case GenericIntersection::BSP_CUT:			cvStart = ((BspCutIntersection*)startInter)->GetCv();			sgStart = ((BspCutIntersection*)startInter)->GetSg();			break;		case GenericIntersection::BSP_CUT_T:			cvStart = ((BspCutTIntersection*)startInter)->GetCv();			sgStart = ((BspCutTIntersection*)startInter)->GetSg();			break;	}	int cvSgStart = cvStart * sNumSegmentsPerCurve + sgStart;		//Get the curve and segment at the ending position	int cvEnd, sgEnd;	if (!stopAtFirstOccurrence)	{		switch (endInter->GetType())		{			case GenericIntersection::BSP_BSP:				if (traverseToTop)				{					cvEnd = ((BspBspIntersection*)endInter)->GetCv1();					sgEnd = ((BspBspIntersection*)endInter)->GetSg1();				}				else				{					cvEnd = ((BspBspIntersection*)endInter)->GetCv2();					sgEnd = ((BspBspIntersection*)endInter)->GetSg2();				}				break;			case GenericIntersection::BSP_CUT:				cvEnd = ((BspCutIntersection*)endInter)->GetCv();				sgEnd = ((BspCutIntersection*)endInter)->GetSg();				break;			case GenericIntersection::BSP_CUT_T:				cvEnd = ((BspCutTIntersection*)endInter)->GetCv();				sgEnd = ((BspCutTIntersection*)endInter)->GetSg();				break;			case GenericIntersection::CUT_CUT:				MyAssert(false);				break;		}	}	else	{		switch (endInter->GetType())		{			case GenericIntersection::BSP_BSP:				if (!endInter->SelfIntersection())				{					if (((BspBspIntersection*)endInter)->GetBsp1() == this)					{						cvEnd = ((BspBspIntersection*)endInter)->GetCv1();						sgEnd = ((BspBspIntersection*)endInter)->GetSg1();					}					else					{						MyAssert(((BspBspIntersection*)endInter)->GetBsp2() == this);						cvEnd = ((BspBspIntersection*)endInter)->GetCv2();						sgEnd = ((BspBspIntersection*)endInter)->GetSg2();					}				}				else	//Self intersection				{					int cvEnd1 = ((BspBspIntersection*)endInter)->GetCv1();					int sgEnd1 = ((BspBspIntersection*)endInter)->GetSg1();					int cvEnd2 = ((BspBspIntersection*)endInter)->GetCv2();					int sgEnd2 = ((BspBspIntersection*)endInter)->GetSg2();					int cvSgEnd1 = cvEnd1 * sNumSegmentsPerCurve + sgEnd1;					int cvSgEnd2 = cvEnd2 * sNumSegmentsPerCurve + sgEnd2;					MyAssert(cvSgEnd1 != cvSgEnd2);										if (cvSgEnd1 < cvSgStart)						cvSgEnd1 += controlPoints.size() * sNumSegmentsPerCurve;					else if (cvSgEnd1 == cvSgStart)					{						MyAssert(false);	//Not implemented yet					}					if (cvSgEnd2 < cvSgStart)						cvSgEnd2 += controlPoints.size() * sNumSegmentsPerCurve;					else if (cvSgEnd2 == cvSgStart)					{						MyAssert(false);	//Not implemented yet					}										if (cvSgEnd1 < cvSgEnd2)					{						cvEnd = cvEnd1;						sgEnd = sgEnd1;					}					else					{						cvEnd = cvEnd2;						sgEnd = sgEnd2;					}				}				break;			case GenericIntersection::BSP_CUT:				cvEnd = ((BspCutIntersection*)endInter)->GetCv();				sgEnd = ((BspCutIntersection*)endInter)->GetSg();				break;			case GenericIntersection::BSP_CUT_T:				cvEnd = ((BspCutTIntersection*)endInter)->GetCv();				sgEnd = ((BspCutTIntersection*)endInter)->GetSg();				break;			case GenericIntersection::CUT_CUT:				MyAssert(false);				break;		}	}	int cvSgEnd = cvEnd * sNumSegmentsPerCurve + sgEnd;		//If both intersections are on the same segment, there are two possibilities.	//One, the traversal goes all the way around, passing all curve points.	//Two, the traversal goes a very short distance, passing no curve points.	//The first case is handled below, the second case is handled here	if (cvSgStart == cvSgEnd)	{		MyAssert(cvStart == cvEnd && sgStart == sgEnd);		double startDist = LineSegmentLength(startInter->GetLocation(), (*curvePoints[cvStart])[sgStart]);		double endDist = LineSegmentLength(endInter->GetLocation(), (*curvePoints[cvEnd])[sgEnd]);				if ((traverseDir == 1 && startDist < endDist) || (traverseDir == 0 && startDist > endDist))			return;	//The list is empty	}		//Traverse the section bounded by the two intersections and collect the curve points along the way	if (traverseDir == 1)	//forward	{		cvSgStart = (cvSgStart + 1) % totalCurveSegments;	//Advance by one		cvSgEnd = (cvSgEnd + 1) % totalCurveSegments;	//Advance by one				if (cvSgStart != cvSgEnd)		{			for (int i = cvSgStart; i != cvSgEnd; i = (i + 1) % totalCurveSegments)				intermediatePoints.push_back((*curvePoints[i / sNumSegmentsPerCurve])[i % sNumSegmentsPerCurve]);		}		else	//Copy the entire BSpline all the way around		{			for (int i = 0; i < totalCurveSegments; i++)			{				int pointIndex = (i + cvSgStart) % totalCurveSegments;				intermediatePoints.push_back((*curvePoints[pointIndex / sNumSegmentsPerCurve])[pointIndex % sNumSegmentsPerCurve]);			}		}	}	else	//backward	{		if (cvSgStart != cvSgEnd)		{			for (int i = cvSgStart; i != cvSgEnd; i = (i + (totalCurveSegments - 1)) % totalCurveSegments)				intermediatePoints.push_back((*curvePoints[i / sNumSegmentsPerCurve])[i % sNumSegmentsPerCurve]);		}		else	//Copy the entire BSpline all the way around		{			for (int i = totalCurveSegments; i > 0; i--)			{				int pointIndex = (i + cvSgStart) % totalCurveSegments;				intermediatePoints.push_back((*curvePoints[pointIndex / sNumSegmentsPerCurve])[pointIndex % sNumSegmentsPerCurve]);			}		}	}}int BSpline::GetSectionDepth(GenericIntersection* startInter, GenericIntersection* endInter, bool traverseFromTop, int traverseDir){	MyAssert(find(allIntersections.begin(), allIntersections.end(), startInter) != allIntersections.end());	MyAssert(find(allIntersections.begin(), allIntersections.end(), endInter) != allIntersections.end());		//debug	//BspBspIntersection* bspBsp1 = (startInter->GetType() == GenericIntersection::BSP_BSP) ? (BspBspIntersection*)startInter : NULL;	//BspBspIntersection* bspBsp2 = (endInter->GetType() == GenericIntersection::BSP_BSP) ? (BspBspIntersection*)endInter : NULL;		//Find the intersection's location in the intersection list	int interIndex = 0;	while (interIndex < allIntersections.size() && allIntersections[interIndex] != startInter)		interIndex++;	MyAssert(interIndex < allIntersections.size());		//Only for debuggin	//int interIndex2 = 0;	//while (interIndex2 < allIntersections.size() && allIntersections[interIndex2] != endInter)	//	interIndex2++;	//MyAssert(interIndex2 < allIntersections.size());		//Might need to keep going	bool keepGoing = false;	if (startInter->SelfIntersection())	{		if (traverseFromTop)		{			if (((BspBspIntersection*)startInter)->GetCv1() > ((BspBspIntersection*)startInter)->GetCv2())				keepGoing = true;			else if (((BspBspIntersection*)startInter)->GetCv1() == ((BspBspIntersection*)startInter)->GetCv2() && ((BspBspIntersection*)startInter)->GetSg1() > ((BspBspIntersection*)startInter)->GetSg2())				keepGoing = true;		}		else	//Traverse from bottom		{			if (((BspBspIntersection*)startInter)->GetCv2() > ((BspBspIntersection*)startInter)->GetCv1())				keepGoing = true;			else if (((BspBspIntersection*)startInter)->GetCv2() == ((BspBspIntersection*)startInter)->GetCv1() && ((BspBspIntersection*)startInter)->GetSg2() > ((BspBspIntersection*)startInter)->GetSg1())				keepGoing = true;		}	}		if (keepGoing)	{		interIndex++;		while (interIndex < allIntersections.size() && allIntersections[interIndex] != startInter)			interIndex++;		MyAssert(interIndex < allIntersections.size());	}		MyAssert(allIntersections[(interIndex + 1) % allIntersections.size()] == endInter);		//Find the section adjacent to the intersection	int sectionIndex = (traverseDir == 1) ? interIndex : (interIndex - 1);	if (sectionIndex == -1)		sectionIndex = sectionDepths.size() - 1;		//Return the section depth	return sectionDepths[sectionIndex];}int BSpline::FindSubboundaryForSection(UnorientedBoundarySection ubs){	//Some asserts	MyAssert(ubs.bsp == this && !ubs.cut);	MyAssert(find(allIntersections.begin(), allIntersections.end(), ubs.startInter) != allIntersections.end());	MyAssert(find(allIntersections.begin(), allIntersections.end(), ubs.endInter) != allIntersections.end());		//Assume no BSpline has more than sBoundarySectionBspSpacing boundary sections and find an offset for this BSpline	int bspIndex = drawing->GetBSplineIndex(this);	MyAssert(bspIndex >= 0);	int boundarySectionOffset = bspIndex * sBoundarySectionBspSpacing;		BspBspIntersection* bspBspStartInter = (BspBspIntersection*)ubs.startInter;	BspBspIntersection* bspBspEndInter = (BspBspIntersection*)ubs.endInter;		if (gDebug13)	{		Rect r;		PenSize(2, 2);				FloatPoint loc = bspBspStartInter->GetLocation();		SetRect(&r, loc.h - 20, loc.v - 20, loc.h + 20, loc.v + 20);		ForeColor(redColor);		FrameRect(&r);				loc = bspBspEndInter->GetLocation();		SetRect(&r, loc.h - 20, loc.v - 20, loc.h + 20, loc.v + 20);		ForeColor(greenColor);		FrameRect(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		int qc = 1;				ForeColor(whiteColor);		loc = bspBspStartInter->GetLocation();		SetRect(&r, loc.h - 20, loc.v - 20, loc.h + 20, loc.v + 20);		FrameRect(&r);				loc = bspBspEndInter->GetLocation();		SetRect(&r, loc.h - 20, loc.v - 20, loc.h + 20, loc.v + 20);		FrameRect(&r);				PenSize(1, 1);	}		//Find the subboundary indexes for the start and end inters.  If either inter is a self-inter, it will have two indexes, once for the first occurance, and once for the second occurance.	int subboundaryIndexes[4] = { 0, 0, 0, 0 };	//First inter, first and second occurrences, then second inter, first and second occurrences	for (int pass = 0; pass < 4; pass++)	{		if ((pass == 1 && !bspBspStartInter->SelfIntersection()) || (pass == 3 && !bspBspEndInter->SelfIntersection()))		{			subboundaryIndexes[pass] = -1;			continue;		}				int hit = 0;		for (int i = 0; i < allIntersections.size(); i++)		{			if (allIntersections[i]->SelfIntersection())				subboundaryIndexes[pass]++;			else if (allIntersections[i]->GetType() == GenericIntersection::BSP_CUT_T)				subboundaryIndexes[pass]++;	//Not sure this is necessary.  Seems to help distinguish the two sections on either side of a BspCutT inter though.  Keep synced with FindIntersectionsForSubboundary.			else			{				WholeObject* wholeObject = drawing->FindWholeObjectForBSpline(this);				if (wholeObject)					switch (allIntersections[i]->GetType())					{						case GenericIntersection::BSP_BSP:							BSpline* otherBsp = ((BspBspIntersection*)allIntersections[i])->GetOtherBsp(this);							if (find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), otherBsp) != wholeObject->bsplines.end())								subboundaryIndexes[pass]++;							break;						case GenericIntersection::BSP_CUT:							BSpline* cutStartBsp = ((BspCutIntersection*)allIntersections[i])->GetCut()->GetBsp1();							if (find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), cutStartBsp) != wholeObject->bsplines.end())								subboundaryIndexes[pass]++;							break;						case GenericIntersection::BSP_CUT_T:							MyAssert(false);							break;						case GenericIntersection::CUT_CUT:							MyAssert(false);							break;					}			}						if (gDebug13)			{				Rect r;				PenSize(2, 2);								if ((pass == 0 && allIntersections[i] == bspBspStartInter && hit + 1 == 1) ||					(pass == 1 && allIntersections[i] == bspBspStartInter && hit + 1 == 2) ||					(pass == 2 && allIntersections[i] == bspBspEndInter && hit + 1 == 1) ||					(pass == 3 && allIntersections[i] == bspBspEndInter && hit + 1 == 2))					ForeColor(redColor);				else ForeColor(blueColor);				FloatPoint loc = allIntersections[i]->GetLocation();				SetRect(&r, loc.h - 20, loc.v - 20, loc.h + 20, loc.v + 20);				FrameRect(&r);								Str255 str;				TextFace(bold);				TextSize(18);				NumToString(subboundaryIndexes[pass], str);				MoveTo(loc.h + 30, loc.v);				DrawString(str);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qc = 1;								ForeColor(whiteColor);				SetRect(&r, loc.h - 20, loc.v - 20, loc.h + 20, loc.v + 20);				FrameRect(&r);								MoveTo(loc.h + 30, loc.v);				DrawString(str);								PenSize(1, 1);			}						if (pass == 0 && allIntersections[i] == bspBspStartInter && ++hit == 1)				break;			if (pass == 1 && allIntersections[i] == bspBspStartInter && ++hit == 2)				break;			if (pass == 2 && allIntersections[i] == bspBspEndInter && ++hit == 1)				break;			if (pass == 3 && allIntersections[i] == bspBspEndInter && ++hit == 2)				break;		}	}		if (gDebug13)		int qc = 1;		//Determine if the start and end intersections are whole object self-intersections, bspline self-intersection, or not self-intersections	bool startSelfInter = false, endSelfInter = false;	WholeObject* wholeObject = drawing->FindWholeObjectForBSpline(this);	MyAssert(wholeObject);	//if (wholeObject)	//{		switch (bspBspStartInter->GetType())		{			case GenericIntersection::BSP_BSP:				BSpline* otherBsp = ((BspBspIntersection*)bspBspStartInter)->GetOtherBsp(this);				if (find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), otherBsp) != wholeObject->bsplines.end())					startSelfInter = true;				break;			case GenericIntersection::BSP_CUT:				BSpline* cutStartBsp = ((BspCutIntersection*)bspBspStartInter)->GetCut()->GetBsp1();				if (find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), cutStartBsp) != wholeObject->bsplines.end())					startSelfInter = true;				break;			case GenericIntersection::BSP_CUT_T:				break;			case GenericIntersection::CUT_CUT:				MyAssert(false);				break;		}		switch (bspBspEndInter->GetType())		{			case GenericIntersection::BSP_BSP:				BSpline* otherBsp = ((BspBspIntersection*)bspBspEndInter)->GetOtherBsp(this);				if (find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), otherBsp) != wholeObject->bsplines.end())					endSelfInter = true;				break;			case GenericIntersection::BSP_CUT:				BSpline* cutStartBsp = ((BspCutIntersection*)bspBspEndInter)->GetCut()->GetBsp1();				if (find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), cutStartBsp) != wholeObject->bsplines.end())					endSelfInter = true;				break;			case GenericIntersection::BSP_CUT_T:				break;			case GenericIntersection::CUT_CUT:				MyAssert(false);				break;		}	//}		//Count the total number of self-intersections on the bspline	int totalSelfInters = 0;	//if (wholeObject)		for (int i = 0; i < allIntersections.size(); i++)		{			switch (allIntersections[i]->GetType())			{				case GenericIntersection::BSP_BSP:					BSpline* otherBsp = ((BspBspIntersection*)allIntersections[i])->GetOtherBsp(this);					if (find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), otherBsp) != wholeObject->bsplines.end())						totalSelfInters++;					break;				case GenericIntersection::BSP_CUT:					BSpline* cutStartBsp = ((BspCutIntersection*)allIntersections[i])->GetCut()->GetBsp1();					if (find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), cutStartBsp) != wholeObject->bsplines.end())						totalSelfInters++;					break;				case GenericIntersection::BSP_CUT_T:					totalSelfInters++;	//Count this since it counts as a delimiter between subbboundaries					break;				case GenericIntersection::CUT_CUT:					MyAssert(false);					break;			}		}	//else	//	for (int i = 0; i < allIntersections.size(); i++)	//		if (allIntersections[i]->SelfIntersection())	//			totalSelfInters++;	/*	for (int i = 0; i < wholeObject->bsplines.size(); i++)	{		vector<GenericIntersection*> bspInters = wholeObject->bsplines[i]->GetIntersections();		for (int j = 0; j < bspInters.size(); j++)		{			switch (allIntersections[i]->GetType())			{				case GenericIntersection::BSP_BSP:					BSpline* otherBsp = ((BspBspIntersection*)bspInters[j])->GetOtherBsp(wholeObject->bsplines[i]);					if (find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), otherBsp) != wholeObject->bsplines.end())						totalSelfInters++;					break;				case GenericIntersection::BSP_CUT:					BSpline* cutStartBsp = ((BspCutIntersection*)bspInters[j])->GetCut()->GetBsp1();					if (find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), cutStartBsp) != wholeObject->bsplines.end())						totalSelfInters++;					break;				case GenericIntersection::BSP_CUT_T:					break;				case GenericIntersection::CUT_CUT:					MyAssert(false);					break;			}		}	}	*/	MyAssert(totalSelfInters < sBoundarySectionBspSpacing);		//Find and return the subboundary index	if (!startSelfInter)		return subboundaryIndexes[0] % totalSelfInters + boundarySectionOffset;	else if (!endSelfInter)		return subboundaryIndexes[2] % totalSelfInters + boundarySectionOffset;	else	{		if (ubs.startCv != -1)		{			MyAssert(ubs.startSg != -1);						if (subboundaryIndexes[1] == -1)	//Whole object self inter, but not BSpline self inter			{				MyAssert(!bspBspStartInter->SelfIntersection());				return subboundaryIndexes[0] % totalSelfInters + boundarySectionOffset;			}						int cv1 = bspBspStartInter->GetCv1();			int cv2 = bspBspStartInter->GetCv2();			int sg1 = bspBspStartInter->GetSg1();			int sg2 = bspBspStartInter->GetSg2();			int cvsg1 = cv1 * sNumSegmentsPerCurve + sg1;			int cvsg2 = cv2 * sNumSegmentsPerCurve + sg2;						if (ubs.startCv == cv1 && ubs.startSg == sg1)	//The boundary section is on top at the start inter			{				if (cvsg1 < cvsg2)	//If the top is earlier than the bottom					return subboundaryIndexes[0] % totalSelfInters + boundarySectionOffset;				return subboundaryIndexes[1] % totalSelfInters + boundarySectionOffset;			}			else	//The boundary section is on the bottom at the start inter			{				MyAssert(ubs.startCv == cv2 && ubs.startSg == sg2);								if (cvsg2 < cvsg1)	//If the bottom is earlier than the top					return subboundaryIndexes[0] % totalSelfInters + boundarySectionOffset;				return subboundaryIndexes[1] % totalSelfInters + boundarySectionOffset;			}		}		else		{			MyAssert(ubs.endSg != -1 && ubs.endSg != -1);						if (subboundaryIndexes[3] == -1)	//Whole object self inter, but not BSpline self inter			{				MyAssert(!bspBspEndInter->SelfIntersection());				MyAssert(subboundaryIndexes[2] - 1 >= 0);				return (subboundaryIndexes[2] - 1) % totalSelfInters + boundarySectionOffset;			}						int cv1a = bspBspEndInter->GetCv1();			int cv2a = bspBspEndInter->GetCv2();			int sg1a = bspBspEndInter->GetSg1();			int sg2a = bspBspEndInter->GetSg2();			int cvsg1a = cv1a * sNumSegmentsPerCurve + sg1a;			int cvsg2a = cv2a * sNumSegmentsPerCurve + sg2a;						if (ubs.endCv == cv1a && ubs.endSg == sg1a)	//The boundary section is on top at the end inter			{				if (cvsg1a < cvsg2a)	//If the top is earlier than the bottom				{					MyAssert(subboundaryIndexes[2] - 1 >= 0);					return (subboundaryIndexes[2] - 1) % totalSelfInters + boundarySectionOffset;				}				else				{					MyAssert(subboundaryIndexes[3] - 1 >= 0);					return (subboundaryIndexes[3] - 1) % totalSelfInters + boundarySectionOffset;				}			}			else	//The boundary section is on the bottom at the end inter			{				MyAssert(ubs.endCv == cv2a && ubs.endSg == sg2a);								if (cvsg2a < cvsg1a)	//If the bottom is earlier than the top				{					MyAssert(subboundaryIndexes[2] - 1 >= 0);					return (subboundaryIndexes[2] - 1) % totalSelfInters + boundarySectionOffset;				}				else				{					MyAssert(subboundaryIndexes[3] - 1 >= 0);					return (subboundaryIndexes[3] - 1) % totalSelfInters + boundarySectionOffset;				}			}		}	}		MyAssert(false);	//Should be impossible to get here}void BSpline::FindIntersectionsForSubboundary(int subboundary, GenericIntersection*& startInter, GenericIntersection*& endInter){	//Assume no BSpline has more than sBoundarySectionBspSpacing boundary sections and find an offset for this BSpline	int bspIndex = drawing->GetBSplineIndex(this);	MyAssert(bspIndex >= 0);	int boundarySectionOffset = bspIndex * sBoundarySectionBspSpacing;		int subboundaryIndex = 0;	for (int i = 0; i < allIntersections.size(); i++)	{		if (allIntersections[i]->SelfIntersection())			subboundaryIndex++;		else if (allIntersections[i]->GetType() == GenericIntersection::BSP_CUT_T)			subboundaryIndex++;	//Keep synced with FindSubboundaryForSection		else		{			WholeObject* wholeObject = drawing->FindWholeObjectForBSpline(this);			if (wholeObject)				switch (allIntersections[i]->GetType())				{					case GenericIntersection::BSP_BSP:						BSpline* otherBsp = ((BspBspIntersection*)allIntersections[i])->GetOtherBsp(this);						if (find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), otherBsp) != wholeObject->bsplines.end())							subboundaryIndex++;						break;					case GenericIntersection::BSP_CUT:						BSpline* cutStartBsp = ((BspCutIntersection*)allIntersections[i])->GetCut()->GetBsp1();						if (find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), cutStartBsp) != wholeObject->bsplines.end())							subboundaryIndex++;						break;					case GenericIntersection::BSP_CUT_T:						MyAssert(false);						break;					case GenericIntersection::CUT_CUT:						MyAssert(false);						break;				}		}				if (subboundaryIndex + boundarySectionOffset == subboundary)		{			startInter = allIntersections[i];			endInter = allIntersections[(i + 1) % allIntersections.size()];			return;		}	}	MyAssert(false);	//Shouldn't get here}int BSpline::GetMinIntersectionGap(){	int minGapDepth = 999999;		for (int i = 0; i < allIntersections.size(); i++)	{		GenericIntersection* intersection = allIntersections[i];				//I think we can ignore BspCutT intersections		if (intersection->GetType() == GenericIntersection::BSP_CUT_T)			continue;		else if (intersection->GetType() == GenericIntersection::BSP_BSP)		{			BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;						if (bspBspInter->SelfIntersection())				continue;						//Get the intersection's basic data			BSpline* bsp1 = bspBspInter->GetBsp1();			BSpline* bsp2 = bspBspInter->GetBsp2();			int curve1 = bspBspInter->GetCv1();			int curve2 = bspBspInter->GetCv2();			int seg1 = bspBspInter->GetSg1();			int seg2 = bspBspInter->GetSg2();			int occludedEdge = bspBspInter->DetermineOccludedEdge();						//Get the four depths at the intersection			int bsp1End1Depth = bsp1->GetSectionDepthBeforeIntersection(intersection, curve1, seg1);			int bsp1End2Depth = bsp1->GetSectionDepthAfterIntersection(intersection, curve1, seg1);			int bsp2End1Depth = bsp2->GetSectionDepthBeforeIntersection(intersection, curve2, seg2);			int bsp2End2Depth = bsp2->GetSectionDepthAfterIntersection(intersection, curve2, seg2);						MyAssert(intersection->IntersectionLegal());						if (bsp1 == this)			{				//No need to calc gap depth when on top, unless interested in negative gap depths, which we aren't right now				/*				int gapDepth = bsp1End1Depth - (occludedEdge == 3 ? bsp1End2Depth : bsp1End1Depth);				MyAssert(gapDepth <= 0);								if (gapDepth > maxGapDepth)					maxGapDepth = gapDepth;				*/			}			else			{				MyAssert(occludedEdge == 3 || occludedEdge == 4);				MyAssert(bsp2 == this);				int gapDepth = (occludedEdge == 3 ? bsp2End2Depth : bsp2End1Depth) - bsp1End1Depth;				MyAssert(gapDepth >= 0);								if (gapDepth < minGapDepth)					minGapDepth = gapDepth;			}		}		else if (intersection->GetType() == GenericIntersection::BSP_CUT)		{			BspCutIntersection* bspCutInter = (BspCutIntersection*)intersection;						//No need to calc gap depth when on top, unless interested in negative gap depths, which we aren't right now			if (bspCutInter->GetBspOnTop())	//Bsp on top				continue;						//Get the intersection's basic data			BSpline* bsp = bspCutInter->GetBsp();			BSplineToBSplineCut* cut = bspCutInter->GetCut();			int curve = bspCutInter->GetCv();			int seg = bspCutInter->GetSg();			int occludedEdge = bspCutInter->DetermineOccludedEdge();						//Get the four depths at the intersection			int bspEnd1Depth = bsp->GetSectionDepthBeforeIntersection(intersection, curve, seg);			int bspEnd2Depth = bsp->GetSectionDepthAfterIntersection(intersection, curve, seg);			int cutEnd1Depth = cut->GetSectionDepthBeforeIntersection(intersection);			int cutEnd2Depth = cut->GetSectionDepthAfterIntersection(intersection);						MyAssert(intersection->IntersectionLegal());			MyAssert(!bspCutInter->GetBspOnTop());						MyAssert(occludedEdge == -1);						MyAssert(bsp == this);			MyAssert(bspEnd1Depth == bspEnd2Depth);			MyAssert(cutEnd1Depth == cutEnd2Depth);			int gapDepth = (bspEnd1Depth - 1) - cutEnd2Depth;			MyAssert(gapDepth >= 0);						if (gapDepth < minGapDepth)				minGapDepth = gapDepth;		}	}		//If didn't find any relevant intersections, return min section depth instead	/*if (minGapDepth == 999999)	{		for (int i = 0; i < sectionDepths.size(); i++)			if (sectionDepths[i] < minGapDepth)				minGapDepth = sectionDepths[i];	}*/		//If didn't find any relevant intersections, return 0 instead	//if (minGapDepth == 999999)	//	minGapDepth = 0;		return minGapDepth;}bool BSpline::GetSectionDepthConstraintBeforeIntersection(GenericIntersection* intersection, int curve, int seg){	int sectionIndex = GetSectionBeforeIntersection(intersection, curve, seg);		return sectionDepthConstraints[sectionIndex];}bool BSpline::GetSectionDepthConstraintAfterIntersection(GenericIntersection* intersection, int curve, int seg){	int sectionIndex = GetSectionAfterIntersection(intersection, curve, seg);		return sectionDepthConstraints[sectionIndex];}int BSpline::GetIntersectionIndex(GenericIntersection* intersection, bool takeFirstFound){	int index = -1;		int numIts = (takeFirstFound ? 1 : 2);	for (int i = 0; i < numIts; i++)		for (index++; index < allIntersections.size(); index++)			if (allIntersections[index] == intersection)				break;	MyAssert(index != -1 && index < allIntersections.size());		return index;}bool BSpline::GetIfIntersectsBSpline(BSpline* bsp){	for (int i = 0; i < allIntersections.size(); i++)	{		//Ignore nonBspBsp intersections		if (allIntersections[i]->GetType() != GenericIntersection::BSP_BSP)			continue;		BspBspIntersection* bspBspInter = (BspBspIntersection*)allIntersections[i];				if (bspBspInter->SelfIntersection())		{			if (bsp == this)				return true;		}		else	//Not self intersection		{			if (bspBspInter->GetOtherBsp(this) == bsp)				return true;		}	}		return false;}bool BSpline::GetAllSectionsConstrained(){	for (int i = 0; i < sectionDepthConstraints.size(); i++)		if (!sectionDepthConstraints[i])			return false;		return true;}bool BSpline::GetAllIntersectionsLegal(bool assertIt){	for (int i = 0; i < allIntersections.size(); i++)	{		GenericIntersection* intersection = allIntersections[i];		MyAssert(!intersection->GetDtored());				if (!allIntersections[i]->IntersectionLegal())		//if (!intersection->IntersectionLegal())		{			if (assertIt)			{				MyAssert(false);				intersection->IntersectionLegal();			}			return false;		}	}		return true;}GenericIntersection* BSpline::FindPrevIntersection(GenericIntersection* intersection, int curve, int segment){	MyAssert(curve >= 0 && curve < curveIntersections.size() && segment >= 0 && segment < sNumSegmentsPerCurve);		//Find the intersection's location along the curve, its sorted position on the curve with respect to any other intersections on the curve	int index;	if (!intersection->SelfIntersection())	{		for (index = 0; index < curveIntersections[curve]->size(); index++)			if ((*curveIntersections[curve])[index] == intersection)				break;	}	else	//Self intersection	{		BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;				MyAssert((bspBspInter->GetCv1() == curve && bspBspInter->GetSg1() == segment) ||				(bspBspInter->GetCv2() == curve && bspBspInter->GetSg2() == segment));				if (bspBspInter->GetCv1() == curve && bspBspInter->GetCv2() == curve)	//Self intersection is on the same curve both times		{			if ((bspBspInter->GetSg1() == segment && bspBspInter->GetSg1() < bspBspInter->GetSg2()) ||				(bspBspInter->GetSg2() == segment && bspBspInter->GetSg2() < bspBspInter->GetSg1()))	//Use first instance of the intersection on the curve			{				for (index = 0; index < curveIntersections[curve]->size(); index++)					if ((*curveIntersections[curve])[index] == bspBspInter)						break;			}			else	//Use the second instance of the intersection on the curve			{				for (index = 0; index < curveIntersections[curve]->size(); index++)					if ((*curveIntersections[curve])[index] == bspBspInter)						break;				index++;				for (; index < curveIntersections[curve]->size(); index++)					if ((*curveIntersections[curve])[index] == bspBspInter)						break;			}		}		else	//Self intersection is on different curves both times		{			for (index = 0; index < curveIntersections[curve]->size(); index++)				if ((*curveIntersections[curve])[index] == bspBspInter)					break;		}	}		MyAssert(index < curveIntersections[curve]->size());		if (index > 0)		return (*curveIntersections[curve])[index - 1];	else	{		int prevCurve = curve;		do		{			prevCurve--;			if (prevCurve < 0)				prevCurve = curveIntersections.size() - 1;		} while (curveIntersections[prevCurve]->size() == 0);		return (*curveIntersections[prevCurve])[curveIntersections[prevCurve]->size() - 1];	}}GenericIntersection* BSpline::FindNextIntersection(GenericIntersection* intersection, int curve, int segment){	MyAssert(curve >= 0 && curve < curveIntersections.size() && segment >= 0 && segment < sNumSegmentsPerCurve);		//Find the intersection's location along the curve, its sorted position on the curve with respect to any other intersections on the curve	int index;	if (!intersection->SelfIntersection())	{		for (index = 0; index < curveIntersections[curve]->size(); index++)			if ((*curveIntersections[curve])[index] == intersection)				break;	}	else	//Self intersection	{		BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;				MyAssert((bspBspInter->GetCv1() == curve && bspBspInter->GetSg1() == segment) ||				(bspBspInter->GetCv2() == curve && bspBspInter->GetSg2() == segment));				if (bspBspInter->GetCv1() == curve && bspBspInter->GetCv2() == curve)	//Self intersection is on the same curve both times		{			if ((bspBspInter->GetSg1() == segment && bspBspInter->GetSg1() < bspBspInter->GetSg2()) ||				(bspBspInter->GetSg2() == segment && bspBspInter->GetSg2() < bspBspInter->GetSg1()))	//Use first instance of the intersection on the curve			{				for (index = 0; index < curveIntersections[curve]->size(); index++)					if ((*curveIntersections[curve])[index] == bspBspInter)						break;			}			else	//Use the second instance of the intersection on the curve			{				for (index = 0; index < curveIntersections[curve]->size(); index++)					if ((*curveIntersections[curve])[index] == bspBspInter)						break;				index++;				for (; index < curveIntersections[curve]->size(); index++)					if ((*curveIntersections[curve])[index] == bspBspInter)						break;			}		}		else	//Self intersection is on different curves both times		{			for (index = 0; index < curveIntersections[curve]->size(); index++)				if ((*curveIntersections[curve])[index] == bspBspInter)					break;		}	}		//еее DEBUG	vector<GenericIntersection*> a1, a2, a3;	if (curveIntersections.size() > 0)		for (int i = 0; i < curveIntersections[0]->size(); i++)			a1.push_back((*curveIntersections[0])[i]);	if (curveIntersections.size() > 1)		for (int i = 0; i < curveIntersections[1]->size(); i++)			a2.push_back((*curveIntersections[1])[i]);	if (curveIntersections.size() > 2)		for (int i = 0; i < curveIntersections[2]->size(); i++)			a3.push_back((*curveIntersections[2])[i]);		MyAssert(index < curveIntersections[curve]->size());		if (index < curveIntersections[curve]->size() - 1)		return (*curveIntersections[curve])[index + 1];	else	{		int nextCurve = curve;		do		{			nextCurve++;			if (nextCurve >= curveIntersections.size())				nextCurve = 0;		} while (curveIntersections[nextCurve]->size() == 0);		return (*curveIntersections[nextCurve])[0];	}}#pragma mark -FloatPoint BSpline::FindCenter(){	double left = 9999, right = -9999;	double top = 9999, bottom = -9999;		for (vector<FloatPoint>::iterator i = controlPoints.begin(); i != controlPoints.end(); i++)	{		if ((*i).h < left)			left = (*i).h;		if ((*i).h > right)			right = (*i).h;		if ((*i).v < top)			top = (*i).v;		if ((*i).v > bottom)			bottom = (*i).v;	}		return FloatPoint((left + right) / 2.0, (top + bottom) / 2.0);}void BSpline::FlipHorizontal(FloatPoint selectionCenter){	FloatPoint center = (selectionCenter.h == -999999) ? FindCenter() : selectionCenter;		//Flip each control point across the center	for (vector<FloatPoint>::iterator i = controlPoints.begin(); i != controlPoints.end(); i++)		if ((*i).h < center.h)			(*i).h = center.h + (center.h - (*i).h);		else if ((*i).h > center.h)			(*i).h = center.h - ((*i).h - center.h);		SetAllCurvesToRecalc();		RecalcBSpline();}void BSpline::FlipVertical(FloatPoint selectionCenter){	FloatPoint center = (selectionCenter.h == -999999) ? FindCenter() : selectionCenter;		//Flip each control point across the center	for (vector<FloatPoint>::iterator i = controlPoints.begin(); i != controlPoints.end(); i++)		if ((*i).v < center.v)			(*i).v = center.v + (center.v - (*i).v);		else if ((*i).v > center.v)			(*i).v = center.v - ((*i).v - center.v);		SetAllCurvesToRecalc();		RecalcBSpline();}void BSpline::Rotate90CW(FloatPoint selectionCenter){	RotateNumeric(PiOver2, selectionCenter);}void BSpline::Rotate90CCW(FloatPoint selectionCenter){	RotateNumeric(3.0 * PiOver2, selectionCenter);}void BSpline::Rotate180(FloatPoint selectionCenter){	RotateNumeric(Pi, selectionCenter);}void BSpline::RotateNumeric(double rotation, FloatPoint selectionCenter){	FloatPoint center = (selectionCenter.h == -999999) ? FindCenter() : selectionCenter;		//Rotate each control point around the center	for (vector<FloatPoint>::iterator i = controlPoints.begin(); i != controlPoints.end(); i++)	{		double segLength = LineSegmentLength(center, *i);				//Find the angle to the control point's starting position		double originalAngle = LineSegmentAngle(center, *i);				MyAssert(originalAngle >= 0 && originalAngle <= PiTimes2);				//Find the new angle		double newAngle = originalAngle + rotation;		if (newAngle < 0)			newAngle += PiTimes2;		else if (newAngle >= PiTimes2)			newAngle -= PiTimes2;				//Find the new position of the point		*i = ProjectPointAtAngle(center, newAngle, segLength);	}		SetAllCurvesToRecalc();		RecalcBSpline();}void BSpline::RotateFree(){}void BSpline::ScaleNumeric(double scaleAmount){	FloatPoint center = FindCenter();		//Scale each control point away from the center	for (vector<FloatPoint>::iterator i = controlPoints.begin(); i != controlPoints.end(); i++)	{		if ((*i).h < center.h)			(*i).h += 50;		else (*i).h -= 50;		/*		double segLength = LineSegmentLength(center, *i);				//Find the angle to the control point's starting position		double angle = LineSegmentAngle(center, *i);				MyAssert(angle >= 0 && angle <= PiTimes2);				//Find the new distance		double newDistance = segLength * scaleAmount;				//Find the new position of the point		*i = ProjectPointAtAngle(center, angle, newDistance);		*/	}		SetAllCurvesToRecalc();		RecalcBSpline();}void BSpline::ScaleFree(){}#pragma mark -		void BSpline::ConstrainMoveWithinCanvas(Point& delta, Point canvasSize){/*	for (vector<FloatPoint>::iterator i = controlPoints.begin(); i != controlPoints.end(); i++)	{		if ((*i).h + delta.h < 0)			delta.h = -(*i).h;		else if ((*i).h + delta.h >= canvasSize.h)			delta.h = (canvasSize.h - 1) - (*i).h;		if ((*i).v + delta.v < 0)			delta.v = -(*i).v;		else if ((*i).v + delta.v >= canvasSize.v)			delta.v = (canvasSize.v - 1) - (*i).v;	}*/}#pragma mark -void BSpline::SetSurfaceTraits(SurfaceTraits st){	surfaceTraits = st;}int BSpline::AddControlPoint(FloatPoint newPoint){	BackupCurvePoints();		controlPoints.push_back(newPoint);	curvePoints.push_back(new vector<FloatPoint>(sNumSegmentsPerCurve));	curveIntersections.push_back(new vector<GenericIntersection*>);	intersectionCurveSegments.resize(controlPoints.size() * sNumSegmentsPerCurve);		curvesToRecalc.push_back(false);	curvesToReintersect.push_back(false);		for (int i = 0; i >= -(degree + 1); i--)	{		curvesToRecalc[(curvesToRecalc.size() + (curvesToRecalc.size() + i)) % curvesToRecalc.size()] = true;		curvesToReintersect[(curvesToReintersect.size() + (curvesToReintersect.size() + i)) % curvesToReintersect.size()] = true;	}	//MyAssert(curvesToRecalc.size() == curvesToReintersect.size());	//for (int i = 0; i < curvesToReintersect.size(); i++)	//	curvesToRecalc[i] = curvesToReintersect[i] = true;		RecalcBSpline();		//Update the locations of BspCutT intersections	for (int i = 0; i < allIntersections.size(); i++)		if (allIntersections[i]->GetType() == GenericIntersection::BSP_CUT_T)			((BspCutTIntersection*)allIntersections[i])->RecalcStartEndLocs();		return controlPoints.size() - 1;}void BSpline::SplitControlBoundarySegment(int controlBoundarySegment, FloatPoint newPoint){	BackupCurvePoints();		vector<FloatPoint>::iterator i = controlPoints.begin();	vector<vector<FloatPoint>*>::iterator j = curvePoints.begin();	vector<vector<GenericIntersection*>*>::iterator n = curveIntersections.begin();	vector<bool>::iterator k = curvesToRecalc.begin();	vector<bool>::iterator m = curvesToReintersect.begin();		i++;	for (int a = 0; a < controlBoundarySegment; a++)	{		i++;		j++;		n++;		k++;		m++;	}		if (0)//еееcontrolPoints.size() >= 3)	{		//еее DEBUG		bool* recalcArray1 = new bool[controlPoints.size()];		bool* reinterArray1 = new bool[controlPoints.size()];		for (int i = 0; i < controlPoints.size(); i++)		{			recalcArray1[i] = curvesToRecalc[i];			reinterArray1[i] = curvesToReintersect[i];		}				for (int i = 0; i > -degree; i--)		{			curvesToRecalc[(controlBoundarySegment + (curvesToRecalc.size() + i)) % curvesToRecalc.size()] = true;			curvesToReintersect[(controlBoundarySegment + (curvesToReintersect.size() + i)) % curvesToReintersect.size()] = true;		}		//MyAssert(curvesToRecalc.size() == curvesToReintersect.size());		//for (int i = 0; i < curvesToReintersect.size(); i++)		//	curvesToRecalc[i] = curvesToReintersect[i] = true;				//еее DEBUG		for (int i = 0; i < controlPoints.size(); i++)		{			recalcArray1[i] = curvesToRecalc[i];			reinterArray1[i] = curvesToReintersect[i];		}		delete [] recalcArray1;		delete [] reinterArray1;				for (int i = 0; i < curvesToReintersect.size(); i++)			if (curvesToReintersect[i])			{				//for (vector<GenericIntersection*>::iterator it = curveIntersections[i]->begin(); it != curveIntersections[i]->end(); it++)				int stopCount = 0;				while (curveIntersections[i]->size() > stopCount)				{					vector<GenericIntersection*>::iterator it = curveIntersections[i]->begin();										if ((*it)->SelfIntersection())					{						BspBspIntersection* bspBspInter = (BspBspIntersection*)(*it);						MyAssert(bspBspInter->GetCv1() == i || bspBspInter->GetCv2() == i);						int otherCurve = (bspBspInter->GetCv1() == i) ? bspBspInter->GetCv2() : bspBspInter->GetCv1();						bool foundIt = false;						for (vector<GenericIntersection*>::iterator kt = curveIntersections[otherCurve]->begin();								kt != curveIntersections[otherCurve]->end(); kt++)							if (*kt == *it)							{								curveIntersections[otherCurve]->erase(kt);								foundIt = true;								break;							}						MyAssert(foundIt);					}										switch ((*it)->GetType())					{						case GenericIntersection::BSP_BSP:							BspBspIntersection* bspBspInter1 = (BspBspIntersection*)(*it);	//еее							((BspBspIntersection*)(*it))->SetNullBsp(this);							break;						case GenericIntersection::BSP_CUT:							BspCutIntersection* bspCutInter1 = (BspCutIntersection*)(*it);	//еее							((BspCutIntersection*)(*it))->SetNullBsp();							break;						case GenericIntersection::BSP_CUT_T:							//BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)(*it);	//еее							//((BspCutTIntersection*)(*it))->SetNullBsp();							break;					}										if ((*it)->GetType() != GenericIntersection::BSP_CUT_T)					{						delete *it;						curveIntersections[i]->erase(it);					}					else stopCount++;				}			}	}		controlPoints.insert(i, newPoint);	curvePoints.insert(j, new vector<FloatPoint>(sNumSegmentsPerCurve));	curveIntersections.insert(n, new vector<GenericIntersection*>);	curvesToRecalc.insert(k, false);	curvesToReintersect.insert(m, false);	intersectionCurveSegments.resize(controlPoints.size() * sNumSegmentsPerCurve);		for (int i = curveIntersections.size() - 1; i >= controlBoundarySegment; i--)		for (vector<GenericIntersection*>::iterator j = curveIntersections[i]->begin(); j != curveIntersections[i]->end(); j++)		{			switch ((*j)->GetType())			{				case GenericIntersection::BSP_BSP:					((BspBspIntersection*)(*j))->IncreaseCurve(this, i - 1);					break;				case GenericIntersection::BSP_CUT:					((BspCutIntersection*)(*j))->IncreaseCurve();					break;				case GenericIntersection::BSP_CUT_T:					((BspCutTIntersection*)(*j))->IncreaseCurve();					break;				case GenericIntersection::CUT_CUT:					MyAssert(false);					break;			}		}		//еее DEBUG	bool* recalcArray = new bool[controlPoints.size()];	bool* reinterArray = new bool[controlPoints.size()];	for (int i = 0; i < controlPoints.size(); i++)	{		recalcArray[i] = curvesToRecalc[i];		reinterArray[i] = curvesToReintersect[i];	}		for (int i = 1; i /*>=*/> -degree; i--)	{		curvesToRecalc[(controlBoundarySegment + (curvesToRecalc.size() + i)) % curvesToRecalc.size()] = true;		curvesToReintersect[(controlBoundarySegment + (curvesToReintersect.size() + i)) % curvesToReintersect.size()] = true;	}	//MyAssert(curvesToRecalc.size() == curvesToReintersect.size());	//for (int i = 0; i < curvesToReintersect.size(); i++)	//	curvesToRecalc[i] = curvesToReintersect[i] = true;		//еее DEBUG	for (int i = 0; i < controlPoints.size(); i++)	{		recalcArray[i] = curvesToRecalc[i];		reinterArray[i] = curvesToReintersect[i];	}	delete [] recalcArray;	delete [] reinterArray;		RecalcBSpline();		//Update the locations of BspCutT intersections	for (int i = 0; i < allIntersections.size(); i++)		if (allIntersections[i]->GetType() == GenericIntersection::BSP_CUT_T)			((BspCutTIntersection*)allIntersections[i])->RecalcStartEndLocs();}bool BSpline::ChangeControlPoint(int controlPointIndex, FloatPoint newPoint, bool changeAllPoints, Point canvasSize){	BackupCurvePoints();		int oldWindingNum = windingNumber;		//Calculate the offset or delta based on the old and new positions of the point	double oH, oV;	oH = newPoint.h - controlPoints[controlPointIndex].h;	oV = newPoint.v - controlPoints[controlPointIndex].v;		//A full object translation is handled quite differently from a control point spline reshaping command	if (changeAllPoints)	{		//Constrain the translation withing the canvas		/*for (vector<FloatPoint>::iterator i = controlPoints.begin(); i != controlPoints.end(); i++)		{			if ((*i).h + oH < 0)				oH = -(*i).h;			else if ((*i).h + oH >= canvasSize.h)				oH = (canvasSize.h - 1) - (*i).h;			if ((*i).v + oV < 0)				oV = -(*i).v;			else if ((*i).v + oV >= canvasSize.v)				oV = (canvasSize.v - 1) - (*i).v;		}*/				//Translate the control points		for (vector<FloatPoint>::iterator i = controlPoints.begin(); i != controlPoints.end(); i++)		{			(*i).h += oH;			(*i).v += oV;		}				//Translate the curve points		for (vector<vector<FloatPoint>*>::iterator i = curvePoints.begin(); i != curvePoints.end(); i++)			for (vector<FloatPoint>::iterator j = (*i)->begin(); j != (*i)->end(); j++)			{				(*j).h += oH;				(*j).v += oV;			}				//Translate the intersections		vector<GenericIntersection*> selfIntersTranslatedAlready;		for (int i = 0; i < curveIntersections.size(); i++)			for (int j = 0; j < curveIntersections[i]->size(); j++)				if (!(*curveIntersections[i])[j]->SelfIntersection())				{					if ((*curveIntersections[i])[j]->GetType() != GenericIntersection::BSP_BSP)	//BspCut and BspCutT inters are translated by the BSpline, not the cut						(*curveIntersections[i])[j]->Offset(oH, oV);					else					{						BSpline* bsp1 = ((BspBspIntersection*)(*curveIntersections[i])[j])->GetBsp1();						BSpline* bsp2 = ((BspBspIntersection*)(*curveIntersections[i])[j])->GetBsp2();						if (bsp1 == this)							(*curveIntersections[i])[j]->Offset(oH, oV);					}				}				else if (find(selfIntersTranslatedAlready.begin(), selfIntersTranslatedAlready.end(), (*curveIntersections[i])[j]) == selfIntersTranslatedAlready.end())	//To move self inters only once, only move it the first time				{					(*curveIntersections[i])[j]->Offset(oH, oV);					selfIntersTranslatedAlready.push_back((*curveIntersections[i])[j]);				}				SetAllCurvesToReintersect();	}	else	//not changing all points, just reshaping one point	{		//Move the control point by the offset		controlPoints[controlPointIndex].h += oH;		controlPoints[controlPointIndex].v += oV;				//Constrain the new position of the control point within the canvas		/*		if (controlPoints[controlPointIndex].h < 0)			controlPoints[controlPointIndex].h = 0;		else if (controlPoints[controlPointIndex].h >= canvasSize.h)			controlPoints[controlPointIndex].h = canvasSize.h - 1;		if (controlPoints[controlPointIndex].v < 0)			controlPoints[controlPointIndex].v = 0;		else if (controlPoints[controlPointIndex].v >= canvasSize.v)			controlPoints[controlPointIndex].v = canvasSize.v - 1;		*/		//еее DEBUG		bool* recalcArray = new bool[controlPoints.size()];		bool* reinterArray = new bool[controlPoints.size()];		for (int i = 0; i < controlPoints.size(); i++)		{			recalcArray[i] = curvesToRecalc[i];			reinterArray[i] = curvesToReintersect[i];		}				//Determine which spline curves need to be recalculated and reintersected as a result of the change		for (int i = 0; i >= -degree; i--)		{			int numCurves = controlPoints.size();						MyAssert(curvesToRecalc.size() == numCurves);			MyAssert(curvesToReintersect.size() == numCurves);						int curveIndex = (controlPointIndex + (numCurves + i)) % numCurves;			MyAssert(curveIndex >= 0 && curveIndex < numCurves);			curvesToRecalc[curveIndex] = true;						curveIndex = (controlPointIndex + (numCurves + i)) % numCurves;			MyAssert(curveIndex >= 0 && curveIndex < numCurves);			curvesToReintersect[curveIndex] = true;		}				//еее DEBUG		for (int i = 0; i < controlPoints.size(); i++)		{			recalcArray[i] = curvesToRecalc[i];			reinterArray[i] = curvesToReintersect[i];		}		delete [] recalcArray;		delete [] reinterArray;				RecalcBSpline();	}		//Update the locations of BspCutT intersections	for (int i = 0; i < allIntersections.size(); i++)		if (allIntersections[i]->GetType() == GenericIntersection::BSP_CUT_T)			((BspCutTIntersection*)allIntersections[i])->RecalcStartEndLocs();		return (windingNumber != oldWindingNum);}void BSpline::RemoveControlPoint(int controlPointIndex, bool removeAllPoints){	VerifyNumSectionsMatchesNumInters();	VerifyTotalIntersMatchesCurveInters();		for (int i = 0; i < allIntersections.size(); i++)		MyAssert(!allIntersections[i]->GetDtored());		BackupCurvePoints();		if (removeAllPoints)	{		Destroy();		return;	}		vector<FloatPoint>::iterator i = controlPoints.begin();	vector<vector<FloatPoint>*>::iterator j = curvePoints.begin();	vector<vector<GenericIntersection*>*>::iterator n = curveIntersections.begin();	vector<bool>::iterator k = curvesToRecalc.begin();	vector<bool>::iterator m = curvesToReintersect.begin();		for (int a = 0; a < controlPointIndex; a++)	{		i++;		j++;		n++;		k++;		m++;	}		controlPoints.erase(i);	delete *j;	curvePoints.erase(j);		if (controlPoints.size() >= 3)	{		//еее DEBUG		bool* recalcArray1 = new bool[controlPoints.size()];		bool* reinterArray1 = new bool[controlPoints.size()];		for (int i = 0; i < controlPoints.size(); i++)		{			recalcArray1[i] = curvesToRecalc[i];			reinterArray1[i] = curvesToReintersect[i];		}				for (int i = 0; i >= -degree; i--)		{			curvesToRecalc[(controlPointIndex + (curvesToRecalc.size() + i)) % curvesToRecalc.size()] = true;			curvesToReintersect[(controlPointIndex + (curvesToReintersect.size() + i)) % curvesToReintersect.size()] = true;		}		//MyAssert(curvesToRecalc.size() == curvesToReintersect.size());		//for (int i = 0; i < curvesToReintersect.size(); i++)		//	curvesToRecalc[i] = curvesToReintersect[i] = true;				//еее DEBUG		for (int i = 0; i < controlPoints.size(); i++)		{			recalcArray1[i] = curvesToRecalc[i];			reinterArray1[i] = curvesToReintersect[i];		}		delete [] recalcArray1;		delete [] reinterArray1;				for (int i = 0; i < curvesToReintersect.size(); i++)			if (curvesToReintersect[i])			{				//for (vector<GenericIntersection*>::iterator it = curveIntersections[i]->begin(); it != curveIntersections[i]->end(); it++)				int stopCount = 0;				vector<BspCutTIntersection*> bspCutTsAlteredAlready;				while (curveIntersections[i]->size() > stopCount)				{					vector<GenericIntersection*>::iterator it = curveIntersections[i]->begin();										if ((*it)->SelfIntersection())					{						BspBspIntersection* bspBspInter = (BspBspIntersection*)(*it);						MyAssert(bspBspInter->GetCv1() == i || bspBspInter->GetCv2() == i);						int otherCurve = (bspBspInter->GetCv1() == i) ? bspBspInter->GetCv2() : bspBspInter->GetCv1();						bool foundIt = false;						for (vector<GenericIntersection*>::iterator kt = curveIntersections[otherCurve]->begin();								kt != curveIntersections[otherCurve]->end(); kt++)							if (*kt == *it)							{								curveIntersections[otherCurve]->erase(kt);								foundIt = true;								break;							}						MyAssert(foundIt);					}										switch ((*it)->GetType())					{						case GenericIntersection::BSP_BSP:							BspBspIntersection* bspBspInter1 = (BspBspIntersection*)(*it);	//еее							((BspBspIntersection*)(*it))->SetNullBsp(this);							break;						case GenericIntersection::BSP_CUT:							BspCutIntersection* bspCutInter1 = (BspCutIntersection*)(*it);	//еее							((BspCutIntersection*)(*it))->SetNullBsp();							break;						case GenericIntersection::BSP_CUT_T:							//BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)(*it);	//еее							//((BspCutTIntersection*)(*it))->SetNullBsp();							//if (i == controlPointIndex)	//Might depend on degree							if (find((*n)->begin(), (*n)->end(), *it) != (*n)->end() &&								find(bspCutTsAlteredAlready.begin(), bspCutTsAlteredAlready.end(), *it) == bspCutTsAlteredAlready.end())							{								int ii = i;	//еее								MyAssert(find ((*n)->begin(), (*n)->end(), *it) != (*n)->end());								MyAssert(((BspCutTIntersection*)(*it))->GetCv() == i);								((BspCutTIntersection*)(*it))->DecreaseCurve();								bspCutTsAlteredAlready.push_back((BspCutTIntersection*)(*it));							}							break;					}										if ((*it)->GetType() != GenericIntersection::BSP_CUT_T)					{						delete *it;						curveIntersections[i]->erase(it);					}					else stopCount++;				}			}	}		delete *n;	curveIntersections.erase(n);		curvesToRecalc.erase(k);		curvesToReintersect.erase(m);		if (controlPoints.size() < 3)	//If there are fewer than 3 points remaining, destroy all intersections	{		for (int i = 0; i < curveIntersections.size(); i++)		{			for (vector<GenericIntersection*>::iterator j = curveIntersections[i]->begin(); j != curveIntersections[i]->end(); j++)			{				if ((*j)->SelfIntersection())				{					BspBspIntersection* bspBspInter = (BspBspIntersection*)(*j);					MyAssert(bspBspInter->GetCv1() == controlPointIndex || bspBspInter->GetCv2() == controlPointIndex);					int otherCurve;					if (bspBspInter->GetCv1() == controlPointIndex)						otherCurve = bspBspInter->GetCv2();					else otherCurve = bspBspInter->GetCv1();					for (vector<GenericIntersection*>::iterator k = curveIntersections[otherCurve]->begin();							k != curveIntersections[otherCurve]->end(); k++)						if (*k == *j)						{							curveIntersections[otherCurve]->erase(k);							break;						}				}								switch ((*j)->GetType())				{					case GenericIntersection::BSP_BSP:						((BspBspIntersection*)(*j))->SetNullBsp(this);						break;					case GenericIntersection::BSP_CUT:						((BspCutIntersection*)(*j))->SetNullBsp();						break;					case GenericIntersection::BSP_CUT_T:						((BspCutTIntersection*)(*j))->SetNullBsp();						break;				}								delete *j;			}			curveIntersections[i]->clear();		}	}	else	{		for (int i = controlPointIndex; i < curveIntersections.size(); i++)			for (vector<GenericIntersection*>::iterator j = curveIntersections[i]->begin(); j != curveIntersections[i]->end(); j++)			{				switch ((*j)->GetType())				{					case GenericIntersection::BSP_BSP:						((BspBspIntersection*)(*j))->DecreaseCurve(this, i + 1);						break;					case GenericIntersection::BSP_CUT:						((BspCutIntersection*)(*j))->DecreaseCurve();						break;					case GenericIntersection::BSP_CUT_T:						((BspCutTIntersection*)(*j))->DecreaseCurve();						break;				}			}				//еее DEBUG		bool* recalcArray = new bool[controlPoints.size()];		bool* reinterArray = new bool[controlPoints.size()];		for (int i = 0; i < controlPoints.size(); i++)		{			recalcArray[i] = curvesToRecalc[i];			reinterArray[i] = curvesToReintersect[i];		}				for (int i = /*0*/-1; i >= -degree; i--)		{			curvesToRecalc[(controlPointIndex + (curvesToRecalc.size() + i)) % curvesToRecalc.size()] = true;			curvesToReintersect[(controlPointIndex + (curvesToReintersect.size() + i)) % curvesToReintersect.size()] = true;		}		//MyAssert(curvesToRecalc.size() == curvesToReintersect.size());		//for (int i = 0; i < curvesToReintersect.size(); i++)		//	curvesToRecalc[i] = curvesToReintersect[i] = true;				//еее DEBUG		for (int i = 0; i < controlPoints.size(); i++)		{			recalcArray[i] = curvesToRecalc[i];			reinterArray[i] = curvesToReintersect[i];		}		delete [] recalcArray;		delete [] reinterArray;	}		intersectionCurveSegments.resize(controlPoints.size() * sNumSegmentsPerCurve);		RecalcBSpline();		if (MakeIntersectionList())		EqualizeNumberOfSections();		//Update the locations of BspCutT intersections	for (int i = 0; i < allIntersections.size(); i++)		if (allIntersections[i]->GetType() == GenericIntersection::BSP_CUT_T)			((BspCutTIntersection*)allIntersections[i])->RecalcStartEndLocs();		VerifyNumSectionsMatchesNumInters();}void BSpline::PushPullBSpline(int depthChange){	if (depthChange == 0)		return;		for (int i = 0; i < sectionDepths.size(); i++)		sectionDepths[i] += depthChange;}void BSpline::WrapSectionDepths(bool forward){	if (forward)	{		int sectionDepth = sectionDepths[sectionDepths.size() - 1];		for (int i = sectionDepths.size() - 1; i > 0; i--)			sectionDepths[i] = sectionDepths[i - 1];		sectionDepths[0] = sectionDepth;	}	else	{		int sectionDepth = sectionDepths[0];		for (int i = 0; i < sectionDepths.size() - 1; i++)			sectionDepths[i] = sectionDepths[i + 1];		sectionDepths[sectionDepths.size() - 1] = sectionDepth;	}}void BSpline::SetSectionDepthBeforeIntersection(GenericIntersection* intersection, int curve, int seg, int depth){	int intersectionIndex = GetIntersectionIndex(intersection, IntersectionIsFirstOccurance(intersection, curve, seg));	intersectionIndex = (intersectionIndex + (sectionDepths.size() - 1)) % sectionDepths.size();		sectionDepths[intersectionIndex] = depth;}void BSpline::SetSectionDepthAfterIntersection(GenericIntersection* intersection, int curve, int seg, int depth){	int intersectionIndex = GetIntersectionIndex(intersection, IntersectionIsFirstOccurance(intersection, curve, seg));		sectionDepths[intersectionIndex] = depth;}void BSpline::InitSectionMaxPossibleDepths(){	maxPossibleSectionDepths.resize(sectionDepths.size());	shallowestMaxPossibleSection = deepestMaxPossibleSection = -1;	for (int i = 0; i < maxPossibleSectionDepths.size(); i++)		maxPossibleSectionDepths[i] = 0;}void BSpline::PickShallowestAndDeepestMaxPossibleSection(){	int shallowestMaxPossibleSectionDepth = 999999, deepestMaxPossibleSectionDepth = -1;	shallowestMaxPossibleSection = deepestMaxPossibleSection = -1;	for (int i = 0; i < maxPossibleSectionDepths.size(); i++)	{		if (maxPossibleSectionDepths[i] < shallowestMaxPossibleSectionDepth)		{			shallowestMaxPossibleSectionDepth = maxPossibleSectionDepths[i];			shallowestMaxPossibleSection = i;		}		if (maxPossibleSectionDepths[i] > deepestMaxPossibleSectionDepth)		{			deepestMaxPossibleSectionDepth = maxPossibleSectionDepths[i];			deepestMaxPossibleSection = i;		}	}	MyAssert(shallowestMaxPossibleSection != -1 && deepestMaxPossibleSection != -1);}bool BSpline::IncrementMaxPossibleSectionDepthBeforeIntersection(GenericIntersection* intersection, int curve, int seg, int depth){	int intersectionIndex = GetIntersectionIndex(intersection, IntersectionIsFirstOccurance(intersection, curve, seg));	intersectionIndex = (intersectionIndex + (sectionDepths.size() - 1)) % sectionDepths.size();		if (depth > maxPossibleSectionDepths[intersectionIndex])	{		maxPossibleSectionDepths[intersectionIndex] = depth;		return true;	}		return false;}bool BSpline::IncrementMaxPossibleSectionDepthAfterIntersection(GenericIntersection* intersection, int curve, int seg, int depth){	int intersectionIndex = GetIntersectionIndex(intersection, IntersectionIsFirstOccurance(intersection, curve, seg));		if (depth > maxPossibleSectionDepths[intersectionIndex])	{		maxPossibleSectionDepths[intersectionIndex] = depth;		return true;	}		return false;}void BSpline::PushDoublyInwardBoundSectionsDownOne(){	//Loop through all the sections.  For any section that is inward bound at both ends by two different boundaries, push is max possible depth down by one.	int firstBspBspInterIndex = 0;	while (firstBspBspInterIndex < allIntersections.size() && allIntersections[firstBspBspInterIndex]->GetType() != GenericIntersection::BSP_BSP)		firstBspBspInterIndex++;		if (firstBspBspInterIndex == allIntersections.size())	//No BspBsp intersections		return;		int sectionStartInterIndex = firstBspBspInterIndex;	int sectionEndInterIndex = -1;		BspBspIntersection *sectionStartInter = (BspBspIntersection*)allIntersections[sectionStartInterIndex];	BspBspIntersection *sectionEndInter;	BSpline *startCrossBsp, *endCrossBsp;	bool startOnTop, endOnTop;	vector<BspBspIntersection*> intersectionsVisitedAlready;		//Find the starting cross bsp	if (!sectionStartInter->SelfIntersection())	{		startCrossBsp = sectionStartInter->GetOtherBsp(this);		startOnTop = (sectionStartInter->GetBsp1() == this);	}	else	//Self intersection	{		int cv1 = sectionStartInter->GetCv1();		int cv2 = sectionStartInter->GetCv2();		int sg1 = sectionStartInter->GetSg1();		int sg2 = sectionStartInter->GetSg2();				if (find(intersectionsVisitedAlready.begin(), intersectionsVisitedAlready.end(), sectionStartInter) == intersectionsVisitedAlready.end())		{			//Take the earlier occurance			if (cv1 < cv2)			{				startCrossBsp = sectionStartInter->GetBsp1();				startOnTop = true;			}			else if (cv2 < cv1)			{				startCrossBsp = sectionStartInter->GetBsp2();				startOnTop = false;			}			else if (sg1 < sg2)			{				startCrossBsp = sectionStartInter->GetBsp1();				startOnTop = true;			}			else			{				MyAssert(sg2 < sg1);				startCrossBsp = sectionStartInter->GetBsp2();				startOnTop = false;			}		}		else		{			//Take the later occurance			if (cv1 > cv2)			{				startCrossBsp = sectionStartInter->GetBsp1();				startOnTop = true;			}			else if (cv2 > cv1)			{				startCrossBsp = sectionStartInter->GetBsp2();				startOnTop = false;			}			else if (sg1 > sg2)			{				startCrossBsp = sectionStartInter->GetBsp1();				startOnTop = true;			}			else			{				MyAssert(sg2 > sg1);				startCrossBsp = sectionStartInter->GetBsp2();				startOnTop = false;			}		}		intersectionsVisitedAlready.push_back(sectionStartInter);	}		while (true)	{		//At the start of this loop, the sectionStartIndex is always set properly for the next section and the sectionEndIndex is always lagging one behind				//Find the sectionEndIndex		sectionEndInterIndex = (sectionStartInterIndex + 1) % allIntersections.size();		while (allIntersections[sectionEndInterIndex]->GetType() != GenericIntersection::BSP_BSP)			sectionEndInterIndex = (sectionEndInterIndex + 1) % allIntersections.size();				sectionStartInter = (BspBspIntersection*)allIntersections[sectionStartInterIndex];		sectionEndInter = (BspBspIntersection*)allIntersections[sectionEndInterIndex];				if (gDebug8)		{			Rect r;			FloatPoint intersectionLoc = sectionStartInter->GetLocation();			SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);			ForeColor(blueColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qy = 1;						SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);			ForeColor(whiteColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						qy = 1;		}				//Find the ending cross bsp		if (!sectionEndInter->SelfIntersection())		{			endCrossBsp = sectionEndInter->GetOtherBsp(this);			endOnTop = (sectionEndInter->GetBsp1() == this);		}		else	//Self intersection		{			int cv1 = sectionEndInter->GetCv1();			int cv2 = sectionEndInter->GetCv2();			int sg1 = sectionEndInter->GetSg1();			int sg2 = sectionEndInter->GetSg2();						if (find(intersectionsVisitedAlready.begin(), intersectionsVisitedAlready.end(), sectionEndInter) == intersectionsVisitedAlready.end())			{				//Take the earlier occurance				if (cv1 < cv2)				{					endCrossBsp = sectionEndInter->GetBsp1();					endOnTop = true;				}				else if (cv2 < cv1)				{					endCrossBsp = sectionEndInter->GetBsp2();					endOnTop = false;				}				else if (sg1 < sg2)				{					endCrossBsp = sectionEndInter->GetBsp1();					endOnTop = true;				}				else				{					MyAssert(sg2 < sg1);					endCrossBsp = sectionEndInter->GetBsp2();					endOnTop = false;				}			}			else			{				//Take the later occurance				if (cv1 > cv2)				{					endCrossBsp = sectionEndInter->GetBsp1();					endOnTop = true;				}				else if (cv2 > cv1)				{					endCrossBsp = sectionEndInter->GetBsp2();					endOnTop = false;				}				else if (sg1 > sg2)				{					endCrossBsp = sectionEndInter->GetBsp1();					endOnTop = true;				}				else				{					MyAssert(sg2 > sg1);					endCrossBsp = sectionEndInter->GetBsp2();					endOnTop = false;				}			}			intersectionsVisitedAlready.push_back(sectionEndInter);		}				//Only consider inward bounding if the bsps don't match		if (startCrossBsp != endCrossBsp)		{			//Determine if both intersections bound inward to the section			int startOccludedEdge = sectionStartInter->DetermineOccludedEdge();			int endOccludedEdge = sectionEndInter->DetermineOccludedEdge();			if ((startOccludedEdge == 3 && startOnTop) || (startOccludedEdge == 4 && !startOnTop))	//Start inwardly bounds			{				if ((endOccludedEdge == 4 && endOnTop) || (endOccludedEdge == 3 && !endOnTop))	//End inwardly bounds				{					//This section passed the test.  Push it down one.					maxPossibleSectionDepths[sectionStartInterIndex]++;										if (gDebug8)					{						Rect r;												FloatPoint intersectionLoc = sectionStartInter->GetLocation();						SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);						ForeColor(redColor);						FrameOval(&r);												intersectionLoc = sectionEndInter->GetLocation();						SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);						ForeColor(magentaColor);						FrameOval(&r);												QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qy = 1;												intersectionLoc = sectionStartInter->GetLocation();						SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);						ForeColor(whiteColor);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												intersectionLoc = sectionEndInter->GetLocation();						SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);						ForeColor(whiteColor);						FrameOval(&r);												qy = 1;					}				}			}		}				if (sectionEndInterIndex == firstBspBspInterIndex)			break;				//Update the start for the next section		sectionStartInterIndex = sectionEndInterIndex;		startCrossBsp = endCrossBsp;		startOnTop = endOnTop;	}}/*bool BSpline::IncrementMaxPossibleSectionDepthBeforeIntersectionV2(GenericIntersection* intersection, int curve, int seg, int depth, BSpline* stopCross){	bool changeMade = false;	while (true)	{		if (gDebug8)		{			Rect r;			FloatPoint intersectionLoc = intersection->GetLocation();			SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);			ForeColor(blueColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qy = 1;						SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);			ForeColor(whiteColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						qy = 1;		}				int intersectionIndex = GetIntersectionIndex(intersection, IntersectionIsFirstOccurance(intersection, curve, seg));		intersectionIndex = (intersectionIndex + (sectionDepths.size() - 1)) % sectionDepths.size();				if (depth > maxPossibleSectionDepths[intersectionIndex])		{			maxPossibleSectionDepths[intersectionIndex] = depth;			changeMade = true;		}				do		{			intersection = FindPrevIntersection(intersection, curve, seg);			if (!intersection->SelfIntersection())			{				switch (intersection->GetType())				{					case GenericIntersection::BSP_BSP:						if (((BspBspIntersection*)intersection)->GetBsp1() == this)						{							curve = ((BspBspIntersection*)intersection)->GetCv1();							seg = ((BspBspIntersection*)intersection)->GetSg1();						}						else						{							curve = ((BspBspIntersection*)intersection)->GetCv2();							seg = ((BspBspIntersection*)intersection)->GetSg2();						}						break;					case GenericIntersection::BSP_CUT:						curve = ((BspCutIntersection*)intersection)->GetCv();						seg = ((BspCutIntersection*)intersection)->GetSg();						break;					case GenericIntersection::BSP_CUT_T:						curve = ((BspCutTIntersection*)intersection)->GetCv();						seg = ((BspCutTIntersection*)intersection)->GetSg();						break;				}			}			else	//Self intersection			{				BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;								int curve1 = bspBspInter->GetCv1();				int curve2 = bspBspInter->GetCv2();				int seg1 = bspBspInter->GetSg1();				int seg2 = bspBspInter->GetSg2();								int curveSeg = curve * BSpline::sNumSegmentsPerCurve + seg;				int curveSeg1 = curve1 * BSpline::sNumSegmentsPerCurve + seg1;				int curveSeg2 = curve2 * BSpline::sNumSegmentsPerCurve + seg2;								//Take the curve/seg that is closer to and after the present curve/seg				if ((curveSeg1 > curveSeg && curveSeg2 > curveSeg) ||					(curveSeg1 < curveSeg && curveSeg2 < curveSeg))				{					if (curveSeg1 < curveSeg2)					{						curve = curve2;						seg = seg2;					}					else					{						curve = curve1;						seg = seg1;					}				}				if (curveSeg1 > curveSeg && curveSeg2 < curveSeg)				{					curve = curve2;					seg = seg2;				}				else if (curveSeg2 > curveSeg && curveSeg1 < curveSeg)				{					curve = curve1;					seg = seg1;				}				else if (curveSeg1 == curve)				{					MyAssert(curveSeg2 != curve);					MyAssert(0);					//double curveSeg1Dist = LineSegmentLength((*curvePoints[curve])[seg], bspBspInter);				}				else if (curveSeg2 == curve)				{					MyAssert(curveSeg1 != curve);					MyAssert(0);				}			}		} while (intersection->GetType() != GenericIntersection::BSP_BSP);				if (((BspBspIntersection*)intersection)->GetOtherBsp(this) == stopCross)		{			if (gDebug8)			{				Rect r;				FloatPoint intersectionLoc = intersection->GetLocation();				SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);				ForeColor(cyanColor);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qy = 1;								SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);				ForeColor(whiteColor);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								qy = 1;			}						break;		}	}		return changeMade;}bool BSpline::IncrementMaxPossibleSectionDepthAfterIntersectionV2(GenericIntersection* intersection, int curve, int seg, int depth, BSpline* stopCross){	bool changeMade = false;	while (true)	{		if (gDebug8)		{			Rect r;			FloatPoint intersectionLoc = intersection->GetLocation();			SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);			ForeColor(redColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qy = 1;						SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);			ForeColor(whiteColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						qy = 1;		}				int intersectionIndex = GetIntersectionIndex(intersection, IntersectionIsFirstOccurance(intersection, curve, seg));				if (depth > maxPossibleSectionDepths[intersectionIndex])		{			maxPossibleSectionDepths[intersectionIndex] = depth;			changeMade = true;		}				do		{			intersection = FindNextIntersection(intersection, curve, seg);			if (!intersection->SelfIntersection())			{				switch (intersection->GetType())				{					case GenericIntersection::BSP_BSP:						if (((BspBspIntersection*)intersection)->GetBsp1() == this)						{							curve = ((BspBspIntersection*)intersection)->GetCv1();							seg = ((BspBspIntersection*)intersection)->GetSg1();						}						else						{							curve = ((BspBspIntersection*)intersection)->GetCv2();							seg = ((BspBspIntersection*)intersection)->GetSg2();						}						break;					case GenericIntersection::BSP_CUT:						curve = ((BspCutIntersection*)intersection)->GetCv();						seg = ((BspCutIntersection*)intersection)->GetSg();						break;					case GenericIntersection::BSP_CUT_T:						curve = ((BspCutTIntersection*)intersection)->GetCv();						seg = ((BspCutTIntersection*)intersection)->GetSg();						break;				}			}			else	//Self intersection			{				BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;								int curve1 = bspBspInter->GetCv1();				int curve2 = bspBspInter->GetCv2();				int seg1 = bspBspInter->GetSg1();				int seg2 = bspBspInter->GetSg2();								int curveSeg = curve * BSpline::sNumSegmentsPerCurve + seg;				int curveSeg1 = curve1 * BSpline::sNumSegmentsPerCurve + seg1;				int curveSeg2 = curve2 * BSpline::sNumSegmentsPerCurve + seg2;								//Take the curve/seg that is closer to and after the present curve/seg				if ((curveSeg1 > curveSeg && curveSeg2 > curveSeg) ||					(curveSeg1 < curveSeg && curveSeg2 < curveSeg))				{					if (curveSeg1 < curveSeg2)					{						curve = curve2;						seg = seg2;					}					else					{						curve = curve1;						seg = seg1;					}				}				if (curveSeg1 > curveSeg && curveSeg2 < curveSeg)				{					curve = curve2;					seg = seg2;				}				else if (curveSeg2 > curveSeg && curveSeg1 < curveSeg)				{					curve = curve1;					seg = seg1;				}				else if (curveSeg1 == curve)				{					MyAssert(curveSeg2 != curve);					MyAssert(0);					//double curveSeg1Dist = LineSegmentLength((*curvePoints[curve])[seg], bspBspInter);				}				else if (curveSeg2 == curve)				{					MyAssert(curveSeg1 != curve);					MyAssert(0);				}			}		} while (intersection->GetType() != GenericIntersection::BSP_BSP);				if (((BspBspIntersection*)intersection)->GetOtherBsp(this) == stopCross)		{			if (gDebug8)			{				Rect r;				FloatPoint intersectionLoc = intersection->GetLocation();				SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);				ForeColor(magentaColor);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qy = 1;								SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);				ForeColor(whiteColor);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								qy = 1;			}						break;		}	}		return changeMade;}void BSpline::InitSectionsIncrementedAlready(){	//Speed this up in the future by putting the allocation in a different function and only calling it once		for (int i = 0; i < sectionsIncrementedAlready.size(); i++)		delete sectionsIncrementedAlready[i];		for (int i = 0; i < maxPossibleSectionDepths.size(); i++)	{		vector<BSpline*>* bsps = new vector<BSpline*>;		sectionsIncrementedAlready.push_back(bsps);	}}void BSpline::SetSectionIncrementedAlreadyBeforeIntersection(GenericIntersection* intersection, int curve, int seg){	int intersectionIndex = GetIntersectionIndex(intersection, IntersectionIsFirstOccurance(intersection, curve, seg));	intersectionIndex = (intersectionIndex + (sectionDepths.size() - 1)) % sectionDepths.size();		sectionsIncrementedAlready[intersectionIndex] = true;}void BSpline::SetSectionIncrementedAlreadyAfterIntersection(GenericIntersection* intersection, int curve, int seg){	int intersectionIndex = GetIntersectionIndex(intersection, IntersectionIsFirstOccurance(intersection, curve, seg));		sectionsIncrementedAlready[intersectionIndex] = true;}void BSpline::IncrementMaxPossibleSectionDepthBeforeIntersectionV3(int recursionDepth, GenericIntersection* intersection, int curve, int seg, BSpline* stopCross){	int intersectionIndex = GetIntersectionIndex(intersection, IntersectionIsFirstOccurance(intersection, curve, seg));	intersectionIndex = (intersectionIndex + (sectionDepths.size() - 1)) % sectionDepths.size();		if (gDebug8)	{		Rect r;		FloatPoint intersectionLoc = intersection->GetLocation();		SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);		if (!sectionsIncrementedAlready[intersectionIndex])			ForeColor(redColor);		else ForeColor(yellowColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qy = 1;				SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);		ForeColor(whiteColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				qy = 1;	}		if (sectionsIncrementedAlready[intersectionIndex])		return;	sectionsIncrementedAlready[intersectionIndex] = true;		maxPossibleSectionDepths[intersectionIndex]++;			if (gDebug8)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));		Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);				PenSize(1, 1);		Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		gDrawing->DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		PenSize(2, 2);				int qy = 1;	}		do	{		intersection = FindPrevIntersection(intersection, curve, seg);		if (!intersection->SelfIntersection())		{			switch (intersection->GetType())			{				case GenericIntersection::BSP_BSP:					if (((BspBspIntersection*)intersection)->GetBsp1() == this)					{						curve = ((BspBspIntersection*)intersection)->GetCv1();						seg = ((BspBspIntersection*)intersection)->GetSg1();					}					else					{						curve = ((BspBspIntersection*)intersection)->GetCv2();						seg = ((BspBspIntersection*)intersection)->GetSg2();					}					break;				case GenericIntersection::BSP_CUT:					curve = ((BspCutIntersection*)intersection)->GetCv();					seg = ((BspCutIntersection*)intersection)->GetSg();					break;				case GenericIntersection::BSP_CUT_T:					curve = ((BspCutTIntersection*)intersection)->GetCv();					seg = ((BspCutTIntersection*)intersection)->GetSg();					break;			}		}		else	//Self intersection		{			BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;						int curve1 = bspBspInter->GetCv1();			int curve2 = bspBspInter->GetCv2();			int seg1 = bspBspInter->GetSg1();			int seg2 = bspBspInter->GetSg2();						int curveSeg = curve * BSpline::sNumSegmentsPerCurve + seg;			int curveSeg1 = curve1 * BSpline::sNumSegmentsPerCurve + seg1;			int curveSeg2 = curve2 * BSpline::sNumSegmentsPerCurve + seg2;						//Take the curve/seg that is closer to and after the present curve/seg			if ((curveSeg1 > curveSeg && curveSeg2 > curveSeg) ||				(curveSeg1 < curveSeg && curveSeg2 < curveSeg))			{				if (curveSeg1 < curveSeg2)				{					curve = curve2;					seg = seg2;				}				else				{					curve = curve1;					seg = seg1;				}			}			if (curveSeg1 > curveSeg && curveSeg2 < curveSeg)			{				curve = curve2;				seg = seg2;			}			else if (curveSeg2 > curveSeg && curveSeg1 < curveSeg)			{				curve = curve1;				seg = seg1;			}			else if (curveSeg1 == curve)			{				MyAssert(curveSeg2 != curve);				MyAssert(0);				//double curveSeg1Dist = LineSegmentLength((*curvePoints[curve])[seg], bspBspInter);			}			else if (curveSeg2 == curve)			{				MyAssert(curveSeg1 != curve);				MyAssert(0);			}		}	} while (intersection->GetType() != GenericIntersection::BSP_BSP);		BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;		if (bspBspInter->GetOtherBsp(this) == stopCross)	{		if (gDebug8)		{			Rect r;			FloatPoint intersectionLoc = intersection->GetLocation();			SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);			ForeColor(magentaColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qy = 1;						SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);			ForeColor(whiteColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						qy = 1;		}		return;	}		bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthBeforeIntersection(recursionDepth + 1, bspBspInter, bspBspInter->GetCv1(), bspBspInter->GetSg1(), stopCross);	bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthAfterIntersection(recursionDepth + 1, bspBspInter, bspBspInter->GetCv1(), bspBspInter->GetSg1(), stopCross);	bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthBeforeIntersection(recursionDepth + 1, bspBspInter, bspBspInter->GetCv2(), bspBspInter->GetSg2(), stopCross);	bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthAfterIntersection(recursionDepth + 1, bspBspInter, bspBspInter->GetCv2(), bspBspInter->GetSg2(), stopCross);}void BSpline::IncrementMaxPossibleSectionDepthAfterIntersectionV3(int recursionDepth, GenericIntersection* intersection, int curve, int seg, BSpline* stopCross){	int intersectionIndex = GetIntersectionIndex(intersection, IntersectionIsFirstOccurance(intersection, curve, seg));		if (gDebug8)	{		Rect r;		FloatPoint intersectionLoc = intersection->GetLocation();		SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);		if (!sectionsIncrementedAlready[intersectionIndex])			ForeColor(blueColor);		else ForeColor(yellowColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qy = 1;				SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);		ForeColor(whiteColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				qy = 1;	}		if (sectionsIncrementedAlready[intersectionIndex])		return;	sectionsIncrementedAlready[intersectionIndex] = true;		maxPossibleSectionDepths[intersectionIndex]++;		if (gDebug8)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));		Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);				PenSize(1, 1);		Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		gDrawing->DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		PenSize(2, 2);				int qy = 1;	}		do	{		intersection = FindNextIntersection(intersection, curve, seg);		if (!intersection->SelfIntersection())		{			switch (intersection->GetType())			{				case GenericIntersection::BSP_BSP:					if (((BspBspIntersection*)intersection)->GetBsp1() == this)					{						curve = ((BspBspIntersection*)intersection)->GetCv1();						seg = ((BspBspIntersection*)intersection)->GetSg1();					}					else					{						curve = ((BspBspIntersection*)intersection)->GetCv2();						seg = ((BspBspIntersection*)intersection)->GetSg2();					}					break;				case GenericIntersection::BSP_CUT:					curve = ((BspCutIntersection*)intersection)->GetCv();					seg = ((BspCutIntersection*)intersection)->GetSg();					break;				case GenericIntersection::BSP_CUT_T:					curve = ((BspCutTIntersection*)intersection)->GetCv();					seg = ((BspCutTIntersection*)intersection)->GetSg();					break;			}		}		else	//Self intersection		{			BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;						int curve1 = bspBspInter->GetCv1();			int curve2 = bspBspInter->GetCv2();			int seg1 = bspBspInter->GetSg1();			int seg2 = bspBspInter->GetSg2();						int curveSeg = curve * BSpline::sNumSegmentsPerCurve + seg;			int curveSeg1 = curve1 * BSpline::sNumSegmentsPerCurve + seg1;			int curveSeg2 = curve2 * BSpline::sNumSegmentsPerCurve + seg2;						//Take the curve/seg that is closer to and after the present curve/seg			if ((curveSeg1 > curveSeg && curveSeg2 > curveSeg) ||				(curveSeg1 < curveSeg && curveSeg2 < curveSeg))			{				if (curveSeg1 < curveSeg2)				{					curve = curve2;					seg = seg2;				}				else				{					curve = curve1;					seg = seg1;				}			}			if (curveSeg1 > curveSeg && curveSeg2 < curveSeg)			{				curve = curve2;				seg = seg2;			}			else if (curveSeg2 > curveSeg && curveSeg1 < curveSeg)			{				curve = curve1;				seg = seg1;			}			else if (curveSeg1 == curve)			{				MyAssert(curveSeg2 != curve);				MyAssert(0);				//double curveSeg1Dist = LineSegmentLength((*curvePoints[curve])[seg], bspBspInter);			}			else if (curveSeg2 == curve)			{				MyAssert(curveSeg1 != curve);				MyAssert(0);			}		}	} while (intersection->GetType() != GenericIntersection::BSP_BSP);		BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;		if (bspBspInter->GetOtherBsp(this) == stopCross)	{		if (gDebug8)		{			Rect r;			FloatPoint intersectionLoc = intersection->GetLocation();			SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);			ForeColor(cyanColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qy = 1;						SetRect(&r, intersectionLoc.h - 8, intersectionLoc.v - 8, intersectionLoc.h + 8, intersectionLoc.v + 8);			ForeColor(whiteColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						qy = 1;		}		return;	}		bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthBeforeIntersection(recursionDepth + 1, bspBspInter, bspBspInter->GetCv1(), bspBspInter->GetSg1(), stopCross);	bspBspInter->GetBsp1()->IncrementMaxPossibleSectionDepthAfterIntersection(recursionDepth + 1, bspBspInter, bspBspInter->GetCv1(), bspBspInter->GetSg1(), stopCross);	bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthBeforeIntersection(recursionDepth + 1, bspBspInter, bspBspInter->GetCv2(), bspBspInter->GetSg2(), stopCross);	bspBspInter->GetBsp2()->IncrementMaxPossibleSectionDepthAfterIntersection(recursionDepth + 1, bspBspInter, bspBspInter->GetCv2(), bspBspInter->GetSg2(), stopCross);}		*/void BSpline::HalveSectionMaxPossibleDepths(){	for (int i = 0; i < maxPossibleSectionDepths.size(); i++)	{		MyAssert(maxPossibleSectionDepths[i] % 2 == 0);		maxPossibleSectionDepths[i] /= 2;	}}void BSpline::SetSectionDepthConstraintBeforeIntersection(GenericIntersection* intersection, int curve, int seg, bool value){	int sectionIndex = GetSectionBeforeIntersection(intersection, curve, seg);		sectionDepthConstraints[sectionIndex] = value;}void BSpline::SetSectionDepthConstraintAfterIntersection(GenericIntersection* intersection, int curve, int seg, bool value){	int sectionIndex = GetSectionAfterIntersection(intersection, curve, seg);		sectionDepthConstraints[sectionIndex] = value;}void BSpline::SetAllSectionsNoHardConstraint(){	for (int i = 0; i < sectionDepthConstraints.size(); i++)		sectionDepthConstraints[i] = false;}#pragma mark -void BSpline::VerifyBackupsMatchPresent(){	MyAssert(prevCurvePoints.size() == curvePoints.size());		for (int i = 0; i < curvePoints.size(); i++)	{		MyAssert(prevCurvePoints[i]->size() == curvePoints[i]->size());				for (int j = 0; j < (*curvePoints[i]).size(); j++)			MyAssert((*prevCurvePoints[i])[j] == (*curvePoints[i])[j]);	}}void BSpline::VerifyNothingDtored(){	MyAssert(!dtored);	for (int i = 0; i < allIntersections.size(); i++)		MyAssert(!allIntersections[i]->GetDtored());}void BSpline::BackupCurvePoints(){	while (prevCurvePoints.size() < curvePoints.size())	{		vector<FloatPoint> *pcp = new vector<FloatPoint>;		pcp->resize(sNumSegmentsPerCurve);		prevCurvePoints.push_back(pcp);	}	while (prevCurvePoints.size() > curvePoints.size())	{		delete prevCurvePoints.back();		prevCurvePoints.pop_back();	}		for (int i = 0; i < curvePoints.size(); i++)	{		MyAssert(prevCurvePoints[i]->size() == curvePoints[i]->size());				for (int j = 0; j < (*curvePoints[i]).size(); j++)			(*prevCurvePoints[i])[j] = (*curvePoints[i])[j];	}}void BSpline::RecalcBSpline(){	//Need at least three points to have a 2D object	if (controlPoints.size() < 3)		return;		//Recalc the BSpline points	int numControlPoints = controlPoints.size();	FloatPoint p1;	FloatPoint p2;	vector<FloatPoint>* cp;	double d;	for (int j = 0; j < numControlPoints; j++)		if (curvesToRecalc[j])		{			cp = curvePoints[j];			p1.h = -1;			for (int k = 0; k <= sNumSegmentsPerCurve; k++)			{				d = (double)k / sNumSegmentsPerCurve;				CalcBSplinePoint(d, j, numControlPoints, p2);								if (p1.h != -1)					(*cp)[k - 1] = p1;				p1 = p2;			}						curvesToRecalc[j] = false;		}		CalculateWindingNumber();}void BSpline::CalcBSplinePoint(double& d, int cp, int numControlPoints, FloatPoint& fp){	double* ad1 = new double[degree + 1];	double* ad2 = new double[degree + 1];		for (int k = 0; k <= degree; k++)	{		ad1[k] = controlPoints[(k + cp) % numControlPoints].h;		ad2[k] = controlPoints[(k + cp) % numControlPoints].v;	}		double degreePlusD = (double)degree + d;	for (int deg1 = 0; deg1 < degree; deg1++)		for (int deg2 = 0; deg2 < degree - deg1; deg2++)		{			ad1[deg2] = (ad1[deg2] *							((double)(deg2 + 1) - d) + ad1[deg2 + 1] *							(degreePlusD - 1.0 - deg1 - deg2)) /						(degree - deg1);			ad2[deg2] = (ad2[deg2] *							((double)(deg2 + 1) - d) + ad2[deg2 + 1] *							(degreePlusD - 1.0 - deg1 - deg2)) /						(degree - deg1);		}		fp.h = ad1[0];	fp.v = ad2[0];		delete [] ad1;	delete [] ad2;}	void BSpline::CalculateWindingNumber(){	windingNumber = 0;	double totalAngle = 0;	double prevAngle;		for (int i = 0; i < curvePoints.size(); i++)		for (int j = 0; j < sNumSegmentsPerCurve; j++)		{			FloatPoint pt1 = (*curvePoints[i])[j];			FloatPoint pt2;			if (j < sNumSegmentsPerCurve - 1)				pt2 = (*curvePoints[i])[j + 1];			else pt2 = (*curvePoints[(i + 1) % curvePoints.size()])[0];						double segAngle = LineSegmentAngle(pt1, pt2);			//double sa = segAngle * (360.0 / PiTimes2);						if (i == 0 && j == 0)			{				pt1 = (*curvePoints[curvePoints.size() - 1])[sNumSegmentsPerCurve - 1];				pt2 = (*curvePoints[0])[0];								prevAngle = LineSegmentAngle(pt1, pt2);			}						//double pa = prevAngle * (360.0 / PiTimes2);						double difAngle = segAngle - prevAngle;			if (difAngle > Pi)				difAngle -= PiTimes2;			else if (difAngle < -Pi)				difAngle += PiTimes2;						totalAngle += difAngle;						//double ta = totalAngle * (360.0 / PiTimes2);						prevAngle = segAngle;		}		double wn = totalAngle / PiTimes2;	//Push floating point numerical precision up a bit so the float to int truncation works properly	if (wn > 0)		wn += .1;	else wn -= .1;	windingNumber = wn;}//Not used ANYWHERE anymorevoid BSpline::CleanUpIntersections(vector<BSpline*> bsplines, vector<BSplineToBSplineCut*> cuts){	//Make a list of touched BSplines that includes BSplines that are about to become untouched when intersections are destroyed	vector<BSpline*> touchedBSplines;	for (vector<GenericIntersection*>::iterator i = allIntersections.begin(); i != allIntersections.end(); i++)	{		//Ignore nonBspBsp intersections		if ((*i)->GetType() != GenericIntersection::BSP_BSP)			continue;				if ((*i)->SelfIntersection())			continue;				BspBspIntersection* bspBspInter = (BspBspIntersection*)(*i);		BSpline* otherBSpline = bspBspInter->GetOtherBsp(this);		MyAssert(otherBSpline);		if (find(touchedBSplines.begin(), touchedBSplines.end(), otherBSpline) == touchedBSplines.end())			touchedBSplines.push_back(otherBSpline);	}		//Destroy old intersections	DestroyOldIntersections();		//Find new intersections	/*for (vector<BSpline*>::iterator i = bsplines.begin(); i != bsplines.end(); i++)		FindNewIntersections(*i);	for (vector<BSplineToBSplineCut*>::iterator i = cuts.begin(); i != cuts.end(); i++)		FindNewIntersections(*i);	*/		//takes group now FindAndAddNewIntersections(bsplines, cuts);		//Delete all cuts	/*bool foundOne = true;	while (foundOne)	{		foundOne = false;		for (vector<BSplineToBSplineCut*>::iterator i = cuts.begin(); i != cuts.end(); i++)			if ((*i)->GetBsp1() == this || (*i)->GetBsp2() == this)			{				drawing->RemoveCut(*i);	aslkdfjaklsj Not working quite yet				foundOne = true;				break;			}	}*/		//Add newly touched BSplines to the list of touched BSplines	for (vector<GenericIntersection*>::iterator i = allIntersections.begin(); i != allIntersections.end(); i++)	{		//Ignore nonBspBsp intersections		if ((*i)->GetType() != GenericIntersection::BSP_BSP)			return;		BspBspIntersection* bspBspInter = (BspBspIntersection*)(*i);				if ((*i)->SelfIntersection())			continue;				BSpline* otherBSpline = bspBspInter->GetOtherBsp(this);		MyAssert(otherBSpline);		if (find(touchedBSplines.begin(), touchedBSplines.end(), otherBSpline) == touchedBSplines.end())			touchedBSplines.push_back(otherBSpline);	}		//Equalize the number of sections on the touched BSplines	for (vector<BSpline*>::iterator i = touchedBSplines.begin(); i != touchedBSplines.end(); i++)		(*i)->EqualizeNumberOfSections();		SetAllCurvesToNotReintersect();		//Equalize the number of sections	EqualizeNumberOfSections();		//If any BSplines, including this one, go to a single section (no intersections), make them depth 0	/*if (allIntersections.size() == 0)		sectionDepths[0] = 0;	for (vector<BSpline*>::iterator i = touchedBSplines.begin(); i != touchedBSplines.end(); i++)		if ((*i)->allIntersections.size() == 0)		{			MyAssert((*i)->sectionDepths.size() > 0);						(*i)->sectionDepths[0] = 0;		}*/}#pragma mark -bool BSpline::ProjectIntersections(vector<GenericIntersection*>& alreadyProjectedInters, vector<BSpline*>& bsplineIntersDeleted, vector<BSplineToBSplineCut*>& cutIntersDeleted, bool dontProjectSelfInters, bool dontProjectAnyInters){	VerifyNumSectionsMatchesNumInters();		//еее	//Backups	vector<int> oldIntersCv1, oldIntersCv2, oldIntersSeg1, oldIntersSeg2;	vector<FloatPoint> oldIntersLoc;	for (int i = 0; i < allIntersections.size(); i++)	{		if (allIntersections[i]->GetType() == GenericIntersection::BSP_BSP)		{			BspBspIntersection* bspBspInter = (BspBspIntersection*)allIntersections[i];						oldIntersCv1.push_back(bspBspInter->GetCv1());			oldIntersCv2.push_back(bspBspInter->GetCv2());			oldIntersSeg1.push_back(bspBspInter->GetSg1());			oldIntersSeg2.push_back(bspBspInter->GetSg2());			oldIntersLoc.push_back(bspBspInter->GetLocation());		}		else		{			oldIntersCv1.push_back(-1);			oldIntersCv2.push_back(-1);			oldIntersSeg1.push_back(-1);			oldIntersSeg2.push_back(-1);			oldIntersLoc.push_back(allIntersections[i]->GetLocation());		}	}		vector<BSpline*> otherBSplines;	vector<GenericIntersection*> deleteIntersections;	vector<GenericIntersection*> intersAlreadyProjected;	vector<pair<GenericIntersection*, double> > distIntersMoved;		//еее	int* seg1s = new int[allIntersections.size()];	int* seg2s = new int[allIntersections.size()];	FloatPoint* a1Pres = new FloatPoint[allIntersections.size()];	FloatPoint* a2Pres = new FloatPoint[allIntersections.size()];	FloatPoint* b1s = new FloatPoint[allIntersections.size()];	FloatPoint* b2s = new FloatPoint[allIntersections.size()];		//еее	GenericIntersection** allInts = new GenericIntersection*[allIntersections.size()];	for (int iii = 0; iii < allIntersections.size(); iii++)		allInts[iii] = allIntersections[iii];		//Make a copy of the intersections before the intersection propagation	vector<GenericIntersection*> prevAllIntersections;	for (int i = 0; i < allIntersections.size(); i++)		prevAllIntersections.push_back(allIntersections[i]);		//Get a list of all the BSplines in this BSpline's group	vector<BSpline*> groupBSplines;	drawing->GetBSplinesInGroupFromBSpline(this, groupBSplines);		//Iterate through the intersections	for (int i = 0; i < allIntersections.size(); i++)	{		//Can't remember if copying allIntersections to a different list is serving some important purpose.		//Need to study this closely at some point.  Ugh.		GenericIntersection* intersection = allInts[i];//еееallIntersections[i];				//Don't project an intersection more than once		if (find(alreadyProjectedInters.begin(), alreadyProjectedInters.end(), intersection) != alreadyProjectedInters.end())			continue;				switch (intersection->GetType())		{			case GenericIntersection::BSP_BSP:				bool projectThisInter = true;				/*				//When dragging a bspline, we don't need to project inters with the same bspline.  However, we may need to project "self inters" with the whole object.				//This distinction is not properly made so I'm just editing this out.				if (dontProjectSelfInters)				{					BSpline* otherBsp = ((BspBspIntersection*)intersection)->GetOtherBsp(this);					if (find(groupBSplines.begin(), groupBSplines.end(), otherBsp) != groupBSplines.end())						projectThisInter = false;				}*/				if (projectThisInter && !dontProjectAnyInters)					ProjectBspBspIntersection(intersection, intersAlreadyProjected,												otherBSplines, deleteIntersections,												distIntersMoved);					break;			case GenericIntersection::BSP_CUT:				//Ignore intersection in which the Cut is attached to this BSpline.				//They will be taken care of in the next pass.				//BSplineToBSplineCut* cut = ((BspCutIntersection*)intersection)->GetCut();				//if (cut->GetBsp1() != this && cut->GetBsp2() != this)					ProjectBspCutIntersection(intersection, deleteIntersections,											distIntersMoved);					break;			case GenericIntersection::BSP_CUT_T:				ProjectBspCutTIntersection(intersection);					break;			case GenericIntersection::CUT_CUT:				MyAssert(false);					break;		}				alreadyProjectedInters.push_back(intersection);	//Will include deleted intersections, but that's okay	}	//End loop for all intersections		if (deleteIntersections.size() == 0)		MyAssert(allIntersections.size() == prevAllIntersections.size());		//If any intersections perfectly overlap, they represent an error that must be fixed.	//Intersections that should have been deleted were not because their vanishing was not detected higher up in this function.	if (distIntersMoved.size() >= 2)		for (int i = 0; i < distIntersMoved.size() - 1; i++)			for (int j = i + 1; j < distIntersMoved.size(); j++)				if (distIntersMoved[i].first->GetLocation() == distIntersMoved[j].first->GetLocation())				{					//Fix the error by deleting the intersection that moved further to get to the new location.					//This is ugly, there is no guarantee that this always deletes the right intersection.										if (distIntersMoved[i].second > distIntersMoved[j].second)						deleteIntersections.push_back(distIntersMoved[i].first);					else deleteIntersections.push_back(distIntersMoved[j].first);				}		for (int i = 0; i < allIntersections.size(); i++)		MyAssert(!allIntersections[i]->GetDtored());		//Delete any intersections that have vanished	bool intersectionsDeleted = false;	if (deleteIntersections.size() != 0)	{		for (vector<GenericIntersection*>::iterator i = deleteIntersections.begin(); i != deleteIntersections.end(); i++)		{			//Store the other BSpline at the intersection			if ((*i)->GetType() == GenericIntersection::BSP_BSP)				bsplineIntersDeleted.push_back(((BspBspIntersection*)(*i))->GetOtherBsp(this));			if ((*i)->GetType() == GenericIntersection::BSP_CUT)				cutIntersDeleted.push_back(((BspCutIntersection*)(*i))->GetCut());						delete *i;		}				for (int i = 0; i < cutIntersDeleted.size(); i++)			cutIntersDeleted[i]->ReweaveCut();				if (MakeIntersectionList())		{			for (int i = 0; i < allIntersections.size(); i++)				MyAssert(!allIntersections[i]->GetDtored());						EqualizeNumberOfSections();						for (int i = 0; i < allIntersections.size(); i++)				MyAssert(!allIntersections[i]->GetDtored());		}				for (vector<BSpline*>::iterator i = otherBSplines.begin(); i != otherBSplines.end(); i++)			if ((*i)->MakeIntersectionList())				(*i)->EqualizeNumberOfSections();				intersectionsDeleted = true;	}		/*	int totalIntersections = 0;	for (int i = 0; i < curveIntersections.size(); i++)		for (int j = 0; j < (*curveIntersections[i]).size(); j++)			totalIntersections++;	MyAssert(totalIntersections % 2 == 0);	*/	for (int i = 0; i < allIntersections.size(); i++)		MyAssert(!allIntersections[i]->GetDtored());		//MyAssert(allIntersections.size() % 2 == 0);		if (!intersectionsDeleted)		MyAssert(allIntersections.size() == prevAllIntersections.size());		MakeIntersectionList();		//Determine if the intersection order changed	bool segmentIntersectionReorder = false;	if (!intersectionsDeleted && (allIntersections.size() == prevAllIntersections.size()))		for (int i = 0; i < allIntersections.size(); i++)			if (allIntersections[i] != prevAllIntersections[i])				segmentIntersectionReorder = true;		if (allIntersections.size() != prevAllIntersections.size())		segmentIntersectionReorder = true;		//MyAssert(allIntersections.size() % 2 == 0);		for (vector<BSpline*>::iterator i = otherBSplines.begin(); i != otherBSplines.end(); i++)		if (*i != this)			(*i)->MakeIntersectionList();		for (int i = 0; i < allIntersections.size(); i++)		MyAssert(!allIntersections[i]->GetDtored());		for (int i = 0; i < allIntersections.size(); i++)	{		if (allIntersections[i]->GetType() != GenericIntersection::BSP_BSP)			continue;		((BspBspIntersection*)allIntersections[i])->TestForAdjacentSegments();	}		//Notify any BspCutT intersections to notify their cuts to update their start and end points	//Shouldn't be necessary, should've been handled in the BspCutT projection	//for (int i = 0; i < allIntersections.size(); i++)	//	if (allIntersections[i]->GetType() == GenericIntersection::BSP_CUT_T)	//		((BspCutTIntersection*)allIntersections[i])->RecalcStartEndLocs();		//еее	delete [] seg1s;	delete [] seg2s;	delete [] a1Pres;	delete [] a2Pres;	delete [] b1s;	delete [] b2s;	delete [] allInts;		if (!segmentIntersectionReorder)		VerifyNumSectionsMatchesNumInters();	VerifyTotalIntersMatchesCurveInters();		return (intersectionsDeleted || segmentIntersectionReorder);	//return intersectionsDeleted;}#pragma mark -void BSpline::ProjectBspBspIntersection(GenericIntersection* intersection, vector<GenericIntersection*>& intersAlreadyProjected,										vector<BSpline*>& otherBSplines, vector<GenericIntersection*>& deleteIntersections,										vector<pair<GenericIntersection*, double> >& distIntersMoved){		BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;		//Project self intersections only once	if (bspBspInter->SelfIntersection() &&		intersAlreadyProjected.size() > 0 &&		find(intersAlreadyProjected.begin(), intersAlreadyProjected.end(), intersection) != intersAlreadyProjected.end())		return;		int cv1bk = bspBspInter->GetCv1();	int cv2bk = bspBspInter->GetCv2();	int sg1bk = bspBspInter->GetSg1();	int sg2bk = bspBspInter->GetSg2();	FloatPoint oldLoc = bspBspInter->GetLocation();		//еее	bspBspInter->SetCurvesAndSegs(cv1bk, sg1bk, cv2bk, sg2bk);	bspBspInter->SetLocation(oldLoc);		FloatPoint newLoc;		//Get some necessary data about the intersection and the other BSpline	BSpline* otherBSpline = bspBspInter->GetOtherBsp(this);		if (find(otherBSplines.begin(), otherBSplines.end(), otherBSpline) == otherBSplines.end())		otherBSplines.push_back(otherBSpline);		vector<vector<FloatPoint>*>* otherBSplineCurvePoints = otherBSpline->GetCurvePoints();	vector<vector<FloatPoint>*>* otherBSplinePrevCurvePoints = otherBSpline->GetPrevCurvePoints();	int seg1, seg2;	int seg1old, seg2old;		FloatPoint pA1post, pA2post, pA1pre, pA2pre;	FloatPoint pB1post, pB2post, pB1pre, pB2pre;		if (GetIntersectionSegmentPoints(intersection, *otherBSplineCurvePoints, *otherBSplinePrevCurvePoints,										seg1, seg2, seg1old, seg2old,										pA1post, pA2post, pA1pre, pA2pre,										pB1post, pB2post, pB1pre, pB2pre))		intersAlreadyProjected.push_back((BspBspIntersection*)intersection);		//Test, make sure the starting line segments originally intersected	double lineSegInter1pre, lineSegInter2pre;	LineSegmentIntersection(pA1pre, pA2pre, pB1pre, pB2pre, newLoc, lineSegInter1pre, lineSegInter2pre);	if (!bspBspInter->SelfIntersection())		MyAssert(!(lineSegInter1pre < 0 || lineSegInter1pre > 1.0 || lineSegInter2pre < 0 || lineSegInter2pre > 1.0));		//Keep projecting the intersection until the new location is found	int curveEndWrap1 = 0, curveEndWrap2 = 0;	int movSearchDir = 0, statSearchDir = 0;	int numIts = 0;	bool noIntersectionFound = false;	while (true)	{		//Infinite loop check		if (numIts++ >= 100)		{			bspBspInter->SetCurvesAndSegs(cv1bk, sg1bk, cv2bk, sg2bk);			bspBspInter->SetLocation(oldLoc);			noIntersectionFound = true;			break;		}				//Test whether the two segments presently in question intersect		double lineSegInter1post, lineSegInter2post;		if (LineSegmentIntersection(pA1post, pA2post, pB1post, pB2post, newLoc, lineSegInter1post, lineSegInter2post))			//if (intersection->SelfIntersection() && lineSegInter1post > .01 && lineSegInter1post < .99 && lineSegInter2post > .01 && lineSegInter2post < .99)			{				//We're done, just update the intersection's position and end				bspBspInter->SetLocation(newLoc);								bspBspInter->TestForAdjacentSegments();								break;			}				//Getting here means the two segments don't intersect				//Determine the direction the intersection moves along each of the two objects from the original locations on the corresponding segments.		//Don't allow the intersection search to go the other direction past the original segment at any point in time.		if (numIts == 1)			if (DetermineSearchDirections(bspBspInter, newLoc,										pA1pre, pA2pre, pB1pre, pB2pre,										pA1post, pA2post, pB1post, pB2post,										lineSegInter1pre, lineSegInter2pre,										movSearchDir, statSearchDir))				noIntersectionFound = true;				if (noIntersectionFound)			break;				MyAssert(movSearchDir != 0 && statSearchDir != 0);				//Determine how far off the intersection is on both segments		double pAerror, pBerror;				if (lineSegInter1post < 0)			pAerror = fabs(lineSegInter1post);		else if (lineSegInter1post > 1.0)			pAerror = lineSegInter1post - 1;		else pAerror = 0;				if (lineSegInter2post < 0)			pBerror = fabs(lineSegInter2post);		else if (lineSegInter2post > 1.0)			pBerror = lineSegInter2post - 1;		else pBerror = 0;				MyAssert(pAerror != 0 || pBerror != 0);				int result;				if (pAerror > pBerror)	//Moving segment is more off the mark than the stationary segment		{			result = SwitchMovingSegments(intersection, lineSegInter1post,												cv1bk, sg1bk, cv2bk, sg2bk,												pA1pre, pA2pre, pA1post, pA2post,												seg1, seg2, noIntersectionFound, curveEndWrap1);			if (result == 0)				break;			else if (result == 1)				continue;		}				//Getting here means the two segments don't intersect and the moving segment is on the intersection		//which means the stationary segment must not be on the intersection, so change stationary segments		result = SwitchStationarySegments(intersection, otherBSpline, otherBSplineCurvePoints, lineSegInter2post,											cv1bk, sg1bk, cv2bk, sg2bk,											pB1pre, pB2pre, pB1post, pB2post,											seg1, seg2, noIntersectionFound, curveEndWrap2);		if (result == 0)			break;		else if (result == 1)			continue;				//Should be impossible to get here		MyAssert(false);	}	//End loop for one intersection		double distMoved = sqrt((newLoc.h - oldLoc.h) * (newLoc.h - oldLoc.h) + (newLoc.v - oldLoc.v) * (newLoc.v - oldLoc.v));		//еее Kind of a hack	if (!noIntersectionFound && distMoved > 300)	{		bspBspInter->SetCurvesAndSegs(cv1bk, sg1bk, cv2bk, sg2bk);		bspBspInter->SetLocation(oldLoc);		noIntersectionFound = true;	}		if (noIntersectionFound)	{		deleteIntersections.push_back(bspBspInter);				//Set the delete directions of the intersection to delete the section that "vanishes" as a result of the propagation		MyAssert(bspBspInter->GetBsp1() == this || bspBspInter->GetBsp2() == this);		if (bspBspInter->GetBsp1() == this)		{			bspBspInter->SetDeleteDir1((movSearchDir == -1) ? -1 : 0);			bspBspInter->SetDeleteDir2((statSearchDir == -1) ? -1 : 0);		}		else		{			bspBspInter->SetDeleteDir2((movSearchDir == -1) ? -1 : 0);			bspBspInter->SetDeleteDir1((statSearchDir == -1) ? -1 : 0);		}				return;	}		distIntersMoved.push_back(pair<GenericIntersection*, double>(bspBspInter, distMoved));		//Might need to change curves	ChangeCurves(intersection, otherBSpline,					seg1, seg2, seg1old, seg2old,					curveEndWrap1, curveEndWrap2);}bool BSpline::GetIntersectionSegmentPoints(GenericIntersection* intersection, vector<vector<FloatPoint>*>& otherBSplineCurvePoints, vector<vector<FloatPoint>*>& otherBSplinePrevCurvePoints,										int& seg1, int& seg2, int& seg1old, int& seg2old,										FloatPoint& pA1post, FloatPoint& pA2post, FloatPoint& pA1pre, FloatPoint& pA2pre,										FloatPoint& pB1post, FloatPoint& pB2post, FloatPoint& pB1pre, FloatPoint& pB2pre){	bool returnVal = false;		//Make seg1 correspond to this BSpline and seg2 the other BSpline	if (!intersection->SelfIntersection())	{		MyAssert(intersection->GetType() == GenericIntersection::BSP_BSP);		BspBspIntersection* bspBspInter = (BspBspIntersection*) intersection;				if (bspBspInter->GetBsp1() == this)		{			seg1 = bspBspInter->GetCv1() * sNumSegmentsPerCurve + bspBspInter->GetSg1();			seg2 = bspBspInter->GetCv2() * sNumSegmentsPerCurve + bspBspInter->GetSg2();		}		else		{			seg2 = bspBspInter->GetCv1() * sNumSegmentsPerCurve + bspBspInter->GetSg1();			seg1 = bspBspInter->GetCv2() * sNumSegmentsPerCurve + bspBspInter->GetSg2();		}	}	else	//Self intersection	{		seg1 = ((BspBspIntersection*)intersection)->GetCv1() * sNumSegmentsPerCurve + ((BspBspIntersection*)intersection)->GetSg1();		seg2 = ((BspBspIntersection*)intersection)->GetCv2() * sNumSegmentsPerCurve + ((BspBspIntersection*)intersection)->GetSg2();				returnVal = true;	}		seg1old = seg1;	seg2old = seg2;		//Get the endpoints of the moving segment	int cv, sg;		cv = seg1 / sNumSegmentsPerCurve;	sg = seg1 % sNumSegmentsPerCurve;	pA1post = (*curvePoints[cv])[sg];	cv = ((seg1 + 1) / sNumSegmentsPerCurve) % curvePoints.size();	sg = (seg1 + 1) % sNumSegmentsPerCurve;	pA2post = (*curvePoints[cv])[sg];		//Get the endpoints that were the moving segment before the move	cv = seg1 / sNumSegmentsPerCurve;	sg = seg1 % sNumSegmentsPerCurve;	MyAssert(cv < prevCurvePoints.size());	pA1pre = (*prevCurvePoints[cv])[sg];	cv = ((seg1 + 1) / sNumSegmentsPerCurve) % prevCurvePoints.size();	sg = (seg1 + 1) % sNumSegmentsPerCurve;	MyAssert(cv < prevCurvePoints.size());	pA2pre = (*prevCurvePoints[cv])[sg];		//Get the endpoints of the stationary segment (stationary isn't really correct in the case of self intersections and simultaneously moved groups of bsplines)	cv = seg2 / sNumSegmentsPerCurve;	sg = seg2 % sNumSegmentsPerCurve;	pB1post = (*otherBSplineCurvePoints[cv])[sg];	cv = ((seg2 + 1) / sNumSegmentsPerCurve) % otherBSplineCurvePoints.size();	sg = (seg2 + 1) % sNumSegmentsPerCurve;	pB2post = (*otherBSplineCurvePoints[cv])[sg];		if (intersection->SelfIntersection())	{		cv = seg2 / sNumSegmentsPerCurve;		sg = seg2 % sNumSegmentsPerCurve;		MyAssert(cv < prevCurvePoints.size());		pB1pre = (*prevCurvePoints[cv])[sg];		cv = ((seg2 + 1) / sNumSegmentsPerCurve) % prevCurvePoints.size();		sg = (seg2 + 1) % sNumSegmentsPerCurve;		MyAssert(cv < prevCurvePoints.size());		pB2pre = (*prevCurvePoints[cv])[sg];	}	else	{		//Use to do it this way, which assumed that stationary segment was truly stationary.		//This is often not true though since two intersecting BSplines may be moved simultaneously.		//pB1pre = pB1post;		//pB2pre = pB2post;				cv = seg2 / sNumSegmentsPerCurve;		sg = seg2 % sNumSegmentsPerCurve;		MyAssert(cv < otherBSplinePrevCurvePoints.size());		pB1pre = (*otherBSplinePrevCurvePoints[cv])[sg];		cv = ((seg2 + 1) / sNumSegmentsPerCurve) % otherBSplinePrevCurvePoints.size();		sg = (seg2 + 1) % sNumSegmentsPerCurve;		MyAssert(cv < otherBSplinePrevCurvePoints.size());		pB2pre = (*otherBSplinePrevCurvePoints[cv])[sg];	}		return returnVal;}bool BSpline::DetermineSearchDirections(GenericIntersection* intersection, FloatPoint newLoc,										FloatPoint pA1pre, FloatPoint pA2pre, FloatPoint pB1pre, FloatPoint pB2pre,										FloatPoint pA1post, FloatPoint pA2post, FloatPoint pB1post, FloatPoint pB2post,										double lineSegInter1pre, double lineSegInter2pre,										int& movSearchDir, int& statSearchDir){	bool noIntersectionFound = false;	FloatPoint pA1preProj, pA2preProj;	double projDistFrac = .000001;	double lineSegInter1preProj, lineSegInter2preProj;		if (!intersection->SelfIntersection())	{		MyAssert(LineSegmentIntersection(pA1pre, pA2pre, pB1pre, pB2pre, newLoc, lineSegInter1preProj, lineSegInter2preProj));		do		{			pA1preProj.h = pA1pre.h + (pA1post.h - pA1pre.h) * projDistFrac;			pA1preProj.v = pA1pre.v + (pA1post.v - pA1pre.v) * projDistFrac;			pA2preProj.h = pA2pre.h + (pA2post.h - pA2pre.h) * projDistFrac;			pA2preProj.v = pA2pre.v + (pA2post.v - pA2pre.v) * projDistFrac;						MyAssert(LineSegmentIntersection(pA1preProj, pA2preProj, pB1post, pB2post, newLoc, lineSegInter1preProj, lineSegInter2preProj));						projDistFrac *= 10.0;		} while (lineSegInter1preProj == lineSegInter1pre || lineSegInter2preProj == lineSegInter2pre);	}	else	//Self intersection	{		FloatPoint pB1preProj, pB2preProj;				MyAssert(LineSegmentIntersection(pA1pre, pA2pre, pB1pre, pB2pre, newLoc, lineSegInter1preProj, lineSegInter2preProj));		do		{			pA1preProj.h = pA1pre.h + (pA1post.h - pA1pre.h) * projDistFrac;			pA1preProj.v = pA1pre.v + (pA1post.v - pA1pre.v) * projDistFrac;			pA2preProj.h = pA2pre.h + (pA2post.h - pA2pre.h) * projDistFrac;			pA2preProj.v = pA2pre.v + (pA2post.v - pA2pre.v) * projDistFrac;						pB1preProj.h = pB1pre.h + (pB1post.h - pB1pre.h) * projDistFrac;			pB1preProj.v = pB1pre.v + (pB1post.v - pB1pre.v) * projDistFrac;			pB2preProj.h = pB2pre.h + (pB2post.h - pB2pre.h) * projDistFrac;			pB2preProj.v = pB2pre.v + (pB2post.v - pB2pre.v) * projDistFrac;						if (!LineSegmentIntersection(pA1preProj, pA2preProj, pB1preProj, pB2preProj, newLoc, lineSegInter1preProj, lineSegInter2preProj))			{				noIntersectionFound = true;				break;			}						projDistFrac *= 10.0;		} while (lineSegInter1preProj == lineSegInter1pre || lineSegInter2preProj == lineSegInter2pre);	}		movSearchDir = (lineSegInter1preProj > lineSegInter1pre ? 1 : -1);	statSearchDir = (lineSegInter2preProj > lineSegInter2pre ? 1 : -1);		return noIntersectionFound;}int BSpline::SwitchMovingSegments(GenericIntersection* intersection, double lineSegInter1post,									int cv1bk, int sg1bk, int cv2bk, int sg2bk,									FloatPoint& pA1pre, FloatPoint& pA2pre, FloatPoint& pA1post, FloatPoint& pA2post,									int& seg1, int seg2, bool& noIntersectionFound, int& curveEndWrap1){	//If the moving segment isn't on the intersection, switch segments on the moving object	if (lineSegInter1post < 0)	{		/*if (false)//movSearchDir == 1 && seg1 == seg1old)		{			//Segment searched has reversed on itself and is attempting to go back past the original segment in the opposite direction			bspBspInter->SetCurvesAndSegs(cv1bk, sg1bk, cv2bk, sg2bk);			bspBspInter->SetLocation(oldLoc);			noIntersectionFound = true;			break;		}*/				//Change moving segments		pA2pre = pA1pre;		pA2post = pA1post;				int prevSeg = seg1;		seg1--;		if (intersection->SelfIntersection() && (fabs(seg1 - seg2) <= 1 || fabs(seg1 - seg2) == sNumSegmentsPerCurve * curvePoints.size() - 1))		{			noIntersectionFound = true;			return 0;		}				if (seg1 < 0)		{			seg1 += curvePoints.size() * sNumSegmentsPerCurve;			curveEndWrap1 = -1;		}				int cv1 = seg1 / sNumSegmentsPerCurve;		int sg1 = seg1 % sNumSegmentsPerCurve;		MyAssert(cv1 < prevCurvePoints.size());		pA1pre = (*prevCurvePoints[cv1])[sg1];		MyAssert(cv1 < curvePoints.size());		pA1post = (*curvePoints[cv1])[sg1];				int cv = -1, sg = -1;		if (intersection->SelfIntersection())		{			cv = prevSeg / sNumSegmentsPerCurve;			sg = prevSeg % sNumSegmentsPerCurve;		}				MyAssert(intersection->GetType() == GenericIntersection::BSP_BSP);				((BspBspIntersection*)intersection)->DecreaseSeg(this, curvePoints.size(), cv, sg);							return 1;	}	else if (lineSegInter1post > 1.0)	{		/*if (false)//movSearchDir == -1 && seg1 == seg1old)		{			//Segment searched has reversed on itself and is attempting to go back past the original segment in the opposite direction			bspBspInter->SetCurvesAndSegs(cv1bk, sg1bk, cv2bk, sg2bk);			intersection->SetLocation(oldLoc);			noIntersectionFound = true;			break;		}*/				//Change moving segments		pA1pre = pA2pre;		pA1post = pA2post;				int prevSeg = seg1;		seg1++;		if (intersection->SelfIntersection() && (fabs(seg1 - seg2) <= 1 || fabs(seg1 - seg2) == sNumSegmentsPerCurve * curvePoints.size() - 1))		{			noIntersectionFound = true;			return 0;		}				if (seg1 >= curvePoints.size() * sNumSegmentsPerCurve)		{			seg1 -= curvePoints.size() * sNumSegmentsPerCurve;			curveEndWrap1 = 1;		}				int cv1 = ((seg1 + 1) / sNumSegmentsPerCurve) % prevCurvePoints.size();		int sg1 = (seg1 + 1) % sNumSegmentsPerCurve;		MyAssert(cv1 < prevCurvePoints.size());		pA2pre = (*prevCurvePoints[cv1])[sg1];		MyAssert(cv1 < curvePoints.size());		pA2post = (*curvePoints[cv1])[sg1];				int cv = -1, sg = -1;		if (intersection->SelfIntersection())		{			cv = prevSeg / sNumSegmentsPerCurve;			sg = prevSeg % sNumSegmentsPerCurve;		}				MyAssert(intersection->GetType() == GenericIntersection::BSP_BSP);		((BspBspIntersection*)intersection)->IncreaseSeg(this, curvePoints.size(), cv, sg);				return 1;	}		MyAssert(false);	//I think it's impossible to get here	return 2;}int BSpline::SwitchStationarySegments(GenericIntersection* intersection, BSpline* otherBSpline, vector<vector<FloatPoint>*>* otherBSplineCurvePoints, double lineSegInter2post,										int cv1bk, int sg1bk, int cv2bk, int sg2bk,										FloatPoint& pB1pre, FloatPoint& pB2pre, FloatPoint& pB1post, FloatPoint& pB2post,										int seg1, int& seg2, bool& noIntersectionFound, int& curveEndWrap2){	if (lineSegInter2post < 0)	{		/*if (false)//statSearchDir == 1 && seg2 == seg2old)		{			//Segment searched has reversed on itself and is attempting to go back past the original segment in the opposite direction			bspBspInter->SetCurvesAndSegs(cv1bk, sg1bk, cv2bk, sg2bk);			bspBspInter->SetLocation(oldLoc);			noIntersectionFound = true;			break;		}*/				//Change stationary segments		pB2pre = pB1pre;		pB2post = pB1post;				int prevSeg = seg2;		seg2--;		if (intersection->SelfIntersection() && (fabs(seg1 - seg2) <= 1 || fabs(seg1 - seg2) == sNumSegmentsPerCurve * curvePoints.size() - 1))		{			noIntersectionFound = true;			return 0;		}				if (seg2 < 0)		{			seg2 += otherBSplineCurvePoints->size() * sNumSegmentsPerCurve;			curveEndWrap2 = -1;		}				if (!intersection->SelfIntersection())		{			int cv1 = seg2 / sNumSegmentsPerCurve;			int sg1 = seg2 % sNumSegmentsPerCurve;			MyAssert(cv1 < otherBSplineCurvePoints->size());			MyAssert(sg1 < (*(*otherBSplineCurvePoints)[cv1]).size());						pB1pre = pB1post = (*(*otherBSplineCurvePoints)[cv1])[sg1];		}		else		{			int cv1 = seg2 / sNumSegmentsPerCurve;			int sg1 = seg2 % sNumSegmentsPerCurve;			MyAssert(cv1 < prevCurvePoints.size());			pB1pre = (*prevCurvePoints[cv1])[sg1];			MyAssert(cv1 < curvePoints.size());			pB1post = (*curvePoints[cv1])[sg1];		}				int cv = -1, sg = -1;		if (intersection->SelfIntersection())		{			cv = prevSeg / sNumSegmentsPerCurve;			sg = prevSeg % sNumSegmentsPerCurve;		}				MyAssert(intersection->GetType() == GenericIntersection::BSP_BSP);		((BspBspIntersection*)intersection)->DecreaseSeg(otherBSpline, otherBSplineCurvePoints->size(), cv, sg);				return 1;	}	else if (lineSegInter2post > 1.0)	{		/*if (false)//statSearchDir == -1 && seg2 == seg2old)		{			//Segment searched has reversed on itself and is attempting to go back past the original segment in the opposite direction			bspBspInter->SetCurvesAndSegs(cv1bk, sg1bk, cv2bk, sg2bk);			bspBspInter->SetLocation(oldLoc);			noIntersectionFound = true;			break;		}*/				//Change stationary segments		pB1pre = pB2pre;		pB1post = pB2post;				int prevSeg = seg2;		seg2++;		if (intersection->SelfIntersection() && (fabs(seg1 - seg2) <= 1 || fabs(seg1 - seg2) == sNumSegmentsPerCurve * curvePoints.size() - 1))		{			noIntersectionFound = true;			return 0;		}				if (seg2 >= otherBSplineCurvePoints->size() * sNumSegmentsPerCurve)		{			seg2 -= otherBSplineCurvePoints->size() * sNumSegmentsPerCurve;			curveEndWrap2 = 1;		}				int nextSeg2 = (seg2 + 1) % (otherBSplineCurvePoints->size() * sNumSegmentsPerCurve);				if (!intersection->SelfIntersection())		{			int cv1 = nextSeg2 / sNumSegmentsPerCurve;			int sg1 = nextSeg2 % sNumSegmentsPerCurve;			MyAssert(cv1 < otherBSplineCurvePoints->size());			MyAssert(sg1 < (*(*otherBSplineCurvePoints)[cv1]).size());						pB2pre = pB2post = (*(*otherBSplineCurvePoints)[cv1])[sg1];		}		else		{			int cv1 = nextSeg2 / sNumSegmentsPerCurve;			int sg1 = nextSeg2 % sNumSegmentsPerCurve;			MyAssert(cv1 < prevCurvePoints.size());			pB2pre = (*prevCurvePoints[cv1 % prevCurvePoints.size()])[sg1];			MyAssert(cv1 < curvePoints.size());			pB2post = (*curvePoints[cv1 % curvePoints.size()])[sg1];		}				int cv = -1, sg = -1;		if (intersection->SelfIntersection())		{			cv = prevSeg / sNumSegmentsPerCurve;			sg = prevSeg % sNumSegmentsPerCurve;		}				MyAssert(intersection->GetType() == GenericIntersection::BSP_BSP);		((BspBspIntersection*)intersection)->IncreaseSeg(otherBSpline, otherBSplineCurvePoints->size(), cv, sg);				return 1;	}		MyAssert(false);	//I think it's impossible to get here	return 2;}void BSpline::ChangeCurves(GenericIntersection* intersection, BSpline* otherBSpline,							int seg1, int seg2, int seg1old, int seg2old,							int curveEndWrap1, int curveEndWrap2){	VerifyNumSectionsMatchesNumInters();	otherBSpline->VerifyNumSectionsMatchesNumInters();	VerifyTotalIntersMatchesCurveInters();	otherBSpline->VerifyTotalIntersMatchesCurveInters();		if (seg1 / sNumSegmentsPerCurve != seg1old / sNumSegmentsPerCurve || seg1 != seg1old)	{		//MyAssert(seg1 / sNumSegmentsPerCurve == seg1old / sNumSegmentsPerCurve);		MoveIntersection(intersection, seg1old / sNumSegmentsPerCurve, seg1old % sNumSegmentsPerCurve, seg1 / sNumSegmentsPerCurve, seg1 % sNumSegmentsPerCurve, 1);				//Check for wrap around the ends		if (curveEndWrap1 == -1)			WrapSectionDepths(false);		else if (curveEndWrap1 == 1)			WrapSectionDepths(true);	}	else CheckSegmentIntersectionOrder(intersection);		if (seg2 / sNumSegmentsPerCurve != seg2old / sNumSegmentsPerCurve || seg2 != seg2old)	{		vector<int>* otherBSplineSectionDepths = otherBSpline->GetSectionDepths();		//еее		//int *dot = new int[ (*otherBSplineSectionDepths).size()];		//for (int i = 0; i <  (*otherBSplineSectionDepths).size(); i++)		//	dot[i] =  (*otherBSplineSectionDepths)[i];				otherBSpline->MoveIntersection(intersection, seg2old / sNumSegmentsPerCurve, seg2old % sNumSegmentsPerCurve, seg2 / sNumSegmentsPerCurve, seg2 % sNumSegmentsPerCurve, 2);				//Check for wrap around the ends		if (curveEndWrap2 == -1)			otherBSpline->WrapSectionDepths(false);		else if (curveEndWrap2 == 1)			otherBSpline->WrapSectionDepths(true);	}	else otherBSpline->CheckSegmentIntersectionOrder(intersection);		VerifyNumSectionsMatchesNumInters();	otherBSpline->VerifyNumSectionsMatchesNumInters();	VerifyTotalIntersMatchesCurveInters();	otherBSpline->VerifyTotalIntersMatchesCurveInters();}#pragma mark -void BSpline::ProjectBspCutIntersection(GenericIntersection* intersection, vector<GenericIntersection*>& deleteIntersections,										vector<pair<GenericIntersection*, double> >& distIntersMoved){	BspCutIntersection* bspCutInter = (BspCutIntersection*)intersection;		int cvbk = bspCutInter->GetCv();	int sgbk = bspCutInter->GetSg();	FloatPoint startLocPre = bspCutInter->GetCut()->GetPrevStart();	FloatPoint endLocPre = bspCutInter->GetCut()->GetPrevEnd();	FloatPoint startLocPost = bspCutInter->GetCut()->GetStart();	FloatPoint endLocPost = bspCutInter->GetCut()->GetEnd();	FloatPoint oldLoc = bspCutInter->GetLocation();		//еее	bspCutInter->SetCurveAndSeg(cvbk, sgbk);	bspCutInter->SetLocation(oldLoc);		FloatPoint newLoc;		int seg;	int segOld;		FloatPoint pA1post, pA2post, pA1pre, pA2pre;		GetIntersectionSegmentPoints(intersection, seg, segOld,								pA1post, pA2post, pA1pre, pA2pre);		//Test, make sure the starting line segments originally intersected	double lineSegInter1pre, lineSegInter2pre;	LineSegmentIntersection(pA1pre, pA2pre, startLocPre, endLocPre, newLoc, lineSegInter1pre, lineSegInter2pre);	MyAssert(!(lineSegInter1pre < 0 || lineSegInter1pre > 1.0 || lineSegInter2pre < 0 || lineSegInter2pre > 1.0));		//Keep projecting the intersection until the new location is found	int curveEndWrap = 0;	int movSearchDir = 0;	int numIts = 0;	bool noIntersectionFound = false;	while (true)	{		//Infinite loop check		if (numIts++ >= 100)		{			bspCutInter->SetCurveAndSeg(cvbk, sgbk);			bspCutInter->SetLocation(oldLoc);			noIntersectionFound = true;			break;		}				//Test whether the segment presently in question intersects the cut		double lineSegInter1post, lineSegInter2post;		if (LineSegmentIntersection(pA1post, pA2post, startLocPost, endLocPost, newLoc, lineSegInter1post, lineSegInter2post))			//if (intersection->SelfIntersection() && lineSegInter1post > .01 && lineSegInter1post < .99 && lineSegInter2post > .01 && lineSegInter2post < .99)			{				//We're done, just update the intersection's position and end				bspCutInter->SetLocation(newLoc);				break;			}				//Getting here means the segment doesn't intersect the cut				//Determine the direction the intersection moves along the BSpline from the original location on the segment.		//Don't allow the intersection search to go the other direction past the original segment at any point in time.		if (numIts == 1)			if (DetermineSearchDirection(bspCutInter, newLoc,										pA1pre, pA2pre, pA1post, pA2post,										startLocPre, endLocPre, startLocPost, endLocPost,										lineSegInter1pre, lineSegInter2pre,										movSearchDir))				noIntersectionFound = true;				if (noIntersectionFound)			break;				MyAssert(movSearchDir != 0);				int result = SwitchMovingSegments(intersection, lineSegInter1post,											cvbk, sgbk, cvbk, sgbk,											pA1pre, pA2pre, pA1post, pA2post,											seg, noIntersectionFound, curveEndWrap);		if (result == 0)			break;		else if (result == 1)			continue;				//Intersection fell off the end of the cut (not entirely sure about the analysis here)		bspCutInter->SetCurveAndSeg(cvbk, sgbk);		bspCutInter->SetLocation(oldLoc);		noIntersectionFound = true;		break;	}	//End loop for one intersection		double distMoved = sqrt((newLoc.h - oldLoc.h) * (newLoc.h - oldLoc.h) + (newLoc.v - oldLoc.v) * (newLoc.v - oldLoc.v));		//еее Kind of a hack	if (!noIntersectionFound && distMoved > 300)	{		bspCutInter->SetCurveAndSeg(cvbk, sgbk);		bspCutInter->SetLocation(oldLoc);		noIntersectionFound = true;	}		if (noIntersectionFound)	{		deleteIntersections.push_back(bspCutInter);		return;	}		distIntersMoved.push_back(pair<GenericIntersection*, double>(bspCutInter, distMoved));		//Might need to change curves	ChangeCurves(intersection,					seg, segOld,					curveEndWrap);		//Make sure the resulting line segments actually do intersect	GetIntersectionSegmentPoints(intersection, seg, segOld,								pA1post, pA2post, pA1pre, pA2pre);		startLocPost = bspCutInter->GetCut()->GetStart();	endLocPost = bspCutInter->GetCut()->GetEnd();		double lineSegInter1post, lineSegInter2post;	MyAssert(LineSegmentIntersection(pA1post, pA2post, startLocPost, endLocPost, newLoc, lineSegInter1post, lineSegInter2post));}void BSpline::GetIntersectionSegmentPoints(GenericIntersection* intersection, int& seg, int& segOld,										FloatPoint& pA1post, FloatPoint& pA2post, FloatPoint& pA1pre, FloatPoint& pA2pre){	MyAssert(intersection->GetType() == GenericIntersection::BSP_CUT);		seg = ((BspCutIntersection*)intersection)->GetCv() * sNumSegmentsPerCurve + ((BspCutIntersection*)intersection)->GetSg();		segOld = seg;		//Get the endpoints of the moving segment	int cv, sg;	cv = seg / sNumSegmentsPerCurve;	sg = seg % sNumSegmentsPerCurve;	MyAssert(cv < curvePoints.size());	pA1post = (*curvePoints[cv])[sg];	cv = ((seg + 1) / sNumSegmentsPerCurve) % curvePoints.size();	sg = (seg + 1) % sNumSegmentsPerCurve;	MyAssert(cv < curvePoints.size());	pA2post = (*curvePoints[cv])[sg];		//Get the endpoints that were the moving segment before the move	cv = seg / sNumSegmentsPerCurve;	sg = seg % sNumSegmentsPerCurve;	MyAssert(cv < prevCurvePoints.size());	pA1pre = (*prevCurvePoints[cv])[sg];	cv = ((seg + 1) / sNumSegmentsPerCurve) % prevCurvePoints.size();	sg = (seg + 1) % sNumSegmentsPerCurve;	MyAssert(cv < prevCurvePoints.size());	pA2pre = (*prevCurvePoints[cv])[sg];}bool BSpline::DetermineSearchDirection(GenericIntersection* intersection, FloatPoint newLoc,										FloatPoint pA1pre, FloatPoint pA2pre, FloatPoint pA1post, FloatPoint pA2post, 										FloatPoint startLocPre, FloatPoint endLocPre, FloatPoint startLocPost, FloatPoint endLocPost,										double lineSegInter1pre, double lineSegInter2pre,										int& movSearchDir){	bool noIntersectionFound = false;	FloatPoint pA1preProj, pA2preProj;	FloatPoint startLocProj, endLocProj;	double projDistFrac = .000001;	double lineSegInter1preProj, lineSegInter2preProj;		MyAssert(LineSegmentIntersection(pA1pre, pA2pre, startLocPre, endLocPre, newLoc, lineSegInter1preProj, lineSegInter2preProj));	do	{		pA1preProj.h = pA1pre.h + (pA1post.h - pA1pre.h) * projDistFrac;		pA1preProj.v = pA1pre.v + (pA1post.v - pA1pre.v) * projDistFrac;		pA2preProj.h = pA2pre.h + (pA2post.h - pA2pre.h) * projDistFrac;		pA2preProj.v = pA2pre.v + (pA2post.v - pA2pre.v) * projDistFrac;				startLocProj.h = startLocPre.h + (startLocPost.h - startLocPre.h) * projDistFrac;		startLocProj.v = startLocPre.v + (startLocPost.v - startLocPre.v) * projDistFrac;		endLocProj.h = endLocPre.h + (endLocPost.h - endLocPre.h) * projDistFrac;		endLocProj.v = endLocPre.v + (endLocPost.v - endLocPre.v) * projDistFrac;				MyAssert(LineSegmentIntersection(pA1preProj, pA2preProj, startLocProj, endLocProj, newLoc, lineSegInter1preProj, lineSegInter2preProj));				projDistFrac *= 10.0;	} while (lineSegInter1preProj == lineSegInter1pre || lineSegInter2preProj == lineSegInter2pre);		movSearchDir = (lineSegInter1preProj > lineSegInter1pre ? 1 : -1);		return noIntersectionFound;}int BSpline::SwitchMovingSegments(GenericIntersection* intersection, double lineSegInter1post,									int cv1bk, int sg1bk, int cv2bk, int sg2bk,									FloatPoint& pA1pre, FloatPoint& pA2pre, FloatPoint& pA1post, FloatPoint& pA2post,									int& seg, bool& noIntersectionFound, int& curveEndWrap){	//If the moving segment isn't on the intersection, switch segments on the moving object	if (lineSegInter1post < 0)	{		/*if (false)//movSearchDir == 1 && seg1 == seg1old)		{			//Segment searched has reversed on itself and is attempting to go back past the original segment in the opposite direction			bspBspInter->SetCurvesAndSegs(cv1bk, sg1bk, cv2bk, sg2bk);			bspBspInter->SetLocation(oldLoc);			noIntersectionFound = true;			break;		}*/				//Change moving segments		pA2pre = pA1pre;		pA2post = pA1post;				int prevSeg = seg;		seg--;		if (seg < 0)		{			seg += curvePoints.size() * sNumSegmentsPerCurve;			curveEndWrap = -1;		}				int cv = seg / sNumSegmentsPerCurve;		int sg = seg % sNumSegmentsPerCurve;		MyAssert(cv < prevCurvePoints.size());		pA1pre = (*prevCurvePoints[cv])[sg];		MyAssert(cv < curvePoints.size());		pA1post = (*curvePoints[cv])[sg];				MyAssert(intersection->GetType() == GenericIntersection::BSP_CUT);				((BspCutIntersection*)intersection)->DecreaseSeg(curvePoints.size());							return 1;	}	else if (lineSegInter1post > 1.0)	{		/*if (false)//movSearchDir == -1 && seg == segold)		{			//Segment searched has reversed on itself and is attempting to go back past the original segment in the opposite direction			bspBspInter->SetCurvesAndSegs(cv1bk, sg1bk, cv2bk, sg2bk);			intersection->SetLocation(oldLoc);			noIntersectionFound = true;			break;		}*/				//Change moving segments		pA1pre = pA2pre;		pA1post = pA2post;				int prevSeg = seg;		seg++;		if (seg >= curvePoints.size() * sNumSegmentsPerCurve)		{			seg -= curvePoints.size() * sNumSegmentsPerCurve;			curveEndWrap = 1;		}				int cv = ((seg + 1) / sNumSegmentsPerCurve) % prevCurvePoints.size();		int sg = (seg + 1) % sNumSegmentsPerCurve;		MyAssert(cv < prevCurvePoints.size());		pA2pre = (*prevCurvePoints[cv])[sg];		cv = ((seg + 1) / sNumSegmentsPerCurve) % curvePoints.size();		sg = (seg + 1) % sNumSegmentsPerCurve;		MyAssert(cv < curvePoints.size());		pA2post = (*curvePoints[cv])[sg];				MyAssert(intersection->GetType() == GenericIntersection::BSP_CUT);		((BspCutIntersection*)intersection)->IncreaseSeg(curvePoints.size());				return 1;	}		//Similar versions of this function elsewhere in this file are used such that it is impossible to get to this point in the function.	//However, that is not true in this specific function's case.	return 2;}void BSpline::ChangeCurves(GenericIntersection* intersection,							int seg, int segOld,							int curveEndWrap){	if (seg / sNumSegmentsPerCurve != segOld / sNumSegmentsPerCurve || seg != segOld)	{		//MyAssert(seg / sNumSegmentsPerCurve == segold / sNumSegmentsPerCurve);		MoveIntersection(intersection, segOld / sNumSegmentsPerCurve, segOld % sNumSegmentsPerCurve, seg / sNumSegmentsPerCurve, seg % sNumSegmentsPerCurve, 1);				//Check for wrap around the ends		if (curveEndWrap == -1)			WrapSectionDepths(false);		else if (curveEndWrap == 1)			WrapSectionDepths(true);	}	else CheckSegmentIntersectionOrder(intersection);}#pragma mark -void BSpline::ProjectBspCutTIntersection(GenericIntersection* intersection){	//Projecting BspCutT intersections is easy.	//Since BspCutT intersections move with the BSpline they don't change segments and therefore	//only need to have their endpoint locations updated when the relevant segments move.  That's it.	//Well, additionally, it is polite to update infinite BspCutTs in tandem with BSpline BspCutTs so the infinite cuts stay perfectly horizontal.		//((BspCutTIntersection*)intersection)->RecalcStartEndLocs();	//tells the associated cut to update its endpoints directly from the BSpline	((BspCutTIntersection*)intersection)->SetLocToCutStartOrEndLoc();	//sets the location of the intersection to the new position	((BspCutTIntersection*)intersection)->RecalcEdgeDirection();	//checks the new edge direction		//If the BspCutT is on an infinite cut, update the other end of the cut to keep the cut horizontal	BSplineToBSplineCut* cut = ((BspCutTIntersection*)intersection)->GetCut();	BSpline* otherBsp = (cut->GetBsp1() == this) ? cut->GetBsp2() : cut->GetBsp1();	if (!otherBsp)	{		MyAssert(cut->GetFirstIntersection() == intersection);		GenericIntersection* infiniteBspCutTinter = cut->GetLastIntersection();		MyAssert(!((BspCutTIntersection*)infiniteBspCutTinter)->GetBsp());		FloatPoint infiniteBspCutTloc = infiniteBspCutTinter->GetLocation();		MyAssert(infiniteBspCutTloc.h < -999998.0);		infiniteBspCutTloc.v = intersection->GetLocation().v;		infiniteBspCutTinter->SetLocation(infiniteBspCutTloc);				WholeObject* wholeObject = ((BspCutTIntersection*)infiniteBspCutTinter)->GetInfiniteWholeObject();		MyAssert(wholeObject);		MyAssert(wholeObject->bgDepths.size() > 0);		MyAssert(find(wholeObject->bspCutTinters.begin(), wholeObject->bspCutTinters.end(), infiniteBspCutTinter) != wholeObject->bspCutTinters.end());		drawing->SortWholeObjectInfiniteInters(wholeObject);	}}#pragma mark -bool BSpline::FindAndAddNewIntersections(vector<BSpline*> bsplines, vector<BSplineToBSplineCut*> cuts, vector<BSpline*> groupBSplines, bool forceToTop, bool cmdKey){	if (curvePoints.size() < 3)		return false;		VerifyNumSectionsMatchesNumInters();	VerifyTotalIntersMatchesCurveInters();		double intersectionMatchDiff = .00000001;	bool anyIntersectionsFound = false;		//еее DEBUG	bool ctri[100];	for (int i = 0; i < curvesToReintersect.size(); i++)		ctri[i] = curvesToReintersect[i];		vector<BSpline*> bsplinesToGroup;		//Find new intersections with BSplines	for (int bspCnt = 0; bspCnt != bsplines.size(); bspCnt++)	{		bool intersectionFound = false;				BSpline* bsp = bsplines[bspCnt];				//If the group was passed in, that means not to self check against the group		if (find(groupBSplines.begin(), groupBSplines.end(), bsp) != groupBSplines.end())			continue;				vector<vector<FloatPoint>*> *bspCurvePoints = bsp->GetCurvePoints();				if (bspCurvePoints->size() < 3)			continue;				FloatPoint intersectionLoc;		FloatPoint pA1, pA2, pB1, pB2;		//Iterate over this BSpline's curves		for (int i = 0; i < curvePoints.size(); i++)			if (curvesToReintersect[i])			{				//Iterate over one of this BSpline's curve's segments				for (int j = 0; j < sNumSegmentsPerCurve; j++)				{					pA1 = (*curvePoints[i])[j];					if (j == sNumSegmentsPerCurve - 1)						pA2 = (*curvePoints[(i + 1) % curvePoints.size()])[0];					else pA2 = (*curvePoints[i])[j + 1];										//Iterate over the other BSpline's curves					for (int ii = 0; ii < bspCurvePoints->size(); ii++)					{						if (bsp == this)						{							//Don't check a curve against another curve if the other curve was already checked							if (i > ii && curvesToReintersect[ii])								continue;						}												//Iterate over the other BSpline's curve's segments						for (int jj = 0; jj < sNumSegmentsPerCurve; jj++)						{							if (bsp == this)							{								//Don't check segments of the same curve against each other twice								if (ii == i && jj <= j + 1)									continue;															//Don't check segments against their neighbors in adjacent curves								if (ii == ((i - 1) + curvePoints.size()) % curvePoints.size() &&										j == 0 && jj == sNumSegmentsPerCurve - 1)									continue;								else if (ii == ((i + 1) + curvePoints.size()) % curvePoints.size() &&										j == sNumSegmentsPerCurve - 1 && jj == 0)									continue;							}														pB1 = (*(*bspCurvePoints)[ii])[jj];							if (jj == sNumSegmentsPerCurve - 1)								pB2 = (*(*bspCurvePoints)[(ii + 1) % bspCurvePoints->size()])[0];							else pB2 = (*(*bspCurvePoints)[ii])[jj + 1];														//Test whether the two line segments intersect							if (LineSegmentIntersection(pA1, pA2, pB1, pB2, intersectionLoc))							{								//Check the intersection against existing intersections.  Only add the intersection if it doesn't exist yet.								bool intersectionAlreadyExists = false;								for (vector<GenericIntersection*>::iterator iter = allIntersections.begin(); iter != allIntersections.end(); iter++)									if (fabs((*iter)->GetLocation().h - intersectionLoc.h) < intersectionMatchDiff &&										fabs((*iter)->GetLocation().v - intersectionLoc.v) < intersectionMatchDiff)									{										intersectionAlreadyExists = true;										break;									}																if (gDebug)								{									SetPort(GetWindowPort(gMainWindow->GetWindow()));																		Rect r;									SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);									ForeColor(redColor);									FrameOval(&r);									QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);																		int k = 1;								}																	if (!intersectionAlreadyExists)								{									int edgeDirection = LineCrossLineDirection(pA1, pA2, pB1, pB2);									MyAssert(edgeDirection != 0);									int thisBspDepth = GetArbitraryCurvePointDepth(i, j, intersectionLoc);									int otherBspDepth = bsp->GetArbitraryCurvePointDepth(ii, jj, intersectionLoc);									int otherBspWindingNumber = bsp->GetWindingNumber();																		bool thisBspOnTop;									if (windingNumber > otherBspWindingNumber)	//Higher winding number wins, assuming depth is not deeper than cross										thisBspOnTop = (thisBspDepth <= otherBspDepth);									else if (windingNumber < otherBspWindingNumber)	//Lower winding number loses, assuming depth is not shallower than cross										thisBspOnTop = (thisBspDepth < otherBspDepth);									else if (windingNumber == otherBspWindingNumber)	//Equal winding numbers require looking at the edge direction									{										if (edgeDirection == 1)	//Crossing an occluded edge loses, assuming depth is not shallower than cross											thisBspOnTop = (thisBspDepth < otherBspDepth);										else thisBspOnTop = (thisBspDepth <= otherBspDepth);	//Crossing a revealing edge wins, assuming depth is not deeper than cross									}																		if (forceToTop)										thisBspOnTop = true;																		BspBspIntersection* newIntersection;									if (thisBspOnTop)										newIntersection = new BspBspIntersection(drawing, intersectionLoc,												this, bsp, drawing->GetBSplineIndex(this), drawing->GetBSplineIndex(bsp), i, ii, j, jj);									else newIntersection = new BspBspIntersection(drawing, intersectionLoc,												bsp, this, drawing->GetBSplineIndex(bsp), drawing->GetBSplineIndex(this), ii, i, jj, j);																			MyAssert(!newIntersection->GetDtored());																		AddIntersection(i, j, (GenericIntersection*)newIntersection);									bsp->AddIntersection(ii, jj, (GenericIntersection*)newIntersection);									anyIntersectionsFound = intersectionFound = true;																		if (find(bsplinesToGroup.begin(), bsplinesToGroup.end(), this) == bsplinesToGroup.end())										bsplinesToGroup.push_back(this);									if (find(bsplinesToGroup.begin(), bsplinesToGroup.end(), bsp) == bsplinesToGroup.end())										bsplinesToGroup.push_back(bsp);								}							}						}					}				}			}				if (intersectionFound)		{			MakeIntersectionList();			bsp->MakeIntersectionList();			EqualizeNumberOfSections();			bsp->EqualizeNumberOfSections();		}	}		VerifyNumSectionsMatchesNumInters();	VerifyTotalIntersMatchesCurveInters();		//Find new intersections with Cuts	vector<BSplineToBSplineCut*> deleteCuts;	for (int cutCnt = 0; cutCnt < cuts.size(); cutCnt++)	{		bool intersectionFound = false;		BSplineToBSplineCut* cut = cuts[cutCnt];				//if (!cut->GetBsp2())		//	continue;				FloatPoint intersectionLoc;		FloatPoint pA1, pA2, startLoc, endLoc;				startLoc = cut->GetStart();		endLoc = cut->GetEnd();				//Iterate over this BSpline's curves		for (int i = 0; i < curvePoints.size(); i++)			if (curvesToReintersect[i])			{				//Iterate over one of this BSpline's curve's segments				for (int j = 0; j < sNumSegmentsPerCurve; j++)				{					pA1 = (*curvePoints[i])[j];					if (j == sNumSegmentsPerCurve - 1)						pA2 = (*curvePoints[(i + 1) % curvePoints.size()])[0];					else pA2 = (*curvePoints[i])[j + 1];										//Test whether the segment intersects the cut					if (LineSegmentIntersection(pA1, pA2, startLoc, endLoc, intersectionLoc))					{						//Check the intersection against existing intersections.  Only add the intersection if it doesn't exist yet.						bool intersectionAlreadyExists = false;						for (vector<GenericIntersection*>::iterator iter = allIntersections.begin(); iter != allIntersections.end(); iter++)							if (fabs((*iter)->GetLocation().h - intersectionLoc.h) < intersectionMatchDiff &&								fabs((*iter)->GetLocation().v - intersectionLoc.v) < intersectionMatchDiff)							{								intersectionAlreadyExists = true;								break;							}												if (gDebug)						{							SetPort(GetWindowPort(gMainWindow->GetWindow()));														Rect r;							SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);							ForeColor(greenColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int k = 1;						}													if (!intersectionAlreadyExists)						{														int edgeDirection = LineCrossLineDirection(startLoc, endLoc, pA1, pA2);							if (edgeDirection != 0)							{								//It is an open question as to whether the bsp should be on top when the depth of th bsp and the cut are equal.								//	IMPORTANT --- Which ever way this is done, keep it in sync with the same function in the other bspline/cut class.																//bool bspOnTop = (GetArbitraryCurvePointDepth(i, j, intersectionLoc) <= cut->GetArbitraryPointDepth(intersectionLoc));								bool bspOnTop = (GetArbitraryCurvePointDepth(i, j, intersectionLoc) < cut->GetArbitraryPointDepth(intersectionLoc));																BspCutIntersection* newIntersection = new BspCutIntersection(drawing, intersectionLoc,									this, cut, drawing->GetBSplineIndex(this), drawing->GetCutIndex(cut), i, j, bspOnTop, edgeDirection);																MyAssert(!newIntersection->GetDtored());																AddIntersection(i, j, (GenericIntersection*)newIntersection);								cut->AddIntersection((GenericIntersection*)newIntersection);								anyIntersectionsFound = intersectionFound = true;							}														//I can't remember why this is commented out.							//if (find(deleteCuts.begin(), deleteCuts.end(), cut) == deleteCuts.end())							//	deleteCuts.push_back(cut);						}					}				}			}				if (intersectionFound)		{			MakeIntersectionList();			EqualizeNumberOfSections();		}	}		if (!cmdKey)	{		/*		//I commented this out the code the fills up deleteCuts.  Can't remember why.  Nonetheless, the loop is useless as a result since deleteCuts is always empty.		for (int i = 0; i < deleteCuts.size(); i++)		{			if (find(bsplinesToGroup.begin(), bsplinesToGroup.end(), deleteCuts[i]->GetBsp1()) == bsplinesToGroup.end())				bsplinesToGroup.push_back(deleteCuts[i]->GetBsp1());			if (find(bsplinesToGroup.begin(), bsplinesToGroup.end(), deleteCuts[i]->GetBsp2()) == bsplinesToGroup.end())				bsplinesToGroup.push_back(deleteCuts[i]->GetBsp2());			drawing->RemoveCut(deleteCuts[i], true);		}		*/				//Commenting this out to reduce unnecessary deletion of cuts.  Not sure of the best approach yet.		//if (anyIntersectionsFound)		//	drawing->FindWholeObjects2(bsplinesToGroup);	}		VerifyNumSectionsMatchesNumInters();	VerifyTotalIntersMatchesCurveInters();		//еее	Once things are working more smoothly, this routine and its corresponding call in ChangeControlPoint() should be removed	SetAllCurvesToNotReintersect();		VerifyNumSectionsMatchesNumInters();	VerifyTotalIntersMatchesCurveInters();		return anyIntersectionsFound;}//return false if nothing to do, return true if number of sections is alteredbool BSpline::EqualizeNumberOfSections(){	for (int i = 0; i < allIntersections.size(); i++)		MyAssert(!allIntersections[i]->GetDtored());		int oldNumSections = sectionDepths.size();	int newNumSections = allIntersections.size();		if (oldNumSections == newNumSections)	{		VerifyNumSectionsMatchesNumInters();		VerifyTotalIntersMatchesCurveInters();		return false;	}		if (newNumSections > oldNumSections)		for (int i = oldNumSections; i < newNumSections; i++)		{			sectionDepths.push_back(0);			sectionDepthConstraints.push_back(false);		}	else if (newNumSections < oldNumSections)		for (int i = oldNumSections; i > newNumSections; i--)			if (sectionDepths.size() > 1)			{				sectionDepths.pop_back();				sectionDepthConstraints.pop_back();			}		for (int i = 0; i < allIntersections.size(); i++)		MyAssert(!allIntersections[i]->GetDtored());		VerifyNumSectionsMatchesNumInters();	VerifyTotalIntersMatchesCurveInters();		return true;}void BSpline::VerifyNumSectionsMatchesNumInters(){	if (allIntersections.size() == 0)		MyAssert(sectionDepths.size () == 1);	else MyAssert(allIntersections.size() == sectionDepths.size());}void BSpline::VerifyTotalIntersMatchesCurveInters(){	int totalIntersections = 0;	for (int i = 0; i < curveIntersections.size(); i++)		totalIntersections += curveIntersections[i]->size();	MyAssert(totalIntersections == allIntersections.size());}void BSpline::MakeAllDepthsZero(){	for (vector<int>::iterator i = sectionDepths.begin(); i != sectionDepths.end(); i++)		*i = 0;}void BSpline::DestroyOldIntersections(){	vector<GenericIntersection*> intersToDelete;		//For each curve that needs to be recalced	for (int i = 0; i < curvesToReintersect.size(); i++)	{		for (vector<GenericIntersection*>::iterator jj = curveIntersections[i]->begin(); jj != curveIntersections[i]->end(); jj++)			MyAssert(!(*jj)->GetDtored());				if (curvesToReintersect[i])			for (int j = 0; j < curveIntersections[i]->size(); j++)			{				GenericIntersection* intersection = (*curveIntersections[i])[j];								MyAssert(intersection->GetType() != GenericIntersection::CUT_CUT);								//Don't delete Bsp-Cut-T inters				if (intersection->GetType() != GenericIntersection::BSP_CUT_T)					intersToDelete.push_back(intersection);			}	}		//Remove doubles (self intersections) from the do-delete list	bool done = false;	while (!done)	{		done = true;		for (vector<GenericIntersection*>::iterator i = intersToDelete.begin(); i != intersToDelete.end(); i++)		{			for (vector<GenericIntersection*>::iterator j = i + 1; j != intersToDelete.end(); j++)				if (*i == *j)				{					intersToDelete.erase(j);					done = false;					break;				}			if (!done)				break;		}				}		for (int i = 0; i < intersToDelete.size(); i++)		delete intersToDelete[i];		MakeIntersectionList();		//Just temporary debugging stuff here	int totalIntersections = 0;	for (vector<vector<GenericIntersection*>*>::iterator i = curveIntersections.begin(); i != curveIntersections.end(); i++)		for (vector<GenericIntersection*>::iterator j = (*i)->begin(); j != (*i)->end(); j++)			totalIntersections++;	MyAssert(allIntersections.size() == totalIntersections);}void BSpline::FindNewIntersections(BSpline* bsp){	if (controlPoints.size() < 3)		return;		vector<vector<FloatPoint>*> *bspCurvePoints = bsp->GetCurvePoints();		if (bspCurvePoints->size() < 3)		return;		bool intersectionFound = false;		FloatPoint intersectionLoc;	FloatPoint pA1, pA2, pB1, pB2;	//Iterate over this BSpline's curves	for (int i = 0; i < curvePoints.size(); i++)	{		if (curvesToReintersect[i])		{			//Iterate over one of this BSpline's curve's segments			for (int j = 0; j < sNumSegmentsPerCurve; j++)			{				pA1 = (*curvePoints[i])[j];				if (j == sNumSegmentsPerCurve - 1)					pA2 = (*curvePoints[(i + 1) % curvePoints.size()])[0];				else pA2 = (*curvePoints[i])[j + 1];								//Iterate over the other BSpline's curves				for (int ii = 0; ii < bspCurvePoints->size(); ii++)				{					if (bsp == this)					{						//Don't check a curve against another curve if the other curve was already checked						if (i > ii && curvesToReintersect[ii])							continue;					}										//Iterate over the other BSpline's curve's segments					for (int jj = 0; jj < sNumSegmentsPerCurve; jj++)					{						if (bsp == this)						{							//Don't check segments of the same curve against each other twice							if (ii == i && jj <= j + 1)								continue;													//Don't check segments against their neighbors in adjacent curves							if (ii == ((i - 1) + curvePoints.size()) % curvePoints.size() &&									j == 0 && jj == sNumSegmentsPerCurve - 1)								continue;							else if (ii == ((i + 1) + curvePoints.size()) % curvePoints.size() &&									j == sNumSegmentsPerCurve - 1 && jj == 0)								continue;						}												pB1 = (*(*bspCurvePoints)[ii])[jj];						if (jj == sNumSegmentsPerCurve - 1)							pB2 = (*(*bspCurvePoints)[(ii + 1) % bspCurvePoints->size()])[0];						else pB2 = (*(*bspCurvePoints)[ii])[jj + 1];												if (LineSegmentIntersection(pA1, pA2, pB1, pB2, intersectionLoc))						{							BspBspIntersection* newIntersection = new BspBspIntersection(drawing, intersectionLoc,								this, bsp, drawing->GetBSplineIndex(this), drawing->GetBSplineIndex(bsp), i, ii, j, jj);							//curveIntersections[i]->push_back(newIntersection);														MyAssert(!newIntersection->GetDtored());														AddIntersection(i, j, (GenericIntersection*)newIntersection);							bsp->AddIntersection(ii, jj, (GenericIntersection*)newIntersection);							intersectionFound = true;						}					}				}			}		}				if (intersectionFound)		{			MakeIntersectionList();			bsp->MakeIntersectionList();			EqualizeNumberOfSections();			bsp->EqualizeNumberOfSections();		}	}}void BSpline::FindNewIntersections(BSplineToBSplineCut* cut){	if (controlPoints.size() < 3)		return;		double intersectionMatchDiff = .00000001;	bool intersectionFound = false;		FloatPoint intersectionLoc;	FloatPoint pA1, pA2, startLoc, endLoc;		startLoc = cut->GetStart();	endLoc = cut->GetEnd();		//Iterate over this BSpline's curves	for (int i = 0; i < curvePoints.size(); i++)		if (curvesToReintersect[i])		{			//Iterate over one of this BSpline's curve's segments			for (int j = 0; j < sNumSegmentsPerCurve; j++)			{				pA1 = (*curvePoints[i])[j];				if (j == sNumSegmentsPerCurve - 1)					pA2 = (*curvePoints[(i + 1) % curvePoints.size()])[0];				else pA2 = (*curvePoints[i])[j + 1];								//Test whether the segment intersects the cut				if (LineSegmentIntersection(pA1, pA2, startLoc, endLoc, intersectionLoc))				{					//Check the intersection against existing intersections.  Only add the intersection if it doesn't exist yet.					bool intersectionAlreadyExists = false;					for (vector<GenericIntersection*>::iterator iter = allIntersections.begin(); iter != allIntersections.end(); iter++)						if (fabs((*iter)->GetLocation().h - intersectionLoc.h) < intersectionMatchDiff &&							fabs((*iter)->GetLocation().v - intersectionLoc.v) < intersectionMatchDiff)						{							intersectionAlreadyExists = true;							break;						}											if (!intersectionAlreadyExists)					{						int edgeDirection = LineCrossLineDirection(startLoc, endLoc, pA1, pA2);						if (edgeDirection != 0)						{							bool bspOnTop = (GetArbitraryCurvePointDepth(i, j, intersectionLoc) <=											cut->GetArbitraryPointDepth(intersectionLoc));														BspCutIntersection* newIntersection = new BspCutIntersection(drawing, intersectionLoc,								this, cut, drawing->GetBSplineIndex(this), drawing->GetCutIndex(cut), i, j, bspOnTop, edgeDirection);														MyAssert(!newIntersection->GetDtored());														AddIntersection(i, j, (GenericIntersection*)newIntersection);							cut->AddIntersection((GenericIntersection*)newIntersection);							/*anyIntersectionsFound = NOT REALLY NECESSARY */intersectionFound = true;						}					}				}			}		}		if (intersectionFound)	{		MakeIntersectionList();		EqualizeNumberOfSections();	}}bool BSpline::MakeIntersectionList(){	//Count all the intersections.  Don't bother making a list if the count is odd	int totalIntersections = 0;	/*for (int i = 0; i < curveIntersections.size(); i++)		for (int j = 0; j < (*curveIntersections[i]).size(); j++)			totalIntersections++;	if (totalIntersections % 2 != 0)		return false;	*/	totalIntersections = 0;		//Calc the total number of segments in the BSpline	int totalCurveSegments = curveIntersections.size() * sNumSegmentsPerCurve;		//Keep track of which segments have intersections on them.	//Init this list to all false and accumulate such segments during the search.	for (int i = 0; i < totalCurveSegments; i++)		intersectionCurveSegments[i] = false;		//Make an ordered list of the intersections, identified by their curve segment index	allIntersections.clear();	int cvSgIdx;	for (int i = 0; i < curveIntersections.size(); i++)	//Loop over the curves	{		vector<BspBspIntersection*> intersVisitedAlready;				for (int j = 0; j < (*curveIntersections[i]).size(); j++)	//Loop over the segments of one curve		{			GenericIntersection* nextIntersection = (*curveIntersections[i])[j];			MyAssert(nextIntersection);						MyAssert(!nextIntersection->GetDtored());						allIntersections.push_back(nextIntersection);			totalIntersections++;						switch (nextIntersection->GetType())			{				case GenericIntersection::BSP_BSP:					BspBspIntersection* bspBspInter = (BspBspIntersection*)nextIntersection;										if (!bspBspInter->SelfIntersection())					{						if (bspBspInter->GetBsp1() == this)						{							MyAssert(bspBspInter->GetCv1() == i);							cvSgIdx = i * sNumSegmentsPerCurve + (bspBspInter->GetSg1());							intersectionCurveSegments[cvSgIdx] = true;						}						else						{							MyAssert(bspBspInter->GetCv2() == i);							MyAssert(bspBspInter->GetBsp2() == this);							cvSgIdx = i * sNumSegmentsPerCurve + (bspBspInter->GetSg2());							intersectionCurveSegments[cvSgIdx] = true;						}					}					else	//self intersection					{						if (bspBspInter->GetCv1() == i &&							find(intersVisitedAlready.begin(), intersVisitedAlready.end(), bspBspInter) == intersVisitedAlready.end())							cvSgIdx = i * sNumSegmentsPerCurve + (bspBspInter->GetSg1());						else						{							MyAssert(bspBspInter->GetCv2() == i);							cvSgIdx = i * sNumSegmentsPerCurve + (bspBspInter->GetSg2());						}						intersectionCurveSegments[cvSgIdx] = true;						intersVisitedAlready.push_back(bspBspInter);					}					break;				case GenericIntersection::BSP_CUT:					BspCutIntersection* bspCutInter = (BspCutIntersection*)nextIntersection;										MyAssert(bspCutInter->GetBsp() == this);										MyAssert(bspCutInter->GetCv() == i);					cvSgIdx = i * sNumSegmentsPerCurve + (bspCutInter->GetSg());					intersectionCurveSegments[cvSgIdx] = true;					break;				case GenericIntersection::BSP_CUT_T:					BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)nextIntersection;										MyAssert(bspCutTInter->GetBsp() == this);										MyAssert(bspCutTInter->GetCv() == i);					cvSgIdx = i * sNumSegmentsPerCurve + (bspCutTInter->GetSg());					intersectionCurveSegments[cvSgIdx] = true;					break;				case GenericIntersection::CUT_CUT:					MyAssert(false);					break;			}		}	}		MyAssert(allIntersections.size() == totalIntersections);	//MyAssert(allIntersections.size() % 2 == 0);		for (int i = 0; i < allIntersections.size(); i++)		MyAssert(!allIntersections[i]->GetDtored());		return true;}#pragma mark -void BSpline::DrawBSpline(MainWindow::ViewMode viewMode, Point scrollOffset, bool selected, bool hilighted, bool showDepths, bool exportingPict, bool debug){	VerifyNumSectionsMatchesNumInters();	VerifyTotalIntersMatchesCurveInters();		//MyAssert(allIntersections.size() % 2 == 0);		TextFont(FMGetFontFamilyFromName("\pHelvetica"));	TextFace(0);	TextSize(9);		if (viewMode == MainWindow::SPLINE_MODE || viewMode == MainWindow::KNOT_MODE)	{		if (!exportingPict)			DrawControlPointBoundary(scrollOffset, selected, hilighted, debug);		DrawInterpolatedCurves(scrollOffset, viewMode, showDepths, debug);		/*		if (viewMode == MainWindow::KNOT_MODE)		{			ForeColor(blackColor);						WriteSectionDepths(scrollOffset);		}		*/	}		//==============================================================	//Intersections	//Define whole object colors	/*if (0)//wholeObjectIndex != -1)	{		vector<GenericIntersection*> allReadyFoundInters;		Str255 str;		TextSize(14);		TextFace(bold);		for (int i = 0; i < allIntersections.size(); i++)		{			GenericIntersection* intersection = allIntersections[i];						if (intersection->SelfIntersection())			{					bool secondPass = (find(allReadyFoundInters.begin(), allReadyFoundInters.end(), intersection) != allReadyFoundInters.end());				allReadyFoundInters.push_back(intersection);								NumToString(i, str);								FloatPoint loc = intersection->GetLocation();				if (!secondPass)					MoveTo(loc.h, loc.v - 10);				else MoveTo(loc.h, loc.v + 25);								ForeColor(cyanColor);				DrawString(str);			}			else			{				NumToString(i, str);								FloatPoint loc = intersection->GetLocation();								if (intersection->GetBsp1() == this)					MoveTo(loc.h - 20, loc.v);				else MoveTo(loc.h + 10, loc.v);								ForeColor(magentaColor);				DrawString(str);			}		}		TextFace(0);		TextSize(9);	}*/	//==============================================================}void BSpline::DrawControlPointBoundary(Point scrollOffset, bool selected, bool hilighted, bool debug){	//Draw the boundary connecting the control points	if (controlPoints.size() > 1 && degree > 1)	{		if (!hilighted)		{			RGBForeColor(&gColors.boundary);		}		else		{			RGBColor boundaryInverted;			boundaryInverted.red = 65535 - gColors.boundary.red;			boundaryInverted.green = 65535 - gColors.boundary.green;			boundaryInverted.blue = 65535 - gColors.boundary.blue;			RGBForeColor(&boundaryInverted);		}				int thicknessOffset = 0;		if (selected && !debug)		{			PenSize(3, 3);			thicknessOffset = -1;		}				FloatPoint prevPoint;		for (vector<FloatPoint>::iterator i = controlPoints.begin(); i != controlPoints.end(); i++)		{			if (i != controlPoints.begin())			{				MoveTo(prevPoint.h + scrollOffset.h + thicknessOffset, prevPoint.v + scrollOffset.v + thicknessOffset);				LineTo((*i).h + scrollOffset.h, (*i).v + scrollOffset.v);			}			prevPoint = (*i);		}				MoveTo(prevPoint.h + scrollOffset.h + thicknessOffset, prevPoint.v + scrollOffset.v + thicknessOffset);		LineTo((*(controlPoints.begin())).h + scrollOffset.h, (*(controlPoints.begin())).v + scrollOffset.v);				if (!debug)			PenSize(1, 1);	}		//Draw the control points	RGBForeColor(&gColors.controlPoint);	Rect r;	int j = 0;	for (vector<FloatPoint>::iterator i = controlPoints.begin(); i != controlPoints.end(); i++)	{		SetRect(&r, (*i).h - gPointRadius, (*i).v - gPointRadius, (*i).h + gPointRadius, (*i).v + gPointRadius);		OffsetRect(&r, scrollOffset.h, scrollOffset.v);		PaintOval(&r);				if (selected)		{			SetRect(&r, (*i).h - (gPointRadius + 2), (*i).v - (gPointRadius + 2), (*i).h + (gPointRadius + 2), (*i).v + (gPointRadius + 2));			OffsetRect(&r, scrollOffset.h, scrollOffset.v);			FrameOval(&r);		}				/*		Str255 s;		NumToString(j++, s);		MoveTo((*i).h + 5 + scrollOffset.h, (*i).v + 5 + scrollOffset.v);		DrawString(s);		*/	}}void BSpline::DrawPostscriptBSpline(short fRefNum, MainWindow::ViewMode viewMode, Point canvasSize, bool showDepths){	if (viewMode == MainWindow::SPLINE_MODE)	{		MyAssert(false);	}	else if (viewMode == MainWindow::KNOT_MODE)	{		//Draw the boundary connecting the control points		//Not done in postscript				DrawPostscriptInterpolatedCurves(fRefNum, viewMode, canvasSize, showDepths);				//Draw the control points		//Not done in postscript	}}void BSpline::DrawInterpolatedCurves(Point scrollOffset, MainWindow::ViewMode viewMode, bool showDepths, bool debug){	if (controlPoints.size() < 3)		return;			for (int i = 0; i < curvesToRecalc.size(); i++)		MyAssert(!curvesToRecalc[i]);		if (viewMode == MainWindow::SPLINE_MODE)		DrawCurvesSplineMode(scrollOffset);	else if (viewMode == MainWindow::KNOT_MODE)	{		if (!debug)			DrawCurvesKnotMode(scrollOffset, showDepths);		else DrawCurvesKnotMode(scrollOffset, showDepths, true, true, true);	}}void BSpline::DrawPostscriptInterpolatedCurves(short fRefNum, MainWindow::ViewMode viewMode, Point canvasSize, bool showDepths){	if (controlPoints.size() < 3)		return;			for (int i = 0; i < curvesToRecalc.size(); i++)		MyAssert(!curvesToRecalc[i]);		if (viewMode == MainWindow::SPLINE_MODE)		{}//еее	Not implemented yet ------ DrawCurvesSplineMode(colorNotUsed, scrollOffset);	else if (viewMode == MainWindow::KNOT_MODE)		DrawPostscriptCurvesKnotMode(fRefNum, canvasSize, showDepths);}void BSpline::DrawCurvesSplineMode(Point scrollOffset){		//Make a list of the segments, denoting their depths	int totalCurveSegments = curveIntersections.size() * sNumSegmentsPerCurve;		MyAssert(intersectionCurveSegments.size() == totalCurveSegments);		Rect r;		int segOffset = 0;	if (allIntersections.size() != 0)		while (!intersectionCurveSegments[segOffset])			segOffset++;		for (int i = 0; i < totalCurveSegments; i++)	{		int seg = (i + segOffset) % totalCurveSegments;		FloatPoint p1 = (*curvePoints[seg / sNumSegmentsPerCurve])[seg % sNumSegmentsPerCurve];		FloatPoint p2;		if (seg < (totalCurveSegments - 1))			p2 = (*curvePoints[(seg + 1) / sNumSegmentsPerCurve])[(seg + 1) % sNumSegmentsPerCurve];		else p2 = (*curvePoints[0])[0];				switch (seg % 2)		{			case 0:	RGBForeColor(&gColors.segmentB);	break;			case 1:	RGBForeColor(&gColors.segmentA);	break;		}				//еее	//Plot intersection curve segments a different color		if (intersectionCurveSegments[(i + segOffset) % totalCurveSegments])		{			PenSize(2, 2);			RGBForeColor(&gColors.intersection);		}				MoveTo((int)p1.h + scrollOffset.h, (int)p1.v + scrollOffset.v);		LineTo((int)p2.h + scrollOffset.h, (int)p2.v + scrollOffset.v);				//еее		if (intersectionCurveSegments[(i + segOffset) % totalCurveSegments])			PenSize(1, 1);				//Plot curve points		if (seg % sNumSegmentsPerCurve == 0)		{			RGBForeColor(&gColors.curvePoint);			SetRect(&r, (int)p1.h - gPointRadius, (int)p1.v - gPointRadius,						(int)p1.h + gPointRadius, (int)p1.v + gPointRadius);			OffsetRect(&r, scrollOffset.h, scrollOffset.v);			PaintOval(&r);						Str255 s;			NumToString(seg / sNumSegmentsPerCurve, s);			MoveTo(p1.h + 10 + scrollOffset.h, p1.v + 5 + scrollOffset.v);			DrawString(s);		}	}}vector<vector<FloatPoint>*> BSpline::GenerateSectionSegEndPoints(){	int totalCurveSegments = curveIntersections.size() * sNumSegmentsPerCurve;	vector<vector<FloatPoint>*> sectionSegEndPoints;		if (allIntersections.size() != 0)	{		vector<GenericIntersection*>::iterator nextIntersection = allIntersections.begin();		int totalPoints = totalCurveSegments + allIntersections.size();					//Get the curve and seg of the first intersection		int nextInterCv, nextInterSg;		switch (allIntersections[0]->GetType())		{			case GenericIntersection::BSP_BSP:				BspBspIntersection* bspBspInter = (BspBspIntersection*)allIntersections[0];				if (!bspBspInter->SelfIntersection())				{					if (bspBspInter->GetBsp1() == this)					{						nextInterCv = bspBspInter->GetCv1();						nextInterSg = bspBspInter->GetSg1();					}					else					{						nextInterCv = bspBspInter->GetCv2();						nextInterSg = bspBspInter->GetSg2();					}				}				else	//Self intersection				{					if (bspBspInter->GetCv1() < bspBspInter->GetCv2())					{						nextInterCv = bspBspInter->GetCv1();						nextInterSg = bspBspInter->GetSg1();					}					else if (bspBspInter->GetCv2() < bspBspInter->GetCv1())					{						nextInterCv = bspBspInter->GetCv2();						nextInterSg = bspBspInter->GetSg2();					}					else if (bspBspInter->GetSg1() < bspBspInter->GetSg2())					{						nextInterCv = bspBspInter->GetCv1();						nextInterSg = bspBspInter->GetSg1();					}					else if (bspBspInter->GetSg2() < bspBspInter->GetSg1())					{						nextInterCv = bspBspInter->GetCv2();						nextInterSg = bspBspInter->GetSg2();					}					else	//equal curve and seg					{						MyAssert(false);					}				}				break;			case GenericIntersection::BSP_CUT:				nextInterCv = ((BspCutIntersection*)allIntersections[0])->GetCv();				nextInterSg = ((BspCutIntersection*)allIntersections[0])->GetSg();				break;			case GenericIntersection::BSP_CUT_T:				nextInterCv = ((BspCutTIntersection*)allIntersections[0])->GetCv();				nextInterSg = ((BspCutTIntersection*)allIntersections[0])->GetSg();		}				bool nextPointIsInter = true;		int nextInterIndex = 0, nextInterModIndex = 0;		int nextInterCvSg = nextInterCv * sNumSegmentsPerCurve + nextInterSg;;		int nextCurvePointIndex = nextInterCvSg + 1;		int nextCurvePointModIndex = nextCurvePointIndex % totalCurveSegments;		FloatPoint nextPointLoc;		bool firstInter = true;		bool waitingForEndWrap = false;				vector<FloatPoint>* presentSectionPoints = new vector<FloatPoint>;				vector<BspBspIntersection*> selfIntersVisitedAlready;				Rect r;				//Loop over all the points along the curve.  This includes curve points and intersections		for (int i = 0; i <= totalPoints; i++)		{			MyAssert(presentSectionPoints);						//Determine if the next point is an intersection or a curve point			nextPointIsInter = (nextInterCvSg < nextCurvePointIndex);						//Get the location of the next point			if (nextPointIsInter)			{				nextPointLoc = allIntersections[nextInterModIndex]->GetLocation();								if (allIntersections[nextInterModIndex]->SelfIntersection())				{					vector<BspBspIntersection*>::iterator findIter = find(selfIntersVisitedAlready.begin(), selfIntersVisitedAlready.end(), (BspBspIntersection*)allIntersections[nextInterModIndex]);					if (findIter == selfIntersVisitedAlready.end())						selfIntersVisitedAlready.push_back((BspBspIntersection*)allIntersections[nextInterModIndex]);					else selfIntersVisitedAlready.erase(findIter);				}								nextInterIndex++;				nextInterModIndex = nextInterIndex % allIntersections.size();								//Get the curve and seg of the next intersection				if (!allIntersections[nextInterModIndex]->SelfIntersection())				{					switch (allIntersections[nextInterModIndex]->GetType())					{						case GenericIntersection::BSP_BSP:							if (((BspBspIntersection*)allIntersections[nextInterModIndex])->GetBsp1() == this)							{								nextInterCv = ((BspBspIntersection*)allIntersections[nextInterModIndex])->GetCv1();								nextInterSg = ((BspBspIntersection*)allIntersections[nextInterModIndex])->GetSg1();							}							else							{								nextInterCv = ((BspBspIntersection*)allIntersections[nextInterModIndex])->GetCv2();								nextInterSg = ((BspBspIntersection*)allIntersections[nextInterModIndex])->GetSg2();							}							break;						case GenericIntersection::BSP_CUT:							nextInterCv = ((BspCutIntersection*)allIntersections[nextInterModIndex])->GetCv();							nextInterSg = ((BspCutIntersection*)allIntersections[nextInterModIndex])->GetSg();							break;						case GenericIntersection::BSP_CUT_T:							nextInterCv = ((BspCutTIntersection*)allIntersections[nextInterModIndex])->GetCv();							nextInterSg = ((BspCutTIntersection*)allIntersections[nextInterModIndex])->GetSg();					}				}				else	//Self intersection				{					BspBspIntersection* bspBspInter = (BspBspIntersection*)allIntersections[nextInterModIndex];					if (find(selfIntersVisitedAlready.begin(), selfIntersVisitedAlready.end(), bspBspInter) == selfIntersVisitedAlready.end())					{						if (bspBspInter->GetCv1() < bspBspInter->GetCv2())						{							nextInterCv = bspBspInter->GetCv1();							nextInterSg = bspBspInter->GetSg1();						}						else if (bspBspInter->GetCv2() < bspBspInter->GetCv1())						{							nextInterCv = bspBspInter->GetCv2();							nextInterSg = bspBspInter->GetSg2();						}						else if (bspBspInter->GetSg1() < bspBspInter->GetSg2())						{							nextInterCv = bspBspInter->GetCv1();							nextInterSg = bspBspInter->GetSg1();						}						else if (bspBspInter->GetSg2() < bspBspInter->GetSg1())						{							nextInterCv = bspBspInter->GetCv2();							nextInterSg = bspBspInter->GetSg2();						}						else	//equal curve and seg						{							MyAssert(false);						}					}					else	//second time visiting this intersection					{						if (bspBspInter->GetCv1() < bspBspInter->GetCv2())						{							nextInterCv = bspBspInter->GetCv2();							nextInterSg = bspBspInter->GetSg2();						}						else if (bspBspInter->GetCv2() < bspBspInter->GetCv1())						{							nextInterCv = bspBspInter->GetCv1();							nextInterSg = bspBspInter->GetSg1();						}						else if (bspBspInter->GetSg1() < bspBspInter->GetSg2())						{							nextInterCv = bspBspInter->GetCv2();							nextInterSg = bspBspInter->GetSg2();						}						else if (bspBspInter->GetSg2() < bspBspInter->GetSg1())						{							nextInterCv = bspBspInter->GetCv1();							nextInterSg = bspBspInter->GetSg1();						}						else	//equal curve and seg						{							MyAssert(false);						}					}				}				nextInterCvSg = nextInterCv * sNumSegmentsPerCurve + nextInterSg;				if (nextInterIndex >= allIntersections.size())					nextInterCvSg += totalCurveSegments;			}			else	//next point is a curve point			{				nextPointLoc = (*curvePoints[nextCurvePointModIndex / sNumSegmentsPerCurve])[nextCurvePointModIndex % sNumSegmentsPerCurve];				nextCurvePointIndex++;				nextCurvePointModIndex = nextCurvePointIndex % totalCurveSegments;			}						//Add the location of the next point to the present section's list of points			presentSectionPoints->push_back(nextPointLoc);						//If the next point was an intersection, finish the present section and start the next one			if (nextPointIsInter && !firstInter)			{				sectionSegEndPoints.push_back(presentSectionPoints);				if (sectionSegEndPoints.size() < allIntersections.size())				{					presentSectionPoints = new vector<FloatPoint>;					presentSectionPoints->push_back(nextPointLoc);				}				else presentSectionPoints = NULL;			}						firstInter = false;		}	}	else	//No intersections	{		vector<FloatPoint>* oneSectionSegEndPoints = new vector<FloatPoint>;				for (int i = 0; i < totalCurveSegments; i++)			oneSectionSegEndPoints->push_back((*curvePoints[i / sNumSegmentsPerCurve])[i % sNumSegmentsPerCurve]);		oneSectionSegEndPoints->push_back((*curvePoints[0 / sNumSegmentsPerCurve])[0 % sNumSegmentsPerCurve]);				sectionSegEndPoints.push_back(oneSectionSegEndPoints);	}		return sectionSegEndPoints;}void BSpline::OutlineDepthZeroSections(Point scrollOffset){	DrawCurvesKnotMode(scrollOffset, false, false, false);}	void BSpline::DrawCurvesKnotMode(Point scrollOffset, bool showDepths, bool drawOccludedSections, bool shadeSignOfOcclusion, bool debug){	VerifyNumSectionsMatchesNumInters();	VerifyTotalIntersMatchesCurveInters();		vector<vector<FloatPoint>*> sectionSegEndPoints;	sectionSegEndPoints.resize(0);		sectionSegEndPoints = GenerateSectionSegEndPoints();		MyAssert(sectionSegEndPoints.size() == sectionDepths.size());		//Define the "deep" version of the color	RGBColor colorDeep = surfaceTraits.interiorColor;	colorDeep.red += (65535 - colorDeep.red) * .67;	colorDeep.green += (65535 - colorDeep.green) * .67;	colorDeep.blue += (65535 - colorDeep.blue) * .67;		RGBColor gray;	gray.red = gray.green = gray.blue = 65535 * .67;		bool allIntersectionsLegal = true;//еееGetAllIntersectionsLegal(false);		int offset = 0;	if (!debug)	{		if (!drawOccludedSections)		{			PenSize(surfaceTraits.borderThickness, surfaceTraits.borderThickness);			offset = surfaceTraits.borderThickness / 2;		}		else PenSize(1, 1);	}		//Plot the line segments	vector<int>::iterator sectionDepthIter = sectionDepths.begin();	vector<int>::iterator maxPossibleSectionDepthIter = maxPossibleSectionDepths.begin();	double distFromLastShade = 999999;	int segCounter = 0;	int prevSectionDepth = sectionDepths[sectionDepths.size() - 1];	for (int i = 0; i < sectionSegEndPoints.size(); i++)	{		MyAssert(*sectionDepthIter >= 0);				if (*sectionDepthIter == 0 || drawOccludedSections)		{			for (int j = 0; j < (sectionSegEndPoints[i])->size() - 1; j++)			{				segCounter++;								//Skip segments on lower boundaries at intersections				if (shadeSignOfOcclusion && sShadeWithArrows)				{					int gapSpacer = 1;					if (j <= gapSpacer)					{						if (*sectionDepthIter != prevSectionDepth)							continue;					}					else if (j >= (sectionSegEndPoints[i])->size() - (gapSpacer + 2))					{						int nextSectionDepth;						if (i < sectionSegEndPoints.size() - 1)							nextSectionDepth = *(sectionDepthIter + 1);						else nextSectionDepth = sectionDepths[0];						if (*sectionDepthIter != nextSectionDepth)							continue;					}				}								//Determine the color of the segment and draw it				FloatPoint thisPoint = (*sectionSegEndPoints[i])[j];				FloatPoint nextPoint;								if (*sectionDepthIter == 0 || sShadeWithArrows)				{					if (allIntersectionsLegal)					{						if (drawOccludedSections)							RGBForeColor(&surfaceTraits.interiorColor);						else RGBForeColor(&surfaceTraits.borderColor);					}					else ForeColor(blackColor);				}				else if (segCounter % 2 == 0)				{					if (allIntersectionsLegal)						RGBForeColor(&colorDeep);					else RGBForeColor(&gray);				}				else				{					distFromLastShade += LineSegmentLength(thisPoint, nextPoint);					continue;				}								nextPoint = (*sectionSegEndPoints[i])[j + 1];								MoveTo((int)thisPoint.h + scrollOffset.h - offset, (int)thisPoint.v + scrollOffset.v - offset);				LineTo((int)nextPoint.h + scrollOffset.h - offset, (int)nextPoint.v + scrollOffset.v - offset);								//"Shade" the segment				if (shadeSignOfOcclusion && !sShadeWithArrows)				{					MyAssert(offset == 0);					if (distFromLastShade > sShadeSize)					{						double segAngle = LineSegmentAngle(thisPoint, nextPoint);						segAngle += PiOver2;						FloatPoint segCenter;						segCenter.h = (thisPoint.h + nextPoint.h) / 2.0;						segCenter.v = (thisPoint.v + nextPoint.v) / 2.0;						FloatPoint shadePoint = ProjectPointAtAngle(segCenter, segAngle, sShadeSize);						MoveTo((int)segCenter.h + scrollOffset.h, (int)segCenter.v + scrollOffset.v);						LineTo((int)shadePoint.h + scrollOffset.h, (int)shadePoint.v + scrollOffset.v);						distFromLastShade = 0;					}										distFromLastShade += LineSegmentLength(thisPoint, nextPoint);				}			}		}		else segCounter += ((sectionSegEndPoints[i])->size() - 1);				//Write the section depth		//if (*sectionDepthIter != 0)		if (showDepths && drawOccludedSections && (*sectionDepthIter != 0 || (sectionSegEndPoints[i])->size() > 10))		{			ForeColor(blackColor);			Str255 str1;			NumToString(*sectionDepthIter, str1);			FloatPoint midPoint = (*sectionSegEndPoints[i])[(sectionSegEndPoints[i])->size() / 2];			MoveTo((int)midPoint.h + 5 + scrollOffset.h, (int)midPoint.v + scrollOffset.v);			DrawString(str1);						if (maxPossibleSectionDepths.size() == sectionDepths.size())			{				DrawString("\p / ");				NumToString(*maxPossibleSectionDepthIter, str1);				DrawString(str1);			}			/*			if (i < allIntersections.size())			{				GenericIntersection *startInter = allIntersections[i];				GenericIntersection *endInter = allIntersections[(i + 1) % allIntersections.size()];				int scv, ssg;				switch (startInter->GetType())				{					case GenericIntersection::BSP_BSP:						//Not correct.  Might need the second curve and segment instead						scv = ((BspBspIntersection*)startInter)->GetCv1();						scv = ((BspBspIntersection*)startInter)->GetSg1();						break;					case GenericIntersection::BSP_CUT:						scv = ((BspCutIntersection*)startInter)->GetCv();						scv = ((BspCutIntersection*)startInter)->GetSg();						break;					case GenericIntersection::BSP_CUT_T:						scv = ((BspCutTIntersection*)startInter)->GetCv();						scv = ((BspCutTIntersection*)startInter)->GetSg();						break;					case GenericIntersection::CUT_CUT:						MyAssert(false);						break;				}				UnorientedBoundarySection ubs(this, NULL, startInter, endInter, scv, ssg, true);				int subboundaryIndex = FindSubboundaryForSection(ubs);				NumToString(subboundaryIndex, str1);				MoveTo((int)midPoint.h + 5 + scrollOffset.h, (int)midPoint.v + scrollOffset.v + 10);				DrawString(str1);			}			*/		}				prevSectionDepth = *sectionDepthIter;		sectionDepthIter++;		maxPossibleSectionDepthIter++;				delete sectionSegEndPoints[i];	}		if (!debug && !drawOccludedSections)		PenSize(1, 1);		if (shadeSignOfOcclusion && sShadeWithArrows)		for (int i = 0; i < controlPoints.size(); i++)			DrawSignOfOcclusionArrow(i, scrollOffset);}void BSpline::DrawSignOfOcclusionArrow(int curveIndex, Point scrollOffset){	RGBForeColor(&surfaceTraits.interiorColor);		//Find the curveSegment at the center of the curve	int curveSeg = sNumSegmentsPerCurve / 2;		//Get the endpoints of the segment	FloatPoint end1 = (*curvePoints[curveIndex])[curveSeg];	FloatPoint end2 = (*curvePoints[curveIndex])[curveSeg + 1];	double length = sqrt((end1.h - end2.h) * (end1.h - end2.h) + (end1.v - end2.v) * (end1.v - end2.v));		//Find the angle of the segment	double segAngle = LineSegmentAngle(end1, end2);		//Make the angles for the arrow head	double arrowHeadAngle1 = segAngle + sArrowHeadAngle;	if (arrowHeadAngle1 >= PiTimes2)		arrowHeadAngle1 -= PiTimes2;	double arrowHeadAngle2 = segAngle - sArrowHeadAngle;	if (arrowHeadAngle2 < 0)		arrowHeadAngle2 += PiTimes2;		//Find the endpoints for the arrow head	FloatPoint arrowHeadEndPoint1 = ProjectPointAtAngle(end1, arrowHeadAngle1, sShadeSize);	FloatPoint arrowHeadEndPoint2 = ProjectPointAtAngle(end1, arrowHeadAngle2, sShadeSize);		MoveTo(end1.h + scrollOffset.h, end1.v + scrollOffset.v);	LineTo(arrowHeadEndPoint1.h + scrollOffset.h, arrowHeadEndPoint1.v + scrollOffset.v);		MoveTo(end1.h + scrollOffset.h, end1.v + scrollOffset.v);	LineTo(arrowHeadEndPoint2.h + scrollOffset.h, arrowHeadEndPoint2.v + scrollOffset.v);}void BSpline::OutlinePostscriptDepthZeroSections(short fRefNum, Point canvasSize){	DrawPostscriptCurvesKnotMode(fRefNum, canvasSize, false, false, false);}void BSpline::DrawPostscriptCurvesKnotMode(short fRefNum, Point canvasSize, bool showDepths, bool drawOccludedSections, bool shadeSignOfOcclusion){	if (surfaceTraits.borderThickness == 0)		return;		string st;		vector<vector<FloatPoint>*> sectionSegEndPoints = GenerateSectionSegEndPoints();		MyAssert(sectionSegEndPoints.size() == sectionDepths.size());		//Define the "deep" version of the color	RGBColor colorDeep = surfaceTraits.interiorColor;	colorDeep.red += (65535 - colorDeep.red) * .67;	colorDeep.green += (65535 - colorDeep.green) * .67;	colorDeep.blue += (65535 - colorDeep.blue) * .67;		RGBColor gray;	gray.red = gray.green = gray.blue = 65535 * .67;		bool allIntersectionsLegal = true;//еееGetAllIntersectionsLegal(false);		//	0.0001	for hairlines, such as for posters	//	0.001	for print, such as papers	//	0.01	for pixelated images, such as presentations	double lineThickness = drawOccludedSections ? .002 : (surfaceTraits.borderThickness / (double)max(canvasSize.h, canvasSize.v));	ostringstream lineThicknessOss;	lineThicknessOss << lineThickness;	st += lineThicknessOss.str();	st += " setlinewidth\n";		//Plot the line segments	vector<int>::iterator sectionDepthIter = sectionDepths.begin();	double distFromLastShade = 999999;	int segCounter = 0;	int prevSectionDepth = sectionDepths[sectionDepths.size() - 1];	for (int i = 0; i < sectionSegEndPoints.size(); i++)	{		MyAssert(*sectionDepthIter >= 0);				if (*sectionDepthIter == 0 || drawOccludedSections)		{			for (int j = 0; j < (sectionSegEndPoints[i])->size() - 1; j++)			{				segCounter++;								//Skip segments on lower boundaries at intersections				if (shadeSignOfOcclusion && sShadeWithArrows)				{					int gapSpacer = 1;					if (j <= gapSpacer)					{						if (*sectionDepthIter != prevSectionDepth)							continue;					}					else if (j >= (sectionSegEndPoints[i])->size() - (gapSpacer + 2))					{						int nextSectionDepth;						if (i < sectionSegEndPoints.size() - 1)							nextSectionDepth = *(sectionDepthIter + 1);						else nextSectionDepth = sectionDepths[0];						if (*sectionDepthIter != nextSectionDepth)							continue;					}				}								FloatPoint thisPoint = (*sectionSegEndPoints[i])[j];				FloatPoint nextPoint;								if (*sectionDepthIter == 0 || sShadeWithArrows)				{					ostringstream oss;					if (allIntersectionsLegal)					{						if (drawOccludedSections)						{							oss << ((double)surfaceTraits.interiorColor.red / 65535.0);							oss << " ";							oss << ((double)surfaceTraits.interiorColor.green / 65535.0);							oss << " ";							oss << ((double)surfaceTraits.interiorColor.blue / 65535.0);						}						else						{							oss << ((double)surfaceTraits.borderColor.red / 65535.0);							oss << " ";							oss << ((double)surfaceTraits.borderColor.green / 65535.0);							oss << " ";							oss << ((double)surfaceTraits.borderColor.blue / 65535.0);						}					}					else					{						oss << 0;						oss << " ";						oss << 0;						oss << " ";						oss << 0;					}										oss << " setrgbcolor\n";										st += oss.str();				}				else if (segCounter % 2 == 0)				{					ostringstream oss;					if (allIntersectionsLegal)					{						oss << ((double)colorDeep.red / 65535.0);						oss << " ";						oss << ((double)colorDeep.green / 65535.0);						oss << " ";						oss << ((double)colorDeep.blue / 65535.0);					}					else					{						oss << .66667;//((double)gray.red / 65535.0);						oss << " ";						oss << .66667;//((double)gray.green / 65535.0);						oss << " ";						oss << .66667;//((double)gray.blue / 65535.0);					}										oss << " setrgbcolor\n";										st += oss.str();				}				else				{					distFromLastShade += LineSegmentLength(thisPoint, nextPoint);					continue;				}								nextPoint = (*sectionSegEndPoints[i])[j + 1];								ostringstream oss;				oss << (double)thisPoint.h / canvasSize.h;				oss << " ";				oss << (double)(canvasSize.v - thisPoint.v) / canvasSize.v;				oss << " moveto\n";								oss << (double)nextPoint.h / canvasSize.h;				oss << " ";				oss << (double)(canvasSize.v - nextPoint.v) / canvasSize.v;				oss << " lineto\n";								oss << "stroke\n";								st += oss.str();								//"Shade" the segment				if (shadeSignOfOcclusion && !sShadeWithArrows)				{					if (distFromLastShade > sShadeSize)					{						double segAngle = LineSegmentAngle(thisPoint, nextPoint);						segAngle += PiOver2;						FloatPoint segCenter;						segCenter.h = (thisPoint.h + nextPoint.h) / 2.0;						segCenter.v = (thisPoint.v + nextPoint.v) / 2.0;						FloatPoint shadePoint = ProjectPointAtAngle(segCenter, segAngle, sShadeSize);												ostringstream oss;						oss << (double)segCenter.h / canvasSize.h;						oss << " ";						oss << (double)(canvasSize.v - segCenter.v) / canvasSize.v;						oss << " moveto\n";												oss << (double)shadePoint.h / canvasSize.h;						oss << " ";						oss << (double)(canvasSize.v - shadePoint.v) / canvasSize.v;						oss << " lineto\n";												oss << "stroke\n";												st += oss.str();												distFromLastShade = 0;					}										distFromLastShade += LineSegmentLength(thisPoint, nextPoint);				}			}		}		else segCounter += ((sectionSegEndPoints[i])->size() - 1);				//Write the section depth		if (showDepths && drawOccludedSections && (*sectionDepthIter != 0 || (sectionSegEndPoints[i])->size() > 10))		{			//ForeColor(blackColor);			Str255 str;			NumToString(*sectionDepthIter, str);			FloatPoint midPoint = (*sectionSegEndPoints[i])[(sectionSegEndPoints[i])->size() / 2];			//MoveTo((int)midPoint.h + 5, (int)midPoint.v);			//DrawString(str);						//st += "/Times-Roman findfont .02 scalefont setfont\n";			st += "/Times-Roman findfont .03 scalefont setfont\n";						ostringstream oss;						oss << 0;			oss << " ";			oss << 0;			oss << " ";			oss << 0;						oss << " setrgbcolor\n";						oss << "newpath\n";						oss << (double)midPoint.h / canvasSize.h;			oss << " ";			oss << (double)(canvasSize.v - midPoint.v) / canvasSize.v;			oss << " moveto\n";						oss << "(";			oss << *sectionDepthIter;			oss << ") show\n";						st += oss.str();		}				prevSectionDepth = *sectionDepthIter;		sectionDepthIter++;				delete sectionSegEndPoints[i];	}		long strLen = st.length();	OSErr err = FSWrite(fRefNum, &strLen, st.c_str());		if (shadeSignOfOcclusion && sShadeWithArrows)	{		ostringstream lineThicknessOss2;		lineThicknessOss2 << lineThickness;		st += lineThicknessOss2.str();		st += " setlinewidth\n";				for (int i = 0; i < controlPoints.size(); i++)			DrawPostscriptSignOfOcclusionArrow(fRefNum, canvasSize, i);	}}void BSpline::DrawPostscriptSignOfOcclusionArrow(short fRefNum, Point canvasSize, int curveIndex){	ostringstream oss;		oss << ((double)surfaceTraits.interiorColor.red / 65535.0);	oss << " ";	oss << ((double)surfaceTraits.interiorColor.green / 65535.0);	oss << " ";	oss << ((double)surfaceTraits.interiorColor.blue / 65535.0);		oss << " setrgbcolor\n";		//Find the curveSegment at the center of the curve	int curveSeg = sNumSegmentsPerCurve / 2;		//Get the endpoints of the segment	FloatPoint end1 = (*curvePoints[curveIndex])[curveSeg];	FloatPoint end2 = (*curvePoints[curveIndex])[curveSeg + 1];	double length = sqrt((end1.h - end2.h) * (end1.h - end2.h) + (end1.v - end2.v) * (end1.v - end2.v));		//Find the angle of the segment	double segAngle = LineSegmentAngle(end1, end2);		//Make the angles for the arrow head	double arrowHeadAngle1 = segAngle + sArrowHeadAngle;	if (arrowHeadAngle1 >= PiTimes2)		arrowHeadAngle1 -= PiTimes2;	double arrowHeadAngle2 = segAngle - sArrowHeadAngle;	if (arrowHeadAngle2 < 0)		arrowHeadAngle2 += PiTimes2;		//Find the endpoints for the arrow head	FloatPoint arrowHeadEndPoint1 = ProjectPointAtAngle(end1, arrowHeadAngle1, sShadeSize);	FloatPoint arrowHeadEndPoint2 = ProjectPointAtAngle(end1, arrowHeadAngle2, sShadeSize);		oss << (double)end1.h / canvasSize.h;	oss << " ";	oss << (double)(canvasSize.v - end1.v) / canvasSize.v;	oss << " moveto\n";		oss << (double)arrowHeadEndPoint1.h / canvasSize.h;	oss << " ";	oss << (double)(canvasSize.v - arrowHeadEndPoint1.v) / canvasSize.v;	oss << " lineto\n";		oss << "stroke\n";		oss << (double)end1.h / canvasSize.h;	oss << " ";	oss << (double)(canvasSize.v - end1.v) / canvasSize.v;	oss << " moveto\n";		oss << (double)arrowHeadEndPoint2.h / canvasSize.h;	oss << " ";	oss << (double)(canvasSize.v - arrowHeadEndPoint2.v) / canvasSize.v;	oss << " lineto\n";		oss << "stroke\n";		string st;	st += oss.str();		long strLen = st.length();	OSErr err = FSWrite(fRefNum, &strLen, st.c_str());}#pragma mark -void BSpline::DumpFileData(short fRefNum){	string st;	ostringstream oss;		//Add the degree	oss << "  " << degree << "\n";		//Add the surface traits	oss << "  " << surfaceTraits.interiorColor.red << " " << surfaceTraits.interiorColor.green << " " << surfaceTraits.interiorColor.blue << "\n";	oss << "  " << surfaceTraits.interiorReflectance << "\n";	oss << "  " << surfaceTraits.borderColor.red << " " << surfaceTraits.borderColor.green << " " << surfaceTraits.borderColor.blue << "\n";	oss << "  " << surfaceTraits.borderReflectance << "\n";	oss << "  " << surfaceTraits.borderThickness << "\n";		//Add the number of control points	oss << "  " << controlPoints.size() << "\n";		//Add the control points	for (int i = 0; i < controlPoints.size(); i++)		oss << "    " << controlPoints[i].h << " " << controlPoints[i].v << "\n";		//Add the number sections	oss << "  " << sectionDepths.size() << "\n";		//Add the section depths	for (int i = 0; i < sectionDepths.size(); i++)		oss << "    " << sectionDepths[i] << "\n";		//That's it for BSpline data	st += oss.str();	long strLen = st.length();	OSErr err = FSWrite(fRefNum, &strLen, st.c_str());}void BSpline::LoadFileData(istringstream& iss, double fileVersion){	//Erase the present BSpline (shouldn't be necessary since this BSpline should have just been created, but oh well)		//Control points	controlPoints.clear();		//Curve points	for (vector<vector<FloatPoint>*>::iterator i = curvePoints.begin(); i != curvePoints.end(); i++)		delete *i;	curvePoints.clear();	for (vector<vector<FloatPoint>*>::iterator i = prevCurvePoints.begin(); i != prevCurvePoints.end(); i++)		delete *i;	prevCurvePoints.clear();		//Curve intersections	for (int i = 0; i < curveIntersections.size(); i++)		delete curveIntersections[i];	curveIntersections.clear();		//Recalc curves	curvesToRecalc.clear();		//Reintersect curves	curvesToReintersect.clear();		//Section depths	sectionDepths.clear();		//Min section depth constraints	sectionDepthConstraints.clear();		//=======================================================================================		if (fileVersion == 1.0)	{		//Load the degree		iss >> degree;				//Load the color		iss >> surfaceTraits.interiorColor.red >> surfaceTraits.interiorColor.green >> surfaceTraits.interiorColor.blue;		iss >> surfaceTraits.interiorReflectance;				//Guess the rest of the traits as best as possible		surfaceTraits.borderColor.red = surfaceTraits.interiorColor.red;		surfaceTraits.borderColor.green = surfaceTraits.interiorColor.green;		surfaceTraits.borderColor.blue = surfaceTraits.interiorColor.blue;		surfaceTraits.borderReflectance = surfaceTraits.interiorReflectance;		surfaceTraits.borderThickness = 1.0;				//Load the number of control points		int numControlPoints;		iss >> numControlPoints;		controlPoints.resize(numControlPoints);		curvePoints.resize(numControlPoints);		prevCurvePoints.resize(numControlPoints);		curveIntersections.resize(numControlPoints);		curvesToRecalc.resize(numControlPoints);		curvesToReintersect.resize(numControlPoints);		intersectionCurveSegments.resize(numControlPoints * sNumSegmentsPerCurve);				//Load the control points		for (int i = 0; i < numControlPoints; i++)			iss >> controlPoints[i].h >> controlPoints[i].v;				for (int i = 0; i < numControlPoints; i++)		{			//Curve points			vector<FloatPoint> *cp = new vector<FloatPoint>;			cp->resize(sNumSegmentsPerCurve);			curvePoints[i] = cp;						//Prev curve points			vector<FloatPoint> *pcp = new vector<FloatPoint>;			pcp->resize(sNumSegmentsPerCurve);			prevCurvePoints[i] = pcp;						//Curve intersections			curveIntersections[i] = new vector<GenericIntersection*>;						//Recalc			curvesToRecalc[i] = true;						//Reintersect			curvesToReintersect[i] = false;		}				//Load the number of sections		int numSections;		iss >> numSections;		sectionDepths.resize(numSections);				//Why is this failing?!  It gives a fairly low level memory error.		//sectionDepthConstraints.resize(numSections);		for (int i = 0; i < numSections; i++)			sectionDepthConstraints.push_back(0);				//Load the section depths		for (int i = 0; i < numSections; i++)			iss >> sectionDepths[i];				RecalcBSpline();		BackupCurvePoints();	}	else if (fileVersion == 1.1 || fileVersion == 1.2)	{		//Load the degree		iss >> degree;				//Load the surface traits		iss >> surfaceTraits.interiorColor.red >> surfaceTraits.interiorColor.green >> surfaceTraits.interiorColor.blue;		iss >> surfaceTraits.interiorReflectance;		iss >> surfaceTraits.borderColor.red >> surfaceTraits.borderColor.green >> surfaceTraits.borderColor.blue;		iss >> surfaceTraits.borderReflectance;		iss >> surfaceTraits.borderThickness;				//Load the number of control points		int numControlPoints;		iss >> numControlPoints;		controlPoints.resize(numControlPoints);		curvePoints.resize(numControlPoints);		prevCurvePoints.resize(numControlPoints);		curveIntersections.resize(numControlPoints);		curvesToRecalc.resize(numControlPoints);		curvesToReintersect.resize(numControlPoints);		intersectionCurveSegments.resize(numControlPoints * sNumSegmentsPerCurve);				//Load the control points		for (int i = 0; i < numControlPoints; i++)			iss >> controlPoints[i].h >> controlPoints[i].v;				for (int i = 0; i < numControlPoints; i++)		{			//Curve points			vector<FloatPoint> *cp = new vector<FloatPoint>;			cp->resize(sNumSegmentsPerCurve);			curvePoints[i] = cp;						//Prev curve points			vector<FloatPoint> *pcp = new vector<FloatPoint>;			pcp->resize(sNumSegmentsPerCurve);			prevCurvePoints[i] = pcp;						//Curve intersections			curveIntersections[i] = new vector<GenericIntersection*>;						//Recalc			curvesToRecalc[i] = true;						//Reintersect			curvesToReintersect[i] = false;		}				//Load the number of sections		int numSections;		iss >> numSections;		sectionDepths.resize(numSections);				//Why is this failing?!  It gives a fairly low level memory error.		//sectionDepthConstraints.resize(numSections);		for (int i = 0; i < numSections; i++)			sectionDepthConstraints.push_back(0);				//Load the section depths		for (int i = 0; i < numSections; i++)			iss >> sectionDepths[i];				RecalcBSpline();		BackupCurvePoints();	}}#pragma mark -void BSpline::ChangeDegree(bool decrease){	BackupCurvePoints();		SetAllCurvesToRecalc();	SetAllCurvesToReintersect();		if (!decrease)	{		degree++;		RecalcBSpline();	}	else if (degree > 1)	{		degree--;		RecalcBSpline();	}		MyAssert(degree >= 0);		//Should this be here?	//Update the locations of BspCutT intersections	for (int i = 0; i < allIntersections.size(); i++)		if (allIntersections[i]->GetType() == GenericIntersection::BSP_CUT_T)			((BspCutTIntersection*)allIntersections[i])->RecalcStartEndLocs();}void BSpline::SetDegree(int newDegree){	MyAssert(newDegree >= 0);	degree = newDegree;}void BSpline::SetAllCurvesToRecalc(){	for (vector<bool>::iterator i = curvesToRecalc.begin(); i != curvesToRecalc.end(); i++)		(*i) = true;}void BSpline::SetAllCurvesToNotRecalc(){	for (vector<bool>::iterator i = curvesToRecalc.begin(); i != curvesToRecalc.end(); i++)		(*i) = false;}void BSpline::SetAllCurvesToReintersect(){	for (vector<bool>::iterator i = curvesToReintersect.begin(); i != curvesToReintersect.end(); i++)		(*i) = true;}void BSpline::SetAllCurvesToNotReintersect(){	for (vector<bool>::iterator i = curvesToReintersect.begin(); i != curvesToReintersect.end(); i++)		(*i) = false;}void BSpline::ReallocateCurvePoints(){	for (vector<vector<FloatPoint>*>::iterator i = curvePoints.begin(); i != curvePoints.end(); i++)	{		delete *i;		*i = new vector<FloatPoint>(sNumSegmentsPerCurve);	}		for (vector<vector<FloatPoint>*>::iterator i = prevCurvePoints.begin(); i != prevCurvePoints.end(); i++)	{		delete *i;		*i = new vector<FloatPoint>(sNumSegmentsPerCurve);	}		intersectionCurveSegments.resize(controlPoints.size() * sNumSegmentsPerCurve);		SetAllCurvesToRecalc();	SetAllCurvesToReintersect();	RecalcBSpline();		//Should this be here?	//Update the locations of BspCutT intersections	for (int i = 0; i < allIntersections.size(); i++)		if (allIntersections[i]->GetType() == GenericIntersection::BSP_CUT_T)			((BspCutTIntersection*)allIntersections[i])->RecalcStartEndLocs();		BackupCurvePoints();	VerifyBackupsMatchPresent();}		void BSpline::ReverseControlPointOrder(){	BackupCurvePoints();		vector<FloatPoint> newControlPoints(controlPoints.size());	for (int i = 0; i < controlPoints.size(); i++)		newControlPoints[i] = controlPoints[(controlPoints.size() - 1) - i];	for (int i = 0; i < controlPoints.size(); i++)		controlPoints[i] = newControlPoints[i];		vector<int> newSectionDepths(sectionDepths.size());	for (int i = 0; i < sectionDepths.size() - 1; i++)		newSectionDepths[i] = sectionDepths[(sectionDepths.size() - 2) - i];	for (int i = 0; i < sectionDepths.size() - 1; i++)		sectionDepths[i] = newSectionDepths[i];		SetAllCurvesToRecalc();	SetAllCurvesToReintersect();	RecalcBSpline();		//Should this be here?	//Update the locations of BspCutT intersections	for (int i = 0; i < allIntersections.size(); i++)		if (allIntersections[i]->GetType() == GenericIntersection::BSP_CUT_T)			((BspCutTIntersection*)allIntersections[i])->RecalcStartEndLocs();}#pragma mark -bool BSpline::VerifyLegalLabeling(){	return true;	//еее		if (allIntersections.size() == 0)		return true;		//Go through all the intersections and sections in order	vector<GenericIntersection*>::iterator nextIntersection = allIntersections.begin();	for (int i = 0; i < sectionDepths.size(); i++)	{		switch ((*nextIntersection)->GetType())		{			case GenericIntersection::BSP_BSP:				if (!((BspBspIntersection*)(*nextIntersection))->SelfIntersection())				{					BspBspIntersection* bspBspInter = (BspBspIntersection*)(*nextIntersection);										if (bspBspInter->GetBsp1() == this)	//This BSpline is on top at this intersection					{						//If the section depths on either side of the intersection don't match, it isn't legal						if (sectionDepths[(i + (sectionDepths.size() - 1)) % sectionDepths.size()] != sectionDepths[i])							return false;					}					else	//This BSpline is on the bottom at this intersection					{						//If the section depths on either side of the intersection don't differ by one (positive in one						//direction, negative in the other), it isn't legal						int occludedEdge = bspBspInter->DetermineOccludedEdge();						MyAssert(occludedEdge == 3 || occludedEdge == 4);						if (occludedEdge == 3 && sectionDepths[(i + (sectionDepths.size() - 1)) % sectionDepths.size()] != sectionDepths[i] + 1)							return false;						else if (occludedEdge == 4 && sectionDepths[(i + (sectionDepths.size() - 1)) % sectionDepths.size()] != sectionDepths[i] - 1)							return false;					}				}				else	//Self intersection				{					//ееееееееееееееееееееееееееееееее					//Not coded yet				}				break;			case GenericIntersection::BSP_CUT:				break;			case GenericIntersection::BSP_CUT_T:				break;		}				nextIntersection++;	}		return true;}