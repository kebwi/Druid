#include "Drawing.h"#include "MinimalDrawing.h"#include "BSpline.h"#include "BSplineToBSplineCut.h"#include "GenericIntersection.h"#include "BspBspIntersection.h"#include "BspCutIntersection.h"#include "BspCutTIntersection.h"#include "CutCutIntersection.h"#include "MainWindow.h"	//еее#include "FloatPoint.h"#include "Colors.h"#include "trigConstants.h"#include "Random.h"#include "PascalStringUtil.h"#include <ColorPicker.h>#include <time.h>#include <algorithm.h>#include <utility.h> //for pair#include <math.h>#include <list.h>#include <vector.h>#include <string>#include <sstream>#include <fstream>using namespace::std;//******************************************************************************//Extern Globalsextern WindowPtr gAnalysisWindow;	//еееextern Colors gColors;extern MainWindow* gMainWindow;extern Drawing *gDrawing;extern int gPointRadius;extern int gFindPointDist;extern UserEventUPP gEventProcUPP;extern unsigned long Drawing::sTreeWalk;extern SurfaceTraits Drawing::sOldSurfaceTraits;extern ColorChangedUPP Drawing::sColorChangedUPP;extern NColorChangedUPP Drawing::sColorNChangedUPP;extern int gLabelingMethod;	//0:	tree search							//1:	uniquely determine from companion setextern int gCompanionSetMethod;	//0:	don't use companion sets								//1:	use companion sets to order search, but not to truncate search								//2:	use companion sets to truncate searchextern int gDepthEnumerationMethod;	//0:	use half the number of intersections on a boundary as the enumeration limit and enumerate from the first intersection on the boundary									//1:	find the depth range for each section of a boundary to use as the enumeration limit and enumerate from the deepest range intersection on the boundary (stupid idea, purely for comparative purposes)									//2:	find the depth range for each section of a boundary to use as the enumeration limit and enumerate from the shallowest range intersection on the boundaryextern int gBoundingMethod;	//0:	no bounding							//1:	boundingextern int gTreeSearchMethod;	//0:	depth-first-search								//1:	iterative deepening								//2:	breadth-first-searchextern float gTimeLimitScalar;extern bool gMouseTerminated;extern bool gDebug;extern bool gDebug1;extern bool gDebug3;extern bool gDebug5;extern bool gDebug6;extern bool gDebug7;extern bool gDebug8;extern bool gDebug10;extern bool gDebug11;extern bool gDebug12;extern int gTextH;extern int gTextV;extern vector<pair<GenericIntersection*, int> > gInterDists;extern int gHorizon;extern bool gTestLogOn;extern stringstream* gOutputFileStream;//******************************************************************************//Global Declarations//******************************************************************************//Function Prototypes	//	In external files		//	main.cppvoid MyAssert(bool condition);pascal Boolean ColorPickerEventProc(EventRecord *event);		//lineEquations.cppdouble LineSegmentLength(FloatPoint p1, FloatPoint p2);double LineSegmentAngle(FloatPoint p1, FloatPoint p2);FloatPoint ProjectPointAtAngle(FloatPoint origin, double angle, double segLength);int LineCrossLineDirection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2);bool LineSegmentIntersection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2, FloatPoint &intersection);bool LineSegmentIntersection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2,							FloatPoint &intersection, double& lineSegInter1, double& lineSegInter2);#pragma mark -void Drawing::UpdateTouchedBSplines(int bspIndex, vector<int>& touchedBSplineIndexes){	MyAssert(bspIndex != -1);	vector<BSpline*> groupBSplines;	GetBSplinesInGroupFromBSpline(bsplines[bspIndex], groupBSplines);	if (groupBSplines.size() > 0)	//A group was found	{		bool groupIncludedAlready = false;		for (int i = 0; i < touchedBSplineIndexes.size(); i++)			if (find(groupBSplines.begin(), groupBSplines.end(), bsplines[touchedBSplineIndexes[i]]) != groupBSplines.end())			{				groupIncludedAlready = true;				break;			}		if (!groupIncludedAlready)			touchedBSplineIndexes.push_back(bspIndex);	}	else	//A group was not found		if (find(touchedBSplineIndexes.begin(), touchedBSplineIndexes.end(), bspIndex) == touchedBSplineIndexes.end())			touchedBSplineIndexes.push_back(bspIndex);}#pragma mark -BspCutTIntersection* Drawing::FindNextInfiniteSolidCut(BspCutTIntersection* infiniteInter, bool useAllInfiniteObjects){	MyAssert(!infiniteInter->GetBsp());		//Find the BSpline at the beginning of the cut	MyAssert(infiniteInter->GetCut()->GetNumIntersections() > 0);	BSpline* bsp = ((BspCutTIntersection*)infiniteInter->GetCut()->GetFirstIntersection())->GetBsp();	MyAssert(bsp);		vector<BSpline*> groupBSplines;	if (!useAllInfiniteObjects)	{		//Get all the BSplines in this group		GetBSplinesInGroupFromBSpline(bsp, groupBSplines);		}	else	{		if (wholeObjects.size() > 0)			//Loop through the whole objects			for (vector<WholeObject*>::iterator i = wholeObjects.begin(); i != wholeObjects.end(); i++)			{				int groupSize = (*i)->bsplines.size();				MyAssert(groupSize > 0);								if ((*i)->bgDepths.size() > 0)	//Only accept infinite objects					for (int k = 0; k < groupSize; k++)						groupBSplines.push_back((*i)->bsplines[k]);			}	}		if (groupBSplines.size() == 0)		return infiniteInter;	//Is this the right way to handle this situation?		//if (groupBSplines.size() == 1)	//	return infiniteInter;		//Get all the infinite cuts in the group (may include infinite cuts in other groups as well, depending on the useAllInfiniteObjects variable passed in)	vector<BSplineToBSplineCut*> infiniteSolidCuts;	for (int i = 0; i < groupBSplines.size(); i++)	//Loop through the group		for (int j = 0; j < bsplinePairCuts.size(); j++)	//Loop through all of the drawing's cuts (not very efficient)			if (bsplinePairCuts[j]->GetBsp1() == groupBSplines[i] && !bsplinePairCuts[j]->GetBsp2())			{				infiniteSolidCuts.push_back(bsplinePairCuts[j]);				break;			}	/*		//Get all the infinite cuts	vector<BSplineToBSplineCut*> infiniteSolidCuts;	for (int j = 0; j < bsplinePairCuts.size(); j++)	//Loop through all of the drawing's cuts (not very efficient)		if (!bsplinePairCuts[j]->GetBsp2())			infiniteSolidCuts.push_back(bsplinePairCuts[j]);	*/		MyAssert(infiniteSolidCuts.size() > 0);		if (infiniteSolidCuts.size() == 1)		return infiniteInter;		//Find this cut in the list	int thisCutIndex = 0;	for (thisCutIndex = 0; thisCutIndex < infiniteSolidCuts.size(); thisCutIndex++)		if (infiniteSolidCuts[thisCutIndex] == infiniteInter->GetCut())			break;	MyAssert(thisCutIndex < infiniteSolidCuts.size());		//Find the vertical window position of this cut	int thisCutHeight = infiniteSolidCuts[thisCutIndex]->GetStart().v;		//Determine whether this cut is at the top of the vertically sorted list of inifinite cuts	bool atTop = true;	for (int i = 0; i < infiniteSolidCuts.size(); i++)	{		if (i == thisCutIndex)			continue;				int cutHeight = infiniteSolidCuts[i]->GetStart().v;		int diffCutHeight = thisCutHeight - cutHeight;		if (diffCutHeight > 0)			atTop = false;	}		//Find the cut directly above this cut, or loop around to the bottom if this cut is at the top	int minDiffCut = -1;	if (!atTop)	{		float minDiffCutHeight = 999999;		for (int i = 0; i < infiniteSolidCuts.size(); i++)		{			if (i == thisCutIndex)				continue;						int cutHeight = infiniteSolidCuts[i]->GetStart().v;			int diffCutHeight = thisCutHeight - cutHeight;						if (diffCutHeight >= 0 && diffCutHeight < minDiffCutHeight)			{				minDiffCut = i;				minDiffCutHeight = diffCutHeight;			}		}	}	else	//at top, find lowest cut in the drawing	{		float maxCutHeight = -999999;		for (int i = 0; i < infiniteSolidCuts.size(); i++)		{			if (i == thisCutIndex)				continue;						int cutHeight = infiniteSolidCuts[i]->GetStart().v;						if (cutHeight > maxCutHeight)			{				minDiffCut = i;				maxCutHeight = cutHeight;			}		}	}		MyAssert(minDiffCut != -1);	GenericIntersection* lastInter = infiniteSolidCuts[minDiffCut]->GetLastIntersection();	MyAssert(lastInter->GetType() == GenericIntersection::BSP_CUT_T);	MyAssert(lastInter->GetLocation().h < 0);	return (BspCutTIntersection*)lastInter;}BspCutTIntersection* Drawing::FindPrevInfiniteSolidCut(BspCutTIntersection* infiniteInter, bool useAllInfiniteObjects){	MyAssert(!infiniteInter->GetBsp());		//Find the BSpline at the beginning of the cut	MyAssert(infiniteInter->GetCut()->GetNumIntersections() > 0);	BSpline* bsp = ((BspCutTIntersection*)infiniteInter->GetCut()->GetFirstIntersection())->GetBsp();	MyAssert(bsp);		vector<BSpline*> groupBSplines;	if (!useAllInfiniteObjects)	{		//Get all the BSplines in this group		GetBSplinesInGroupFromBSpline(bsp, groupBSplines);		}	else	{		if (wholeObjects.size() > 0)			//Loop through the whole objects			for (vector<WholeObject*>::iterator i = wholeObjects.begin(); i != wholeObjects.end(); i++)			{				int groupSize = (*i)->bsplines.size();				MyAssert(groupSize > 0);								if ((*i)->bgDepths.size() > 0)	//Only accept infinite objects					for (int k = 0; k < groupSize; k++)						groupBSplines.push_back((*i)->bsplines[k]);			}	}		if (groupBSplines.size() == 0)		return infiniteInter;	//Is this the right way to handle this situation?		//if (groupBSplines.size() == 1)	//	return infiniteInter;		//Get all the infinite cuts in the group (may include infinite cuts in other groups as well, depending on the useAllInfiniteObjects variable passed in)	vector<BSplineToBSplineCut*> infiniteSolidCuts;	for (int i = 0; i < groupBSplines.size(); i++)	//Loop through the group		for (int j = 0; j < bsplinePairCuts.size(); j++)	//Loop through all of the drawing's cuts (not very efficient)			if (bsplinePairCuts[j]->GetBsp1() == groupBSplines[i] && !bsplinePairCuts[j]->GetBsp2())			{				infiniteSolidCuts.push_back(bsplinePairCuts[j]);				break;			}	/*		//Get all the infinite cuts	vector<BSplineToBSplineCut*> infiniteSolidCuts;	for (int j = 0; j < bsplinePairCuts.size(); j++)	//Loop through all of the drawing's cuts (not very efficient)		if (!bsplinePairCuts[j]->GetBsp2())			infiniteSolidCuts.push_back(bsplinePairCuts[j]);	*/		MyAssert(infiniteSolidCuts.size() > 0);		if (infiniteSolidCuts.size() == 1)		return infiniteInter;		//Find this cut in the list	int thisCutIndex = 0;	for (thisCutIndex = 0; thisCutIndex < infiniteSolidCuts.size(); thisCutIndex++)		if (infiniteSolidCuts[thisCutIndex] == infiniteInter->GetCut())			break;	MyAssert(thisCutIndex < infiniteSolidCuts.size());		//Find the vertical window position of this cut	int thisCutHeight = infiniteSolidCuts[thisCutIndex]->GetStart().v;		//Determine whether this cut is at the bottom of the vertically sorted list of inifinite cuts	bool atBottom = true;	for (int i = 0; i < infiniteSolidCuts.size(); i++)	{		if (i == thisCutIndex)			continue;				int cutHeight = infiniteSolidCuts[i]->GetStart().v;		int diffCutHeight = thisCutHeight - cutHeight;		if (diffCutHeight < 0)			atBottom = false;	}		//Find the cut directly below this cut, or loop around to the top if this cut is at the bottom	int minDiffCut = -1;	if (!atBottom)	{		float minDiffCutHeight = 999999;		for (int i = 0; i < infiniteSolidCuts.size(); i++)		{			if (i == thisCutIndex)				continue;						int cutHeight = infiniteSolidCuts[i]->GetStart().v;			int diffCutHeight = cutHeight - thisCutHeight;						if (diffCutHeight >= 0 && diffCutHeight < minDiffCutHeight)			{				minDiffCut = i;				minDiffCutHeight = diffCutHeight;			}		}	}	else	//at bottom, find the highest cut in the drawing	{		float minCutHeight = 999999;		for (int i = 0; i < infiniteSolidCuts.size(); i++)		{			if (i == thisCutIndex)				continue;						int cutHeight = infiniteSolidCuts[i]->GetStart().v;						if (cutHeight < minCutHeight)			{				minDiffCut = i;				minCutHeight = cutHeight;			}		}	}		MyAssert(minDiffCut != -1);	GenericIntersection* lastInter = infiniteSolidCuts[minDiffCut]->GetLastIntersection();	MyAssert(lastInter->GetType() == GenericIntersection::BSP_CUT_T);	MyAssert(lastInter->GetLocation().h < 0);	return (BspCutTIntersection*)lastInter;}int Drawing::FindInfiniteWOsectionForInter(BspCutTIntersection* infiniteInter, WholeObject* wholeObject){	if (infiniteInter->GetLocation().h > -999998)		return -1;		if (!wholeObject)	{		for (int i = 0; i < wholeObjects.size(); i++)			for (int j = 0; j < wholeObjects[i]->bspCutTinters.size(); j++)				if (wholeObjects[i]->bspCutTinters[j] == infiniteInter)					return j;		MyAssert(false);	//Should be impossible to get here	}		MyAssert(wholeObject);	for (int j = 0; j < wholeObject->bspCutTinters.size(); j++)		if (wholeObject->bspCutTinters[j] == infiniteInter)			return j;	MyAssert(false);	//Should be impossible to get here}bool Drawing::CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod0(int recursionDepth, int depthAttempt, FloatPoint intersectionLoc, int traversalBSplineIndex,															vector<int> touchedBSplineIndexes, Drawing*& minDeltaLeaf,															int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,															bool& timeLimitReached){	MyAssert(gCompanionSetMethod == 0);	MyAssert(!timeLimitReached);		Rect r;	if (gDebug)	{		SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(blackColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qMethod0 = 1;	}		sTreeWalk++;	if (gDebug12)	{		if (sTreeWalk % 1000 == 0)		{			InitAnalysisWindow();						MoveTo(gTextH++ * 7 + 5, gTextV * 10 + 5);			DrawString("\pе");						GetPortBounds(GetWindowPort(gAnalysisWindow), &r);			if (gTextH * 7 + 5 > r.right - 10)			{				gTextH = 0;				IncrementTextV();			}						QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);			SetPort(GetWindowPort(gMainWindow->GetWindow()));		}	}		//See if the time has expired	if (sTreeWalk % 100 == 0)	{		clock_t presentTime = clock();		clock_t elapsedTime = presentTime - labelingStartTime;		clock_t elapsedTimeSeconds = elapsedTime / CLOCKS_PER_SEC;		if ((elapsedTimeSeconds > labelAttemptWithSolutionTimeLimitSeconds * gTimeLimitScalar && minFlipDelta != 999999) ||			(elapsedTimeSeconds > labelAttemptWithoutSolutionTimeLimitSeconds * gTimeLimitScalar && minFlipDelta == 999999))		{			timeLimitReached = true;						if (gDebug5)			{				bool secondTimeLimit = (elapsedTimeSeconds > labelAttemptWithoutSolutionTimeLimitSeconds * gTimeLimitScalar);								InitAnalysisWindow();								IncrementTextV();				MoveTo(5, IncrementTextV() * 10 + 5);				TextFace(bold);				!secondTimeLimit ? DrawString("\pFirst time limit expired") : DrawString("\pSecond time limit expired");				TextFace(0);				gTextH = 0;								QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);				SetPort(GetWindowPort(gMainWindow->GetWindow()));			}						return false;		}	}		//See if the labeling attempt should be terminated	if (sTreeWalk % 100 == 0)		if (!TestForMouseTermination())		{			timeLimitReached = true;			return false;		}		//Find the intersection based on the passed in location	GenericIntersection* intersection = NULL;	for (int i = 0; i < intersections.size(); i++)		if (intersections[i]->GetLocation() == intersectionLoc)		{			intersection = intersections[i];			break;		}	MyAssert(intersection);		//Find the bspline based on the passed in index	BSpline* traversalBSpline = bsplines[traversalBSplineIndex];		//Find the curve and seg of the intersection on the bspline.	//Also find the crossing boundary.	BSpline *crossBSpline = NULL;	BSplineToBSplineCut *crossCut = NULL;	int cv, sg;	switch (intersection->GetType())	{		case GenericIntersection::BSP_BSP:			BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;			crossBSpline = bspBspInter->GetOtherBsp(traversalBSpline);						if (!intersection->SelfIntersection())			{				if (bspBspInter->GetBsp1() == traversalBSpline)				{					cv = bspBspInter->GetCv1();					sg = bspBspInter->GetSg1();				}				else				{					cv = bspBspInter->GetCv2();					sg = bspBspInter->GetSg2();				}			}			else	//self intersection			{				//First thing to do, if this is a self intersection, is figure out which of the two crossing edges we're on				bool topIn = traversalBSpline->GetSectionDepthConstraintBeforeIntersection(intersection, bspBspInter->GetCv1(), bspBspInter->GetSg1());				bool topOut = traversalBSpline->GetSectionDepthConstraintAfterIntersection(intersection, bspBspInter->GetCv1(), bspBspInter->GetSg1());				bool bottomIn = traversalBSpline->GetSectionDepthConstraintBeforeIntersection(intersection, bspBspInter->GetCv2(), bspBspInter->GetSg2());				bool bottomOut = traversalBSpline->GetSectionDepthConstraintAfterIntersection(intersection, bspBspInter->GetCv2(), bspBspInter->GetSg2());								//We must be on the unconstrained out-going edge								bool topEdge = false;								if (!topIn && !topOut && !bottomIn && !bottomOut)				{					//Arbitrary, so go with the earlier edge (can only occur when the traversal starts from this intersection)					if (bspBspInter->GetCv1() < bspBspInter->GetCv2())						topEdge = true;					else if (bspBspInter->GetCv1() == bspBspInter->GetCv2() && bspBspInter->GetSg1() < bspBspInter->GetSg2())						topEdge = true;					else topEdge = false;				}				else if (topIn && !topOut && !bottomIn && !bottomOut)				{					//Top is unfinished in to out					topEdge = true;				}				else if (!topIn && !topOut && bottomIn && !bottomOut)				{					//Bottom is unfinished in to out					topEdge = false;				}				else if (topIn && !topOut && !bottomIn && bottomOut)				{					//Top is unfinished in to out					topEdge = true;				}				else if (!topIn && topOut && bottomIn && !bottomOut)				{					//Bottom is unfinished in to out					topEdge = false;				}				else if (topIn && !topOut && bottomIn && bottomOut)				{					//Top is unfinished in to out					topEdge = true;				}				else if (topIn && topOut && bottomIn && !bottomOut)				{					//Bottom is unfinished in to out					topEdge = false;				}				else if (topIn && topOut && bottomIn && bottomOut)				{					//Arbitrary, so go with the earlier edge (can only occur when the traversal starts from this intersection)					if (bspBspInter->GetCv1() < bspBspInter->GetCv2())						topEdge = true;					else if (bspBspInter->GetCv1() == bspBspInter->GetCv2() && bspBspInter->GetSg1() < bspBspInter->GetSg2())						topEdge = true;					else topEdge = false;				}				else MyAssert(false);								if (topEdge)				{					cv = bspBspInter->GetCv1();					sg = bspBspInter->GetSg1();				}				else	//bottom edge				{					cv = bspBspInter->GetCv2();					sg = bspBspInter->GetSg2();				}			}			break;		case GenericIntersection::BSP_CUT:			crossCut = ((BspCutIntersection*)intersection)->GetCut();			cv = ((BspCutIntersection*)intersection)->GetCv();			sg = ((BspCutIntersection*)intersection)->GetSg();			break;		case GenericIntersection::BSP_CUT_T:			crossCut = ((BspCutTIntersection*)intersection)->GetCut();			cv = ((BspCutTIntersection*)intersection)->GetCv();			sg = ((BspCutTIntersection*)intersection)->GetSg();			break;		case GenericIntersection::CUT_CUT:			MyAssert(false);			break;	}		//Update the lists of touched BSplines and Cuts	int bsp1Index = GetBSplineIndex(traversalBSpline);	int bsp2Index = crossBSpline ? GetBSplineIndex(crossBSpline) : -1;	int cutIndex = crossCut ? GetCutIndex(crossCut) : -1;		if (bsp2Index != -1)		UpdateTouchedBSplines(bsp2Index, touchedBSplineIndexes);	if (cutIndex != -1)	{		MyAssert(crossCut);		BSpline* crossCutBsp = crossCut->GetBsp1();		int crossCutBspIndex = GetBSplineIndex(crossCutBsp);		MyAssert(crossCutBsp->GetFirstIntersection() != NULL);		UpdateTouchedBSplines(crossCutBspIndex, touchedBSplineIndexes);	}		//Remember the prev constraint	bool prevInterConst = intersection->GetHardConstraint();		//If the intersection is hard constrained, there is only one child, and therefore no branching in the tree	int numChildren = (prevInterConst || intersection->GetPermanentHardConstraint()) ? 1 : 2;		intersection->SetHardConstraint(true);	//However, T junction intersections don't have "tops" and "bottoms"	if (intersection->GetType() == GenericIntersection::BSP_CUT_T)	{		MyAssert(!crossBSpline);		numChildren = 1;	}		//Can't flip an intersection that is beyond the horizon.	//The inter dist vector is already sorted in increasing order of dist, so just search the list up to the horizon and see if the intersection is found in that range of the list.	if (gTreeSearchMethod == 1)	{		int interDistIdx = 0;		while (interDistIdx < gInterDists.size() && gInterDists[interDistIdx].first != intersection && gInterDists[interDistIdx].second <= gHorizon)			interDistIdx++;		if (interDistIdx < gInterDists.size() && gInterDists[interDistIdx].second > gHorizon)			numChildren = 1;	}		//Child 0: no change, don't constrain companions	//Child 1: flip intersection, don't constrain companions	bool betterSolutionFound = false;	bool prevSectionConst;	bool interFlipped = false;	for (int child = 0; child < numChildren; child++)	{		if (child == 1)	//Flip the intersection, but don't flip its companions		{			//Remember the depth constraint			prevSectionConst = traversalBSpline->GetSectionDepthConstraintAfterIntersection(intersection, cv, sg);						//Flip the the intersection			traversalBSpline->SetSectionDepthConstraintAfterIntersection(intersection, cv, sg, false);			intersection->FlipTopBottom();			interFlipped = true;						if (find(brandNewIntersections.begin(), brandNewIntersections.end(), intersection) == brandNewIntersections.end())				accumFlipDelta++;						if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)//еее(accumFlipDelta > minFlipDelta || (accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))			{				if (gDebug)				{					SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));					ForeColor(yellowColor);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qMethod0 = 1;				}								break;			}						if (gDebug)			{				SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));				ForeColor(greenColor);				FrameRect(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qMethod0 = 1;			}		}				int occludedEdge = intersection->DetermineOccludedEdge();				//Make sure things seem clean		if (intersection->GetType() == GenericIntersection::BSP_BSP)		{			MyAssert(occludedEdge == 3 || occludedEdge == 4);			MyAssert(((BspBspIntersection*)intersection)->GetBsp1() == traversalBSpline ||					((BspBspIntersection*)intersection)->GetBsp2() == traversalBSpline);		}		else if (intersection->GetType() == GenericIntersection::BSP_CUT)			MyAssert(((BspCutIntersection*)intersection)->GetBsp() == traversalBSpline);		else if (intersection->GetType() == GenericIntersection::BSP_CUT_T)			MyAssert(((BspCutTIntersection*)intersection)->GetBsp() == traversalBSpline);				//Determine the section depth before the intersection on the traversal BSpline		int beforeDepth;		if (depthAttempt == -1)	//In the middle of a boundary traversal, so just read the depth off			beforeDepth = traversalBSpline->GetSectionDepthBeforeIntersection(intersection, cv, sg);		else	//Starting a boundary traversal, need to enumerate the possible starting depths		{			switch (intersection->GetType())			{				case GenericIntersection::BSP_BSP:					if (!intersection->SelfIntersection())					{						MyAssert(occludedEdge == 3 || occludedEdge == 4);						if (((BspBspIntersection*)intersection)->GetBsp1() == traversalBSpline)							beforeDepth = depthAttempt;	//BSpline is on top						else if (occludedEdge == 3)							beforeDepth = depthAttempt + 1;	//Before depth is occluded						else beforeDepth = depthAttempt;	//After depth is occluded					}					else	//еее Not sure about this					{						bool onTop = (((BspBspIntersection*)intersection)->GetCv1() == cv && ((BspBspIntersection*)intersection)->GetSg1() == sg);						if (onTop)							beforeDepth = depthAttempt;						else if (occludedEdge == 3)							beforeDepth = depthAttempt + 1;	//Before depth is occluded						else beforeDepth = depthAttempt;	//After depth is occluded					}					break;				case GenericIntersection::BSP_CUT:					MyAssert(occludedEdge == -1 || occludedEdge == 1 || occludedEdge == 2);					beforeDepth = depthAttempt;					break;				case GenericIntersection::BSP_CUT_T:					beforeDepth = depthAttempt;					break;				case GenericIntersection::CUT_CUT:					MyAssert(false);					break;			}		}				bool turnedCorner = false;				//If the propagation is entering a T junction from a BSpline it is necessary to turn into the Cut instead of continuing along the BSpline		if (intersection->GetType() == GenericIntersection::BSP_CUT_T)		{			//if (((BspCutTIntersection*)intersection)->GetCut()->GetBsp2())			{				if (!timeLimitReached && HandleBSplinePropagationTurnIntoCut(recursionDepth /*DEBUG*/, intersection,																				traversalBSpline, touchedBSplineIndexes,																				cv, sg, beforeDepth,																				minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																				timeLimitReached))					betterSolutionFound = true;				turnedCorner = true;			}		}				if (!turnedCorner)		{			//See if the depth constraint on the far side of the intersection will allow the depth to propagate through			if (!traversalBSpline->GetSectionDepthConstraintAfterIntersection(intersection, cv, sg))			{				if (!timeLimitReached && HandleBSplinePropagation(recursionDepth, child,																	intersection, traversalBSplineIndex, touchedBSplineIndexes,																	cv, sg, beforeDepth,																	minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																	timeLimitReached))					betterSolutionFound = true;			}			else	//Can't propagate, so check legality			{				if (!timeLimitReached && HandleBSplinePropagationEnd(recursionDepth, child,																		intersection, traversalBSplineIndex, touchedBSplineIndexes,																		cv, sg, beforeDepth,																		minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																		timeLimitReached))					betterSolutionFound = true;			}		}				//Undo the change		if (child == 1)		{			traversalBSpline->SetSectionDepthConstraintAfterIntersection(intersection, cv, sg, prevSectionConst);			intersection->FlipTopBottom();			interFlipped = false;		}	}		//Undo the change	intersection->SetHardConstraint(prevInterConst);	if (interFlipped)	{		traversalBSpline->SetSectionDepthConstraintAfterIntersection(intersection, cv, sg, prevSectionConst);		intersection->FlipTopBottom();	}		if (gDebug)	{		SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		if (betterSolutionFound)			ForeColor(greenColor);		else ForeColor(yellowColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qMethod0 = 1;				SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(whiteColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(whiteColor);		FrameRect(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		if (betterSolutionFound)		MyAssert(minDeltaLeaf);	return betterSolutionFound;}bool Drawing::CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod1(int recursionDepth, int depthAttempt, FloatPoint intersectionLoc, int traversalBSplineIndex,															vector<int> touchedBSplineIndexes, Drawing*& minDeltaLeaf,															int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,															bool& timeLimitReached){	MyAssert(gCompanionSetMethod == 1);	MyAssert(!timeLimitReached);		Rect r;	if (gDebug)	{		SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(blackColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qMethod1 = 1;	}		sTreeWalk++;	if (gDebug12)	{		if (sTreeWalk % 1000 == 0)		{			InitAnalysisWindow();						MoveTo(gTextH++ * 7 + 5, gTextV * 10 + 5);			DrawString("\pе");						GetPortBounds(GetWindowPort(gAnalysisWindow), &r);			if (gTextH * 7 + 5 > r.right - 10)			{				gTextH = 0;				IncrementTextV();			}						QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);			SetPort(GetWindowPort(gMainWindow->GetWindow()));		}	}		//See if the time has expired	if (sTreeWalk % 100 == 0)	{		clock_t presentTime = clock();		clock_t elapsedTime = presentTime - labelingStartTime;		clock_t elapsedTimeSeconds = elapsedTime / CLOCKS_PER_SEC;		if ((elapsedTimeSeconds > labelAttemptWithSolutionTimeLimitSeconds * gTimeLimitScalar && minFlipDelta != 999999) ||			(elapsedTimeSeconds > labelAttemptWithoutSolutionTimeLimitSeconds * gTimeLimitScalar && minFlipDelta == 999999))		{			timeLimitReached = true;						if (gDebug5)			{				bool secondTimeLimit = (elapsedTimeSeconds > labelAttemptWithoutSolutionTimeLimitSeconds * gTimeLimitScalar);								InitAnalysisWindow();								IncrementTextV();				MoveTo(5, IncrementTextV() * 10 + 5);				TextFace(bold);				!secondTimeLimit ? DrawString("\pFirst time limit expired") : DrawString("\pSecond time limit expired");				TextFace(0);				gTextH = 0;								QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);				SetPort(GetWindowPort(gMainWindow->GetWindow()));			}						return false;		}	}		//See if the labeling attempt should be terminated	if (sTreeWalk % 100 == 0)		if (!TestForMouseTermination())		{			timeLimitReached = true;			return false;		}		//Find the intersection based on the passed in location	GenericIntersection* intersection = NULL;	for (int i = 0; i < intersections.size(); i++)		if (intersections[i]->GetLocation() == intersectionLoc)		{			intersection = intersections[i];			break;		}	MyAssert(intersection);		//Find the bspline based on the passed in index	BSpline* traversalBSpline = bsplines[traversalBSplineIndex];		//Find the curve and seg of the intersection on the bspline.	//Also find the crossing boundary.	BSpline *crossBSpline = NULL;	BSplineToBSplineCut *crossCut = NULL;	int cv, sg;	switch (intersection->GetType())	{		case GenericIntersection::BSP_BSP:			BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;			crossBSpline = bspBspInter->GetOtherBsp(traversalBSpline);						if (!intersection->SelfIntersection())			{				if (bspBspInter->GetBsp1() == traversalBSpline)				{					cv = bspBspInter->GetCv1();					sg = bspBspInter->GetSg1();				}				else				{					cv = bspBspInter->GetCv2();					sg = bspBspInter->GetSg2();				}			}			else	//self intersection			{				//First thing to do, if this is a self intersection, is figure out which of the two crossing edges we're on				bool topIn = traversalBSpline->GetSectionDepthConstraintBeforeIntersection(intersection, bspBspInter->GetCv1(), bspBspInter->GetSg1());				bool topOut = traversalBSpline->GetSectionDepthConstraintAfterIntersection(intersection, bspBspInter->GetCv1(), bspBspInter->GetSg1());				bool bottomIn = traversalBSpline->GetSectionDepthConstraintBeforeIntersection(intersection, bspBspInter->GetCv2(), bspBspInter->GetSg2());				bool bottomOut = traversalBSpline->GetSectionDepthConstraintAfterIntersection(intersection, bspBspInter->GetCv2(), bspBspInter->GetSg2());								//We must be on the unconstrained out-going edge								bool topEdge = false;								if (!topIn && !topOut && !bottomIn && !bottomOut)				{					//Arbitrary, so go with the earlier edge (can only occur when the traversal starts from this intersection)					if (bspBspInter->GetCv1() < bspBspInter->GetCv2())						topEdge = true;					else if (bspBspInter->GetCv1() == bspBspInter->GetCv2() && bspBspInter->GetSg1() < bspBspInter->GetSg2())						topEdge = true;					else topEdge = false;				}				else if (topIn && !topOut && !bottomIn && !bottomOut)				{					//Top is unfinished in to out					topEdge = true;				}				else if (!topIn && !topOut && bottomIn && !bottomOut)				{					//Bottom is unfinished in to out					topEdge = false;				}				else if (topIn && !topOut && !bottomIn && bottomOut)				{					//Top is unfinished in to out					topEdge = true;				}				else if (!topIn && topOut && bottomIn && !bottomOut)				{					//Bottom is unfinished in to out					topEdge = false;				}				else if (topIn && !topOut && bottomIn && bottomOut)				{					//Top is unfinished in to out					topEdge = true;				}				else if (topIn && topOut && bottomIn && !bottomOut)				{					//Bottom is unfinished in to out					topEdge = false;				}				else if (topIn && topOut && bottomIn && bottomOut)				{					//Arbitrary, so go with the earlier edge (can only occur when the traversal starts from this intersection)					if (bspBspInter->GetCv1() < bspBspInter->GetCv2())						topEdge = true;					else if (bspBspInter->GetCv1() == bspBspInter->GetCv2() && bspBspInter->GetSg1() < bspBspInter->GetSg2())						topEdge = true;					else topEdge = false;				}				else MyAssert(false);								if (topEdge)				{					cv = bspBspInter->GetCv1();					sg = bspBspInter->GetSg1();				}				else	//bottom edge				{					cv = bspBspInter->GetCv2();					sg = bspBspInter->GetSg2();				}			}			break;		case GenericIntersection::BSP_CUT:			crossCut = ((BspCutIntersection*)intersection)->GetCut();			cv = ((BspCutIntersection*)intersection)->GetCv();			sg = ((BspCutIntersection*)intersection)->GetSg();			break;		case GenericIntersection::BSP_CUT_T:			crossCut = ((BspCutTIntersection*)intersection)->GetCut();			cv = ((BspCutTIntersection*)intersection)->GetCv();			sg = ((BspCutTIntersection*)intersection)->GetSg();			break;		case GenericIntersection::CUT_CUT:			MyAssert(false);			break;	}		//Update the lists of touched BSplines and Cuts	int bsp1Index = GetBSplineIndex(traversalBSpline);	int bsp2Index = crossBSpline ? GetBSplineIndex(crossBSpline) : -1;	int cutIndex = crossCut ? GetCutIndex(crossCut) : -1;		if (bsp2Index != -1)		UpdateTouchedBSplines(bsp2Index, touchedBSplineIndexes);	if (cutIndex != -1)	{		MyAssert(crossCut);		BSpline* crossCutBsp = crossCut->GetBsp1();		int crossCutBspIndex = GetBSplineIndex(crossCutBsp);		MyAssert(crossCutBsp->GetFirstIntersection() != NULL);		UpdateTouchedBSplines(crossCutBspIndex, touchedBSplineIndexes);	}		//Remember the prev constraint	bool prevInterConst = intersection->GetHardConstraint();		//If the intersection is hard constrained, there is only two child, not four	bool childrenMask[4] = { true, true, true, true };	if (prevInterConst || intersection->GetPermanentHardConstraint())		childrenMask[1] = childrenMask[3] = false;	//int numChildren = (prevInterConst || intersection->GetPermanentHardConstraint()) ? 2 : 4;	//If constrained, only try two children, those that don't flip	//int childIncrement = (prevInterConst || intersection->GetPermanentHardConstraint()) ? 2 : 1;	//If constrained, do child 0 followed by child 2.  Otherwise do all 4 in order.		intersection->SetHardConstraint(true);	//However, T junction intersections don't have "tops" and "bottoms"	if (intersection->GetType() == GenericIntersection::BSP_CUT_T)	{		MyAssert(!crossBSpline);		childrenMask[0] = childrenMask[1] = childrenMask[3] = false;		MyAssert(childrenMask[2]);		//childIncrement = 2;	}		//Find the companion set.  If there isn't one, set the index to -1.	MyAssert(interCompanionPairSets.size() == 0);	int compSetIndex = -1;	bool foundIt = false;	/*	for (compSetIndex = 0; compSetIndex < interCompanionPairSets.size(); compSetIndex++)	{		for (int i = 0; i < interCompanionPairSets[compSetIndex]->size(); i++)			if ((*interCompanionPairSets[compSetIndex])[i].first == intersection || (*interCompanionPairSets[compSetIndex])[i].second == intersection)			{				foundIt = true;				break;			}		if (foundIt)			break;	}	*/	//Find the companion set for the intersection	for (compSetIndex = 0; compSetIndex < interCompanionSets.size(); compSetIndex++)	//Loop through the sets		if (find(interCompanionSets[compSetIndex]->begin(), interCompanionSets[compSetIndex]->end(), intersection) != interCompanionSets[compSetIndex]->end())		{			foundIt = true;			break;		}		if (foundIt)		MyAssert(compSetIndex < interCompanionSets.size());//interCompanionPairSets.size());	else if (compSetIndex == interCompanionSets.size())//interCompanionPairSets.size())	{		compSetIndex = -1;		childrenMask[0] = childrenMask[1] = false;	//If there are no companions, skip the two companion related children		//numChildren = 2;	}		//Find out if the companion set is going to be flipped.  The only way this wouldn't happen is if the companion set is already constrained.	//All the companions should be unconstrained or constrained, not a mix (with the exception of the present intersection).	bool atLeastOneCompUnconstrained = false, atLeastOneCompConstrained = false;	vector<GenericIntersection*> compSetInters;	if (compSetIndex != -1)	{		compSetInters = *interCompanionSets[compSetIndex];		for (vector<GenericIntersection*>::iterator i = compSetInters.begin(); i != compSetInters.end(); i++)			if (*i == intersection)			{				compSetInters.erase(i);				break;			}		/*		for (int i = 0; i < interCompanionPairSets[compSetIndex]->size(); i++)		{			GenericIntersection* inter1 = (*interCompanionPairSets[compSetIndex])[i].first;			GenericIntersection* inter2 = (*interCompanionPairSets[compSetIndex])[i].second;						if (inter1 != intersection)				if (inter1->GetHardConstraint() || inter1->GetPermanentHardConstraint())					atLeastOneCompConstrained = true;				else atLeastOneCompUnconstrained = true;						if (inter2 != intersection)				if (inter2->GetHardConstraint() || inter2->GetPermanentHardConstraint())					atLeastOneCompConstrained = true;				else atLeastOneCompUnconstrained = true;		}		*/		//Not necessarily true MyAssert(!atLeastOneCompConstrained || !atLeastOneCompUnconstrained);		for (int i = 0; i < compSetInters.size(); i++)		{			GenericIntersection* inter1 = compSetInters[i];			if (inter1 != intersection)				if (inter1->GetHardConstraint() || inter1->GetPermanentHardConstraint())					atLeastOneCompConstrained = true;				else atLeastOneCompUnconstrained = true;		}		MyAssert(!atLeastOneCompConstrained || !atLeastOneCompUnconstrained);		/*		//Find the minimal set of unique intersections in the companion set (intersections can be present in the set either once or twice)		for (int i = 0; i < interCompanionPairSets[compSetIndex]->size(); i++)		{			if ((*interCompanionPairSets[compSetIndex])[i].first != intersection &&				find(compSetInters.begin(), compSetInters.end(), (*interCompanionPairSets[compSetIndex])[i].first) == compSetInters.end())				compSetInters.push_back((*interCompanionPairSets[compSetIndex])[i].first);			if ((*interCompanionPairSets[compSetIndex])[i].second != intersection &&				find(compSetInters.begin(), compSetInters.end(), (*interCompanionPairSets[compSetIndex])[i].second) == compSetInters.end())				compSetInters.push_back((*interCompanionPairSets[compSetIndex])[i].second);		}		*/	}		//Can't flip an intersection that is beyond the horizon.	//The inter dist vector is already sorted in increasing order of dist, so just search the list up to the horizon and see if the intersection is found in that range of the list.	if (gTreeSearchMethod == 1)	{		int interDistIdx = 0;		while (interDistIdx < gInterDists.size() && gInterDists[interDistIdx].first != intersection && gInterDists[interDistIdx].second <= gHorizon)			interDistIdx++;		if (interDistIdx < gInterDists.size() && gInterDists[interDistIdx].second > gHorizon)			childrenMask[1] = childrenMask[3] = false;	//Beyond the horizon, skip the two flipping related children			//childIncrement = 1;	}		MyAssert(childrenMask[2]);	//This is kind of the default child, it should always occur		//Child 0: no change, constrain companions	//Child 1: flip intersection and companions, constrain companions	//Child 2: no change, don't constrain companions	//Child 3: flip intersection, don't flip companions, don't constrain companions	bool betterSolutionFound = false;	bool prevSectionConst;	int originalAccumDelta = accumFlipDelta;	bool interFlipped = false;	for (int child = 0; child < 4/*numChildren*/; child += 1/*childIncrement*/)	{		if (gDebug)		{			Str255 str1;						TextSize(12);			TextFace(bold);						if (child != 0)			{				NumToString(child - 1, str1);				ForeColor(whiteColor);				MoveTo(max(intersectionLoc.h, 0.0) + 20, intersectionLoc.v + recursionDepth * 5);				DrawString(str1);			}						NumToString(child, str1);			childrenMask[child] ? ForeColor(blackColor) : ForeColor(cyanColor);			MoveTo(max(intersectionLoc.h, 0.0) + 20, intersectionLoc.v + recursionDepth * 5);			DrawString(str1);						TextFace(0);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						if (childrenMask[child])			{				int qMethod1 = 1;			}		}				if (!childrenMask[child])			continue;				accumFlipDelta = originalAccumDelta;				if (child == 1 || child == 3)	//Flip this intersection		{			//Remember the depth constraint			prevSectionConst = traversalBSpline->GetSectionDepthConstraintAfterIntersection(intersection, cv, sg);						//Flip the the intersection			traversalBSpline->SetSectionDepthConstraintAfterIntersection(intersection, cv, sg, false);			intersection->FlipTopBottom();			interFlipped = true;						if (find(brandNewIntersections.begin(), brandNewIntersections.end(), intersection) == brandNewIntersections.end())				accumFlipDelta++;						if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)//еее(accumFlipDelta > minFlipDelta || (accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))			{				if (gDebug)				{					SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));					ForeColor(yellowColor);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qMethod1 = 1;				}								break;			}						if (gDebug)			{				SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));				ForeColor(greenColor);				FrameRect(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qMethod1 = 1;			}		}				if (child == 1)	//Flip companions if they aren't constrained		{			//If the companion set is going to be flipped, add it to the accumFlipDelta and flip the intersections			if (!atLeastOneCompConstrained && compSetIndex != -1)			{				MyAssert(!prevInterConst);								//Add the comp inters to the accumFlipDelta				accumFlipDelta += compSetInters.size();				if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)//еее(accumFlipDelta > minFlipDelta || (accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))				{					if (gDebug)					{						SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));						ForeColor(blackColor);						FrameRect(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qMethod1 = 1;					}										break;				}								//Flip each intersection in the companion set				for (int i = 0; i < compSetInters.size(); i++)				{					compSetInters[i]->FlipTopBottom();										if (gDebug)					{						FloatPoint interLoc = compSetInters[i]->GetLocation();						SetRect(&r, max(interLoc.h, 0.0) - (recursionDepth + 10), interLoc.v - (recursionDepth + 10), max(interLoc.h, 0.0) + (recursionDepth + 10), interLoc.v + (recursionDepth + 10));						ForeColor(magentaColor);						FrameRect(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qMethod2 = 1;					}				}			}		}				//Constrain all the companions		if (child == 0 || child == 1)			if (!atLeastOneCompConstrained && compSetIndex != -1)			{				for (int i = 0; i < compSetInters.size(); i++)				{					compSetInters[i]->SetHardConstraint(true);										if (gDebug)					{						FloatPoint interLoc = compSetInters[i]->GetLocation();						SetRect(&r, max(interLoc.h, 0.0) - (recursionDepth + 10), interLoc.v - (recursionDepth + 10), max(interLoc.h, 0.0) + (recursionDepth + 10), interLoc.v + (recursionDepth + 10));						ForeColor(redColor);						FrameRect(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qMethod1 = 1;					}				}			}				int occludedEdge = intersection->DetermineOccludedEdge();				//Make sure things seem clean		if (intersection->GetType() == GenericIntersection::BSP_BSP)		{			MyAssert(occludedEdge == 3 || occludedEdge == 4);			MyAssert(((BspBspIntersection*)intersection)->GetBsp1() == traversalBSpline ||					((BspBspIntersection*)intersection)->GetBsp2() == traversalBSpline);		}		else if (intersection->GetType() == GenericIntersection::BSP_CUT)			MyAssert(((BspCutIntersection*)intersection)->GetBsp() == traversalBSpline);		else if (intersection->GetType() == GenericIntersection::BSP_CUT_T)			MyAssert(((BspCutTIntersection*)intersection)->GetBsp() == traversalBSpline);				//Determine the section depth before the intersection on the traversal BSpline		int beforeDepth;		if (depthAttempt == -1)	//In the middle of a boundary traversal, so just read the depth off			beforeDepth = traversalBSpline->GetSectionDepthBeforeIntersection(intersection, cv, sg);		else	//Starting a boundary traversal, need to enumerate the possible starting depths		{			switch (intersection->GetType())			{				case GenericIntersection::BSP_BSP:					MyAssert(occludedEdge == 3 || occludedEdge == 4);					if (((BspBspIntersection*)intersection)->GetBsp1() == traversalBSpline)						beforeDepth = depthAttempt;	//BSpline is on top					else if (occludedEdge == 3)						beforeDepth = depthAttempt + 1;	//Before depth is occluded					else beforeDepth = depthAttempt;	//After depth is occluded					break;				case GenericIntersection::BSP_CUT:					MyAssert(occludedEdge == -1 || occludedEdge == 1 || occludedEdge == 2);					beforeDepth = depthAttempt;					break;				case GenericIntersection::BSP_CUT_T:					beforeDepth = depthAttempt;					break;				case GenericIntersection::CUT_CUT:					MyAssert(false);					break;			}		}				bool turnedCorner = false;				//If the propagation is entering a T junction from a BSpline it is necessary to turn into the Cut instead of continuing along the BSpline		if (intersection->GetType() == GenericIntersection::BSP_CUT_T)		{			//if (((BspCutTIntersection*)intersection)->GetCut()->GetBsp2())			{				if (!timeLimitReached && HandleBSplinePropagationTurnIntoCut(recursionDepth /*DEBUG*/, intersection,																				traversalBSpline, touchedBSplineIndexes,																				cv, sg, beforeDepth,																				minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																				timeLimitReached))					betterSolutionFound = true;				turnedCorner = true;			}		}				if (!turnedCorner)		{			//See if the depth constraint on the far side of the intersection will allow the depth to propagate through			if (!traversalBSpline->GetSectionDepthConstraintAfterIntersection(intersection, cv, sg))			{				if (!timeLimitReached && HandleBSplinePropagation(recursionDepth, child,																	intersection, traversalBSplineIndex, touchedBSplineIndexes,																	cv, sg, beforeDepth,																	minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																	timeLimitReached))					betterSolutionFound = true;			}			else	//Can't propagate, so check legality			{				if (!timeLimitReached && HandleBSplinePropagationEnd(recursionDepth, child,																		intersection, traversalBSplineIndex, touchedBSplineIndexes,																		cv, sg, beforeDepth,																		minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																		timeLimitReached))					betterSolutionFound = true;			}		}				//If the companions were flipped by this child, unflip them		if (!atLeastOneCompConstrained && compSetIndex != -1 && child == 1)		{			//Flip each intersection in the companion set			for (int i = 0; i < compSetInters.size(); i++)			{				compSetInters[i]->FlipTopBottom();								if (gDebug)				{					FloatPoint interLoc = compSetInters[i]->GetLocation();					SetRect(&r, max(interLoc.h, 0.0) - (recursionDepth + 10), interLoc.v - (recursionDepth + 10), max(interLoc.h, 0.0) + (recursionDepth + 10), interLoc.v + (recursionDepth + 10));					ForeColor(whiteColor);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qMethod2 = 1;				}			}		}				//Unconstrain all the companions		if (child == 0 || child == 1)			if (!atLeastOneCompConstrained && compSetIndex != -1)			{				for (int i = 0; i < compSetInters.size(); i++)				{					compSetInters[i]->SetHardConstraint(false);										if (gDebug)					{						FloatPoint interLoc = compSetInters[i]->GetLocation();						SetRect(&r, max(interLoc.h, 0.0) - (recursionDepth + 10), interLoc.v - (recursionDepth + 10), max(interLoc.h, 0.0) + (recursionDepth + 10), interLoc.v + (recursionDepth + 10));						ForeColor(whiteColor);						FrameRect(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qMethod1 = 1;					}				}			}				if (child == 1 || child == 3)		{			traversalBSpline->SetSectionDepthConstraintAfterIntersection(intersection, cv, sg, prevSectionConst);			intersection->FlipTopBottom();			interFlipped = false;		}	}		//Undo the change	intersection->SetHardConstraint(prevInterConst);	if (interFlipped)	{		traversalBSpline->SetSectionDepthConstraintAfterIntersection(intersection, cv, sg, prevSectionConst);		intersection->FlipTopBottom();	}		if (gDebug)	{		SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		if (betterSolutionFound)			ForeColor(greenColor);		else ForeColor(yellowColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qMethod1 = 1;				SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(whiteColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(whiteColor);		FrameRect(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		if (betterSolutionFound)		MyAssert(minDeltaLeaf);	return betterSolutionFound;}bool Drawing::CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod2(int recursionDepth, int depthAttempt, FloatPoint intersectionLoc, int traversalBSplineIndex,															vector<int> touchedBSplineIndexes, Drawing*& minDeltaLeaf,															int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,															bool& timeLimitReached){	MyAssert(gCompanionSetMethod == 2);	MyAssert(!timeLimitReached);		Rect r;	if (gDebug)	{		SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(blackColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qMethod2 = 1;	}		sTreeWalk++;	if (gDebug12)	{		if (sTreeWalk % 1000 == 0)		{			InitAnalysisWindow();						MoveTo(gTextH++ * 7 + 5, gTextV * 10 + 5);			DrawString("\pе");						GetPortBounds(GetWindowPort(gAnalysisWindow), &r);			if (gTextH * 7 + 5 > r.right - 10)			{				gTextH = 0;				IncrementTextV();			}						QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);			SetPort(GetWindowPort(gMainWindow->GetWindow()));		}	}		//See if the time has expired	if (sTreeWalk % 100 == 0)	{		clock_t presentTime = clock();		clock_t elapsedTime = presentTime - labelingStartTime;		clock_t elapsedTimeSeconds = elapsedTime / CLOCKS_PER_SEC;		if ((elapsedTimeSeconds > labelAttemptWithSolutionTimeLimitSeconds * gTimeLimitScalar && minFlipDelta != 999999) ||			(elapsedTimeSeconds > labelAttemptWithoutSolutionTimeLimitSeconds * gTimeLimitScalar && minFlipDelta == 999999))		{			timeLimitReached = true;						if (gDebug5)			{				bool secondTimeLimit = (elapsedTimeSeconds > labelAttemptWithoutSolutionTimeLimitSeconds * gTimeLimitScalar);								InitAnalysisWindow();								IncrementTextV();				MoveTo(5, IncrementTextV() * 10 + 5);				TextFace(bold);				!secondTimeLimit ? DrawString("\pFirst time limit expired") : DrawString("\pSecond time limit expired");				TextFace(0);				gTextH = 0;								QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);				SetPort(GetWindowPort(gMainWindow->GetWindow()));			}						return false;		}	}		//See if the labeling attempt should be terminated	if (sTreeWalk % 100 == 0)		if (!TestForMouseTermination())		{			timeLimitReached = true;			return false;		}		//Find the intersection based on the passed in location	GenericIntersection* intersection = NULL;	for (int i = 0; i < intersections.size(); i++)		if (intersections[i]->GetLocation() == intersectionLoc)		{			intersection = intersections[i];			break;		}	MyAssert(intersection);		//Find the bspline based on the passed in index	BSpline* traversalBSpline = bsplines[traversalBSplineIndex];		//Find the curve and seg of the intersection on the bspline.	//Also find the crossing boundary.	BSpline *crossBSpline = NULL;	BSplineToBSplineCut *crossCut = NULL;	int cv, sg;	switch (intersection->GetType())	{		case GenericIntersection::BSP_BSP:			BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;			crossBSpline = bspBspInter->GetOtherBsp(traversalBSpline);						if (!intersection->SelfIntersection())			{				if (bspBspInter->GetBsp1() == traversalBSpline)				{					cv = bspBspInter->GetCv1();					sg = bspBspInter->GetSg1();				}				else				{					cv = bspBspInter->GetCv2();					sg = bspBspInter->GetSg2();				}			}			else	//self intersection			{				//First thing to do, if this is a self intersection, is figure out which of the two crossing edges we're on				bool topIn = traversalBSpline->GetSectionDepthConstraintBeforeIntersection(intersection, bspBspInter->GetCv1(), bspBspInter->GetSg1());				bool topOut = traversalBSpline->GetSectionDepthConstraintAfterIntersection(intersection, bspBspInter->GetCv1(), bspBspInter->GetSg1());				bool bottomIn = traversalBSpline->GetSectionDepthConstraintBeforeIntersection(intersection, bspBspInter->GetCv2(), bspBspInter->GetSg2());				bool bottomOut = traversalBSpline->GetSectionDepthConstraintAfterIntersection(intersection, bspBspInter->GetCv2(), bspBspInter->GetSg2());								//We must be on the unconstrained out-going edge								bool topEdge = false;								if (!topIn && !topOut && !bottomIn && !bottomOut)				{					//Arbitrary, so go with the earlier edge (can only occur when the traversal starts from this intersection)					if (bspBspInter->GetCv1() < bspBspInter->GetCv2())						topEdge = true;					else if (bspBspInter->GetCv1() == bspBspInter->GetCv2() && bspBspInter->GetSg1() < bspBspInter->GetSg2())						topEdge = true;					else topEdge = false;				}				else if (topIn && !topOut && !bottomIn && !bottomOut)				{					//Top is unfinished in to out					topEdge = true;				}				else if (!topIn && !topOut && bottomIn && !bottomOut)				{					//Bottom is unfinished in to out					topEdge = false;				}				else if (topIn && !topOut && !bottomIn && bottomOut)				{					//Top is unfinished in to out					topEdge = true;				}				else if (!topIn && topOut && bottomIn && !bottomOut)				{					//Bottom is unfinished in to out					topEdge = false;				}				else if (topIn && !topOut && bottomIn && bottomOut)				{					//Top is unfinished in to out					topEdge = true;				}				else if (topIn && topOut && bottomIn && !bottomOut)				{					//Bottom is unfinished in to out					topEdge = false;				}				else if (topIn && topOut && bottomIn && bottomOut)				{					//Arbitrary, so go with the earlier edge (can only occur when the traversal starts from this intersection)					if (bspBspInter->GetCv1() < bspBspInter->GetCv2())						topEdge = true;					else if (bspBspInter->GetCv1() == bspBspInter->GetCv2() && bspBspInter->GetSg1() < bspBspInter->GetSg2())						topEdge = true;					else topEdge = false;				}				else MyAssert(false);								if (topEdge)				{					cv = bspBspInter->GetCv1();					sg = bspBspInter->GetSg1();				}				else	//bottom edge				{					cv = bspBspInter->GetCv2();					sg = bspBspInter->GetSg2();				}			}			break;		case GenericIntersection::BSP_CUT:			crossCut = ((BspCutIntersection*)intersection)->GetCut();			cv = ((BspCutIntersection*)intersection)->GetCv();			sg = ((BspCutIntersection*)intersection)->GetSg();			break;		case GenericIntersection::BSP_CUT_T:			crossCut = ((BspCutTIntersection*)intersection)->GetCut();			cv = ((BspCutTIntersection*)intersection)->GetCv();			sg = ((BspCutTIntersection*)intersection)->GetSg();			break;		case GenericIntersection::CUT_CUT:			MyAssert(false);			break;	}		//Update the lists of touched BSplines and Cuts	int bsp1Index = GetBSplineIndex(traversalBSpline);	int bsp2Index = crossBSpline ? GetBSplineIndex(crossBSpline) : -1;	int cutIndex = crossCut ? GetCutIndex(crossCut) : -1;		if (bsp2Index != -1)		UpdateTouchedBSplines(bsp2Index, touchedBSplineIndexes);	if (cutIndex != -1)	{		MyAssert(crossCut);		BSpline* crossCutBsp = crossCut->GetBsp1();		int crossCutBspIndex = GetBSplineIndex(crossCutBsp);		MyAssert(crossCutBsp->GetFirstIntersection() != NULL);		UpdateTouchedBSplines(crossCutBspIndex, touchedBSplineIndexes);	}		//Remember the prev constraint	bool prevInterConst = intersection->GetHardConstraint();		//If the intersection is hard constrained, there is only one child, and therefore no branching in the tree	int numChildren = (prevInterConst || intersection->GetPermanentHardConstraint()) ? 1 : 2;		intersection->SetHardConstraint(true);	//However, T junction intersections don't have "tops" and "bottoms"	if (intersection->GetType() == GenericIntersection::BSP_CUT_T)	{		MyAssert(!crossBSpline);		numChildren = 1;	}		//Find the companion set	MyAssert(interCompanionPairSets.size() == 0);	int compSetIndex = -1;	bool foundIt = false;	/*	for (compSetIndex = 0; compSetIndex < interCompanionPairSets.size(); compSetIndex++)	{		for (int i = 0; i < interCompanionPairSets[compSetIndex]->size(); i++)			if ((*interCompanionPairSets[compSetIndex])[i].first == intersection || (*interCompanionPairSets[compSetIndex])[i].second == intersection)			{				foundIt = true;				break;			}		if (foundIt)			break;	}	*/	//Find the companion set for the intersection	for (compSetIndex = 0; compSetIndex < interCompanionSets.size(); compSetIndex++)	//Loop through the sets		if (find(interCompanionSets[compSetIndex]->begin(), interCompanionSets[compSetIndex]->end(), intersection) != interCompanionSets[compSetIndex]->end())		{			foundIt = true;			break;		}		if (foundIt)		MyAssert(compSetIndex < interCompanionSets.size());//interCompanionPairSets.size());	else if (compSetIndex == interCompanionSets.size())//interCompanionPairSets.size())	{		compSetIndex = -1;	}		//Find out if the companion set is going to be flipped.  The only way this wouldn't happen is if the companion set is already constrained.	//All the companions should be unconstrained or constrained, not a mix (with the exception of the present intersection).	bool atLeastOneCompUnconstrained = false, atLeastOneCompConstrained = false;	vector<GenericIntersection*> compSetInters;	if (compSetIndex != -1)	{		compSetInters = *interCompanionSets[compSetIndex];		for (vector<GenericIntersection*>::iterator i = compSetInters.begin(); i != compSetInters.end(); i++)			if (*i == intersection)			{				compSetInters.erase(i);				break;			}		/*		for (int i = 0; i < interCompanionPairSets[compSetIndex]->size(); i++)		{			GenericIntersection* inter1 = (*interCompanionPairSets[compSetIndex])[i].first;			GenericIntersection* inter2 = (*interCompanionPairSets[compSetIndex])[i].second;						if (inter1 != intersection)				if (inter1->GetHardConstraint() || inter1->GetPermanentHardConstraint())					atLeastOneCompConstrained = true;				else atLeastOneCompUnconstrained = true;						if (inter2 != intersection)				if (inter2->GetHardConstraint() || inter2->GetPermanentHardConstraint())					atLeastOneCompConstrained = true;				else atLeastOneCompUnconstrained = true;		}		*/		for (int i = 0; i < compSetInters.size(); i++)		{			GenericIntersection* inter1 = compSetInters[i];			if (inter1 != intersection)				if (inter1->GetHardConstraint() || inter1->GetPermanentHardConstraint())					atLeastOneCompConstrained = true;				else atLeastOneCompUnconstrained = true;		}		MyAssert(!atLeastOneCompConstrained || !atLeastOneCompUnconstrained);		/*		//Find the minimal set of unique intersections in the companion set (intersections can be present in the set either once or twice)		for (int i = 0; i < interCompanionPairSets[compSetIndex]->size(); i++)		{			if ((*interCompanionPairSets[compSetIndex])[i].first != intersection &&				find(compSetInters.begin(), compSetInters.end(), (*interCompanionPairSets[compSetIndex])[i].first) == compSetInters.end())				compSetInters.push_back((*interCompanionPairSets[compSetIndex])[i].first);			if ((*interCompanionPairSets[compSetIndex])[i].second != intersection &&				find(compSetInters.begin(), compSetInters.end(), (*interCompanionPairSets[compSetIndex])[i].second) == compSetInters.end())				compSetInters.push_back((*interCompanionPairSets[compSetIndex])[i].second);		}		*/	}		//Can't flip an intersection that is beyond the horizon.	//The inter dist vector is already sorted in increasing order of dist, so just search the list up to the horizon and see if the intersection is found in that range of the list.	if (gTreeSearchMethod == 1)	{		int interDistIdx = 0;		while (interDistIdx < gInterDists.size() && gInterDists[interDistIdx].first != intersection && gInterDists[interDistIdx].second <= gHorizon)			interDistIdx++;		if (interDistIdx < gInterDists.size() && gInterDists[interDistIdx].second > gHorizon)			numChildren = 1;	}		//Child 0: no change, constrain companions	//Child 1: flip intersection and companions, constrain companions	bool betterSolutionFound = false;	bool prevSectionConst;	bool interFlipped = false;	for (int child = 0; child < numChildren; child++)	{		if (child == 1)	//Flip this intersection and its companions		{			//Remember the depth constraint			prevSectionConst = traversalBSpline->GetSectionDepthConstraintAfterIntersection(intersection, cv, sg);						//Flip the the intersection			traversalBSpline->SetSectionDepthConstraintAfterIntersection(intersection, cv, sg, false);			intersection->FlipTopBottom();			interFlipped = true;						if (find(brandNewIntersections.begin(), brandNewIntersections.end(), intersection) == brandNewIntersections.end())				accumFlipDelta++;						if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)//еее(accumFlipDelta > minFlipDelta || (accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))			{				if (gDebug)				{					SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));					ForeColor(yellowColor);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qMethod2 = 1;				}								break;			}						if (gDebug)			{				SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));				ForeColor(greenColor);				FrameRect(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qMethod2 = 1;			}						//If the companion set is going to be flipped, add it to the accumFlipDelta and flip the intersections			if (atLeastOneCompUnconstrained)			{				MyAssert(compSetIndex != -1);								//Add the comp inters to the accumFlipDelta				accumFlipDelta += compSetInters.size();				if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)//еее(accumFlipDelta > minFlipDelta || (accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))				{					if (gDebug)					{						SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));						ForeColor(blackColor);						FrameRect(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qMethod2 = 1;					}										break;				}								//Flip each intersection in the companion set				for (int i = 0; i < compSetInters.size(); i++)				{					compSetInters[i]->FlipTopBottom();										if (gDebug)					{						FloatPoint interLoc = compSetInters[i]->GetLocation();						SetRect(&r, max(interLoc.h, 0.0) - (recursionDepth + 10), interLoc.v - (recursionDepth + 10), max(interLoc.h, 0.0) + (recursionDepth + 10), interLoc.v + (recursionDepth + 10));						ForeColor(magentaColor);						FrameRect(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qMethod2 = 1;					}				}			}		}				//Constrain all the companions		if (atLeastOneCompUnconstrained)		{			MyAssert(compSetIndex != -1);			for (int i = 0; i < compSetInters.size(); i++)			{				compSetInters[i]->SetHardConstraint(true);								if (gDebug)				{					FloatPoint interLoc = compSetInters[i]->GetLocation();					SetRect(&r, max(interLoc.h, 0.0) - (recursionDepth + 10), interLoc.v - (recursionDepth + 10), max(interLoc.h, 0.0) + (recursionDepth + 10), interLoc.v + (recursionDepth + 10));					ForeColor(redColor);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qMethod2 = 1;				}			}		}				int occludedEdge = intersection->DetermineOccludedEdge();				//Make sure things seem clean		if (intersection->GetType() == GenericIntersection::BSP_BSP)		{			MyAssert(occludedEdge == 3 || occludedEdge == 4);			MyAssert(((BspBspIntersection*)intersection)->GetBsp1() == traversalBSpline ||					((BspBspIntersection*)intersection)->GetBsp2() == traversalBSpline);		}		else if (intersection->GetType() == GenericIntersection::BSP_CUT)			MyAssert(((BspCutIntersection*)intersection)->GetBsp() == traversalBSpline);		else if (intersection->GetType() == GenericIntersection::BSP_CUT_T)			MyAssert(((BspCutTIntersection*)intersection)->GetBsp() == traversalBSpline);				//Determine the section depth before the intersection on the traversal BSpline		int beforeDepth;		if (depthAttempt == -1)	//In the middle of a boundary traversal, so just read the depth off			beforeDepth = traversalBSpline->GetSectionDepthBeforeIntersection(intersection, cv, sg);		else	//Starting a boundary traversal, need to enumerate the possible starting depths		{			switch (intersection->GetType())			{				case GenericIntersection::BSP_BSP:					if (!intersection->SelfIntersection())					{						MyAssert(occludedEdge == 3 || occludedEdge == 4);						if (((BspBspIntersection*)intersection)->GetBsp1() == traversalBSpline)							beforeDepth = depthAttempt;	//BSpline is on top						else if (occludedEdge == 3)							beforeDepth = depthAttempt + 1;	//Before depth is occluded						else beforeDepth = depthAttempt;	//After depth is occluded					}					else	//еее Not sure about this					{						bool onTop = (((BspBspIntersection*)intersection)->GetCv1() == cv && ((BspBspIntersection*)intersection)->GetSg1() == sg);						if (onTop)							beforeDepth = depthAttempt;						else if (occludedEdge == 3)							beforeDepth = depthAttempt + 1;	//Before depth is occluded						else beforeDepth = depthAttempt;	//After depth is occluded					}					break;				case GenericIntersection::BSP_CUT:					MyAssert(occludedEdge == -1 || occludedEdge == 1 || occludedEdge == 2);					beforeDepth = depthAttempt;					break;				case GenericIntersection::BSP_CUT_T:					beforeDepth = depthAttempt;					break;				case GenericIntersection::CUT_CUT:					MyAssert(false);					break;			}		}				bool turnedCorner = false;				//If the propagation is entering a T junction from a BSpline it is necessary to turn into the Cut instead of continuing along the BSpline		if (intersection->GetType() == GenericIntersection::BSP_CUT_T)		{			//if (((BspCutTIntersection*)intersection)->GetCut()->GetBsp2())			{				if (!timeLimitReached && HandleBSplinePropagationTurnIntoCut(recursionDepth /*DEBUG*/, intersection,																				traversalBSpline, touchedBSplineIndexes,																				cv, sg, beforeDepth,																				minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																				timeLimitReached))					betterSolutionFound = true;				turnedCorner = true;			}		}				if (!turnedCorner)		{			//See if the depth constraint on the far side of the intersection will allow the depth to propagate through			if (!traversalBSpline->GetSectionDepthConstraintAfterIntersection(intersection, cv, sg))			{				if (!timeLimitReached && HandleBSplinePropagation(recursionDepth, child,																	intersection, traversalBSplineIndex, touchedBSplineIndexes,																	cv, sg, beforeDepth,																	minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																	timeLimitReached))					betterSolutionFound = true;			}			else	//Can't propagate, so check legality			{				if (!timeLimitReached && HandleBSplinePropagationEnd(recursionDepth, child,																		intersection, traversalBSplineIndex, touchedBSplineIndexes,																		cv, sg, beforeDepth,																		minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																		timeLimitReached))					betterSolutionFound = true;			}		}				//If the companions were flipped by this child, unflip them		if (child == 1)		{			traversalBSpline->SetSectionDepthConstraintAfterIntersection(intersection, cv, sg, prevSectionConst);			intersection->FlipTopBottom();			interFlipped = false;						//Flip each intersection in the companion set			if (atLeastOneCompUnconstrained)				for (int i = 0; i < compSetInters.size(); i++)				{					compSetInters[i]->FlipTopBottom();										if (gDebug)					{						FloatPoint interLoc = compSetInters[i]->GetLocation();						SetRect(&r, max(interLoc.h, 0.0) - (recursionDepth + 10), interLoc.v - (recursionDepth + 10), max(interLoc.h, 0.0) + (recursionDepth + 10), interLoc.v + (recursionDepth + 10));						ForeColor(whiteColor);						FrameRect(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qMethod2 = 1;					}				}		}				//Unconstrain all the companions		if (atLeastOneCompUnconstrained)		{			MyAssert(compSetIndex != -1);			for (int i = 0; i < compSetInters.size(); i++)			{				compSetInters[i]->SetHardConstraint(false);								if (gDebug)				{					FloatPoint interLoc = compSetInters[i]->GetLocation();					SetRect(&r, max(interLoc.h, 0.0) - (recursionDepth + 10), interLoc.v - (recursionDepth + 10), max(interLoc.h, 0.0) + (recursionDepth + 10), interLoc.v + (recursionDepth + 10));					ForeColor(whiteColor);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qMethod2 = 1;				}			}		}	}		//Undo the change	intersection->SetHardConstraint(prevInterConst);	if (interFlipped)	{		traversalBSpline->SetSectionDepthConstraintAfterIntersection(intersection, cv, sg, prevSectionConst);		intersection->FlipTopBottom();	}		if (gDebug)	{		SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		if (betterSolutionFound)			ForeColor(greenColor);		else ForeColor(yellowColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qMethod2 = 1;				SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(whiteColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(whiteColor);		FrameRect(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		if (betterSolutionFound)		MyAssert(minDeltaLeaf);	return betterSolutionFound;}bool Drawing::HandleBSplinePropagation(int recursionDepth /*DEBUG*/, int child,										GenericIntersection* intersection, int traversalBSplineIndex,										vector<int>& touchedBSplineIndexes,										int cv, int sg, int beforeDepth,										Drawing*& minDeltaLeaf, int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,										bool& timeLimitReached){	MyAssert(!timeLimitReached);		Rect r;	//еее	FloatPoint intersectionLoc = intersection->GetLocation();	//еее		int afterDepth;	int occludedEdge = intersection->DetermineOccludedEdge();		BSpline* traversalBSpline = bsplines[traversalBSplineIndex];		BSpline *crossBSpline = NULL;	BSplineToBSplineCut *crossCut = NULL;		sTreeWalk2++;		//Determine the propagated depth on the far side of the intersection.	//Also find the crossing boundary.	switch (intersection->GetType())	{		case GenericIntersection::BSP_BSP:			crossBSpline = ((BspBspIntersection*)intersection)->GetOtherBsp(traversalBSpline);						bool onTop;			if (!intersection->SelfIntersection())				onTop = (((BspBspIntersection*)intersection)->GetBsp1() == traversalBSpline);			else onTop = (((BspBspIntersection*)intersection)->GetCv1() == cv && ((BspBspIntersection*)intersection)->GetSg1() == sg);						if (onTop)				afterDepth = beforeDepth;	//BSpline is on top			else if (occludedEdge == 3)				afterDepth = beforeDepth - 1;	//Before depth is occluded			else afterDepth = beforeDepth + 1;	//After depth is occluded			break;		case GenericIntersection::BSP_CUT:			crossCut = ((BspCutIntersection*)intersection)->GetCut();			afterDepth = beforeDepth;			break;		case GenericIntersection::BSP_CUT_T:			crossCut = ((BspCutTIntersection*)intersection)->GetCut();			afterDepth = beforeDepth;			break;		case GenericIntersection::CUT_CUT:			MyAssert(false);			break;	}		//This code prevents labelings with negative segment depths from being considered legal.  If this is disabled, labelings with negative	//depths might occur, but will automatically be normalized to a min depth of 0 after the labeling search is completed anyway.  This	//usually works quite well, but if there are problems, you might consider enabling this code to prevent negative depths entirely.	//	NOTE:	Make sure to keep this code commented or uncommented in concert with the same version in HandleCutPropagation.	//MyAssert(beforeDepth >= 0);	//if (afterDepth < 0)	//	return false;		int maxPossibleDepthAfter = traversalBSpline->GetMaxPossibleSectionDepthAfterIntersection(intersection, cv, sg);	if (afterDepth > maxPossibleDepthAfter)		return false;		//See if the traversal depths are legal with the cross depths	bool crossLegal = true;					if (intersection->GetType() == GenericIntersection::BSP_BSP)	{		int cvCross, sgCross;		if (!intersection->SelfIntersection())		{			if (((BspBspIntersection*)intersection)->GetBsp1() == traversalBSpline)			{				cvCross = ((BspBspIntersection*)intersection)->GetCv2();				sgCross = ((BspBspIntersection*)intersection)->GetSg2();			}			else			{				cvCross = ((BspBspIntersection*)intersection)->GetCv1();				sgCross = ((BspBspIntersection*)intersection)->GetSg1();			}		}		else	//self intersection		{			if (((BspBspIntersection*)intersection)->GetCv1() == cv && ((BspBspIntersection*)intersection)->GetSg1() == sg)			{				cvCross = ((BspBspIntersection*)intersection)->GetCv2();				sgCross = ((BspBspIntersection*)intersection)->GetSg2();			}			else			{				MyAssert(((BspBspIntersection*)intersection)->GetCv2() == cv && ((BspBspIntersection*)intersection)->GetSg2() == sg);				cvCross = ((BspBspIntersection*)intersection)->GetCv1();				sgCross = ((BspBspIntersection*)intersection)->GetSg1();			}		}				//Don't even bother checking this if the cross depths aren't constrained		if (crossBSpline->GetSectionDepthConstraintBeforeIntersection(intersection, cvCross, sgCross) ||			crossBSpline->GetSectionDepthConstraintAfterIntersection(intersection, cvCross, sgCross))		{			//if (!intersection->SelfIntersection())			//	MyAssert(crossBSpline->GetSectionDepthConstraintBeforeIntersection(intersection, cvCross, sgCross) &&			//			crossBSpline->GetSectionDepthConstraintAfterIntersection(intersection, cvCross, sgCross));						int crossDepthOne = crossBSpline->GetSectionDepthBeforeIntersection(intersection, cvCross, sgCross);			int crossDepthTwo = crossBSpline->GetSectionDepthAfterIntersection(intersection, cvCross, sgCross);						bool onTop;			if (!intersection->SelfIntersection())				onTop = (((BspBspIntersection*)intersection)->GetBsp1() == traversalBSpline);			else onTop = (((BspBspIntersection*)intersection)->GetCv1() == cv && ((BspBspIntersection*)intersection)->GetSg1() == sg);						if (onTop)	//traversal BSpline on top			{				if (min(crossDepthOne, crossDepthTwo) < beforeDepth)						crossLegal = false;			}			else if (occludedEdge == 3)	//Cross BSpline on top			{				if (crossBSpline->GetSectionDepthConstraintBeforeIntersection(intersection, cvCross, sgCross))				{					if (crossDepthOne > afterDepth)						crossLegal = false;				}				else				{					MyAssert(crossBSpline->GetSectionDepthConstraintAfterIntersection(intersection, cvCross, sgCross));					if (crossDepthTwo > afterDepth)					crossLegal = false;				}			}			else 	//Cross BSpline on top			{				if (crossBSpline->GetSectionDepthConstraintBeforeIntersection(intersection, cvCross, sgCross))				{					if (crossDepthOne > beforeDepth)						crossLegal = false;				}				else				{					MyAssert(crossBSpline->GetSectionDepthConstraintAfterIntersection(intersection, cvCross, sgCross));					if (crossDepthTwo > beforeDepth)						crossLegal = false;				}			}		}	}	else if (intersection->GetType() == GenericIntersection::BSP_CUT)	{		//Don't even bother checking this if the cross depths aren't constrained		if (crossCut->GetSectionDepthConstraintBeforeIntersection(intersection) ||			crossCut->GetSectionDepthConstraintAfterIntersection(intersection))		{			MyAssert(crossCut->GetSectionDepthConstraintBeforeIntersection(intersection) &&					crossCut->GetSectionDepthConstraintAfterIntersection(intersection));						int crossDepthOne = crossCut->GetSectionDepthBeforeIntersection(intersection);			int crossDepthTwo = crossCut->GetSectionDepthAfterIntersection(intersection);			MyAssert(beforeDepth == afterDepth);						if (!((BspCutIntersection*)intersection)->GetBspOnTop())	//Cut on top			{				MyAssert(crossDepthOne == crossDepthTwo);				MyAssert(beforeDepth == afterDepth);	//Not sure about this				if (crossDepthOne >= beforeDepth)						crossLegal = false;			}			else if (occludedEdge == 1)	//BSpline on top			{				MyAssert(crossDepthOne == crossDepthTwo + 1);				if (crossDepthTwo < afterDepth)					crossLegal = false;			}			else	//BSpline on top			{				MyAssert(crossDepthTwo == crossDepthOne + 1);				if (crossDepthOne < beforeDepth)						crossLegal = false;			}		}	}	if (!crossLegal)	{		MyAssert(!minDeltaLeaf);		return false;	}		//Remember the prev after depth	int prevAfterDepth = traversalBSpline->GetSectionDepthAfterIntersection(intersection, cv, sg);	MyAssert(!traversalBSpline->GetSectionDepthConstraintAfterIntersection(intersection, cv, sg));		if (afterDepth != prevAfterDepth)	{		accumDepthDelta++;		if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)//еее(accumFlipDelta > minFlipDelta || (accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))			return false;	}		traversalBSpline->SetSectionDepthAfterIntersection(intersection, cv, sg, afterDepth);	traversalBSpline->SetSectionDepthConstraintAfterIntersection(intersection, cv, sg, true);		//Propagate through	GenericIntersection* nextInter = traversalBSpline->FindNextIntersection(intersection, cv, sg);		if (gDebug)	{		/*SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(whiteColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		*/		SetRect(&r, max(nextInter->GetLocation().h, 0.0) - (recursionDepth + 11), nextInter->GetLocation().v - (recursionDepth + 11), max(nextInter->GetLocation().h, 0.0) + (recursionDepth + 11), nextInter->GetLocation().v + (recursionDepth + 11));		ForeColor(redColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qt = 1;	}		if (minDeltaLeaf)		MyAssert(child != 0);		MyAssert(!timeLimitReached);		Drawing* nextLevelLeaf = NULL;	bool betterSolutionFound;	switch (gCompanionSetMethod)	{		case 0:			betterSolutionFound = CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod0(recursionDepth + 1, -1, nextInter->GetLocation(), traversalBSplineIndex,																								touchedBSplineIndexes, nextLevelLeaf,																								minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																								timeLimitReached);			break;		case 1:			betterSolutionFound = CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod1(recursionDepth + 1, -1, nextInter->GetLocation(), traversalBSplineIndex,																								touchedBSplineIndexes, nextLevelLeaf,																								minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																								timeLimitReached);			break;		case 2:			betterSolutionFound = CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod2(recursionDepth + 1, -1, nextInter->GetLocation(), traversalBSplineIndex,																								touchedBSplineIndexes, nextLevelLeaf,																								minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																								timeLimitReached);			break;	}		//Undo the change	traversalBSpline->SetSectionDepthAfterIntersection(intersection, cv, sg, prevAfterDepth);	traversalBSpline->SetSectionDepthConstraintAfterIntersection(intersection, cv, sg, false);		if (!betterSolutionFound)		MyAssert(!nextLevelLeaf);	else	//better solution found	{		if (minDeltaLeaf)		{			MyAssert(child != 0);			delete minDeltaLeaf;		}		MyAssert(nextLevelLeaf);		minDeltaLeaf = nextLevelLeaf;	}		if (gDebug)	{		SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(magentaColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qt = 1;	}		if (betterSolutionFound)		MyAssert(minDeltaLeaf);	return betterSolutionFound;}bool Drawing::HandleBSplinePropagationEnd(int recursionDepth /*DEBUG*/, int child,										GenericIntersection* intersection, int traversalBSplineIndex,										vector<int>& touchedBSplineIndexes,										int cv, int sg, int beforeDepth,										Drawing*& minDeltaLeaf, int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,										bool& timeLimitReached){	MyAssert(!timeLimitReached);		Rect r;	//еее	FloatPoint intersectionLoc = intersection->GetLocation();	//еее		int afterDepth;	int occludedEdge = intersection->DetermineOccludedEdge();		BSpline* traversalBSpline = bsplines[traversalBSplineIndex];		sTreeWalk3++;		//Determine the propagated depth on the far side of the intersection	bool propagationLegal = true;	switch (intersection->GetType())	{		case GenericIntersection::BSP_BSP:			afterDepth = traversalBSpline->GetSectionDepthAfterIntersection(intersection, cv, sg);						bool onTop;			if (!intersection->SelfIntersection())				onTop = (((BspBspIntersection*)intersection)->GetBsp1() == traversalBSpline);			else onTop = (((BspBspIntersection*)intersection)->GetCv1() == cv && ((BspBspIntersection*)intersection)->GetSg1() == sg);						if (onTop)			{				if (afterDepth != beforeDepth)					propagationLegal = false;	//BSpline is on top, so after depth should match before depth			}			else	//BSpline on bottom			{				if (occludedEdge == 3 && afterDepth != beforeDepth - 1)					propagationLegal = false;	//Before depth is occluded				else if (occludedEdge == 4 && afterDepth != beforeDepth + 1)					propagationLegal = false;	//After depth is occluded			}			break;		case GenericIntersection::BSP_CUT:			afterDepth = traversalBSpline->GetSectionDepthAfterIntersection(intersection, cv, sg);			if (afterDepth != beforeDepth)				propagationLegal = false;			break;		case GenericIntersection::BSP_CUT_T:			afterDepth = traversalBSpline->GetSectionDepthAfterIntersection(intersection, cv, sg);			if (afterDepth != beforeDepth)				propagationLegal = false;			break;		case GenericIntersection::CUT_CUT:			MyAssert(false);			break;	}		//This boundry is completely checked, so find a boundry that isn't completely checked.	//If there are none, this is a leaf.	//However, only proceed if the solution is legal so far.	bool betterSolutionFound = false;	if (propagationLegal)	{		int nextTouchedBspIndex = 0;		for (nextTouchedBspIndex = 0; nextTouchedBspIndex < touchedBSplineIndexes.size(); nextTouchedBspIndex++)			if (!bsplines[touchedBSplineIndexes[nextTouchedBspIndex]]->GetAllSectionsConstrained())				break;				if (nextTouchedBspIndex == touchedBSplineIndexes.size())	//No more bsplines		{			if (accumFlipDelta < minFlipDelta || (accumFlipDelta == minFlipDelta && accumDepthDelta < minDepthDelta))			{				bool assertIt = true;				for (int i = 0; i < touchedBSplineIndexes.size(); i++)					MyAssert(bsplines[touchedBSplineIndexes[i]]->GetAllIntersectionsLegal(assertIt));								minDeltaLeaf = new Drawing(*this);				minFlipDelta = accumFlipDelta;				minDepthDelta = accumDepthDelta;				betterSolutionFound = true;								if (gDebug12)				{					InitAnalysisWindow();										IncrementTextV();					MoveTo(5, IncrementTextV() * 10 + 5);					DrawString("\pMin solution: Delta: ");					Str255 str1;					NumToString(accumFlipDelta, str1);					DrawString(str1);					NumToString(accumDepthDelta, str1);					DrawString("\p/");					DrawString(str1);										DrawString("\p Time: ");										clock_t timeUsed = clock() - labelingStartTime;					long double timeUsedSecs = timeUsed / CLOCKS_PER_SEC;					FloatToPascal(timeUsedSecs, 3, str1);					DrawString(str1);										IncrementTextV();					gTextH = 0;										QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);					SetPort(GetWindowPort(gMainWindow->GetWindow()));				}								if (gTestLogOn)				{					//ofstream ofs;					//ofs.open("testData", ofstream::app);					//if (ofs)					//{						clock_t timeUsed = clock() - labelingStartTime;						long double timeUsedSecs = timeUsed / CLOCKS_PER_SEC;						/*ofs*/(*gOutputFileStream) << "Min: " << accumFlipDelta << " " << accumDepthDelta << " " << timeUsedSecs << "\t---\t";					//	ofs.close();					//}				}			}			else			{				if (gDebug12)				{					InitAnalysisWindow();										IncrementTextV();					MoveTo(5, IncrementTextV() * 10 + 5);					DrawString("\pWorse solution: Delta: ");					Str255 str1;					NumToString(accumFlipDelta, str1);					DrawString(str1);					NumToString(accumDepthDelta, str1);					DrawString("\p/");					DrawString(str1);										DrawString("\p Time: ");										clock_t timeUsed = clock() - labelingStartTime;					long double timeUsedSecs = timeUsed / CLOCKS_PER_SEC;					FloatToPascal(timeUsedSecs, 3, str1);					DrawString(str1);										IncrementTextV();					gTextH = 0;										QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);					SetPort(GetWindowPort(gMainWindow->GetWindow()));				}			}		}		else	//Traverse the next bspline		{			BSpline* nextBsp = bsplines[touchedBSplineIndexes[nextTouchedBspIndex]];						//GenericIntersection* nextBspFirstInter = nextBsp->GetFirstBspBspIntersection();			//MyAssert(nextBspFirstInter);						int numPossibleDepths;			GenericIntersection* nextBspFirstInter;			if (gDepthEnumerationMethod == 0)			{				nextBspFirstInter = nextBsp->GetFirstIntersection();								//The number of possible depths for a bspline is half the number of intersections in its group				vector<GenericIntersection*> groupInters = GetOneBSplineGroupIntersections(nextBsp);				if (groupInters.size() == 0)					groupInters = nextBsp->GetIntersections();				int totalInters = groupInters.size();				for (int ii = 0; ii < groupInters.size(); ii++)					if (groupInters[ii]->SelfIntersection() || groupInters[ii]->GetType() == GenericIntersection::BSP_CUT_T)						totalInters--;				numPossibleDepths = max(2, totalInters / 2);			}			else if (gDepthEnumerationMethod == 1)			{				int startingSection = nextBsp->GetDeepestMaxPossibleSection();				numPossibleDepths = nextBsp->GetMaxPossibleSectionDepth(startingSection) + 1;				nextBspFirstInter = nextBsp->GetIntersectionFromIndex(startingSection);			}			else if (gDepthEnumerationMethod == 2)			{				int startingSection = nextBsp->GetShallowestMaxPossibleSection();				numPossibleDepths = nextBsp->GetMaxPossibleSectionDepth(startingSection) + 1;				nextBspFirstInter = nextBsp->GetIntersectionFromIndex(startingSection);			}						int ad = accumFlipDelta, md = minFlipDelta;			for (int i = 0; i < numPossibleDepths; i++)			{				if (gDebug)				{						/*SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));					ForeColor(whiteColor);					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);					*/					SetRect(&r, max(nextBspFirstInter->GetLocation().h, 0.0) - (recursionDepth + 11), nextBspFirstInter->GetLocation().v - (recursionDepth + 11), max(nextBspFirstInter->GetLocation().h, 0.0) + (recursionDepth + 11), nextBspFirstInter->GetLocation().v + (recursionDepth + 11));					ForeColor(blueColor);					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qt = 1;				}								MyAssert(!timeLimitReached);								Drawing* nextLevelLeaf = NULL;				bool oneBetterSolutionFound;				switch (gCompanionSetMethod)				{					case 0:						oneBetterSolutionFound = CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod0(recursionDepth + 1, i, nextBspFirstInter->GetLocation(), touchedBSplineIndexes[nextTouchedBspIndex],																											touchedBSplineIndexes, nextLevelLeaf,																											minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																											timeLimitReached);						break;					case 1:						oneBetterSolutionFound = CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod1(recursionDepth + 1, i, nextBspFirstInter->GetLocation(), touchedBSplineIndexes[nextTouchedBspIndex],																											touchedBSplineIndexes, nextLevelLeaf,																											minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																											timeLimitReached);						break;					case 2:						oneBetterSolutionFound = CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod2(recursionDepth + 1, i, nextBspFirstInter->GetLocation(), touchedBSplineIndexes[nextTouchedBspIndex],																											touchedBSplineIndexes, nextLevelLeaf,																											minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																											timeLimitReached);						break;				}								if (!oneBetterSolutionFound)					MyAssert(!nextLevelLeaf);				else	//better solution found				{					betterSolutionFound = true;					if (minDeltaLeaf)					{						MyAssert(child != 0 || i > 0);						delete minDeltaLeaf;					}					MyAssert(nextLevelLeaf);					minDeltaLeaf = nextLevelLeaf;				}								if (timeLimitReached)					break;								if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)//еее(accumFlipDelta > minFlipDelta || (accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))					break;								if (gDebug)				{					SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));					ForeColor(cyanColor);					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);									int qt = 1;				}			}		}	}		if (betterSolutionFound)		MyAssert(minDeltaLeaf);	return betterSolutionFound;}bool Drawing::HandleBSplinePropagationTurnIntoCut(int recursionDepth /*DEBUG*/, GenericIntersection* intersection,												BSpline* traversalBSpline, vector<int>& touchedBSplineIndexes,												int cv, int sg, int beforeDepth,												Drawing*& minDeltaLeaf, int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,												bool& timeLimitReached){	MyAssert(!timeLimitReached);		Rect r;	//еее	FloatPoint intersectionLoc = intersection->GetLocation();	//еее		MyAssert(intersection->GetType() == GenericIntersection::BSP_CUT_T);	BspCutTIntersection* bspCutTinter = (BspCutTIntersection*)intersection;		BSplineToBSplineCut *crossCut = bspCutTinter->GetCut();	int traversalCutIndex = GetCutIndex(crossCut);		bool cutConstrained = bspCutTinter->GetAtStart() ? crossCut->GetSectionDepthConstraintAfterIntersection(intersection) :														crossCut->GetSectionDepthConstraintBeforeIntersection(intersection);	if (cutConstrained)	{		//The BSpline should be constrained after the Cut because the traversal should have, at an earlier time, exited the Cut and turned right onto the BSpline		if (traversalBSpline)			MyAssert(traversalBSpline->GetSectionDepthConstraintAfterIntersection(intersection, cv, sg));				int cutEndDepth = (bspCutTinter->GetAtStart() ? crossCut->GetSectionDepthAfterIntersection(intersection) :														crossCut->GetSectionDepthBeforeIntersection(intersection));		int bspAfterDepth = traversalBSpline ? traversalBSpline->GetSectionDepthAfterIntersection(intersection, cv, sg) : beforeDepth;				//The depth at the end of the cut should match the outgoing depth of the BSpline		MyAssert(cutEndDepth == bspAfterDepth);				//Check whether the intersection is legal		if (beforeDepth != bspAfterDepth)			return false;				//Jump to the other end of the cut		GenericIntersection* nextInter;		if (bspCutTinter->GetAtStart())			nextInter = crossCut->GetLastIntersection();		else nextInter = crossCut->GetFirstIntersection();				if (gDebug)		{			/*SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));			ForeColor(whiteColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			*/			SetRect(&r, max(nextInter->GetLocation().h, 0.0) - (recursionDepth + 11), nextInter->GetLocation().v - (recursionDepth + 11), max(nextInter->GetLocation().h, 0.0) + (recursionDepth + 11), nextInter->GetLocation().v + (recursionDepth + 11));			RGBColor c;			c.red = 65535;			c.green = 32768;			c.blue = 0;			RGBForeColor(&c);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qt = 1;		}				MyAssert(!timeLimitReached);				Drawing* nextLevelLeaf = NULL;		bool betterSolutionFound;		switch (gCompanionSetMethod)		{			case 0:				betterSolutionFound =  CreateLegalLabelingUsingCutTraversalTreeCompSetMethod0(recursionDepth + 1, nextInter->GetLocation(), traversalCutIndex,																							touchedBSplineIndexes, nextLevelLeaf,																							bspCutTinter->GetAtStart(),																							minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																							timeLimitReached);				break;			case 1:				betterSolutionFound =  CreateLegalLabelingUsingCutTraversalTreeCompSetMethod1(recursionDepth + 1, nextInter->GetLocation(), traversalCutIndex,																							touchedBSplineIndexes, nextLevelLeaf,																							bspCutTinter->GetAtStart(),																							minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																							timeLimitReached);				break;			case 2:				betterSolutionFound =  CreateLegalLabelingUsingCutTraversalTreeCompSetMethod2(recursionDepth + 1, nextInter->GetLocation(), traversalCutIndex,																							touchedBSplineIndexes, nextLevelLeaf,																							bspCutTinter->GetAtStart(),																							minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																							timeLimitReached);				break;		}				if (!betterSolutionFound)			MyAssert(!nextLevelLeaf);		else	//better solution found		{			if (minDeltaLeaf)			{				//MyAssert(child == 1);				delete minDeltaLeaf;			}			MyAssert(nextLevelLeaf);			minDeltaLeaf = nextLevelLeaf;		}				if (gDebug)		{			SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));			RGBColor c;			c.red = 32768;			c.green = 16384;			c.blue = 0;			RGBForeColor(&c);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qt = 1;		}				if (betterSolutionFound)			MyAssert(minDeltaLeaf);		return betterSolutionFound;	}		//After the turn into the cut, the depth of the first section of the cut should be assigned the depth of the BSpline at the T junction	int afterDepth = beforeDepth;		//Remember the prev after depth	int prevAfterDepth = bspCutTinter->GetAtStart() ? crossCut->GetSectionDepthAfterIntersection(intersection) :													crossCut->GetSectionDepthBeforeIntersection(intersection);	MyAssert(bspCutTinter->GetAtStart() ? !crossCut->GetSectionDepthConstraintAfterIntersection(intersection) :													!crossCut->GetSectionDepthConstraintBeforeIntersection(intersection));		if (afterDepth != prevAfterDepth)	{		accumDepthDelta++;		if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)//еее(accumFlipDelta > minFlipDelta || (accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))			return false;	}		if (bspCutTinter->GetAtStart())	{		crossCut->SetSectionDepthAfterIntersection(intersection, afterDepth);		crossCut->SetSectionDepthConstraintAfterIntersection(intersection, true);	}	else	{		crossCut->SetSectionDepthBeforeIntersection(intersection, afterDepth);		crossCut->SetSectionDepthConstraintBeforeIntersection(intersection, true);	}		//Propagate through	GenericIntersection* nextInter = bspCutTinter->GetAtStart() ? 									crossCut->FindNextIntersection(intersection) :									crossCut->FindPrevIntersection(intersection);		if (gDebug)	{		/*SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(whiteColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		*/		SetRect(&r, max(nextInter->GetLocation().h, 0.0) - (recursionDepth + 11), nextInter->GetLocation().v - (recursionDepth + 11), max(nextInter->GetLocation().h, 0.0) + (recursionDepth + 11), nextInter->GetLocation().v + (recursionDepth + 11));		ForeColor(redColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qt = 1;	}		//if (minDeltaLeaf)	//	MyAssert(child == 1);		//Determine whether to propagate forward or backward along the cut	bool propagateForward = bspCutTinter->GetAtStart();		MyAssert(!timeLimitReached);		Drawing* nextLevelLeaf = NULL;	bool betterSolutionFound;	switch (gCompanionSetMethod)	{		case 0:			betterSolutionFound =  CreateLegalLabelingUsingCutTraversalTreeCompSetMethod0(recursionDepth + 1, nextInter->GetLocation(), traversalCutIndex,																								touchedBSplineIndexes, nextLevelLeaf,																								propagateForward,																								minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																								timeLimitReached);			break;		case 1:			betterSolutionFound =  CreateLegalLabelingUsingCutTraversalTreeCompSetMethod1(recursionDepth + 1, nextInter->GetLocation(), traversalCutIndex,																						touchedBSplineIndexes, nextLevelLeaf,																						bspCutTinter->GetAtStart(),																						minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																						timeLimitReached);			break;		case 2:			betterSolutionFound =  CreateLegalLabelingUsingCutTraversalTreeCompSetMethod2(recursionDepth + 1, nextInter->GetLocation(), traversalCutIndex,																								touchedBSplineIndexes, nextLevelLeaf,																								propagateForward,																								minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																								timeLimitReached);			break;	}		//Undo the change	if (bspCutTinter->GetAtStart())	{		crossCut->SetSectionDepthAfterIntersection(intersection, prevAfterDepth);		crossCut->SetSectionDepthConstraintAfterIntersection(intersection, false);	}	else	{		crossCut->SetSectionDepthBeforeIntersection(intersection, prevAfterDepth);		crossCut->SetSectionDepthConstraintBeforeIntersection(intersection, false);	}		if (!betterSolutionFound)		MyAssert(!nextLevelLeaf);	else	//better solution found	{		if (minDeltaLeaf)		{			//MyAssert(child == 1);			delete minDeltaLeaf;		}		MyAssert(nextLevelLeaf);		minDeltaLeaf = nextLevelLeaf;	}		if (gDebug)	{		SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(magentaColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qt = 1;	}		if (betterSolutionFound)		MyAssert(minDeltaLeaf);	return betterSolutionFound;}bool Drawing::CreateLegalLabelingUsingCutTraversalTreeCompSetMethod0(int recursionDepth /*DEBUG*/, FloatPoint intersectionLoc, int traversalCutIndex,													vector<int> touchedBSplineIndexes, Drawing*& minDeltaLeaf,													bool propagateForward,													int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,													bool& timeLimitReached){	MyAssert(gCompanionSetMethod == 0);	MyAssert(!timeLimitReached);		Rect r;	if (gDebug)	{		SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(blackColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qMethod0 = 1;	}		sTreeWalk++;	if (gDebug12)	{		if (sTreeWalk % 1000 == 0)		{			InitAnalysisWindow();						MoveTo(gTextH++ * 7 + 5, gTextV * 10 + 5);			DrawString("\pе");						GetPortBounds(GetWindowPort(gAnalysisWindow), &r);			if (gTextH * 7 + 5 > r.right - 10)			{				gTextH = 0;				IncrementTextV();			}						QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);			SetPort(GetWindowPort(gMainWindow->GetWindow()));		}	}		//See if the time has expired	if (sTreeWalk % 100 == 0)	{		clock_t presentTime = clock();		clock_t elapsedTime = presentTime - labelingStartTime;		clock_t elapsedTimeSeconds = elapsedTime / CLOCKS_PER_SEC;		if ((elapsedTimeSeconds > labelAttemptWithSolutionTimeLimitSeconds * gTimeLimitScalar && minFlipDelta != 999999) ||			(elapsedTimeSeconds > labelAttemptWithoutSolutionTimeLimitSeconds * gTimeLimitScalar && minFlipDelta == 999999))		{			timeLimitReached = true;						if (gDebug5)			{				bool secondTimeLimit = (elapsedTimeSeconds > labelAttemptWithoutSolutionTimeLimitSeconds * gTimeLimitScalar);								InitAnalysisWindow();								IncrementTextV();				MoveTo(5, IncrementTextV() * 10 + 5);				TextFace(bold);				!secondTimeLimit ? DrawString("\pFirst time limit expired") : DrawString("\pSecond time limit expired");				TextFace(0);				gTextH = 0;								QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);				SetPort(GetWindowPort(gMainWindow->GetWindow()));			}						return false;		}	}		//See if the labeling attempt should be terminated	if (sTreeWalk % 100 == 0)		if (!TestForMouseTermination())		{			timeLimitReached = true;			return false;		}		//Find the intersection based on the passed in location	GenericIntersection* intersection = NULL;	for (int i = 0; i < intersections.size(); i++)		if (intersections[i]->GetLocation() == intersectionLoc)		{			intersection = intersections[i];			break;		}	MyAssert(intersection);		//Find the cut based on the passed in index	BSplineToBSplineCut* traversalCut = bsplinePairCuts[traversalCutIndex];		//Find the crossing boundary	BSpline *crossBSpline = NULL;	BSplineToBSplineCut *crossCut = NULL;	switch (intersection->GetType())	{		case GenericIntersection::BSP_BSP:			MyAssert(false);			break;		case GenericIntersection::BSP_CUT:			crossBSpline = ((BspCutIntersection*)intersection)->GetBsp();			break;		case GenericIntersection::BSP_CUT_T:			crossBSpline = ((BspCutTIntersection*)intersection)->GetBsp();			break;		case GenericIntersection::CUT_CUT:			crossCut = ((CutCutIntersection*)intersection)->GetOtherCut(traversalCut);			break;	}		//Update the lists of touched BSplines and Cuts	int cut1Index = GetCutIndex(traversalCut);	int cut2Index = crossCut ? GetCutIndex(crossCut) : -1;	int bspIndex = crossBSpline ? GetBSplineIndex(crossBSpline) : -1;		if (bspIndex != -1)		UpdateTouchedBSplines(bspIndex, touchedBSplineIndexes);		//Remember the prev constraint	bool prevInterConst = intersection->GetHardConstraint();		//If the intersection is hard constrained, there is only one child, and therefore no branching in the tree	int numChildren = (prevInterConst || intersection->GetPermanentHardConstraint()) ? 1 : 2;		intersection->SetHardConstraint(true);	//However, Cut intersections only have "tops" and "bottoms" when crossing BSplines, so fix this up some	if (crossCut)	{		MyAssert(!crossBSpline);		numChildren = 1;	}	//Furthermore, a T junction doesn't have a "top" or "bottom"	if (intersection->GetType() == GenericIntersection::BSP_CUT_T)		numChildren = 1;		//Can't flip an intersection that is beyond the horizon.	//The inter dist vector is already sorted in increasing order of dist, so just search the list up to the horizon and see if the intersection is found in that range of the list.	if (gTreeSearchMethod == 1)	{		int interDistIdx = 0;		while (interDistIdx < gInterDists.size() && gInterDists[interDistIdx].first != intersection && gInterDists[interDistIdx].second <= gHorizon)			interDistIdx++;		if (interDistIdx < gInterDists.size() && gInterDists[interDistIdx].second > gHorizon)			numChildren = 1;	}		//Child 0: no change, don't constrain companions	//Child 1: flip intersection, don't constrain companions	bool betterSolutionFound = false;	bool prevSectionConst;	bool interFlipped = false;	for (int child = 0; child < numChildren; child++)	{		if (child == 1)	//Flip the intersection, but don't flip its companions		{			//Remember the depth constraint			prevSectionConst = propagateForward ? traversalCut->GetSectionDepthConstraintAfterIntersection(intersection) :												traversalCut->GetSectionDepthConstraintBeforeIntersection(intersection);						//Flip the the intersection			MyAssert(intersection->GetType() == GenericIntersection::BSP_CUT);			propagateForward ? traversalCut->SetSectionDepthConstraintAfterIntersection(intersection, false) :								traversalCut->SetSectionDepthConstraintBeforeIntersection(intersection, false);			intersection->FlipTopBottom();			interFlipped = true;						if (find(brandNewIntersections.begin(), brandNewIntersections.end(), intersection) == brandNewIntersections.end())				accumFlipDelta++;						if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)//еее(accumFlipDelta > minFlipDelta || (accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))			{				if (gDebug)				{					SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));					ForeColor(yellowColor);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qMethod0 = 1;				}								break;			}						if (gDebug)			{				SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));				ForeColor(greenColor);				FrameRect(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qMethod0 = 1;			}		}				int occludedEdge = intersection->DetermineOccludedEdge();				//Make sure things seem clean		if (intersection->GetType() == GenericIntersection::BSP_CUT_T || intersection->GetType() == GenericIntersection::CUT_CUT)			MyAssert(occludedEdge == -1);		else		{			MyAssert(intersection->GetType() == GenericIntersection::BSP_CUT);			if (!((BspCutIntersection*)intersection)->GetBspOnTop())				MyAssert(occludedEdge == -1);			else MyAssert(occludedEdge == 1 || occludedEdge == 2);		}				//Determine the section depth before the intersection on the traversal Cut		int beforeDepth = propagateForward ? traversalCut->GetSectionDepthBeforeIntersection(intersection) : traversalCut->GetSectionDepthAfterIntersection(intersection);				bool turnedCorner = false;				//If the propagation is entering a T junction from a Cut it is necessary to turn out of the Cut onto the BSpline		if (intersection->GetType() == GenericIntersection::BSP_CUT_T)		{			BspCutTIntersection* bspCutTinter = (BspCutTIntersection*)intersection;			BSpline *crossBSpline = bspCutTinter->GetBsp();			if (crossBSpline)			{				if (!timeLimitReached && HandleCutPropagationTurnOutOfCut(recursionDepth /*DEBUG*/, intersection,																			traversalCut, touchedBSplineIndexes,																			beforeDepth,																			minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																			timeLimitReached))					betterSolutionFound = true;				turnedCorner = true;			}			else	//Infinite cut			{				BspCutTIntersection* nextInter = FindNextInfiniteSolidCut(bspCutTinter);								if (gDebug)				{					FloatPoint nextInterLoc = nextInter->GetLocation();					SetRect(&r, max(nextInterLoc.h, 0.0) - (recursionDepth + 10), nextInterLoc.v - (recursionDepth + 10), max(nextInterLoc.h, 0.0) + (recursionDepth + 10), nextInterLoc.v + (recursionDepth + 10));					RGBColor c;					c.red = 32768;					c.green = 65535;					c.blue = 0;					RGBForeColor(&c);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qMethod0 = 1;				}								if (!timeLimitReached && HandleBSplinePropagationTurnIntoCut(recursionDepth /*DEBUG*/, nextInter,																				NULL, touchedBSplineIndexes,																				-1, -1, beforeDepth,																				minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																				timeLimitReached))					betterSolutionFound = true;				turnedCorner = true;			}		}				if (!turnedCorner)		{			//See if the depth constraint on the far side of the intersection will allow the depth to propagate through			if (propagateForward ? !traversalCut->GetSectionDepthConstraintAfterIntersection(intersection) :									!traversalCut->GetSectionDepthConstraintBeforeIntersection(intersection))			{				if (!timeLimitReached && HandleCutPropagation(recursionDepth, child,																intersection, traversalCutIndex, touchedBSplineIndexes,																beforeDepth, propagateForward,																minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																timeLimitReached))					betterSolutionFound = true;			}			else	//Can't propagate, so check legality			{				if (!timeLimitReached && HandleCutPropagationEnd(recursionDepth, child,																	intersection, traversalCutIndex, touchedBSplineIndexes,																	beforeDepth, propagateForward,																	minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																	timeLimitReached))					betterSolutionFound = true;			}		}				if (child == 1)		{			propagateForward ? traversalCut->SetSectionDepthConstraintAfterIntersection(intersection, prevSectionConst) :								traversalCut->SetSectionDepthConstraintBeforeIntersection(intersection, prevSectionConst);			intersection->FlipTopBottom();			interFlipped = false;		}	}		//Undo the change	intersection->SetHardConstraint(prevInterConst);	if (interFlipped)	{		propagateForward ? traversalCut->SetSectionDepthConstraintAfterIntersection(intersection, prevSectionConst) :							traversalCut->SetSectionDepthConstraintBeforeIntersection(intersection, prevSectionConst);		intersection->FlipTopBottom();	}	if (gDebug)	{		SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		if (betterSolutionFound)			ForeColor(greenColor);		else ForeColor(yellowColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qMethod0 = 1;				SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(whiteColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(whiteColor);		FrameRect(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		if (betterSolutionFound)		MyAssert(minDeltaLeaf);	return betterSolutionFound;}bool Drawing::CreateLegalLabelingUsingCutTraversalTreeCompSetMethod1(int recursionDepth /*DEBUG*/, FloatPoint intersectionLoc, int traversalCutIndex,													vector<int> touchedBSplineIndexes, Drawing*& minDeltaLeaf,													bool propagateForward,													int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,													bool& timeLimitReached){	MyAssert(gCompanionSetMethod == 1);	MyAssert(!timeLimitReached);		Rect r;	if (gDebug)	{		SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(blackColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qMethod1 = 1;	}		sTreeWalk++;	if (gDebug12)	{		if (sTreeWalk % 1000 == 0)		{			InitAnalysisWindow();						MoveTo(gTextH++ * 7 + 5, gTextV * 10 + 5);			DrawString("\pе");						GetPortBounds(GetWindowPort(gAnalysisWindow), &r);			if (gTextH * 7 + 5 > r.right - 10)			{				gTextH = 0;				IncrementTextV();			}						QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);			SetPort(GetWindowPort(gMainWindow->GetWindow()));		}	}		//See if the time has expired	if (sTreeWalk % 100 == 0)	{		clock_t presentTime = clock();		clock_t elapsedTime = presentTime - labelingStartTime;		clock_t elapsedTimeSeconds = elapsedTime / CLOCKS_PER_SEC;		if ((elapsedTimeSeconds > labelAttemptWithSolutionTimeLimitSeconds * gTimeLimitScalar && minFlipDelta != 999999) ||			(elapsedTimeSeconds > labelAttemptWithoutSolutionTimeLimitSeconds * gTimeLimitScalar && minFlipDelta == 999999))		{			timeLimitReached = true;						if (gDebug5)			{				bool secondTimeLimit = (elapsedTimeSeconds > labelAttemptWithoutSolutionTimeLimitSeconds * gTimeLimitScalar);								InitAnalysisWindow();								IncrementTextV();				MoveTo(5, IncrementTextV() * 10 + 5);				TextFace(bold);				!secondTimeLimit ? DrawString("\pFirst time limit expired") : DrawString("\pSecond time limit expired");				TextFace(0);				gTextH = 0;								QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);				SetPort(GetWindowPort(gMainWindow->GetWindow()));			}						return false;		}	}		//See if the labeling attempt should be terminated	if (sTreeWalk % 100 == 0)		if (!TestForMouseTermination())		{			timeLimitReached = true;			return false;		}		//Find the intersection based on the passed in location	GenericIntersection* intersection = NULL;	for (int i = 0; i < intersections.size(); i++)		if (intersections[i]->GetLocation() == intersectionLoc)		{			intersection = intersections[i];			break;		}	MyAssert(intersection);		//Find the cut based on the passed in index	BSplineToBSplineCut* traversalCut = bsplinePairCuts[traversalCutIndex];		//Find the crossing boundary	BSpline *crossBSpline = NULL;	BSplineToBSplineCut *crossCut = NULL;	switch (intersection->GetType())	{		case GenericIntersection::BSP_BSP:			MyAssert(false);			break;		case GenericIntersection::BSP_CUT:			crossBSpline = ((BspCutIntersection*)intersection)->GetBsp();			break;		case GenericIntersection::BSP_CUT_T:			crossBSpline = ((BspCutTIntersection*)intersection)->GetBsp();			break;		case GenericIntersection::CUT_CUT:			crossCut = ((CutCutIntersection*)intersection)->GetOtherCut(traversalCut);			break;	}		//Update the lists of touched BSplines and Cuts	int cut1Index = GetCutIndex(traversalCut);	int cut2Index = crossCut ? GetCutIndex(crossCut) : -1;	int bspIndex = crossBSpline ? GetBSplineIndex(crossBSpline) : -1;		if (bspIndex != -1)		UpdateTouchedBSplines(bspIndex, touchedBSplineIndexes);		//Remember the prev constraint	bool prevInterConst = intersection->GetHardConstraint();		//If the intersection is hard constrained, there is only two child, not four	int numChildren = (prevInterConst || intersection->GetPermanentHardConstraint()) ? 2 : 4;	//If constrained, only try two children, those that don't flip	int childIncrement = (prevInterConst || intersection->GetPermanentHardConstraint()) ? 2 : 1;	//If constrained, do child 0 followed by child 2.  Otherwise do all 4 in order.		intersection->SetHardConstraint(true);	//However, Cut intersections only have "tops" and "bottoms" when crossing BSplines, so fix this up some	if (crossCut)	{		MyAssert(!crossBSpline);		childIncrement = 2;	}	//Furthermore, a T junction doesn't have a "top" or "bottom"	if (intersection->GetType() == GenericIntersection::BSP_CUT_T)		childIncrement = 2;		//Find the companion set	MyAssert(interCompanionPairSets.size() == 0);	int compSetIndex = -1;	bool foundIt = false;	/*	for (compSetIndex = 0; compSetIndex < interCompanionPairSets.size(); compSetIndex++)	{		for (int i = 0; i < interCompanionPairSets[compSetIndex]->size(); i++)			if ((*interCompanionPairSets[compSetIndex])[i].first == intersection || (*interCompanionPairSets[compSetIndex])[i].second == intersection)			{				foundIt = true;				break;			}		if (foundIt)			break;	}	*/	//Find the companion set for the intersection	for (compSetIndex = 0; compSetIndex < interCompanionSets.size(); compSetIndex++)	//Loop through the sets		if (find(interCompanionSets[compSetIndex]->begin(), interCompanionSets[compSetIndex]->end(), intersection) != interCompanionSets[compSetIndex]->end())		{			foundIt = true;			break;		}		if (foundIt)		MyAssert(compSetIndex < interCompanionSets.size());//interCompanionPairSets.size());	else if (compSetIndex == interCompanionSets.size())//interCompanionPairSets.size())	{		compSetIndex = -1;	}		//Find out if the companion set is going to be flipped.  The only way this wouldn't happen is if the companion set is already constrained.	//All the companions should be unconstrained or constrained, not a mix (with the exception of the present intersection).	bool atLeastOneCompUnconstrained = false, atLeastOneCompConstrained = false;	vector<GenericIntersection*> compSetInters;	if (compSetIndex != -1)	{		compSetInters = *interCompanionSets[compSetIndex];		for (vector<GenericIntersection*>::iterator i = compSetInters.begin(); i != compSetInters.end(); i++)			if (*i == intersection)			{				compSetInters.erase(i);				break;			}		/*		for (int i = 0; i < interCompanionPairSets[compSetIndex]->size(); i++)		{			GenericIntersection* inter1 = (*interCompanionPairSets[compSetIndex])[i].first;			GenericIntersection* inter2 = (*interCompanionPairSets[compSetIndex])[i].second;						if (inter1 != intersection)				if (inter1->GetHardConstraint() || inter1->GetPermanentHardConstraint())					atLeastOneCompConstrained = true;				else atLeastOneCompUnconstrained = true;						if (inter2 != intersection)				if (inter2->GetHardConstraint() || inter2->GetPermanentHardConstraint())					atLeastOneCompConstrained = true;				else atLeastOneCompUnconstrained = true;		}		*/		for (int i = 0; i < compSetInters.size(); i++)		{			GenericIntersection* inter1 = compSetInters[i];			if (inter1 != intersection)				if (inter1->GetHardConstraint() || inter1->GetPermanentHardConstraint())					atLeastOneCompConstrained = true;				else atLeastOneCompUnconstrained = true;		}		MyAssert(!atLeastOneCompConstrained || !atLeastOneCompUnconstrained);		/*		//Find the minimal set of unique intersections in the companion set (intersections can be present in the set either once or twice)		for (int i = 0; i < interCompanionPairSets[compSetIndex]->size(); i++)		{			if ((*interCompanionPairSets[compSetIndex])[i].first != intersection &&				find(compSetInters.begin(), compSetInters.end(), (*interCompanionPairSets[compSetIndex])[i].first) == compSetInters.end())				compSetInters.push_back((*interCompanionPairSets[compSetIndex])[i].first);			if ((*interCompanionPairSets[compSetIndex])[i].second != intersection &&				find(compSetInters.begin(), compSetInters.end(), (*interCompanionPairSets[compSetIndex])[i].second) == compSetInters.end())				compSetInters.push_back((*interCompanionPairSets[compSetIndex])[i].second);		}		*/	}		//Can't flip an intersection that is beyond the horizon.	//The inter dist vector is already sorted in increasing order of dist, so just search the list up to the horizon and see if the intersection is found in that range of the list.	if (gTreeSearchMethod == 1)	{		int interDistIdx = 0;		while (interDistIdx < gInterDists.size() && gInterDists[interDistIdx].first != intersection && gInterDists[interDistIdx].second <= gHorizon)			interDistIdx++;		if (interDistIdx < gInterDists.size() && gInterDists[interDistIdx].second > gHorizon)			childIncrement = 2;	}		//Child 0: no change, constrain companions	//Child 1: flip intersection, constrain companions	//Child 2: no change, don't constrain companions	//Child 3: flip intersection, don't constrain companions	bool betterSolutionFound = false;	bool prevSectionConst;	int originalAccumDelta = accumFlipDelta;	bool interFlipped = false;	for (int child = 0; child < numChildren; child += childIncrement)	{		accumFlipDelta = originalAccumDelta;				if (child == 1 || child == 3)	//Flip this intersection		{			//Remember the depth constraint			prevSectionConst = propagateForward ? traversalCut->GetSectionDepthConstraintAfterIntersection(intersection) :												traversalCut->GetSectionDepthConstraintBeforeIntersection(intersection);						//Flip the the intersection			MyAssert(intersection->GetType() == GenericIntersection::BSP_CUT);			propagateForward ? traversalCut->SetSectionDepthConstraintAfterIntersection(intersection, false) :								traversalCut->SetSectionDepthConstraintBeforeIntersection(intersection, false);			intersection->FlipTopBottom();			interFlipped = true;						if (find(brandNewIntersections.begin(), brandNewIntersections.end(), intersection) == brandNewIntersections.end())				accumFlipDelta++;						if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)//еее(accumFlipDelta > minFlipDelta || (accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))			{				if (gDebug)				{					SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));					ForeColor(yellowColor);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qMethod1 = 1;				}								break;			}						if (gDebug)			{				SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));				ForeColor(greenColor);				FrameRect(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qMethod1 = 1;			}		}				if (child == 1)		{			//If the companion set is going to be flipped, add it to the accumFlipDelta and flip the intersections			if (!atLeastOneCompConstrained && compSetIndex != -1)			{				//Add the comp inters to the accumFlipDelta				accumFlipDelta += compSetInters.size();				if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)//еее(accumFlipDelta > minFlipDelta || (accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))				{					if (gDebug)					{						SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));						ForeColor(blackColor);						FrameRect(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qMethod1 = 1;					}										break;				}								//Flip each intersection in the companion set				for (int i = 0; i < compSetInters.size(); i++)				{					compSetInters[i]->FlipTopBottom();										if (gDebug)					{						FloatPoint interLoc = compSetInters[i]->GetLocation();						SetRect(&r, max(interLoc.h, 0.0) - (recursionDepth + 10), interLoc.v - (recursionDepth + 10), max(interLoc.h, 0.0) + (recursionDepth + 10), interLoc.v + (recursionDepth + 10));						ForeColor(magentaColor);						FrameRect(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qMethod2 = 1;					}				}			}		}				//Constrain all the companions		if (child == 0 || child == 1)			if (!atLeastOneCompConstrained && compSetIndex != -1)			{				for (int i = 0; i < compSetInters.size(); i++)				{					compSetInters[i]->SetHardConstraint(true);										if (gDebug)					{						FloatPoint interLoc = compSetInters[i]->GetLocation();						SetRect(&r, max(interLoc.h, 0.0) - (recursionDepth + 10), interLoc.v - (recursionDepth + 10), max(interLoc.h, 0.0) + (recursionDepth + 10), interLoc.v + (recursionDepth + 10));						ForeColor(redColor);						FrameRect(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qMethod1 = 1;					}				}			}				int occludedEdge = intersection->DetermineOccludedEdge();				//Make sure things seem clean		if (intersection->GetType() == GenericIntersection::BSP_CUT_T || intersection->GetType() == GenericIntersection::CUT_CUT)			MyAssert(occludedEdge == -1);		else		{			MyAssert(intersection->GetType() == GenericIntersection::BSP_CUT);			if (!((BspCutIntersection*)intersection)->GetBspOnTop())				MyAssert(occludedEdge == -1);			else MyAssert(occludedEdge == 1 || occludedEdge == 2);		}				//Determine the section depth before the intersection on the traversal Cut		int beforeDepth = propagateForward ? traversalCut->GetSectionDepthBeforeIntersection(intersection) : traversalCut->GetSectionDepthAfterIntersection(intersection);				bool turnedCorner = false;				//If the propagation is entering a T junction from a Cut it is necessary to turn out of the Cut onto the BSpline		if (intersection->GetType() == GenericIntersection::BSP_CUT_T)		{			BspCutTIntersection* bspCutTinter = (BspCutTIntersection*)intersection;			BSpline *crossBSpline = bspCutTinter->GetBsp();			if (crossBSpline)			{				if (!timeLimitReached && HandleCutPropagationTurnOutOfCut(recursionDepth /*DEBUG*/, intersection,																			traversalCut, touchedBSplineIndexes,																			beforeDepth,																			minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																			timeLimitReached))					betterSolutionFound = true;				turnedCorner = true;			}			else	//Infinite cut			{				BspCutTIntersection* nextInter = FindNextInfiniteSolidCut(bspCutTinter);								if (gDebug)				{					FloatPoint nextInterLoc = nextInter->GetLocation();					SetRect(&r, max(nextInterLoc.h, 0.0) - (recursionDepth + 10), nextInterLoc.v - (recursionDepth + 10), max(nextInterLoc.h, 0.0) + (recursionDepth + 10), nextInterLoc.v + (recursionDepth + 10));					RGBColor c;					c.red = 32768;					c.green = 65535;					c.blue = 0;					RGBForeColor(&c);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qMethod1 = 1;				}								if (!timeLimitReached && HandleBSplinePropagationTurnIntoCut(recursionDepth /*DEBUG*/, nextInter,																				NULL, touchedBSplineIndexes,																				-1, -1, beforeDepth,																				minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																				timeLimitReached))					betterSolutionFound = true;				turnedCorner = true;			}		}				if (!turnedCorner)		{			//See if the depth constraint on the far side of the intersection will allow the depth to propagate through			if (propagateForward ? !traversalCut->GetSectionDepthConstraintAfterIntersection(intersection) :									!traversalCut->GetSectionDepthConstraintBeforeIntersection(intersection))			{				if (!timeLimitReached && HandleCutPropagation(recursionDepth, child,																intersection, traversalCutIndex, touchedBSplineIndexes,																beforeDepth, propagateForward,																minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																timeLimitReached))					betterSolutionFound = true;			}			else	//Can't propagate, so check legality			{				if (!timeLimitReached && HandleCutPropagationEnd(recursionDepth, child,																	intersection, traversalCutIndex, touchedBSplineIndexes,																	beforeDepth, propagateForward,																	minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																	timeLimitReached))					betterSolutionFound = true;			}		}				//If the companions were flipped by this child, unflip them		if (!atLeastOneCompConstrained && compSetIndex != -1 && child == 1)		{			//Flip each intersection in the companion set			for (int i = 0; i < compSetInters.size(); i++)			{				compSetInters[i]->FlipTopBottom();								if (gDebug)				{					FloatPoint interLoc = compSetInters[i]->GetLocation();					SetRect(&r, max(interLoc.h, 0.0) - (recursionDepth + 10), interLoc.v - (recursionDepth + 10), max(interLoc.h, 0.0) + (recursionDepth + 10), interLoc.v + (recursionDepth + 10));					ForeColor(whiteColor);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qMethod2 = 1;				}			}		}				//Unconstrain all the companions		if (child == 0 || child == 1)			if (!atLeastOneCompConstrained && compSetIndex != -1)			{				for (int i = 0; i < compSetInters.size(); i++)				{					compSetInters[i]->SetHardConstraint(false);										if (gDebug)					{						FloatPoint interLoc = compSetInters[i]->GetLocation();						SetRect(&r, max(interLoc.h, 0.0) - (recursionDepth + 10), interLoc.v - (recursionDepth + 10), max(interLoc.h, 0.0) + (recursionDepth + 10), interLoc.v + (recursionDepth + 10));						ForeColor(whiteColor);						FrameRect(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qMethod1 = 1;					}				}			}				if (child == 1 || child == 3)		{			propagateForward ? traversalCut->SetSectionDepthConstraintAfterIntersection(intersection, prevSectionConst) :								traversalCut->SetSectionDepthConstraintBeforeIntersection(intersection, prevSectionConst);			intersection->FlipTopBottom();			interFlipped = false;		}	}		//Undo the change	intersection->SetHardConstraint(prevInterConst);	if (interFlipped)	{		propagateForward ? traversalCut->SetSectionDepthConstraintAfterIntersection(intersection, prevSectionConst) :							traversalCut->SetSectionDepthConstraintBeforeIntersection(intersection, prevSectionConst);		intersection->FlipTopBottom();	}		if (gDebug)	{		SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		if (betterSolutionFound)			ForeColor(greenColor);		else ForeColor(yellowColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qMethod1 = 1;				SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(whiteColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(whiteColor);		FrameRect(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		if (betterSolutionFound)		MyAssert(minDeltaLeaf);	return betterSolutionFound;}bool Drawing::CreateLegalLabelingUsingCutTraversalTreeCompSetMethod2(int recursionDepth /*DEBUG*/, FloatPoint intersectionLoc, int traversalCutIndex,													vector<int> touchedBSplineIndexes, Drawing*& minDeltaLeaf,													bool propagateForward,													int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,													bool& timeLimitReached){	MyAssert(gCompanionSetMethod == 2);	MyAssert(!timeLimitReached);		Rect r;	if (gDebug)	{		SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(blackColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qMethod2 = 1;	}		sTreeWalk++;	if (gDebug12)	{		if (sTreeWalk % 1000 == 0)		{			InitAnalysisWindow();						MoveTo(gTextH++ * 7 + 5, gTextV * 10 + 5);			DrawString("\pе");						GetPortBounds(GetWindowPort(gAnalysisWindow), &r);			if (gTextH * 7 + 5 > r.right - 10)			{				gTextH = 0;				IncrementTextV();			}						QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);			SetPort(GetWindowPort(gMainWindow->GetWindow()));		}	}		//See if the time has expired	if (sTreeWalk % 100 == 0)	{		clock_t presentTime = clock();		clock_t elapsedTime = presentTime - labelingStartTime;		clock_t elapsedTimeSeconds = elapsedTime / CLOCKS_PER_SEC;		if ((elapsedTimeSeconds > labelAttemptWithSolutionTimeLimitSeconds * gTimeLimitScalar && minFlipDelta != 999999) ||			(elapsedTimeSeconds > labelAttemptWithoutSolutionTimeLimitSeconds * gTimeLimitScalar && minFlipDelta == 999999))		{			timeLimitReached = true;						if (gDebug5)			{				bool secondTimeLimit = (elapsedTimeSeconds > labelAttemptWithoutSolutionTimeLimitSeconds * gTimeLimitScalar);								InitAnalysisWindow();								IncrementTextV();				MoveTo(5, IncrementTextV() * 10 + 5);				TextFace(bold);				!secondTimeLimit ? DrawString("\pFirst time limit expired") : DrawString("\pSecond time limit expired");				TextFace(0);				gTextH = 0;								QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);				SetPort(GetWindowPort(gMainWindow->GetWindow()));			}						return false;		}	}		//See if the labeling attempt should be terminated	if (sTreeWalk % 100 == 0)		if (!TestForMouseTermination())		{			timeLimitReached = true;			return false;		}		//Find the intersection based on the passed in location	GenericIntersection* intersection = NULL;	for (int i = 0; i < intersections.size(); i++)		if (intersections[i]->GetLocation() == intersectionLoc)		{			intersection = intersections[i];			break;		}	MyAssert(intersection);		//Find the cut based on the passed in index	BSplineToBSplineCut* traversalCut = bsplinePairCuts[traversalCutIndex];		//Find the crossing boundary	BSpline *crossBSpline = NULL;	BSplineToBSplineCut *crossCut = NULL;	switch (intersection->GetType())	{		case GenericIntersection::BSP_BSP:			MyAssert(false);			break;		case GenericIntersection::BSP_CUT:			crossBSpline = ((BspCutIntersection*)intersection)->GetBsp();			break;		case GenericIntersection::BSP_CUT_T:			crossBSpline = ((BspCutTIntersection*)intersection)->GetBsp();			break;		case GenericIntersection::CUT_CUT:			crossCut = ((CutCutIntersection*)intersection)->GetOtherCut(traversalCut);			break;	}		//Update the lists of touched BSplines and Cuts	int cut1Index = GetCutIndex(traversalCut);	int cut2Index = crossCut ? GetCutIndex(crossCut) : -1;	int bspIndex = crossBSpline ? GetBSplineIndex(crossBSpline) : -1;		if (bspIndex != -1)		UpdateTouchedBSplines(bspIndex, touchedBSplineIndexes);		//Remember the prev constraint	bool prevInterConst = intersection->GetHardConstraint();		//If the intersection is hard constrained, there is only one child, and therefore no branching in the tree	int numChildren = (prevInterConst || intersection->GetPermanentHardConstraint()) ? 1 : 2;		intersection->SetHardConstraint(true);	//However, Cut intersections only have "tops" and "bottoms" when crossing BSplines, so fix this up some	if (crossCut)	{		MyAssert(!crossBSpline);		numChildren = 1;	}	//Furthermore, a T junction doesn't have a "top" or "bottom"	if (intersection->GetType() == GenericIntersection::BSP_CUT_T)		numChildren = 1;		//Find the companion set	MyAssert(interCompanionPairSets.size() == 0);	int compSetIndex = -1;	bool foundIt = false;	/*	for (compSetIndex = 0; compSetIndex < interCompanionPairSets.size(); compSetIndex++)	{		for (int i = 0; i < interCompanionPairSets[compSetIndex]->size(); i++)			if ((*interCompanionPairSets[compSetIndex])[i].first == intersection || (*interCompanionPairSets[compSetIndex])[i].second == intersection)			{				foundIt = true;				break;			}		if (foundIt)			break;	}	*/	//Find the companion set for the intersection	for (compSetIndex = 0; compSetIndex < interCompanionSets.size(); compSetIndex++)	//Loop through the sets		if (find(interCompanionSets[compSetIndex]->begin(), interCompanionSets[compSetIndex]->end(), intersection) != interCompanionSets[compSetIndex]->end())		{			foundIt = true;			break;		}		if (foundIt)		MyAssert(compSetIndex < interCompanionSets.size());//interCompanionPairSets.size());	else if (compSetIndex == interCompanionSets.size())//interCompanionPairSets.size())	{		compSetIndex = -1;	}		//Find out if the companion set is going to be flipped.  The only way this wouldn't happen is if the companion set is already constrained.	//All the companions should be unconstrained or constrained, not a mix (with the exception of the present intersection).	bool atLeastOneCompUnconstrained = false, atLeastOneCompConstrained = false;	vector<GenericIntersection*> compSetInters;	if (compSetIndex != -1)	{		compSetInters = *interCompanionSets[compSetIndex];		for (vector<GenericIntersection*>::iterator i = compSetInters.begin(); i != compSetInters.end(); i++)			if (*i == intersection)			{				compSetInters.erase(i);				break;			}		/*		for (int i = 0; i < interCompanionPairSets[compSetIndex]->size(); i++)		{			GenericIntersection* inter1 = (*interCompanionPairSets[compSetIndex])[i].first;			GenericIntersection* inter2 = (*interCompanionPairSets[compSetIndex])[i].second;						if (inter1 != intersection)				if (inter1->GetHardConstraint() || inter1->GetPermanentHardConstraint())					atLeastOneCompConstrained = true;				else atLeastOneCompUnconstrained = true;						if (inter2 != intersection)				if (inter2->GetHardConstraint() || inter2->GetPermanentHardConstraint())					atLeastOneCompConstrained = true;				else atLeastOneCompUnconstrained = true;		}		*/		for (int i = 0; i < compSetInters.size(); i++)		{			GenericIntersection* inter1 = compSetInters[i];			if (inter1 != intersection)				if (inter1->GetHardConstraint() || inter1->GetPermanentHardConstraint())					atLeastOneCompConstrained = true;				else atLeastOneCompUnconstrained = true;		}		MyAssert(!atLeastOneCompConstrained || !atLeastOneCompUnconstrained);		/*		//Find the minimal set of unique intersections in the companion set (intersections can be present in the set either once or twice)		for (int i = 0; i < interCompanionPairSets[compSetIndex]->size(); i++)		{			if ((*interCompanionPairSets[compSetIndex])[i].first != intersection &&				find(compSetInters.begin(), compSetInters.end(), (*interCompanionPairSets[compSetIndex])[i].first) == compSetInters.end())				compSetInters.push_back((*interCompanionPairSets[compSetIndex])[i].first);			if ((*interCompanionPairSets[compSetIndex])[i].second != intersection &&				find(compSetInters.begin(), compSetInters.end(), (*interCompanionPairSets[compSetIndex])[i].second) == compSetInters.end())				compSetInters.push_back((*interCompanionPairSets[compSetIndex])[i].second);		}		*/	}		//Can't flip an intersection that is beyond the horizon.	//The inter dist vector is already sorted in increasing order of dist, so just search the list up to the horizon and see if the intersection is found in that range of the list.	if (gTreeSearchMethod == 1)	{		int interDistIdx = 0;		while (interDistIdx < gInterDists.size() && gInterDists[interDistIdx].first != intersection && gInterDists[interDistIdx].second <= gHorizon)			interDistIdx++;		if (interDistIdx < gInterDists.size() && gInterDists[interDistIdx].second > gHorizon)			numChildren = 1;	}		//Child 0: no change, constrain companions	//Child 1: flip intersection, constrain companions	bool betterSolutionFound = false;	bool prevSectionConst;	bool interFlipped = false;	for (int child = 0; child < numChildren; child++)	{		if (child == 1)	//Flip this intersection and its companions		{			//Remember the depth constraint			prevSectionConst = propagateForward ? traversalCut->GetSectionDepthConstraintAfterIntersection(intersection) :												traversalCut->GetSectionDepthConstraintBeforeIntersection(intersection);						//Flip the the intersection			MyAssert(intersection->GetType() == GenericIntersection::BSP_CUT);			propagateForward ? traversalCut->SetSectionDepthConstraintAfterIntersection(intersection, false) :								traversalCut->SetSectionDepthConstraintBeforeIntersection(intersection, false);			intersection->FlipTopBottom();			interFlipped = true;						if (find(brandNewIntersections.begin(), brandNewIntersections.end(), intersection) == brandNewIntersections.end())				accumFlipDelta++;						if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)//еее(accumFlipDelta > minFlipDelta || (accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))			{				if (gDebug)				{					SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));					ForeColor(yellowColor);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qMethod2 = 1;				}								break;			}						if (gDebug)			{				SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));				ForeColor(greenColor);				FrameRect(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qMethod2 = 1;			}						//If the companion set is going to be flipped, add it to the accumFlipDelta and flip the intersections			if (atLeastOneCompUnconstrained)			{				MyAssert(compSetIndex != -1);								//Add the comp inters to the accumFlipDelta				accumFlipDelta += compSetInters.size();				if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)//еее(accumFlipDelta > minFlipDelta || (accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))				{					if (gDebug)					{						SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));						ForeColor(blackColor);						FrameRect(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qMethod2 = 1;					}										break;				}								//Flip each intersection in the companion set				for (int i = 0; i < compSetInters.size(); i++)				{					compSetInters[i]->FlipTopBottom();										if (gDebug)					{						FloatPoint interLoc = compSetInters[i]->GetLocation();						SetRect(&r, max(interLoc.h, 0.0) - (recursionDepth + 10), interLoc.v - (recursionDepth + 10), max(interLoc.h, 0.0) + (recursionDepth + 10), interLoc.v + (recursionDepth + 10));						ForeColor(magentaColor);						FrameRect(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qMethod2 = 1;					}				}			}		}				//Constrain all the companions		if (atLeastOneCompUnconstrained)		{			MyAssert(compSetIndex != -1);			for (int i = 0; i < compSetInters.size(); i++)			{				compSetInters[i]->SetHardConstraint(true);								if (gDebug)				{					FloatPoint interLoc = compSetInters[i]->GetLocation();					SetRect(&r, max(interLoc.h, 0.0) - (recursionDepth + 10), interLoc.v - (recursionDepth + 10), max(interLoc.h, 0.0) + (recursionDepth + 10), interLoc.v + (recursionDepth + 10));					ForeColor(redColor);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qMethod2 = 1;				}			}		}				int occludedEdge = intersection->DetermineOccludedEdge();				//Make sure things seem clean		if (intersection->GetType() == GenericIntersection::BSP_CUT_T || intersection->GetType() == GenericIntersection::CUT_CUT)			MyAssert(occludedEdge == -1);		else		{			MyAssert(intersection->GetType() == GenericIntersection::BSP_CUT);			if (!((BspCutIntersection*)intersection)->GetBspOnTop())				MyAssert(occludedEdge == -1);			else MyAssert(occludedEdge == 1 || occludedEdge == 2);		}				//Determine the section depth before the intersection on the traversal Cut		int beforeDepth = propagateForward ? traversalCut->GetSectionDepthBeforeIntersection(intersection) : traversalCut->GetSectionDepthAfterIntersection(intersection);				bool turnedCorner = false;				//If the propagation is entering a T junction from a Cut it is necessary to turn out of the Cut onto the BSpline		if (intersection->GetType() == GenericIntersection::BSP_CUT_T)		{			BspCutTIntersection* bspCutTinter = (BspCutTIntersection*)intersection;			BSpline *crossBSpline = bspCutTinter->GetBsp();			if (crossBSpline)			{				if (!timeLimitReached && HandleCutPropagationTurnOutOfCut(recursionDepth /*DEBUG*/, intersection,																			traversalCut, touchedBSplineIndexes,																			beforeDepth,																			minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																			timeLimitReached))					betterSolutionFound = true;				turnedCorner = true;			}			else	//Infinite cut			{				BspCutTIntersection* nextInter = FindNextInfiniteSolidCut(bspCutTinter);								if (gDebug)				{					FloatPoint nextInterLoc = nextInter->GetLocation();					SetRect(&r, max(nextInterLoc.h, 0.0) - (recursionDepth + 10), nextInterLoc.v - (recursionDepth + 10), max(nextInterLoc.h, 0.0) + (recursionDepth + 10), nextInterLoc.v + (recursionDepth + 10));					RGBColor c;					c.red = 32768;					c.green = 65535;					c.blue = 0;					RGBForeColor(&c);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qMethod2 = 1;				}								if (!timeLimitReached && HandleBSplinePropagationTurnIntoCut(recursionDepth /*DEBUG*/, nextInter,																				NULL, touchedBSplineIndexes,																				-1, -1, beforeDepth,																				minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																				timeLimitReached))					betterSolutionFound = true;				turnedCorner = true;			}		}				if (!turnedCorner)		{			//See if the depth constraint on the far side of the intersection will allow the depth to propagate through			if (propagateForward ? !traversalCut->GetSectionDepthConstraintAfterIntersection(intersection) :									!traversalCut->GetSectionDepthConstraintBeforeIntersection(intersection))			{				if (!timeLimitReached && HandleCutPropagation(recursionDepth, child,																intersection, traversalCutIndex, touchedBSplineIndexes,																beforeDepth, propagateForward,																minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																timeLimitReached))					betterSolutionFound = true;			}			else	//Can't propagate, so check legality			{				if (!timeLimitReached && HandleCutPropagationEnd(recursionDepth, child,																	intersection, traversalCutIndex, touchedBSplineIndexes,																	beforeDepth, propagateForward,																	minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																	timeLimitReached))					betterSolutionFound = true;			}		}				//If the companions were flipped by this child, unflip them		if (child == 1)		{			propagateForward ? traversalCut->SetSectionDepthConstraintAfterIntersection(intersection, prevSectionConst) :								traversalCut->SetSectionDepthConstraintBeforeIntersection(intersection, prevSectionConst);			intersection->FlipTopBottom();			interFlipped = false;						//Flip each intersection in the companion set			if (atLeastOneCompUnconstrained)				for (int i = 0; i < compSetInters.size(); i++)				{					compSetInters[i]->FlipTopBottom();										if (gDebug)					{						FloatPoint interLoc = compSetInters[i]->GetLocation();						SetRect(&r, max(interLoc.h, 0.0) - (recursionDepth + 10), interLoc.v - (recursionDepth + 10), max(interLoc.h, 0.0) + (recursionDepth + 10), interLoc.v + (recursionDepth + 10));						ForeColor(whiteColor);						FrameRect(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qMethod2 = 1;					}				}		}				//Unconstrain all the companions		if (atLeastOneCompUnconstrained)		{			MyAssert(compSetIndex != -1);			for (int i = 0; i < compSetInters.size(); i++)			{				compSetInters[i]->SetHardConstraint(false);								if (gDebug)				{					FloatPoint interLoc = compSetInters[i]->GetLocation();					SetRect(&r, max(interLoc.h, 0.0) - (recursionDepth + 10), interLoc.v - (recursionDepth + 10), max(interLoc.h, 0.0) + (recursionDepth + 10), interLoc.v + (recursionDepth + 10));					ForeColor(whiteColor);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qMethod2 = 1;				}			}		}	}		//Undo the change	intersection->SetHardConstraint(prevInterConst);	if (interFlipped)	{		propagateForward ? traversalCut->SetSectionDepthConstraintAfterIntersection(intersection, prevSectionConst) :							traversalCut->SetSectionDepthConstraintBeforeIntersection(intersection, prevSectionConst);		intersection->FlipTopBottom();	}	if (gDebug)	{		SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		if (betterSolutionFound)			ForeColor(greenColor);		else ForeColor(yellowColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qMethod2 = 1;				SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(whiteColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(whiteColor);		FrameRect(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		if (betterSolutionFound)		MyAssert(minDeltaLeaf);	return betterSolutionFound;}bool Drawing::HandleCutPropagation(int recursionDepth /*DEBUG*/, int child,								GenericIntersection* intersection, int traversalCutIndex,								vector<int>& touchedBSplineIndexes,								int beforeDepth, bool propagateForward,								Drawing*& minDeltaLeaf, int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,								bool& timeLimitReached){	MyAssert(!timeLimitReached);		Rect r;	//еее	FloatPoint intersectionLoc = intersection->GetLocation();	//еее		int afterDepth;	int occludedEdge = intersection->DetermineOccludedEdge();		BSplineToBSplineCut* traversalCut = bsplinePairCuts[traversalCutIndex];		BSpline *crossBSpline = NULL;	BSplineToBSplineCut *crossCut = NULL;		sTreeWalk2++;		//Determine the propagated depth on the far side of the intersection.	//Also find the crossing boundary.	switch (intersection->GetType())	{		case GenericIntersection::BSP_BSP:			MyAssert(false);			break;		case GenericIntersection::BSP_CUT:			crossBSpline = ((BspCutIntersection*)intersection)->GetBsp();			if (!((BspCutIntersection*)intersection)->GetBspOnTop())				afterDepth = beforeDepth;	//Cut on top			else if (propagateForward)	//Bsp on top			{				if (occludedEdge == 1)					afterDepth = beforeDepth - 1;	//Before depth is occluded				else afterDepth = beforeDepth + 1;	//After depth is occluded			}			else	//Bsp on top, propagate backward			{				if (occludedEdge == 2)					afterDepth = beforeDepth - 1;	//Before depth is occluded				else afterDepth = beforeDepth + 1;	//After depth is occluded			}			break;		case GenericIntersection::BSP_CUT_T:			crossBSpline = ((BspCutTIntersection*)intersection)->GetBsp();			afterDepth = beforeDepth;			break;		case GenericIntersection::CUT_CUT:			crossCut = ((CutCutIntersection*)intersection)->GetOtherCut(traversalCut);			afterDepth = beforeDepth;			break;	}		//This code prevents labelings with negative segment depths from being considered legal.  If this is disabled, labelings with negative	//depths might occur, but will automatically be normalized to a min depth of 0 after the labeling search is completed anyway.  This	//usually works quite well, but if there are problems, you might consider enabling this code to prevent negative depths entirely.	//	NOTE:	Make sure to keep this code commented or uncommented in concert with the same version in HandleBSplinePropagation.	//MyAssert(beforeDepth >= 0);	//if (afterDepth < 0)	//	return false;		int maxPossibleDepthNext = propagateForward ? traversalCut->GetMaxPossibleSectionDepthAfterIntersection(intersection) :												traversalCut->GetMaxPossibleSectionDepthBeforeIntersection(intersection);	if (afterDepth > maxPossibleDepthNext)		return false;		//See if the traversal depths are legal with the cross depths	bool crossLegal = true;					if (intersection->GetType() == GenericIntersection::BSP_CUT)	{		int cvCross = ((BspCutIntersection*)intersection)->GetCv();		int sgCross = ((BspCutIntersection*)intersection)->GetSg();				//Don't even bother checking this if the cross depths aren't constrained		bool crossPrevSectionConst = crossBSpline->GetSectionDepthConstraintBeforeIntersection(intersection, cvCross, sgCross);		bool crossPostSectionConst = crossBSpline->GetSectionDepthConstraintAfterIntersection(intersection, cvCross, sgCross);		if (crossPrevSectionConst || crossPostSectionConst)		{			int crossDepthOne = crossBSpline->GetSectionDepthBeforeIntersection(intersection, cvCross, sgCross);			int crossDepthTwo = crossBSpline->GetSectionDepthAfterIntersection(intersection, cvCross, sgCross);						if (crossPrevSectionConst && crossPostSectionConst)				MyAssert(crossDepthOne == crossDepthTwo);						if (!((BspCutIntersection*)intersection)->GetBspOnTop())	//Cut on top			{				MyAssert(beforeDepth == afterDepth);								if (crossPrevSectionConst && crossDepthOne <= beforeDepth)						crossLegal = false;				else if (crossPostSectionConst && crossDepthTwo <= beforeDepth)						crossLegal = false;			}			else if (propagateForward)	//Bsp on top			{				if (occludedEdge == 1)				{					MyAssert(beforeDepth == afterDepth + 1);					if (crossPrevSectionConst && crossDepthOne > afterDepth)							crossLegal = false;					else if (crossPostSectionConst && crossDepthTwo > afterDepth)							crossLegal = false;				}				else				{					MyAssert(afterDepth == beforeDepth + 1);					if (crossPrevSectionConst && crossDepthOne > beforeDepth)						crossLegal = false;					else if (crossPostSectionConst && crossDepthTwo > beforeDepth)						crossLegal = false;				}			}			else	//Bsp on top, propagate backward			{				if (occludedEdge == 2)				{					MyAssert(beforeDepth == afterDepth + 1);					if (crossPrevSectionConst && crossDepthOne > afterDepth)							crossLegal = false;					else if (crossPostSectionConst && crossDepthTwo > afterDepth)							crossLegal = false;				}				else				{					MyAssert(afterDepth == beforeDepth + 1);					if (crossPrevSectionConst && crossDepthOne > beforeDepth)						crossLegal = false;					else if (crossPostSectionConst && crossDepthTwo > beforeDepth)						crossLegal = false;				}			}		}	}	if (!crossLegal)	{		MyAssert(!minDeltaLeaf);		return false;	}		//Remember the prev after depth	int prevAfterDepth = propagateForward ? traversalCut->GetSectionDepthAfterIntersection(intersection) :											traversalCut->GetSectionDepthBeforeIntersection(intersection);	MyAssert(propagateForward ? !traversalCut->GetSectionDepthConstraintAfterIntersection(intersection) :								!traversalCut->GetSectionDepthConstraintBeforeIntersection(intersection));		if (afterDepth != prevAfterDepth)	{		accumDepthDelta++;		if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)//еее(accumFlipDelta > minFlipDelta || (accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))			return false;	}		if (propagateForward)	{		traversalCut->SetSectionDepthAfterIntersection(intersection, afterDepth);		traversalCut->SetSectionDepthConstraintAfterIntersection(intersection, true);	}	else	//propagate backward	{		traversalCut->SetSectionDepthBeforeIntersection(intersection, afterDepth);		traversalCut->SetSectionDepthConstraintBeforeIntersection(intersection, true);	}		//Propagate through	GenericIntersection* nextInter = propagateForward ? traversalCut->FindNextIntersection(intersection) :														traversalCut->FindPrevIntersection(intersection);		if (gDebug)	{		/*SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(whiteColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		*/		SetRect(&r, max(nextInter->GetLocation().h, 0.0) - (recursionDepth + 11), nextInter->GetLocation().v - (recursionDepth + 11), max(nextInter->GetLocation().h, 0.0) + (recursionDepth + 11), nextInter->GetLocation().v + (recursionDepth + 11));		ForeColor(redColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qt = 1;	}		if (minDeltaLeaf)		MyAssert(child != 0);		MyAssert(!timeLimitReached);		Drawing* nextLevelLeaf = NULL;	bool betterSolutionFound;	switch (gCompanionSetMethod)	{		case 0:			betterSolutionFound =  CreateLegalLabelingUsingCutTraversalTreeCompSetMethod0(recursionDepth + 1, nextInter->GetLocation(), traversalCutIndex,																							touchedBSplineIndexes, nextLevelLeaf,																							propagateForward,																							minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																							timeLimitReached);			break;		case 1:			betterSolutionFound =  CreateLegalLabelingUsingCutTraversalTreeCompSetMethod1(recursionDepth + 1, nextInter->GetLocation(), traversalCutIndex,																							touchedBSplineIndexes, nextLevelLeaf,																							propagateForward,																							minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																							timeLimitReached);			break;		case 2:			betterSolutionFound =  CreateLegalLabelingUsingCutTraversalTreeCompSetMethod2(recursionDepth + 1, nextInter->GetLocation(), traversalCutIndex,																							touchedBSplineIndexes, nextLevelLeaf,																							propagateForward,																							minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																							timeLimitReached);			break;	}		//Undo the change	if (propagateForward)	{		traversalCut->SetSectionDepthAfterIntersection(intersection, prevAfterDepth);		traversalCut->SetSectionDepthConstraintAfterIntersection(intersection, false);	}	else	//propagate backward	{		traversalCut->SetSectionDepthBeforeIntersection(intersection, prevAfterDepth);		traversalCut->SetSectionDepthConstraintBeforeIntersection(intersection, false);	}		if (!betterSolutionFound)		MyAssert(!nextLevelLeaf);	else	//better solution found	{		if (minDeltaLeaf)		{			MyAssert(child != 0);			delete minDeltaLeaf;		}		MyAssert(nextLevelLeaf);		minDeltaLeaf = nextLevelLeaf;	}		if (gDebug)	{		SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(magentaColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qt = 1;	}		if (betterSolutionFound)		MyAssert(minDeltaLeaf);	return betterSolutionFound;}bool Drawing::HandleCutPropagationEnd(int recursionDepth, int child,									GenericIntersection* intersection, int traversalCutIndex,									vector<int>& touchedBSplineIndexes,									int beforeDepth, bool propagateForward,									Drawing*& minDeltaLeaf, int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,									bool& timeLimitReached){	MyAssert(!timeLimitReached);		Rect r;	//еее	FloatPoint intersectionLoc = intersection->GetLocation();	//еее		int afterDepth;	int occludedEdge = intersection->DetermineOccludedEdge();		BSplineToBSplineCut* traversalCut = bsplinePairCuts[traversalCutIndex];		//sTreeWalk3++;		//Determine the propagated depth on the far side of the intersection	bool propagationLegal = true;	switch (intersection->GetType())	{		case GenericIntersection::BSP_BSP:			MyAssert(false);			break;		case GenericIntersection::BSP_CUT:			GenericIntersection* nextIntersection = traversalCut->FindNextIntersection(intersection);						afterDepth = propagateForward ? traversalCut->GetSectionDepthAfterIntersection(intersection) :											traversalCut->GetSectionDepthBeforeIntersection(intersection);			BSpline* bsp = ((BspCutTIntersection*)nextIntersection)->GetBsp();			int cv = ((BspCutTIntersection*)nextIntersection)->GetCv();			int sg = ((BspCutTIntersection*)nextIntersection)->GetSg();						MyAssert(bsp->GetSectionDepthBeforeIntersection(intersection, cv, sg) == bsp->GetSectionDepthAfterIntersection(intersection, cv, sg));			if (afterDepth != bsp->GetSectionDepthBeforeIntersection(intersection, cv, sg))				propagationLegal = false;	//After depth should match bspline depth			break;		case GenericIntersection::BSP_CUT_T:			afterDepth = propagateForward ? traversalCut->GetSectionDepthAfterIntersection(intersection) :											traversalCut->GetSectionDepthBeforeIntersection(intersection);			if (afterDepth != beforeDepth)				propagationLegal = false;			break;		case GenericIntersection::CUT_CUT:			MyAssert(false);			break;	}		//This boundry is completely checked, so find a boundry that isn't completely checked.	//If there are none, this is a leaf.	//However, only proceed if the solution is legal so far.	bool betterSolutionFound = false;	if (propagationLegal)	{		int nextTouchedBspIndex = 0;		for (nextTouchedBspIndex = 0; nextTouchedBspIndex < touchedBSplineIndexes.size(); nextTouchedBspIndex++)			if (!bsplines[touchedBSplineIndexes[nextTouchedBspIndex]]->GetAllSectionsConstrained())				break;				if (nextTouchedBspIndex == touchedBSplineIndexes.size())	//No more bsplines		{			if (accumFlipDelta < minFlipDelta || (accumFlipDelta == minFlipDelta && accumDepthDelta < minDepthDelta))			{				bool assertIt = true;				for (int i = 0; i < touchedBSplineIndexes.size(); i++)					MyAssert(bsplines[touchedBSplineIndexes[i]]->GetAllIntersectionsLegal(assertIt));								minDeltaLeaf = new Drawing(*this);				minFlipDelta = accumFlipDelta;				minDepthDelta = accumDepthDelta;				betterSolutionFound = true;								if (gDebug12)				{					InitAnalysisWindow();										IncrementTextV();					MoveTo(5, IncrementTextV() * 10 + 5);					DrawString("\pMin solution: Delta: ");					Str255 str1;					NumToString(accumFlipDelta, str1);					DrawString(str1);					NumToString(accumDepthDelta, str1);					DrawString("\p/");					DrawString(str1);										DrawString("\p Time: ");										clock_t timeUsed = clock() - labelingStartTime;					long double timeUsedSecs = timeUsed / CLOCKS_PER_SEC;					FloatToPascal(timeUsedSecs, 3, str1);					DrawString(str1);										IncrementTextV();					gTextH = 0;										QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);					SetPort(GetWindowPort(gMainWindow->GetWindow()));				}			}			else			{				if (gDebug12)				{					InitAnalysisWindow();										IncrementTextV();					MoveTo(5, IncrementTextV() * 10 + 5);					DrawString("\pWorse solution: Delta: ");					Str255 str1;					NumToString(accumFlipDelta, str1);					DrawString(str1);					NumToString(accumDepthDelta, str1);					DrawString("\p/");					DrawString(str1);										DrawString("\p Time: ");										clock_t timeUsed = clock() - labelingStartTime;					long double timeUsedSecs = timeUsed / CLOCKS_PER_SEC;					FloatToPascal(timeUsedSecs, 3, str1);					DrawString(str1);										IncrementTextV();					gTextH = 0;										QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);					SetPort(GetWindowPort(gMainWindow->GetWindow()));				}			}		}		else	//Traverse the next bspline		{			BSpline* nextBsp = bsplines[touchedBSplineIndexes[nextTouchedBspIndex]];						//GenericIntersection* nextBspFirstInter = nextBsp->GetFirstBspBspIntersection();			//MyAssert(nextBspFirstInter);						int numPossibleDepths;			GenericIntersection* nextBspFirstInter;			if (gDepthEnumerationMethod == 0)			{				nextBspFirstInter = nextBsp->GetFirstIntersection();								//The number of possible depths for a bspline is half the number of intersections in its group				vector<GenericIntersection*> groupInters = GetOneBSplineGroupIntersections(nextBsp);				if (groupInters.size() == 0)					groupInters = nextBsp->GetIntersections();				int totalInters = groupInters.size();				for (int ii = 0; ii < groupInters.size(); ii++)					if (groupInters[ii]->SelfIntersection() || groupInters[ii]->GetType() == GenericIntersection::BSP_CUT_T)						totalInters--;				numPossibleDepths = max(2, totalInters / 2);			}			else if (gDepthEnumerationMethod == 1)			{				int startingSection = nextBsp->GetDeepestMaxPossibleSection();				numPossibleDepths = nextBsp->GetMaxPossibleSectionDepth(startingSection) + 1;				nextBspFirstInter = nextBsp->GetIntersectionFromIndex(startingSection);			}			else if (gDepthEnumerationMethod == 2)			{				int startingSection = nextBsp->GetShallowestMaxPossibleSection();				numPossibleDepths = nextBsp->GetMaxPossibleSectionDepth(startingSection) + 1;				nextBspFirstInter = nextBsp->GetIntersectionFromIndex(startingSection);			}						int ad = accumFlipDelta, md = minFlipDelta;			for (int i = 0; i < numPossibleDepths; i++)			{				if (gDebug)				{						/*SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));					ForeColor(whiteColor);					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);					*/					SetRect(&r, max(nextBspFirstInter->GetLocation().h, 0.0) - (recursionDepth + 11), nextBspFirstInter->GetLocation().v - (recursionDepth + 11), max(nextBspFirstInter->GetLocation().h, 0.0) + (recursionDepth + 11), nextBspFirstInter->GetLocation().v + (recursionDepth + 11));					ForeColor(blueColor);					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qt = 1;				}								MyAssert(!timeLimitReached);								Drawing* nextLevelLeaf = NULL;				bool oneBetterSolutionFound;				switch (gCompanionSetMethod)				{					case 0:						oneBetterSolutionFound = CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod0(recursionDepth + 1, i, nextBspFirstInter->GetLocation(), touchedBSplineIndexes[nextTouchedBspIndex],																											touchedBSplineIndexes, nextLevelLeaf,																											minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																											timeLimitReached);						break;					case 1:						oneBetterSolutionFound = CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod1(recursionDepth + 1, i, nextBspFirstInter->GetLocation(), touchedBSplineIndexes[nextTouchedBspIndex],																											touchedBSplineIndexes, nextLevelLeaf,																											minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																											timeLimitReached);						break;					case 2:						oneBetterSolutionFound = CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod2(recursionDepth + 1, i, nextBspFirstInter->GetLocation(), touchedBSplineIndexes[nextTouchedBspIndex],																											touchedBSplineIndexes, nextLevelLeaf,																											minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																											timeLimitReached);						break;				}								if (!oneBetterSolutionFound)					MyAssert(!nextLevelLeaf);				else	//better solution found				{					betterSolutionFound = true;					if (minDeltaLeaf)					{						MyAssert(child != 0 || i > 0);						delete minDeltaLeaf;					}					MyAssert(nextLevelLeaf);					minDeltaLeaf = nextLevelLeaf;				}								if (timeLimitReached)					break;								if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)//еее(accumFlipDelta > minFlipDelta || (accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))					break;								if (gDebug)				{					SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));					ForeColor(cyanColor);					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qt = 1;				}			}		}			}		if (betterSolutionFound)		MyAssert(minDeltaLeaf);	return betterSolutionFound;}bool Drawing::HandleCutPropagationTurnOutOfCut(int recursionDepth /*DEBUG*/, GenericIntersection* intersection,												BSplineToBSplineCut* traversalCut, vector<int>& touchedBSplineIndexes,												int beforeDepth,												Drawing*& minDeltaLeaf, int& minFlipDelta, int accumFlipDelta, int& minDepthDelta, int accumDepthDelta,												bool& timeLimitReached){	MyAssert(!timeLimitReached);		Rect r;	//еее	FloatPoint intersectionLoc = intersection->GetLocation();	//еее		MyAssert(intersection->GetType() == GenericIntersection::BSP_CUT_T);	BspCutTIntersection* bspCutTinter = (BspCutTIntersection*)intersection;		BSpline *crossBSpline = bspCutTinter->GetBsp();	int traversalBSplineIndex = GetBSplineIndex(crossBSpline);		int cv = bspCutTinter->GetCv();	int sg = bspCutTinter->GetSg();	bool bspConstrained = crossBSpline->GetSectionDepthConstraintAfterIntersection(intersection, cv, sg);	if (bspConstrained)	//Verify the end and skip to the next bspline		return HandleBSplinePropagationEnd(recursionDepth, /*child*/1,											intersection, traversalBSplineIndex, touchedBSplineIndexes,											cv, sg, beforeDepth,											minDeltaLeaf, minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,											timeLimitReached);		//After the turn out of the cut, the depth of the BSpline should match the cut	int afterDepth = beforeDepth;		//Remember the prev after depth	int prevAfterDepth = crossBSpline->GetSectionDepthAfterIntersection(intersection, cv, sg);	MyAssert(!crossBSpline->GetSectionDepthConstraintAfterIntersection(intersection, cv, sg));		if (afterDepth != prevAfterDepth)	{		accumDepthDelta++;		if (gBoundingMethod == 1 && accumFlipDelta >= minFlipDelta)//еее(accumFlipDelta > minFlipDelta || (accumFlipDelta >= minFlipDelta && accumDepthDelta >= minDepthDelta)))			return false;	}		crossBSpline->SetSectionDepthAfterIntersection(intersection, cv, sg, afterDepth);	crossBSpline->SetSectionDepthConstraintAfterIntersection(intersection, cv, sg, true);		//Propagate through	GenericIntersection* nextInter = crossBSpline->FindNextIntersection(intersection, cv, sg);		if (gDebug)	{		/*SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(whiteColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		*/		SetRect(&r, max(nextInter->GetLocation().h, 0.0) - (recursionDepth + 11), nextInter->GetLocation().v - (recursionDepth + 11), max(nextInter->GetLocation().h, 0.0) + (recursionDepth + 11), nextInter->GetLocation().v + (recursionDepth + 11));		ForeColor(redColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qt = 1;	}		//if (minDeltaLeaf)	//	MyAssert(child == 1);		MyAssert(!timeLimitReached);		Drawing* nextLevelLeaf = NULL;	bool betterSolutionFound;	switch (gCompanionSetMethod)	{		case 0:			betterSolutionFound = CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod0(recursionDepth + 1, -1, nextInter->GetLocation(), traversalBSplineIndex,																								touchedBSplineIndexes, nextLevelLeaf,																								minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																								timeLimitReached);			break;		case 1:			betterSolutionFound = CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod1(recursionDepth + 1, -1, nextInter->GetLocation(), traversalBSplineIndex,																								touchedBSplineIndexes, nextLevelLeaf,																								minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																								timeLimitReached);			break;		case 2:			betterSolutionFound = CreateLegalLabelingUsingBSplineTraversalTreeCompSetMethod2(recursionDepth + 1, -1, nextInter->GetLocation(), traversalBSplineIndex,																								touchedBSplineIndexes, nextLevelLeaf,																								minFlipDelta, accumFlipDelta, minDepthDelta, accumDepthDelta,																								timeLimitReached);			break;	}		//Undo the change	crossBSpline->SetSectionDepthAfterIntersection(intersection, cv, sg, prevAfterDepth);	crossBSpline->SetSectionDepthConstraintAfterIntersection(intersection, cv, sg, false);		if (!betterSolutionFound)		MyAssert(!nextLevelLeaf);	else	//better solution found	{		if (minDeltaLeaf)		{			//MyAssert(child == 1);			delete minDeltaLeaf;		}		MyAssert(nextLevelLeaf);		minDeltaLeaf = nextLevelLeaf;	}		if (gDebug)	{		SetRect(&r, max(intersectionLoc.h, 0.0) - (recursionDepth + 10), intersectionLoc.v - (recursionDepth + 10), max(intersectionLoc.h, 0.0) + (recursionDepth + 10), intersectionLoc.v + (recursionDepth + 10));		ForeColor(magentaColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qt = 1;	}		if (betterSolutionFound)		MyAssert(minDeltaLeaf);	return betterSolutionFound;}