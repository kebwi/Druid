#include "Drawing.h"#include "MinimalDrawing.h"#include "BSpline.h"#include "BSplineToBSplineCut.h"#include "GenericIntersection.h"#include "BspBspIntersection.h"#include "BspCutIntersection.h"#include "BspCutTIntersection.h"#include "CutCutIntersection.h"#include "MainWindow.h"	//еее#include "FloatPoint.h"#include "Colors.h"#include "PascalStringUtil.h"#include "trigConstants.h"#include "Random.h"#include <ColorPicker.h>#include <time.h>#include <algorithm.h>#include <utility.h> //for pair#include <math.h>#include <list.h>#include <vector.h>#include <map.h>#include <set.h>#include <string>#include <sstream>using namespace::std;//******************************************************************************//Extern Globalsextern WindowPtr gAnalysisWindow;	//еееextern Colors gColors;extern MainWindow* gMainWindow;extern Drawing *gDrawing;extern int gPointRadius;extern int gFindPointDist;extern UserEventUPP gEventProcUPP;//******************************************************************************//Global Declarationsunsigned long Drawing::sTreeWalk = 0;unsigned long Drawing::sTreeWalk2 = 0;unsigned long Drawing::sTreeWalk3 = 0;SurfaceTraits Drawing::sOldSurfaceTraits;ColorChangedUPP Drawing::sColorChangedUPP = NULL;NColorChangedUPP Drawing::sColorNChangedUPP = NULL;int gLabelingMethod = 1;	//0:	tree search							//1:	uniquely determine from companion setint gCompanionSetMethod = 2;	//0:	don't use companion sets								//1:	use companion sets to order search, but not to truncate search								//2:	use companion sets to truncate searchint gDepthEnumerationMethod = 2;	//0:	use half the number of intersections on a boundary as the enumeration limit and enumerate from the first intersection on the boundary									//1:	find the depth range for each section of a boundary to use as the enumeration limit and enumerate from the deepest range intersection on the boundary (stupid idea, purely for comparative purposes)									//2:	find the depth range for each section of a boundary to use as the enumeration limit and enumerate from the shallowest range intersection on the boundaryint gBoundingMethod = 1;	//0:	no bounding							//1:	boundingint gTreeSearchMethod = 1;	//0:	depth-first-search							//1:	iterative deepening							//2:	breadth-first-searchfloat gTimeLimitScalar = 1.0;bool gMouseTerminated = false;bool gDebug = false;bool gDebug1 = false;bool gDebug3 = false;bool gDebug5 = true;bool gDebug6 = false;bool gDebug7 = false;bool gDebug8 = false;bool gDebug10 = false;bool gDebug11 = false;bool gDebug12 = false;bool gDebug13 = false;bool gDebug14 = true;int gNumSliceAttempts;int gTextH = 0;int gTextV = 1;vector<GenericIntersection*> gTried;	//еееvector<FloatPoint> gTried2;	//еееint gSolutionIndex;	//еееvector<pair<GenericIntersection*, int> > gInterDists;int gHorizon;clock_t sInitLabelAttemptWithSolutionTimeLimitSeconds = 120.0;//.1;clock_t sInitLabelAttemptWithoutSolutionTimeLimitSeconds = 120.0;//5.0;clock_t gCSECsearchTime;//******************************************************************************//Function Prototypes	//	In external files		//	main.cppvoid MyAssert(bool condition);pascal Boolean ColorPickerEventProc(EventRecord *event);void DoErrorMessage(vector<const char*> errLines);		//lineEquations.cppdouble LineSegmentLength(FloatPoint p1, FloatPoint p2);double LineSegmentAngle(FloatPoint p1, FloatPoint p2);FloatPoint ProjectPointAtAngle(FloatPoint origin, double angle, double segLength);int LineCrossLineDirection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2);bool LineSegmentIntersection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2, FloatPoint &intersection);bool LineSegmentIntersection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2,							FloatPoint &intersection, double& lineSegInter1, double& lineSegInter2);#pragma mark -WholeObject::WholeObject() : dtored(false){}WholeObject::~WholeObject(){	MyAssert(!dtored);		//A little late to check for repeats since this is the dtor, but do it anyway	for (vector<BspCutTIntersection*>::iterator i = bspCutTinters.begin(); i != bspCutTinters.end(); i++)	{		vector<BspCutTIntersection*>::iterator j = i;		j++;		MyAssert(find(j, bspCutTinters.end(), *i) == bspCutTinters.end());	}		for (int i = 0; i < bspCutTinters.size(); i++)	{		MyAssert(bspCutTinters[i]->GetInfiniteWholeObject() == this);		bspCutTinters[i]->SetInfiniteWholeObject(NULL);	}	bspCutTinters.clear();		dtored = true;};//******************************************************************************#pragma mark -Drawing::Drawing() : dtored(false), showCrossingStates(true), showCuts(true), showDepths(true), showCompSets(true),					labelingStartTime(0), labelAttemptWithSolutionTimeLimitSeconds(sInitLabelAttemptWithSolutionTimeLimitSeconds), labelAttemptWithoutSolutionTimeLimitSeconds(sInitLabelAttemptWithoutSolutionTimeLimitSeconds),					manualCutStartBsp(NULL), manualCutStartSeg(-1){}//Argument can't be const.  Geez!  Something to do with STL.Drawing::Drawing(Drawing& d) : dtored(false){	MyAssert(!d.dtored);		if (&d == this)		return;		*this = d;	/*	for (int i = 0; i < bsplines.size(); i++)	{		vector<int>* depths = bsplines[i]->GetSectionDepths();		 = new int[depths->size()];		for (int j = 0; j < depths->size(); j++)			d[j] = (*depths)[j];	}	*/		//Just an assert	for (int i = 0; i < wholeObjects.size(); i++)	{		WholeObject* wholeObject1 = wholeObjects[i];				for (int j = 0; j < wholeObject1->bspCutTinters.size(); j++)		{			MyAssert(!wholeObject1->bspCutTinters[j]->GetDtored());			MyAssert(wholeObject1->bspCutTinters[j]->GetDrawing() == this);			MyAssert(wholeObject1->bspCutTinters[j]->GetInfiniteWholeObject() == wholeObject1);		}	}}const Drawing& Drawing::operator=(Drawing& d){	MyAssert(!d.dtored);		if (&d == this)		return *this;		VerifyIntersectionDrawingMatch();	d.VerifyIntersectionDrawingMatch();		MyAssert(brandNewIntersections.size() == 0);		VerifyNothingDtored();	d.VerifyNothingDtored();	for (int i = 0; i < d.interCompanionSets.size(); i++)		for (int j = 0; j < d.interCompanionSets[i]->size(); j++)			MyAssert(find(d.intersections.begin(), d.intersections.end(), (*d.interCompanionSets[i])[j]) != d.intersections.end());		showCrossingStates = d.showCrossingStates;	showCuts = d.showCuts;	showDepths = d.showDepths;	showCompSets = d.showCompSets;		labelingStartTime = d.labelingStartTime;	labelAttemptWithSolutionTimeLimitSeconds = d.labelAttemptWithSolutionTimeLimitSeconds;	labelAttemptWithoutSolutionTimeLimitSeconds = d.labelAttemptWithoutSolutionTimeLimitSeconds;		//gDebug no BSplines dtored	for (int i = 0; i < d.bsplines.size(); i++)		MyAssert(!d.bsplines[i]->dtored);		//Erase the existing drawing by deleting and removing all its objects		//Delete and remove all BSplines	for (int i = 0; i < bsplines.size(); i++)		delete bsplines[i];	bsplines.clear();		//Delete and remove all Cuts	for (int i = 0; i < bsplinePairCuts.size(); i++)		delete bsplinePairCuts[i];	bsplinePairCuts.clear();		//Delete and remove all PrevCuts	for (int i = 0; i < prevCuts.size(); i++)		delete prevCuts[i];	prevCuts.clear();		//Delete and remove all Intersections	for (int i = 0; i < intersections.size(); i++)		delete intersections[i];	intersections.clear();		//Copy the BSplines	//This won't copy the Intersection lists in the BSplines, but the creation of the	//new intersections below will insert them into the BSplines' intersection lists	for (int i = 0; i < d.bsplines.size(); i++)		bsplines.push_back(new BSpline(*(d.bsplines[i]), this));		//Copy the Cuts and add the correct BSplines	//This won't copy the Intersection lists in the BSplines, but the creation of the	//new intersections below will insert them into the BSplines' intersection lists	for (int i = 0; i < d.bsplinePairCuts.size(); i++)	{		bsplinePairCuts.push_back(new BSplineToBSplineCut(*(d.bsplinePairCuts[i]), this));		if (d.bsplinePairCuts[i]->GetBsp2())			bsplinePairCuts[bsplinePairCuts.size() - 1]->SetBSplines(bsplines[d.GetBSplineIndex(d.bsplinePairCuts[i]->GetBsp1())],																	bsplines[d.GetBSplineIndex(d.bsplinePairCuts[i]->GetBsp2())]);		else bsplinePairCuts[bsplinePairCuts.size() - 1]->SetBSplines(bsplines[d.GetBSplineIndex(d.bsplinePairCuts[i]->GetBsp1())],																	NULL);	}		//Copy the prevCuts	for (int i = 0; i < d.prevCuts.size(); i++)	{		PrevCut* prevCut = d.prevCuts[i];				//I am not sure why this happens yet, but let's just dodge the issue for now.		//At some future point, this should be more carefully studied.		//Bottom line, I don't think there should be any PrevCuts with invalid BSpline pointers in them.		if (find(d.bsplines.begin(), d.bsplines.end(), prevCut->bsp1) == d.bsplines.end() &&			find(d.bsplines.begin(), d.bsplines.end(), prevCut->bsp2) == d.bsplines.end())			continue;				PrevCut* prevCutCopy = new PrevCut;				prevCutCopy->cv1 = prevCut->cv1;		prevCutCopy->cv2 = prevCut->cv2;		prevCutCopy->sg1 = prevCut->sg1;		prevCutCopy->sg2 = prevCut->sg2;		prevCutCopy->numInters = prevCut->numInters;				int bspIndex = 0;		while (bspIndex < d.bsplines.size() && d.bsplines[bspIndex] != prevCut->bsp1)			bspIndex++;		MyAssert(bspIndex < d.bsplines.size());		prevCutCopy->bsp1 = bsplines[bspIndex];				if (prevCut->bsp2)		{			bspIndex = 0;			while (bspIndex < d.bsplines.size() && d.bsplines[bspIndex] != prevCut->bsp2)				bspIndex++;			MyAssert(bspIndex < d.bsplines.size());			prevCutCopy->bsp2 = bsplines[bspIndex];		}		else prevCutCopy->bsp2 = NULL;				prevCuts.push_back(prevCutCopy);	}		d.VerifyPrevCuts();	VerifyPrevCuts();		//еее DEBUG	for (int i = 0; i < intersections.size(); i++)		MyAssert(intersections[i]->GetType() != GenericIntersection::BSP_CUT || !((BspCutIntersection*)intersections[i])->GetCutIsSlice());		//Copy the Intersections.  This will create the necessary intersection lists.	for (int i = 0; i < d.intersections.size(); i++)	{		//MyAssert(!d.intersections[i]->GetHardConstraint());		MyAssert(!d.intersections[i]->GetDtored());		MyAssert(d.intersections[i]->GetDrawing() == &d);				int index1, index2;		switch (d.intersections[i]->GetType())		{			case GenericIntersection::BSP_BSP:				BspBspIntersection* oldBspBspInter = (BspBspIntersection*)d.intersections[i];								index1 = oldBspBspInter->GetBsp1Index();				index2 = oldBspBspInter->GetBsp2Index();								MyAssert(oldBspBspInter->GetBsp1() == d.bsplines[index1]);				MyAssert(oldBspBspInter->GetBsp2() == d.bsplines[index2]);								BspBspIntersection* newBspBspInter = new BspBspIntersection(*oldBspBspInter, this, bsplines[index1], bsplines[index2]);								//Add the new intersection to its corresponding BSplines				//Don't equalize the number of sections however.  This was done when the BSpline was copied.				bsplines[index1]->AddIntersection(newBspBspInter->GetCv1(), newBspBspInter->GetSg1(), newBspBspInter, false);				bsplines[index2]->AddIntersection(newBspBspInter->GetCv2(), newBspBspInter->GetSg2(), newBspBspInter, false);				break;			case GenericIntersection::BSP_CUT:				BspCutIntersection* oldBspCutInter = (BspCutIntersection*)d.intersections[i];								index1 = oldBspCutInter->GetBspIndex();				index2 = oldBspCutInter->GetCutIndex();								MyAssert(index2 != -1);				MyAssert(index2 < bsplinePairCuts.size());								MyAssert(oldBspCutInter->GetBsp() == d.bsplines[index1]);				MyAssert(oldBspCutInter->GetCut() == d.bsplinePairCuts[index2]);								BspCutIntersection* newBspCutInter = new BspCutIntersection(*oldBspCutInter, this, bsplines[index1], bsplinePairCuts[index2]);								//Add the new intersection to its corresponding BSpline and Cut				//Don't equalize the number of sections however.  This was done when the BSpline was copied.				bsplines[index1]->AddIntersection(newBspCutInter->GetCv(), newBspCutInter->GetSg(), newBspCutInter, false);				bsplinePairCuts[index2]->AddIntersection(newBspCutInter, false, false);				break;			case GenericIntersection::BSP_CUT_T:				BspCutTIntersection* oldBspCutTInter = (BspCutTIntersection*)d.intersections[i];								index1 = oldBspCutTInter->GetBsp() ? oldBspCutTInter->GetBspIndex() : -1;				index2 = oldBspCutTInter->GetCutIndex();								MyAssert(index2 != -1);				MyAssert(index2 < bsplinePairCuts.size());								if (index1 != -1)					MyAssert(oldBspCutTInter->GetBsp() == d.bsplines[index1]);				MyAssert(oldBspCutTInter->GetCut() == d.bsplinePairCuts[index2]);								BspCutTIntersection* newBspCutTInter;				if (index1 != -1)					newBspCutTInter = new BspCutTIntersection(*oldBspCutTInter, this, bsplines[index1], bsplinePairCuts[index2]);				else newBspCutTInter = new BspCutTIntersection(*oldBspCutTInter, this, NULL, bsplinePairCuts[index2]);								//Add the new intersection to its corresponding BSpline and Cut				//Don't equalize the number of sections however.  This was done when the BSpline was copied.				if (index1 != -1)					bsplines[index1]->AddIntersection(newBspCutTInter->GetCv(), newBspCutTInter->GetSg(), newBspCutTInter, false);				bsplinePairCuts[index2]->AddIntersection(newBspCutTInter, false, false);				break;			case GenericIntersection::CUT_CUT:				CutCutIntersection* oldCutCutInter = (CutCutIntersection*)d.intersections[i];								index1 = oldCutCutInter->GetCut1Index();				index2 = oldCutCutInter->GetCut2Index();								MyAssert(index1 != -1 && index2 != -1);				MyAssert(index1 < bsplinePairCuts.size());				MyAssert(index2 < bsplinePairCuts.size());								MyAssert(oldCutCutInter->GetCut1() == d.bsplinePairCuts[index1]);				MyAssert(oldCutCutInter->GetCut2() == d.bsplinePairCuts[index2]);								CutCutIntersection* newCutCutInter = new CutCutIntersection(*oldCutCutInter, this, bsplinePairCuts[index1], bsplinePairCuts[index2]);								//Add the new intersection to its corresponding Cuts				bsplinePairCuts[index1]->AddIntersection(newCutCutInter, false, false);				bsplinePairCuts[index2]->AddIntersection(newCutCutInter, false, false);				break;		}	}	ClearBrandNewIntersections();	//Important, the intersection ctors above label all the copied intersections as brand new		for (int i = 0; i < bsplines.size(); i++)		bsplines[i]->MakeIntersectionList();		//Verify that this Drawing's new intersections have the appropriate BSpline and Cut pointers and indexes	for (int i = 0; i < intersections.size(); i++)	{		MyAssert(intersections[i]->GetDrawing() == this);		switch (intersections[i]->GetType())		{			case GenericIntersection::BSP_BSP:				BspBspIntersection* bspBspInter = (BspBspIntersection*)intersections[i];								MyAssert(bspBspInter->GetBsp1() == bsplines[bspBspInter->GetBsp1Index()]);				MyAssert(bspBspInter->GetBsp2() == bsplines[bspBspInter->GetBsp2Index()]);				break;			case GenericIntersection::BSP_CUT:				BspCutIntersection* bspCutInter = (BspCutIntersection*)intersections[i];								MyAssert(bspCutInter->GetBsp() == bsplines[bspCutInter->GetBspIndex()]);				MyAssert(bspCutInter->GetCut() == bsplinePairCuts[bspCutInter->GetCutIndex()]);				break;			case GenericIntersection::BSP_CUT_T:				BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)intersections[i];								if (bspCutTInter->GetBsp())					MyAssert(bspCutTInter->GetBsp() == bsplines[bspCutTInter->GetBspIndex()]);				MyAssert(bspCutTInter->GetCut() == bsplinePairCuts[bspCutTInter->GetCutIndex()]);				break;			case GenericIntersection::CUT_CUT:				CutCutIntersection* cutCutInter = (CutCutIntersection*)intersections[i];								MyAssert(cutCutInter->GetCut1() == bsplinePairCuts[cutCutInter->GetCut1Index()]);				MyAssert(cutCutInter->GetCut2() == bsplinePairCuts[cutCutInter->GetCut2Index()]);				break;		}	}		//Copy the companion sets	MyAssert(interCompanionPairSets.size() == 0);	//I don't see why this ever would have been true, but it doesn't seem to have caused trouble in the past, which suggests this vector was always 0 here.	for (int i = 0; i < interCompanionPairSets.size(); i++)		delete interCompanionPairSets[i];	interCompanionPairSets.clear();	/*	for (int i = 0; i < d.interCompanionPairSets.size(); i++)	//Loop through the sets	{		//Make a new set		vector<pair<GenericIntersection*, GenericIntersection*> >* newSet = new vector<pair<GenericIntersection*, GenericIntersection*> >;				for (int j = 0; j < d.interCompanionPairSets[i]->size(); j++)	//Loop through the pairs of one set		{			//Get the old pair			pair<GenericIntersection*, GenericIntersection*> oldPair = (*d.interCompanionPairSets[i])[j];						//Make a new pair			pair<GenericIntersection*, GenericIntersection*> newPair;			int interIndex = d.GetIntersectionIndex(oldPair.first);			newPair.first = intersections[interIndex];			interIndex = d.GetIntersectionIndex(oldPair.second);			newPair.second = intersections[interIndex];						//Add the pair to the set			newSet->push_back(newPair);		}				interCompanionPairSets.push_back(newSet);	}	*/	DeleteAllCompSets();	for (int i = 0; i < d.interCompanionSets.size(); i++)	//Loop through the sets	{		MyAssert(d.interCompanionSets[i]->size() > 0);				//Make a new set		vector<GenericIntersection*>* newSet = new vector<GenericIntersection*>;				for (int j = 0; j < d.interCompanionSets[i]->size(); j++)	//Loop through the pairs of one set		{			int interIndex = d.GetIntersectionIndex((*d.interCompanionSets[i])[j]);			MyAssert(intersections[interIndex]->GetType() == GenericIntersection::BSP_BSP || intersections[interIndex]->GetType() == GenericIntersection::BSP_CUT);			newSet->push_back(intersections[interIndex]);		}				MyAssert(newSet->size() > 0);		interCompanionSets.push_back(newSet);	}		//Clear the whole objects	for (int i = 0; i < wholeObjects.size(); i++)		delete wholeObjects[i];	wholeObjects.clear();		//Copy the whole objects	//Loop over the whole objects	for (int ii = 0; ii < d.wholeObjects.size(); ii++)	{		WholeObject* wholeObject = new WholeObject();		WholeObject* dWholeObject = d.wholeObjects[ii];				for (int jj = 0; jj < dWholeObject->bgDepths.size(); jj++)			wholeObject->bgDepths.push_back(dWholeObject->bgDepths[jj]);				//Loop over the bsplines in the whole object		for (int jj = 0; jj < dWholeObject->bsplines.size(); jj++)		{			//Loop over the bsplines			int kk = 0;			for (kk = 0; kk < d.bsplines.size(); kk++)				if (dWholeObject->bsplines[jj] == d.bsplines[kk])				{					wholeObject->bsplines.push_back(bsplines[kk]);					break;				}			MyAssert(kk < d.bsplines.size());		}				//Loop over the BspCutTinters in the whole object		MyAssert(intersections.size() == d.intersections.size());		for (int jj = 0; jj < dWholeObject->bspCutTinters.size(); jj++)		{			BspCutTIntersection* dBspCutTinter = (BspCutTIntersection*)dWholeObject->bspCutTinters[jj];			MyAssert(!dBspCutTinter->GetDtored());			int dBspCutTinterIndex = d.GetIntersectionIndex(dBspCutTinter, true);			MyAssert(dBspCutTinterIndex >= 0 && dBspCutTinterIndex < intersections.size());						MyAssert(intersections[dBspCutTinterIndex]->GetType() == GenericIntersection::BSP_CUT_T);			BspCutTIntersection* bspCutTinter = (BspCutTIntersection*)intersections[dBspCutTinterIndex];			MyAssert(!bspCutTinter->GetDtored());			MyAssert(bspCutTinter->GetInfiniteWOsection() == wholeObject->bspCutTinters.size());	//What is this checking exactly?			MyAssert(find(wholeObject->bspCutTinters.begin(), wholeObject->bspCutTinters.end(), bspCutTinter) == wholeObject->bspCutTinters.end());			bspCutTinter->SetInfiniteWholeObject(wholeObject);						wholeObject->bspCutTinters.push_back(bspCutTinter);		}				wholeObjects.push_back(wholeObject);	}		//Just an assert	for (int i = 0; i < wholeObjects.size(); i++)	{		WholeObject* wholeObject1 = wholeObjects[i];				for (int j = 0; j < wholeObject1->bspCutTinters.size(); j++)		{			MyAssert(!wholeObject1->bspCutTinters[j]->GetDtored());			MyAssert(wholeObject1->bspCutTinters[j]->GetDrawing() == this);			MyAssert(wholeObject1->bspCutTinters[j]->GetInfiniteWholeObject() == wholeObject1);		}	}		return *this;}Drawing::~Drawing(){	VerifyIntersectionDrawingMatch();		for (vector<GenericIntersection*>::iterator i = intersections.begin(); i != intersections.end(); i++)		MyAssert(!(*i)->GetDtored());		//Just an assert	for (int i = 0; i < wholeObjects.size(); i++)	{		WholeObject* wholeObject1 = wholeObjects[i];				for (int j = 0; j < wholeObject1->bspCutTinters.size(); j++)		{			MyAssert(!wholeObject1->bspCutTinters[j]->GetDtored());			MyAssert(wholeObject1->bspCutTinters[j]->GetDrawing() == this);			MyAssert(wholeObject1->bspCutTinters[j]->GetInfiniteWholeObject() == wholeObject1);		}	}	/*	int numInts = intersections.size();	Intersection** intArr = new Intersection*[numInts];	for (int i = 0; i < numInts; i++)		intArr[i] = intersections[i];	*/	//Delete the intersections before deleting the BSplines.	//This isn't crucial, but means the BSplines don't have to delete the intersections themselves because	//the intersections will be gone at that point.		vector<int> woBspCutTs;	//debug	for (int i = 0; i < wholeObjects.size(); i++)		woBspCutTs.push_back(wholeObjects[i]->bspCutTinters.size());		while (intersections.size() > 0)		delete intersections.back();	intersections.clear();		vector<int> woBspCutTs2;	//debug	for (int i = 0; i < wholeObjects.size(); i++)		woBspCutTs2.push_back(wholeObjects[i]->bspCutTinters.size());	for (int i = 0; i < woBspCutTs2.size(); i++)		if (woBspCutTs2[i] != 0)	//This should be impossible since all the intersections were deleted just above here		{			BspCutTIntersection* bspCutT = wholeObjects[i]->bspCutTinters[0];			int q = 1;		}		//delete [] intArr;		for (vector<BSpline*>::iterator i = bsplines.begin(); i != bsplines.end(); i++)		delete *i;	bsplines.clear();		for (vector<BSplineToBSplineCut*>::iterator i = bsplinePairCuts.begin(); i != bsplinePairCuts.end(); i++)		delete *i;	bsplinePairCuts.clear();		for (int i = 0; i < interCompanionPairSets.size(); i++)		delete interCompanionPairSets[i];	interCompanionPairSets.clear();		for (int i = 0; i < interCompanionSets.size(); i++)		delete interCompanionSets[i];	interCompanionSets.clear();		for (int i = 0; i < wholeObjects.size(); i++)		delete wholeObjects[i];	wholeObjects.clear();		dtored = true;}#pragma mark -void Drawing::DoIntersectionGapError(){	vector<const char*> errLines;	errLines.push_back("You have clicked on an intersection whose companion set");	errLines.push_back("     contains a gap.");	errLines.push_back("Are you trying to flip the intersection?");	errLines.push_back("If so, you must flip other intersections to remove the gap first.");	errLines.push_back("The gap intersections have been hilighted.");	DoErrorMessage(errLines);}void Drawing::DoIntersectionFlipConstraintError(){	vector<const char*> errLines;	errLines.push_back("You have clicked on an intersection that could not be flipped.");	errLines.push_back("Are you trying to flip the intersection?");	errLines.push_back("If so, you must flip other intersections first.");	errLines.push_back("Intersections that may help have been hilighted.");	DoErrorMessage(errLines);}#pragma mark -void Drawing::ToggleShowCrossingStates(){	showCrossingStates = !showCrossingStates;}bool Drawing::SetShowCrossingStates(bool newVal){	showCrossingStates = newVal;}bool Drawing::GetShowCrossingStates(){	return showCrossingStates;}void Drawing::ToggleShowCuts(){	showCuts = !showCuts;}bool Drawing::SetShowCuts(bool newVal){	showCuts = newVal;}bool Drawing::GetShowCuts(){	return showCuts;}void Drawing::ToggleShowDepths(){	showDepths = !showDepths;}bool Drawing::SetShowDepths(bool newVal){	showDepths = newVal;}bool Drawing::GetShowDepths(){	return showDepths;}void Drawing::ToggleShowCompSets(){	showCompSets = !showCompSets;}bool Drawing::SetShowCompSets(bool newVal){	showCompSets = newVal;}bool Drawing::GetShowCompSets(){	return showCompSets;}void Drawing::VerifyBackupsMatchPresent(){	for (int i = 0; i < bsplines.size(); i++)		bsplines[i]->VerifyBackupsMatchPresent();	for (int i = 0; i < bsplinePairCuts.size(); i++)		bsplinePairCuts[i]->VerifyBackupsMatchPresent();}	void Drawing::VerifyIntersectionDrawingMatch(){	for (int i = 0; i < intersections.size(); i++)		MyAssert(intersections[i]->GetDrawing() == this);}#pragma mark -int Drawing::GetNumBSplines(){	return bsplines.size();}int Drawing::GetNumCuts(){	return bsplinePairCuts.size();}int Drawing::GetNumIntersections(){	return intersections.size();}int Drawing::GetNumInterCompanionSets(){	//return interCompanionPairSets.size();	return interCompanionSets.size();}vector<WholeObject*> Drawing::GetWholeObjects(){	return wholeObjects;}int Drawing::GetBSplineIndex(BSpline* object){	MyAssert(object);	MyAssert(bsplines.size() > 0);		if (bsplines.size() == 0 || find(bsplines.begin(), bsplines.end(), object) == bsplines.end())		return -1;		int i = 0;	vector<BSpline*>::iterator j = bsplines.begin();	while (*j != object)	{		i++;		j++;		MyAssert(j != bsplines.end());	}		return i;}int Drawing::GetCutIndex(BSplineToBSplineCut* object){	MyAssert(object);		if (bsplinePairCuts.size() == 0 || find(bsplinePairCuts.begin(), bsplinePairCuts.end(), object) == bsplinePairCuts.end())		return -1;		int i = 0;	vector<BSplineToBSplineCut*>::iterator j = bsplinePairCuts.begin();	while (*j != object)	{		i++;		j++;		MyAssert(j != bsplinePairCuts.end());	}		return i;}int Drawing::GetWholeObjectIndex(WholeObject* wo){	MyAssert(wo);	MyAssert(wholeObjects.size() > 0);		if (wholeObjects.size() == 0 || find(wholeObjects.begin(), wholeObjects.end(), wo) == wholeObjects.end())		return -1;		int i = 0;	vector<WholeObject*>::iterator j = wholeObjects.begin();	while (*j != wo)	{		i++;		j++;		MyAssert(j != wholeObjects.end());	}		return i;}vector<BSpline*> Drawing::GetBSplines(){	return bsplines;}vector<BSplineToBSplineCut*> Drawing::GetCuts(){	return bsplinePairCuts;}void Drawing::GetBSplinesInGroupFromBSpline(BSpline* bsp, vector<BSpline*>& groupBSplines){	MyAssert(!bsp->dtored);		groupBSplines.clear();	if (wholeObjects.size() > 0)		//Loop through the whole objects		for (vector<WholeObject*>::iterator i = wholeObjects.begin(); i != wholeObjects.end(); i++)		{			int groupSize = (*i)->bsplines.size();			MyAssert(groupSize > 0);						//See if the BSpline in question is in this whole object			vector<BSpline*>::iterator j = find((*i)->bsplines.begin(), (*i)->bsplines.end(), bsp);			if (j != (*i)->bsplines.end())			{				//The BSpline in question is in this whole object, so this is the whole object we want				groupBSplines.resize(groupSize);				for (int k = 0; k < groupSize; k++)					groupBSplines[k] = (*i)->bsplines[k];				break;			}		}}vector<BSplineToBSplineCut*> Drawing::GetCutsForOneBSpline(BSpline* bsp){	vector<BSplineToBSplineCut*> cutsForOneBSpline;		for (int i = 0; i < bsplinePairCuts.size(); i++)		if (bsplinePairCuts[i]->GetBsp1() == bsp || bsplinePairCuts[i]->GetBsp2() == bsp)			cutsForOneBSpline.push_back(bsplinePairCuts[i]);		return cutsForOneBSpline;}vector<BSplineToBSplineCut*> Drawing::GetCutsTouchingOneBSpline(BSpline* bsp){	vector<BSplineToBSplineCut*> cutsTouchingOneBSpline;		for (int i = 0; i < intersections.size(); i++)		if (intersections[i]->GetType() == GenericIntersection::BSP_CUT && ((BspCutIntersection*)intersections[i])->GetBsp() == bsp)			cutsTouchingOneBSpline.push_back(((BspCutIntersection*)intersections[i])->GetCut());		else if (intersections[i]->GetType() == GenericIntersection::BSP_CUT_T && ((BspCutTIntersection*)intersections[i])->GetBsp() == bsp)			cutsTouchingOneBSpline.push_back(((BspCutTIntersection*)intersections[i])->GetCut());		return cutsTouchingOneBSpline;}vector<GenericIntersection*> Drawing::GetIntersections(){	return intersections;}GenericIntersection* Drawing::GetIntersection(int intersectionPoint){	MyAssert(intersectionPoint >= 0 && intersectionPoint < intersections.size());	return intersections[intersectionPoint];}int Drawing::GetIntersectionIndex(GenericIntersection* intersection, bool assertIt){	MyAssert(intersection);	if (assertIt)		MyAssert(!intersection->GetDtored());		int i = 0;	vector<GenericIntersection*>::iterator j = intersections.begin();	while (j != intersections.end() && *j != intersection)	{		i++;		j++;	}		if (assertIt)		MyAssert(j != intersections.end());		if (j != intersections.end())		return i;		if (assertIt)		MyAssert(false);		return -1;}		vector<GenericIntersection*> Drawing::GetOneBSplineGroupIntersections(BSpline* bsp){	vector<GenericIntersection*> groupInters;		//Get all the bsplines in the group	vector<BSpline*> groupBSplines;	GetBSplinesInGroupFromBSpline(bsp, groupBSplines);		//If the group is empty, return	if (groupBSplines.size() == 0)		return groupInters;		//Loop through the group's bsplines	for (int i = 0; i < groupBSplines.size(); i++)	{		//Add the bspline's intersections		vector<GenericIntersection*> inters = groupBSplines[i]->GetIntersections();		for (int j = 0; j < inters.size(); j++)			if (find(groupInters.begin(), groupInters.end(), inters[j]) == groupInters.end())				groupInters.push_back(inters[j]);				//Get the cuts for the bsplines		vector<BSplineToBSplineCut*> bspCuts = GetCutsForOneBSpline(groupBSplines[i]);				//Loop through the cuts		for (int j = 0; j < bspCuts.size(); j++)		{			//Add the cut's intersections			inters = bspCuts[j]->GetIntersections();			for (int k = 0; k < inters.size(); k++)				if (find(groupInters.begin(), groupInters.end(), inters[k]) == groupInters.end())					groupInters.push_back(inters[k]);		}	}		return groupInters;}#pragma mark -void Drawing::AddBSpline(BSpline* object){	bsplines.push_back(object);}void Drawing::RemoveBSpline(BSpline* object){	//Note that the object has already been destroyed, but not deleted, so a lot of its internal data is erased at this point		//Remove the BSpline from its whole object	for (vector<WholeObject*>::iterator i = wholeObjects.begin(); i != wholeObjects.end(); i++)	{		MyAssert((*i)->bsplines.size() > 0);		vector<BSpline*>::iterator j = find((*i)->bsplines.begin(), (*i)->bsplines.end(), object);		if (j != (*i)->bsplines.end())		{			if ((*i)->bsplines.size() > 1)	//If there are multiple BSplines in the object, just remove the BSpline in question			{				(*i)->bsplines.erase(j);				break;			}			else	//If the object only has the BSpline in question, kill the whole object			{				delete *i;				wholeObjects.erase(i);				break;			}		}	}		//Remove the BSpline's cuts	bool foundOne = true;	while (foundOne)	{		foundOne = false;		for (vector<BSplineToBSplineCut*>::iterator i = bsplinePairCuts.begin(); i != bsplinePairCuts.end(); i++)			if ((*i)->GetBsp1() == object || (*i)->GetBsp2() == object)			{				RemoveCut(*i, true);				foundOne = true;				break;			}	}		//Remove any PrevCuts	foundOne = true;	while (foundOne)	{		foundOne = false;		for (vector<PrevCut*>::iterator i = prevCuts.begin(); i != prevCuts.end(); i++)			if ((*i)->bsp1 == object || (*i)->bsp2 == object)			{				prevCuts.erase(i);				foundOne = true;				break;			}	}	VerifyPrevCuts();		//Remove the BSpline's companion sets	foundOne = true;	while (foundOne)	{		foundOne = false;		for (vector<vector<GenericIntersection*>*>::iterator i = interCompanionSets.begin(); i != interCompanionSets.end(); i++)		{			for (int j = 0; j < (*i)->size(); j++)			{				if ((*(*i))[j]->GetType() == GenericIntersection::BSP_BSP)				{					BspBspIntersection* bspBspInter = (BspBspIntersection*)(*(*i))[j];					if (bspBspInter->GetBsp1() == object || bspBspInter->GetBsp2() == object)					{						delete *i;						interCompanionSets.erase(i);						foundOne = true;						break;					}				}				else				{					MyAssert((*(*i))[j]->GetType() == GenericIntersection::BSP_CUT);					BspCutIntersection* bspCutInter = (BspCutIntersection*)(*(*i))[j];					if (bspCutInter->GetBsp() == object)					{						delete *i;						interCompanionSets.erase(i);						foundOne = true;						break;					}				}			}			if (foundOne)				break;		}	}		//Remove the BSpline	int bsplineIndex = 0;	bool foundIt = false;	for (vector<BSpline*>::iterator i = bsplines.begin(); i != bsplines.end(); i++)	{		if (*i == object)		{			bsplines.erase(i);			foundIt = true;			break;		}		bsplineIndex++;	}	MyAssert(foundIt);		//Notify the intersections of the change in BSpline indexes	for (vector<GenericIntersection*>::iterator i = intersections.begin(); i != intersections.end(); i++)	{		switch ((*i)->GetType())		{			case GenericIntersection::BSP_BSP:				BspBspIntersection* bspBspInter = (BspBspIntersection*)(*i);								if (bspBspInter->GetBsp1Index() > bsplineIndex)					bspBspInter->DecreaseBsp1index();									if (bspBspInter->GetBsp2Index() > bsplineIndex)					bspBspInter->DecreaseBsp2index();				break;			case GenericIntersection::BSP_CUT:				BspCutIntersection* bspCutInter = (BspCutIntersection*)(*i);								if (bspCutInter->GetBspIndex() > bsplineIndex)					bspCutInter->DecreaseBspIndex();				break;			case GenericIntersection::BSP_CUT_T:				BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)(*i);								if (bspCutTInter->GetBsp() && bspCutTInter->GetBspIndex() > bsplineIndex)					bspCutTInter->DecreaseBspIndex();				break;		}	}		//VerticallyCompactDrawing();	NormalizeDepths();}//Returns true is there are enough control pointsbool Drawing::TestBSplineForEnoughControlPoints(BSpline* bsp, vector<BSpline*>& affectedBSplines){	if (bsp->GetNumControlPoints() <= 2)	{		GetBSplinesInGroupFromBSpline(bsp, affectedBSplines);		for (vector<BSpline*>::iterator i = affectedBSplines.begin(); i != affectedBSplines.end(); i++)			if (*i == bsp)			{				affectedBSplines.erase(i);				break;			}				RemoveBSpline(bsp);		delete bsp;				EqualizeNumberOfSections();				return false;	}		return true;}void Drawing::RemoveCut(BSplineToBSplineCut* cut, bool splitGroup){	//Find and erase the cut	int index = 0;	bool foundIt = false;	for (vector<BSplineToBSplineCut*>::iterator i = bsplinePairCuts.begin(); i != bsplinePairCuts.end(); i++, index++)		if (*i == cut)		{			bsplinePairCuts.erase(i);			foundIt = true;			break;		}		//Remember the associated BSplines	BSpline* bsp1 = cut->GetBsp1();	BSpline* bsp2 = cut->GetBsp2();		//Delete the cut	DeleteBSplineToBSplineCut(cut);	//delete cut;		MyAssert(foundIt);		//After removing a cut, decrement any higher cut indexes	for (int i = 0; i < intersections.size(); i++)		switch (intersections[i]->GetType())		{			case GenericIntersection::BSP_BSP:				//Nothing to do here				break;			case GenericIntersection::BSP_CUT:				if (((BspCutIntersection*)intersections[i])->GetCutIndex() > index)					((BspCutIntersection*)intersections[i])->DecreaseCutIndex();				break;			case GenericIntersection::BSP_CUT_T:				if (((BspCutTIntersection*)intersections[i])->GetCutIndex() > index)					((BspCutTIntersection*)intersections[i])->DecreaseCutIndex();				break;			case GenericIntersection::CUT_CUT:				if (((CutCutIntersection*)intersections[i])->GetCut1Index() > index)					((CutCutIntersection*)intersections[i])->DecreaseCut1Index();				if (((CutCutIntersection*)intersections[i])->GetCut2Index() > index)					((CutCutIntersection*)intersections[i])->DecreaseCut2Index();		}		if (splitGroup)	{		//If the cut splits the group, split the group		WholeObject *wholeObject1 = FindWholeObjectForBSpline(bsp1);		WholeObject *wholeObject2 = FindWholeObjectForBSpline(bsp2);		if (wholeObject1 && wholeObject1 == wholeObject2)		{			//Gather the groups of each bspline for the cut			vector<BSpline*> bsp1Group, bsp2Group;			int bspIdx = 0;						bsp1Group.push_back(bsp1);			while (bspIdx < bsp1Group.size())			{				BSpline* bsp = bsp1Group[bspIdx];				for (int i = 0; i < bsplinePairCuts.size(); i++)				{					if (bsplinePairCuts[i]->GetBsp1() == bsp)					{						if (bsplinePairCuts[i]->GetBsp2() && find(bsp1Group.begin(), bsp1Group.end(), bsplinePairCuts[i]->GetBsp2()) == bsp1Group.end())							bsp1Group.push_back(bsplinePairCuts[i]->GetBsp2());					}					else if (bsplinePairCuts[i]->GetBsp2() == bsp)					{						if (bsplinePairCuts[i]->GetBsp1() && find(bsp1Group.begin(), bsp1Group.end(), bsplinePairCuts[i]->GetBsp1()) == bsp1Group.end())							bsp1Group.push_back(bsplinePairCuts[i]->GetBsp1());					}				}				bspIdx++;			}						bspIdx = 0;			bsp2Group.push_back(bsp2);			while (bspIdx < bsp2Group.size())			{				BSpline* bsp = bsp2Group[bspIdx];				for (int i = 0; i < bsplinePairCuts.size(); i++)				{					if (bsplinePairCuts[i]->GetBsp1() == bsp)					{						if (bsplinePairCuts[i]->GetBsp2() && find(bsp2Group.begin(), bsp2Group.end(), bsplinePairCuts[i]->GetBsp2()) == bsp2Group.end())							bsp2Group.push_back(bsplinePairCuts[i]->GetBsp2());					}					else if (bsplinePairCuts[i]->GetBsp2() == bsp)					{						if (bsplinePairCuts[i]->GetBsp1() && find(bsp2Group.begin(), bsp2Group.end(), bsplinePairCuts[i]->GetBsp1()) == bsp2Group.end())							bsp2Group.push_back(bsplinePairCuts[i]->GetBsp1());					}				}				bspIdx++;			}						//Just some asserts.  The union of the two groups should match the original whole object.			for (int i = 0; i < wholeObject1->bsplines.size(); i++)	//Make sure every bspline in the original group is in one of the two split groups				MyAssert(find(bsp1Group.begin(), bsp1Group.end(), wholeObject1->bsplines[i]) != bsp1Group.end() ||						find(bsp2Group.begin(), bsp2Group.end(), wholeObject1->bsplines[i]) != bsp2Group.end());			for (int i = 0; i < bsp1Group.size(); i++)	//Make sure very bspline in the first split group is in the original group				MyAssert(find(wholeObject1->bsplines.begin(), wholeObject1->bsplines.end(), bsp1Group[i]) != wholeObject1->bsplines.end());			for (int i = 0; i < bsp2Group.size(); i++)	//Make sure very bspline in the second split group is in the original group				MyAssert(find(wholeObject1->bsplines.begin(), wholeObject1->bsplines.end(), bsp2Group[i]) != wholeObject1->bsplines.end());						//See if any bsplines are in both groups.			//If so, the groups do not need to be split.			//If not, the groups are distinct and need to be split.			bool groupNeedsToBeSplit = true;			for (int i = 0; i < bsp1Group.size(); i++)				if (find(bsp2Group.begin(), bsp2Group.end(), bsp1Group[i]) != bsp2Group.end())				{					groupNeedsToBeSplit = false;					break;				}						if (groupNeedsToBeSplit)			{				WholeObject* bsp1NewGroup = new WholeObject();				for (int i = 0; i < wholeObject1->bgDepths.size(); i++)					bsp1NewGroup->bgDepths.push_back(wholeObject1->bgDepths[i]);				for (int i = 0; i < bsp1Group.size(); i++)					bsp1NewGroup->bsplines.push_back(bsp1Group[i]);								wholeObjects.push_back(bsp1NewGroup);								WholeObject* bsp2NewGroup = new WholeObject();				for (int i = 0; i < wholeObject1->bgDepths.size(); i++)					bsp2NewGroup->bgDepths.push_back(wholeObject2->bgDepths[i]);				for (int i = 0; i < bsp2Group.size(); i++)					bsp2NewGroup->bsplines.push_back(bsp2Group[i]);								wholeObjects.push_back(bsp2NewGroup);								delete wholeObject1;				vector<WholeObject*>::iterator iter = find(wholeObjects.begin(), wholeObjects.end(), wholeObject1);				MyAssert(iter != wholeObjects.end());				wholeObjects.erase(iter);			}		}	}}void Drawing::RemoveBspFromWholeObject(BSpline* bsp){	WholeObject* wholeObject = FindWholeObjectForBSpline(bsp);	if (!wholeObject)		return;		vector<BSplineToBSplineCut*> cuts = GetCutsForOneBSpline(bsp);	MyAssert(wholeObject->bsplines.size() > 0);	if (wholeObject->bsplines.size() > 1)	{		MyAssert(cuts.size() > 0);		for (int i = 0; i < cuts.size(); i++)			RemoveCut(cuts[i], true);				wholeObject = FindWholeObjectForBSpline(bsp);		MyAssert(wholeObject->bsplines.size() == 1);		MyAssert(wholeObject->bsplines[0] == bsp);	}		int windingNumber = bsp->GetWindingNumber();	if (windingNumber >= 0)	{		wholeObject->bgDepths.clear();		//MyAssert(wholeObject->bspCutTinters.size() == 0);				for (int i = 0; i < wholeObject->bspCutTinters.size(); i++)		{			MyAssert(wholeObject->bspCutTinters[i]->GetInfiniteWholeObject() == wholeObject);			wholeObject->bspCutTinters[i]->SetInfiniteWholeObject(NULL);		}		wholeObject->bspCutTinters.clear();			}}void Drawing::AddIntersection(GenericIntersection* intersection){	MyAssert(!intersection->GetDtored());		MyAssert(find(intersections.begin(), intersections.end(), intersection) == intersections.end());		intersections.push_back(intersection);	if (find(brandNewIntersections.begin(), brandNewIntersections.end(), intersection) == brandNewIntersections.end())		brandNewIntersections.push_back(intersection);}void Drawing::RemoveIntersection(GenericIntersection* intersection){	MyAssert(find(intersections.begin(), intersections.end(), intersection) != intersections.end());		bool foundIt = false;	for (vector<GenericIntersection*>::iterator i = intersections.begin(); i != intersections.end(); i++)		if (*i == intersection)		{			intersections.erase(i);			foundIt = true;			break;		}	MyAssert(foundIt);		for (vector<GenericIntersection*>::iterator i = brandNewIntersections.begin(); i != brandNewIntersections.end(); i++)		if (*i == intersection)		{			brandNewIntersections.erase(i);			break;		}		//Remove the intersection from its companion set	RemoveCompanionPairsForIntersection(intersection);}void Drawing::RemoveWholeObjectBspCutTInter(WholeObject* wholeObject, BspCutTIntersection* inter){	MyAssert(wholeObject);	MyAssert(!wholeObject->dtored && !inter->GetDtored());	MyAssert(find(wholeObjects.begin(), wholeObjects.end(), wholeObject) != wholeObjects.end());		vector<BspCutTIntersection*>::iterator i = find(wholeObject->bspCutTinters.begin(), wholeObject->bspCutTinters.end(), inter);	MyAssert(i != wholeObject->bspCutTinters.end());	wholeObject->bspCutTinters.erase(i);		//Shouldn't be necessary, but what the heck	SortWholeObjectInfiniteInters(wholeObject);		if (wholeObject->bspCutTinters.size() == 0)		wholeObject->bgDepths.clear();}void Drawing::RemoveCompanionPairsForIntersection(GenericIntersection* intersection){	MyAssert(interCompanionPairSets.size() == 0);	/*	if (intersection->GetType() == GenericIntersection::BSP_BSP || intersection->GetType() == GenericIntersection::BSP_CUT)	{		bool foundIt = false;		for (vector<vector<pair<GenericIntersection*, GenericIntersection*> >*>::iterator setIter = interCompanionPairSets.begin();			setIter != interCompanionPairSets.end(); setIter++)	//Loop through the sets		{			for (vector<pair<GenericIntersection*, GenericIntersection*> >::iterator pairIter = (*setIter)->begin();					pairIter != (*setIter)->end(); pairIter++)	//Loop through the pairs of one set				if ((*pairIter).first == intersection || (*pairIter).second == intersection)				{					(*setIter)->erase(pairIter);					if ((*setIter)->size() == 0)						interCompanionPairSets.erase(setIter);					foundIt = true;					break;				}			if (foundIt)				break;		}				if (foundIt)		{			//Second pass			foundIt = false;			for (vector<vector<pair<GenericIntersection*, GenericIntersection*> >*>::iterator setIter = interCompanionPairSets.begin();				setIter != interCompanionPairSets.end(); setIter++)	//Loop through the sets			{				for (vector<pair<GenericIntersection*, GenericIntersection*> >::iterator pairIter = (*setIter)->begin();						pairIter != (*setIter)->end(); pairIter++)	//Loop through the pairs of one set					if ((*pairIter).first == intersection || (*pairIter).second == intersection)					{						(*setIter)->erase(pairIter);						if ((*setIter)->size() == 0)							interCompanionPairSets.erase(setIter);						foundIt = true;						break;					}				if (foundIt)					break;			}		}				//еееееееееееееее		//The remaining set may need to be broken apart into multiple sets now		// NOT IMPLEMENTED YET	}	*/	//////////////////////////////////////////////////////////////////////////////////////////////		//Note that this function should be renamed for the following approach, which acts on companion sets, not companion pairs	if (intersection->GetType() == GenericIntersection::BSP_BSP || intersection->GetType() == GenericIntersection::BSP_CUT)	{		//Find the companion set for the intersection		for (vector<vector<GenericIntersection*>*>::iterator iterA = interCompanionSets.begin(); iterA != interCompanionSets.end(); iterA++)	//Loop through the sets		{			vector<GenericIntersection*>::iterator iter = find((*iterA)->begin(), (*iterA)->end(), intersection);			if (iter != (*iterA)->end())			{				if ((*iterA)->size() > 1)					(*iterA)->erase(iter);				else interCompanionSets.erase(iterA);				break;			}		}	}}void Drawing::ClearBrandNewIntersections(){	brandNewIntersections.clear();}//Doesn't remove the intersections after deleting themvoid Drawing::DeleteAllIntersections(){	while (intersections.size() > 0)		delete intersections.back();}#pragma mark -void Drawing::RemoveAndRefindIntersections(BSpline* bsp){	//еее DEBUG	bool* recalcArray = new bool[bsp->GetNumControlPoints()];	bool* reinterArray = new bool[bsp->GetNumControlPoints()];	vector<bool> curvesToRecalc = bsp->GetCurvesToRecalc();	vector<bool> curvesToReintersect1 = bsp->GetCurvesToReintersect();	for (int i = 0; i < bsp->GetNumControlPoints(); i++)	{		recalcArray[i] = curvesToRecalc[i];		reinterArray[i] = curvesToReintersect1[i];	}		//Remove all the intersections on altered curves for the BSpline.	//Update the locations of the T junctions.	vector<bool> curvesToReintersect = bsp->GetCurvesToReintersect();	bool foundOne = true;	while (foundOne)	{		//This shouldn't do anything for splitting a segment or deleting a control point				foundOne = false;		vector<GenericIntersection*> bspInters = bsp->GetIntersections();		for (int i = 0; i < bspInters.size(); i++)			if (bspInters[i]->GetType() != GenericIntersection::BSP_CUT_T)			{				bool removeInter = false;				if (!bspInters[i]->SelfIntersection())				{					int curve;					switch (bspInters[i]->GetType())					{						case GenericIntersection::BSP_BSP:							curve = (((BspBspIntersection*)bspInters[i])->GetBsp1() == bsp) ?									((BspBspIntersection*)bspInters[i])->GetCv1() :									((BspBspIntersection*)bspInters[i])->GetCv2();							break;						case GenericIntersection::BSP_CUT:							curve = ((BspCutIntersection*)bspInters[i])->GetCv();							break;					}					removeInter = curvesToReintersect[curve];				}				else	//Self Intersection				{					MyAssert(((BspBspIntersection*)bspInters[i])->GetBsp1() == bsp &&							((BspBspIntersection*)bspInters[i])->GetBsp2() == bsp);					removeInter = (curvesToReintersect[((BspBspIntersection*)bspInters[i])->GetCv1()] ||									curvesToReintersect[((BspBspIntersection*)bspInters[i])->GetCv2()]);				}								if (removeInter)				{					//GenericIntersection* inter = bspInters[i];	//еее					delete bspInters[i];										vector<GenericIntersection*>::iterator iter = find(brandNewIntersections.begin(), brandNewIntersections.end(), bspInters[i]);					if (iter != brandNewIntersections.end())						brandNewIntersections.erase(iter);										foundOne = true;					break;				}			}			else	//T junction			{				((BspCutTIntersection*)bspInters[i])->RecalcStartEndLocs();				((BspCutTIntersection*)bspInters[i])->SetLocToCutStartOrEndLoc();			}	}		//еее	delete [] recalcArray;	delete [] reinterArray;		//Remove all the intersections for the BSpline's cuts	vector<BSplineToBSplineCut*> cuts = GetCutsForOneBSpline(bsp);	for (int i = 0; i < cuts.size(); i++)	{		foundOne = true;		while (foundOne)		{			foundOne = false;			vector<GenericIntersection*> cutInters = cuts[i]->GetIntersections();			for (int j = 0; j < cutInters.size(); j++)				if (cutInters[j]->GetType() != GenericIntersection::BSP_CUT_T)				{					GenericIntersection* inter1 = cutInters[j];	//еее					delete cutInters[j];										vector<GenericIntersection*>::iterator iter = find(brandNewIntersections.begin(), brandNewIntersections.end(), cutInters[j]);					if (iter != brandNewIntersections.end())						brandNewIntersections.erase(iter);										foundOne = true;					break;				}		}	}		//еее DEBUG	vector<GenericIntersection*>bspInters = bsp->GetIntersections();	for (int i = 0; i < bspInters.size(); i++)	{		GenericIntersection* inter1 = bspInters[i];	}		//Remove any PrevCuts	// еее This really doesn't belong here, but helps with deleting control points for the time being, I think	foundOne = true;	while (foundOne)	{		foundOne = false;		for (vector<PrevCut*>::iterator i = prevCuts.begin(); i != prevCuts.end(); i++)			if ((*i)->bsp1 == bsp || (*i)->bsp2 == bsp)			{				prevCuts.erase(i);				foundOne = true;				break;			}	}		//Refind the intersections for the BSpline	vector<BSpline*> emptyGroup;	bsp->FindAndAddNewIntersections(bsplines, bsplinePairCuts, emptyGroup, false, false);		//Refind the intersections for the BSpline's cuts	cuts = GetCutsForOneBSpline(bsp);	for (int i = 0; i < cuts.size(); i++)		cuts[i]->FindAndAddNewIntersections(bsplines, bsplinePairCuts);		CleanUpSelfCrossingCuts(cuts);		VerifyNothingDtored();}void Drawing::CleanUpSelfCrossingCuts(vector<BSplineToBSplineCut*> cuts){	vector<BSpline*> touchedBSplines;		//Loop through the cuts	for (int i = 0; i < cuts.size(); i++)	{		BSplineToBSplineCut* cut = cuts[i];		BSpline* bspStart = cut->GetBsp1();		BSpline* bspEnd = cut->GetBsp2();				for (int ii = 0; ii < 2; ii++)		{			BSpline* bspTarget = (ii == 0) ? bspStart : bspEnd;			BSpline* bspOppEnd = (ii == 0) ? bspEnd : bspStart;			MyAssert(bspTarget != bspOppEnd);						bool replacedCut = false;			bool foundOne = true;			while (foundOne)			{				foundOne = false;								if (!cut)					break;								MyAssert(cut);				vector<GenericIntersection*> cutInters = cut->GetIntersections();								MyAssert(cutInters[0]->GetType() == GenericIntersection::BSP_CUT_T && cutInters[cutInters.size() - 1]->GetType() == GenericIntersection::BSP_CUT_T);								for (int j = 1; j < cutInters.size() - 1; j++)				{					if (cutInters[j]->GetType() == GenericIntersection::BSP_CUT && ((BspCutIntersection*)cutInters[j])->GetBsp() == bspTarget)	//BspCut inter crossing the target BSpline					{						if (gDebug6)						{							MyAssert(!dtored);														SetPort(GetWindowPort(gMainWindow->GetWindow()));														Point scrollOffset = {0, 0};							vector<BSpline*> workingBSplines;							DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);														PenSize(2, 2);							FloatPoint startLoc = cut->GetStart();							FloatPoint endLoc = cut->GetEnd();							ForeColor(redColor);							MoveTo(startLoc.h, startLoc.v);							LineTo(endLoc.h, endLoc.v);														PenSize(5, 5);														ForeColor(magentaColor);							MoveTo(startLoc.h - 3, startLoc.v - 3);							Line(0, 0);														ForeColor(blackColor);							MoveTo(endLoc.h - 3, endLoc.v - 3);							Line(0, 0);														FloatPoint loc = cutInters[j]->GetLocation();							ForeColor(greenColor);							MoveTo(loc.h - 3, loc.v - 3);							Line(0, 0);														PenSize(1, 1);														QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int k = 1;						}												//Keep track of the BSplines						if (bspTarget && find(touchedBSplines.begin(), touchedBSplines.end(), bspTarget) == touchedBSplines.end())							touchedBSplines.push_back(bspTarget);						if (bspOppEnd && find(touchedBSplines.begin(), touchedBSplines.end(), bspOppEnd) == touchedBSplines.end())							touchedBSplines.push_back(bspOppEnd);												//Remember the curve and segment of the cross intersection.  It will become the new start/end of the intersection.						int cv1 = ((BspCutIntersection*)cutInters[j])->GetCv();						int sg1 = ((BspCutIntersection*)cutInters[j])->GetSg();												//Remember the curve and segment of the other end of the cut						int cv2, sg2;						if (ii == 0)						{							cv2 = cut->GetCv2();							sg2 = cut->GetSg2();						}						else						{							cv2 = cut->GetCv1();							sg2 = cut->GetSg1();						}												//Remove the cut						for (int k = 0; k < cutInters.size(); k++)						{							vector<GenericIntersection*>::iterator iter = find(brandNewIntersections.begin(), brandNewIntersections.end(), cutInters[k]);							if (iter != brandNewIntersections.end())								brandNewIntersections.erase(iter);						}						RemoveCut(cut, true);						cut = NULL;												//Make the new cut						int initSectionDepth;						MyAssert(bspTarget);	//I guess bspTarget is never NULL						MyAssert(bspTarget || bspOppEnd);	//I guess bspTarget is never NULL						if (bspTarget && !bspOppEnd)							initSectionDepth = bspTarget->GetArbitraryCurveSegCenterDepth(cv1, sg1);						else if (bspTarget && !bspOppEnd)							initSectionDepth = bspOppEnd->GetArbitraryCurveSegCenterDepth(cv2, sg2);						else initSectionDepth = (ii == 0) ? bspTarget->GetArbitraryCurveSegCenterDepth(cv1, sg1) : bspOppEnd->GetArbitraryCurveSegCenterDepth(cv2, sg2);												if (ii == 0)							cut = new BSplineToBSplineCut(this, bspTarget, bspOppEnd, cv1, sg1, cv2, sg2, initSectionDepth);						else cut = new BSplineToBSplineCut(this, bspOppEnd, bspTarget, cv2, sg2, cv1, sg1, initSectionDepth);												int cutEndingDepthNotUsed;						bool goodCut = TestCut(cut, cutEndingDepthNotUsed);						if (goodCut)						{							//Save the new cut							SaveBSplineToBSplineCut(cut);							replacedCut = true;						}						else						{							DeleteBSplineToBSplineCut(cut);							cut = NULL;							replacedCut = false;														VerifyNothingDtored();						}												MyAssert(bspTarget);						bspTarget->VerifyNumSectionsMatchesNumInters();						if (bspOppEnd)							bspOppEnd->VerifyNumSectionsMatchesNumInters();						bspTarget->VerifyTotalIntersMatchesCurveInters();						if (bspOppEnd)							bspOppEnd->VerifyTotalIntersMatchesCurveInters();												VerifyNothingDtored();												foundOne = true;						break;					}	//End condition on finding inter crossing the target BSpline				}	//End loop over cut intersections			}	//End foundOne loop						if (replacedCut)			{				MyAssert(cut);				cut->ReweaveCut();			}		}	//End loop for start of cut, then end of cut (loop has only 2 iterations)				bspStart->VerifyNumSectionsMatchesNumInters();		if (bspEnd)			bspEnd->VerifyNumSectionsMatchesNumInters();		bspStart->VerifyTotalIntersMatchesCurveInters();		if (bspEnd)			bspEnd->VerifyTotalIntersMatchesCurveInters();	}	//End loop over cuts		if (touchedBSplines.size() > 0)		FindWholeObjects2(touchedBSplines);		VerifyNothingDtored();}void Drawing::HalveAllBspCutTInterSegs(){	for (int i = 0; i < intersections.size(); i++)		if (intersections[i]->GetType() == GenericIntersection::BSP_CUT_T)		{			BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)intersections[i];			bspCutTInter->SetCurveAndSeg(bspCutTInter->GetCv(), bspCutTInter->GetSg() / 2);		}		for (int i = 0; i < bsplinePairCuts.size(); i++)		bsplinePairCuts[i]->SetCurvesAndSegs(bsplinePairCuts[i]->GetCv1(),											bsplinePairCuts[i]->GetSg1() / 2,											bsplinePairCuts[i]->GetCv2(),											bsplinePairCuts[i]->GetSg2() / 2);}void Drawing::DoubleAllBspCutTInterSegs(){	for (int i = 0; i < intersections.size(); i++)		if (intersections[i]->GetType() == GenericIntersection::BSP_CUT_T)		{			BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)intersections[i];			bspCutTInter->SetCurveAndSeg(bspCutTInter->GetCv(), bspCutTInter->GetSg() * 2);		}		for (int i = 0; i < bsplinePairCuts.size(); i++)		bsplinePairCuts[i]->SetCurvesAndSegs(bsplinePairCuts[i]->GetCv1(),											bsplinePairCuts[i]->GetSg1() * 2,											bsplinePairCuts[i]->GetCv2(),											bsplinePairCuts[i]->GetSg2() * 2);}#pragma mark -void Drawing::FindInterCompSetsForBrandNewInters(){	FindInterCompSetsForInters(brandNewIntersections);}void Drawing::FindInterCompSetsForAllInters(){	clock_t st = clock();	FindInterCompSetsForInters(intersections);	gCSECsearchTime = (clock() - st) / CLOCKS_PER_SEC;}void Drawing::FindInterCompSetsForInters(vector<GenericIntersection*> intersToComp){	//Throw away all the companion pairs for bsplines and cuts associated with the new intersections	//Then refind the companions for all of the intersections on all the involved bsplines and cuts		//еееееееееееееееееееееееееееееееее	//There is MAJOR serious bug in this algorithm.  This algorithm finds companion pairs by traversing a bspline.	//It should be traversing the surface however, turning in and out of cuts.  Surface boundary traversal has been	//implemented elsewhere in Druid and needs to be adapted to this algorithm.  As of 060309, this bug has not been fixed yet.	//This same bug is present in HilightOverlappingSubsurface().	//еееееееееееееееееееееееееееееееее		//Make a list of all the touched bsplines and cuts	vector<BSpline*> touchedBSplines;	vector<BSplineToBSplineCut*> touchedCuts;		for (int i = 0; i < intersToComp.size(); i++)		if (intersToComp[i]->GetType() == GenericIntersection::BSP_BSP)		{			if (((BspBspIntersection*)intersToComp[i])->GetBsp1())				touchedBSplines.push_back(((BspBspIntersection*)intersToComp[i])->GetBsp1());			if (((BspBspIntersection*)intersToComp[i])->GetBsp2())				touchedBSplines.push_back(((BspBspIntersection*)intersToComp[i])->GetBsp2());		}		else if (intersToComp[i]->GetType() == GenericIntersection::BSP_CUT)		{			if (((BspCutIntersection*)intersToComp[i])->GetBsp())				touchedBSplines.push_back(((BspCutIntersection*)intersToComp[i])->GetBsp());			if (((BspCutIntersection*)intersToComp[i])->GetCut())				touchedCuts.push_back(((BspCutIntersection*)intersToComp[i])->GetCut());		}		//Make list of all the intersections on all the touched bsplines and cuts	vector<GenericIntersection*> touchedInters;	for (int i = 0; i < touchedBSplines.size(); i++)	{		vector<GenericIntersection*> bspInters = touchedBSplines[i]->GetIntersections();		for (int j = 0; j < bspInters.size(); j++)			if ((bspInters[j]->GetType() == GenericIntersection::BSP_BSP ||				bspInters[j]->GetType() == GenericIntersection::BSP_CUT) &&				find(touchedInters.begin(), touchedInters.end(), bspInters[j]) == touchedInters.end())				touchedInters.push_back(bspInters[j]);	}	for (int i = 0; i < touchedCuts.size(); i++)	{		vector<GenericIntersection*> cutInters = touchedCuts[i]->GetIntersections();		for (int j = 0; j < cutInters.size(); j++)			if ((cutInters[j]->GetType() == GenericIntersection::BSP_BSP ||				cutInters[j]->GetType() == GenericIntersection::BSP_CUT) &&				find(touchedInters.begin(), touchedInters.end(), cutInters[j]) == touchedInters.end())				touchedInters.push_back(cutInters[j]);	}		//Throw away all companion pairs for the touched intersections	for (int i = 0; i < touchedInters.size(); i++)		RemoveCompanionPairsForIntersection(touchedInters[i]);	//Do the same for companion sets, as opposed to companion pairs	for (int i = 0; i < touchedInters.size(); i++)		for (vector<vector<GenericIntersection*>*>::iterator j = interCompanionSets.begin(); j != interCompanionSets.end(); j++)		{			MyAssert((*j)->size() > 0);			vector<GenericIntersection*>* gij = *j;	//debug			if (find((*j)->begin(), (*j)->end(), touchedInters[i]) != (*j)->end())			{				delete *j;				interCompanionSets.erase(j);				break;			}		}		if (touchedInters.size() > 0)	{		if (gDebug1)			int k = 1;	}		//Refind the companions for all the touched intersections	vector<pair<BspBspIntersection*, vector<BspCutIntersection*> > > bspCutComps;	for (int i = 0; i < touchedInters.size(); i++)	{		if (gDebug1)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));						Rect r;			GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);			EraseRect(&r);			gMainWindow->DrawGrid();						Point scrollOffset = {0, 0};			vector<BSpline*> workingBSplines;			DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);						int qr = 1;		}				if (touchedInters[i]->GetType() == GenericIntersection::BSP_BSP)		{			pair<BspBspIntersection*, vector<BspCutIntersection*> > thisBspBspsBspCutComps;			thisBspBspsBspCutComps.first = (BspBspIntersection*)touchedInters[i];			FindInterCompSetsForBspBspInter((BspBspIntersection*)touchedInters[i], &thisBspBspsBspCutComps.second, i);			bspCutComps.push_back(thisBspBspsBspCutComps);			if (thisBspBspsBspCutComps.second.size() != 0)			{				if (gDebug1)				{					SetPort(GetWindowPort(gMainWindow->GetWindow()));					Rect r;										PenSize(2, 2);					ForeColor(redColor);					FloatPoint intersectionLoc = touchedInters[i]->GetLocation();					SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);					FrameOval(&r);										ForeColor(greenColor);					for (int j = 0; j < thisBspBspsBspCutComps.second.size(); j++)					{						FloatPoint intersectionLoc = thisBspBspsBspCutComps.second[j]->GetLocation();						SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);						FrameOval(&r);					}					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qr = 1;										ForeColor(whiteColor);					intersectionLoc = touchedInters[i]->GetLocation();					SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);					FrameOval(&r);										for (int j = 0; j < thisBspBspsBspCutComps.second.size(); j++)					{						FloatPoint intersectionLoc = thisBspBspsBspCutComps.second[j]->GetLocation();						SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);						FrameOval(&r);					}					PenSize(1, 1);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				}			}		}		//else if (touchedInters[i]->GetType() == GenericIntersection::BSP_CUT)		//	FindInterCompSetsForBspCutInter((BspCutIntersection*)touchedInters[i], i);				PenSize(1, 1);	}		//Finally, remove all companion pairs in illegal boundaries	//Can cause some problems	/*for (int i = 0; i < bsplines.size(); i++)		if (!bsplines[i]->GetAllIntersectionsLegal())		{			vector<GenericIntersection*> bspInters = bsplines[i]->GetIntersections();			for (int j = 0; j < bspInters.size(); j++)				RemoveCompanionPairsForIntersection(bspInters[j]);		}	for (int i = 0; i < bsplinePairCuts.size(); i++)		if (!bsplinePairCuts[i]->GetAllIntersectionsLegal())		{			vector<GenericIntersection*> cutInters = bsplinePairCuts[i]->GetIntersections();			for (int j = 0; j < cutInters.size(); j++)				RemoveCompanionPairsForIntersection(cutInters[j]);		}*/		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		//Destroy the old companion sets.	//I don't really think this should be necessary, and it might even lose some sets so the resulting drawing isn't fully companioned, but I'm having problems with duplicate sets.	//for (int i = 0; i < interCompanionSets.size(); i++)	//	delete interCompanionSets[i];	//interCompanionSets.clear();		//debug	for (vector<vector<GenericIntersection*>*>::iterator j = interCompanionSets.begin(); j != interCompanionSets.end(); j++)		MyAssert((*j)->size() > 0);		//Convert the companions to the new format	for (int i = 0; i < interCompanionPairSets.size(); i++)	{		if (gDebug1)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));						Rect r;			GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);			EraseRect(&r);			gMainWindow->DrawGrid();						Point scrollOffset = {0, 0};			vector<BSpline*> workingBSplines;			DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			int qr = 1;		}				vector<GenericIntersection*>* companionSet = new vector<GenericIntersection*>;				for (int j = 0; j < (*interCompanionPairSets[i]).size(); j++)		{			if (gDebug1)			{				SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;				PenSize(2, 2);								ForeColor(cyanColor);				FloatPoint intersectionLoc = (*interCompanionPairSets[i])[j].first->GetLocation();				SetRect(&r, intersectionLoc.h - (10 + j * 3), intersectionLoc.v - (10 + j * 3), intersectionLoc.h + (10 + j * 3), intersectionLoc.v + (10 + j * 3));				FrameRect(&r);								ForeColor(blackColor);				intersectionLoc = (*interCompanionPairSets[i])[j].second->GetLocation();				SetRect(&r, intersectionLoc.h - (10 + j * 3), intersectionLoc.v - (10 + j * 3), intersectionLoc.h + (10 + j * 3), intersectionLoc.v + (10 + j * 3));				FrameRect(&r);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qr = 1;								PenSize(1, 1);			}						if ((*interCompanionPairSets[i])[j].first->GetType() == GenericIntersection::BSP_BSP &&				find(companionSet->begin(), companionSet->end(), (*interCompanionPairSets[i])[j].first) == companionSet->end())				companionSet->push_back((*interCompanionPairSets[i])[j].first);			if ((*interCompanionPairSets[i])[j].second->GetType() == GenericIntersection::BSP_BSP &&				find(companionSet->begin(), companionSet->end(), (*interCompanionPairSets[i])[j].second) == companionSet->end())				companionSet->push_back((*interCompanionPairSets[i])[j].second);						//Add any discovered BspCut comps			if ((*interCompanionPairSets[i])[j].first->GetType() == GenericIntersection::BSP_BSP)				for (int k = 0; k < bspCutComps.size(); k++)					if (bspCutComps[k].first == (BspBspIntersection*)(*interCompanionPairSets[i])[j].first)						for (int m = 0; m < bspCutComps[k].second.size(); m++)							if (find(companionSet->begin(), companionSet->end(), bspCutComps[k].second[m]) == companionSet->end())								companionSet->push_back(bspCutComps[k].second[m]);						if ((*interCompanionPairSets[i])[j].second->GetType() == GenericIntersection::BSP_BSP)				for (int k = 0; k < bspCutComps.size(); k++)					if (bspCutComps[k].first == (BspBspIntersection*)(*interCompanionPairSets[i])[j].second)						for (int m = 0; m < bspCutComps[k].second.size(); m++)							if (find(companionSet->begin(), companionSet->end(), bspCutComps[k].second[m]) == companionSet->end())								companionSet->push_back(bspCutComps[k].second[m]);		}				if (gDebug1)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));			Rect r;						PenSize(2, 2);			ForeColor(redColor);			for (int j = 0; j < companionSet->size(); j++)			{				FloatPoint intersectionLoc = (*companionSet)[j]->GetLocation();				SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);				FrameOval(&r);			}						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qr = 1;						ForeColor(whiteColor);			for (int j = 0; j < companionSet->size(); j++)			{				FloatPoint intersectionLoc = (*companionSet)[j]->GetLocation();				SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);				FrameOval(&r);			}						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}				//Check if the companion set already exists		bool atLeastOneCompanionAlreadyCompanioned = false;		for (int j = 0; j < interCompanionSets.size(); j++)		{			for (int k = 0; k < companionSet->size(); k++)				if (find(interCompanionSets[j]->begin(), interCompanionSets[j]->end(), (*companionSet)[k]) != interCompanionSets[j]->end())				{					atLeastOneCompanionAlreadyCompanioned = true;					break;				}			if (atLeastOneCompanionAlreadyCompanioned)				break;		}				if (!atLeastOneCompanionAlreadyCompanioned && companionSet->size() > 0)			interCompanionSets.push_back(companionSet);		else delete companionSet;				delete interCompanionPairSets[i];	}	interCompanionPairSets.clear();		//debug	for (vector<vector<GenericIntersection*>*>::iterator j = interCompanionSets.begin(); j != interCompanionSets.end(); j++)		MyAssert((*j)->size() > 0);		//This shouldn't be necessary, there is a catch for this in the loop above, but it is failing for some reason.	bool foundOne = true;	while (foundOne)	{		foundOne = false;		for (vector<vector<GenericIntersection*>*>::iterator i = interCompanionSets.begin(); i != interCompanionSets.end(); i++)		{			vector<vector<GenericIntersection*>*>::iterator j = i;			j++;			for (; j != interCompanionSets.end(); j++)			{				for (int k = 0; k < (*j)->size(); k++)					if (find((*i)->begin(), (*i)->end(), (*(*j))[k]) != (*i)->end())					{						MyAssert(false);	//Is this happening?  If not, this code block is unnecessary						delete *j;						interCompanionSets.erase(j);						foundOne = true;						break;					}				if (foundOne)					break;			}			if (foundOne)				break;		}	}}void Drawing::FindInterCompSetsForBspBspInter(BspBspIntersection* intersection, vector<BspCutIntersection*>* bspCutComps, int i){	if (gDebug1)	{		MyAssert(!dtored);				SetPort(GetWindowPort(gMainWindow->GetWindow()));				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qr = 1;				PenSize(2, 2);	}	Rect r;		if (gDebug1)	{		FloatPoint intersectionLoc = intersection->GetLocation();		SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));		ForeColor(blackColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qr = 1;	}		//Find the two companions of the intersection.  Every intersection has two companions, but the companions might not be unique (both companions might be the same intersection).	BspBspIntersection *compInter1, *compInter2;	FindOneBspBspInterCompanions(intersection, compInter1, compInter2, bspCutComps);		if (gDebug1)	{		FloatPoint intersectionLoc = intersection->GetLocation();		SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));		ForeColor(whiteColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		if (gDebug1)	{		FloatPoint intersectionLoc;		ForeColor(redColor);		if (compInter1)		{			intersectionLoc = compInter1->GetLocation();			SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}		if (compInter2)		{			intersectionLoc = compInter2->GetLocation();			SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}				int qr = 1;				ForeColor(whiteColor);		if (compInter1)		{			intersectionLoc = compInter1->GetLocation();			SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}		if (compInter2)		{			intersectionLoc = compInter2->GetLocation();			SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}	}		//Every intersection has two companions, but the companions might not be unique (both companions might be the same intersection)	int numIts = (compInter1 == compInter2) ? 1 : 2;		int firstItCompInterSetIndex = -1, secondItCompInterSetIndex = -1;	for (int it = 0; it < numIts; it++)	{		//On the first iteration, take the first companion intersection, on the second, take the second		BspBspIntersection* compInter = (it == 0) ? compInter1 : compInter2;				if (!compInter)			continue;				if (gDebug1)		{			FloatPoint intersectionLoc = compInter->GetLocation();			SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));			ForeColor(greenColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qr = 1;						SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));			ForeColor(whiteColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}				//See if the companion is already in a set.  If so, add the new pair to the set.		//If not, make a new set for the pair.		int compInterSetIndex = -1;		bool duplicateSet = false;		for (int j = 0; j < interCompanionPairSets.size(); j++)	//Loop through sets			for (int k = 0; k < interCompanionPairSets[j]->size(); k++)	//Loop through pairs of one set				if ((*interCompanionPairSets[j])[k].first == compInter || (*interCompanionPairSets[j])[k].second == compInter)	//Is the comp inter in the pair?				{					//Might be a duplicate set					if (((*interCompanionPairSets[j])[k].first == compInter && (*interCompanionPairSets[j])[k].second == intersection) ||						((*interCompanionPairSets[j])[k].second == compInter && (*interCompanionPairSets[j])[k].first == intersection))						duplicateSet = true;										if (gDebug1)					{						if (((*interCompanionPairSets[j])[k].first == compInter && (*interCompanionPairSets[j])[k].second == intersection) ||							((*interCompanionPairSets[j])[k].second == compInter && (*interCompanionPairSets[j])[k].first == intersection))							ForeColor(yellowColor);						else ForeColor(blueColor);												FloatPoint intersectionLoc = (*interCompanionPairSets[j])[k].first->GetLocation();						SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												intersectionLoc = (*interCompanionPairSets[j])[k].second->GetLocation();						SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qr = 1;												ForeColor(whiteColor);						intersectionLoc = (*interCompanionPairSets[j])[k].first->GetLocation();						SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												intersectionLoc = (*interCompanionPairSets[j])[k].second->GetLocation();						SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);					}										//MyAssert(compInterSetIndex == -1 || duplicateSet);	//The compInter should be in, at most, one existing set, and should only be in that set once (twice, but the second time is "this" time, which is new)					if (compInterSetIndex != -1 && !duplicateSet)						duplicateSet = true;	//don't bother with this guy										compInterSetIndex = j;				}				((it == 0) ? firstItCompInterSetIndex : secondItCompInterSetIndex) = compInterSetIndex;				if (duplicateSet)	//The companion pair already exists			continue;				if (compInterSetIndex != -1)	//An existing set was found		{			if (gDebug1)			{				FloatPoint intersectionLoc = compInter->GetLocation();				ForeColor(magentaColor);				SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								intersectionLoc = intersection->GetLocation();				SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qr = 1;								ForeColor(whiteColor);				intersectionLoc = compInter->GetLocation();				SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								intersectionLoc = intersection->GetLocation();				SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			}						//Make a new pair for the two intersections			pair<GenericIntersection*, GenericIntersection*> interCompPair;			interCompPair.first = compInter;			interCompPair.second = intersection;						//Add the pair to the set			(*interCompanionPairSets[compInterSetIndex]).push_back(interCompPair);						//Make sure the new companion is still legal with all its previous companions			BspBspIntersection *compCompInter1, *compCompInter2;			FindOneBspBspInterCompanions(compInter, compCompInter1, compCompInter2, NULL);						//If there are any existing pairs associated with this companion intersection that are illegal (probably outdated in such a case), simply remove them.			bool foundOne = true;			while (foundOne)			{				foundOne = false;				for (vector<pair<GenericIntersection*, GenericIntersection*> >::iterator iter = interCompanionPairSets[compInterSetIndex]->begin();					iter != interCompanionPairSets[compInterSetIndex]->end(); iter++)	//Loop through pairs of the set					if ((*iter).first == compInter)	//If the pair contains the comp inter					{						if ((*iter).second != compCompInter1 && (*iter).second != compCompInter2)	//...and if the pair doesn't contain a legal match						{							interCompanionPairSets[compInterSetIndex]->erase(iter);	//...remove the pair							foundOne = true;							break;						}					}					else if ((*iter).second == compInter)	//If the pair contains the comp inter					{						if ((*iter).first != compCompInter1 && (*iter).first != compCompInter2)	//...and if the pair doesn't contain a legal match						{							interCompanionPairSets[compInterSetIndex]->erase(iter);	//...remove the pair							foundOne = true;							break;						}					}			}		}		else	//An existing companion set was not found, so create one		{			if (gDebug1)			{				FloatPoint intersectionLoc = compInter->GetLocation();				ForeColor(cyanColor);				SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								intersectionLoc = intersection->GetLocation();				SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qr = 1;								ForeColor(whiteColor);				intersectionLoc = compInter->GetLocation();				SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								intersectionLoc = intersection->GetLocation();				SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			}						//Make a new pair for the two intersections			pair<GenericIntersection*, GenericIntersection*> interCompPair;			interCompPair.first = compInter;			interCompPair.second = intersection;						//Make a new set for the pair			vector<pair<GenericIntersection*, GenericIntersection*> >* interCompanionPairSet = new vector<pair<GenericIntersection*, GenericIntersection*> >;			interCompanionPairSet->push_back(interCompPair);						//Add the set to the list of sets			interCompanionPairSets.push_back(interCompanionPairSet);			((it == 0) ? firstItCompInterSetIndex : secondItCompInterSetIndex) = interCompanionPairSets.size() - 1;		}	}		//Might need to merge the two sets	if (firstItCompInterSetIndex != -1 && secondItCompInterSetIndex != -1 && numIts == 2 && firstItCompInterSetIndex != secondItCompInterSetIndex)	{		for (int j = 0; j < interCompanionPairSets[secondItCompInterSetIndex]->size(); j++)	//Loop through the pairs of the second set			interCompanionPairSets[firstItCompInterSetIndex]->push_back((*interCompanionPairSets[secondItCompInterSetIndex])[j]);	//Add each pair from the second set to the first set				//Delete the second set		vector<vector<pair<GenericIntersection*, GenericIntersection*> >*>::iterator iter = interCompanionPairSets.begin();		for (int j = 0; j < secondItCompInterSetIndex; j++)			iter++;		interCompanionPairSets.erase(iter);				//Verify that the new set doesn't have any duplicates		if (interCompanionPairSets[firstItCompInterSetIndex]->size() > 1)			for (int j = 0; j < interCompanionPairSets[firstItCompInterSetIndex]->size() - 1; j++)	//Loop through the pairs of the set				for (int k = j + 1; k < interCompanionPairSets[firstItCompInterSetIndex]->size(); k++)	//Loop through the pairs of the set					MyAssert(!(((*interCompanionPairSets[firstItCompInterSetIndex])[j].first == (*interCompanionPairSets[firstItCompInterSetIndex])[k].first &&							(*interCompanionPairSets[firstItCompInterSetIndex])[j].second == (*interCompanionPairSets[firstItCompInterSetIndex])[k].second) ||							((*interCompanionPairSets[firstItCompInterSetIndex])[j].first == (*interCompanionPairSets[firstItCompInterSetIndex])[k].second &&							(*interCompanionPairSets[firstItCompInterSetIndex])[j].second == (*interCompanionPairSets[firstItCompInterSetIndex])[k].first)));	}}void Drawing::FindInterCompSetsForBspCutInter(BspCutIntersection* intersection, int i /*DEBUG*/){	if (gDebug1)	{		MyAssert(!dtored);				SetPort(GetWindowPort(gMainWindow->GetWindow()));				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qrBspCut = 1;				PenSize(2, 2);	}	Rect r;		if (gDebug1)	{		FloatPoint intersectionLoc = intersection->GetLocation();		SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));		ForeColor(blackColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qrBspCut = 1;	}		//Find the companion of the intersection, if the companion exists	BspCutIntersection *compInter = FindBspCutInterCompanion(intersection);		if (gDebug1)	{		FloatPoint intersectionLoc = intersection->GetLocation();		SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));		ForeColor(whiteColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		if (!compInter)	//There is no companion		return;		if (gDebug1)	{		FloatPoint intersectionLoc = compInter->GetLocation();		SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));		ForeColor(redColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qrBspCut = 1;				SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));		ForeColor(whiteColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		//See if the pair are already a set.	//If not, make a new set for the pair.	int compInterSetIndex = -1;	bool duplicateSet = false;	for (int j = 0; j < interCompanionPairSets.size(); j++)	//Loop through sets		for (int k = 0; k < interCompanionPairSets[j]->size(); k++)	//Loop through pairs of one set			if ((*interCompanionPairSets[j])[k].first == compInter || (*interCompanionPairSets[j])[k].second == compInter)	//Is the comp inter in the pair?			{				if (gDebug1)				{					FloatPoint intersectionLoc = (*interCompanionPairSets[j])[k].first->GetLocation();					ForeColor(blueColor);					SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										intersectionLoc = (*interCompanionPairSets[j])[k].second->GetLocation();					SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qrBspCut = 1;										ForeColor(whiteColor);					intersectionLoc = (*interCompanionPairSets[j])[k].first->GetLocation();					SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										intersectionLoc = (*interCompanionPairSets[j])[k].second->GetLocation();					SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				}								//Might be a duplicate set				if ((*interCompanionPairSets[j])[k].first == compInter)					MyAssert((*interCompanionPairSets[j])[k].second == intersection);				if ((*interCompanionPairSets[j])[k].second == compInter)					MyAssert((*interCompanionPairSets[j])[k].first == intersection);								MyAssert(compInterSetIndex == -1);	//The compInter should be in, at most, one existing set, and should only be in that set once (twice, but the second time is "this" time, which is new)				compInterSetIndex = j;			}		if (compInterSetIndex != -1)	//The companion pair already exists		return;		if (gDebug1)	{		FloatPoint intersectionLoc = compInter->GetLocation();		ForeColor(cyanColor);		SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				intersectionLoc = intersection->GetLocation();		SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qrBspCut = 1;				intersectionLoc = compInter->GetLocation();		ForeColor(whiteColor);		SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				intersectionLoc = intersection->GetLocation();		SetRect(&r, intersectionLoc.h - (i + 10), intersectionLoc.v - (i + 10), intersectionLoc.h + (i + 10), intersectionLoc.v + (i + 10));		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		//Make a new pair for the two intersections	pair<GenericIntersection*, GenericIntersection*> interCompPair;	interCompPair.first = compInter;	interCompPair.second = intersection;		//Make a new set for the pair	vector<pair<GenericIntersection*, GenericIntersection*> >* interCompanionPairSet = new vector<pair<GenericIntersection*, GenericIntersection*> >;	interCompanionPairSet->push_back(interCompPair);		//Add the set to the list of sets	interCompanionPairSets.push_back(interCompanionPairSet);}void Drawing::FindOneBspBspInterCompanions(BspBspIntersection* intersection, BspBspIntersection*& compInter1, BspBspIntersection*& compInter2, vector<BspCutIntersection*>* bspCutComps){	/*	BSpline* bsp1 = intersection->GetBsp1();	BSpline* bsp2 = intersection->GetBsp2();	int occludedEdge = intersection->DetermineOccludedEdge();	MyAssert(occludedEdge == 3 || occludedEdge == 4);	if (occludedEdge == 3)	//potentially edges are 2 and 3	{		compInter1 = FindOneBspBspInterOneCompanion(intersection, bsp1, bsp2, true);		compInter2 = FindOneBspBspInterOneCompanion(intersection, bsp2, bsp1, false);	}	else	//potentially occluded edges are 1 and 4	{		compInter1 = FindOneBspBspInterOneCompanion(intersection, bsp1, bsp2, false);		compInter2 = FindOneBspBspInterOneCompanion(intersection, bsp2, bsp1, true);	}	*/		//=============================================================================================================	/*	BSpline* bsp1 = intersection->GetBsp1();	BSpline* bsp2 = intersection->GetBsp2();	int occludedEdge = intersection->DetermineOccludedEdge();	MyAssert(occludedEdge == 3 || occludedEdge == 4);	if (occludedEdge == 3)	//potentially edges are 2 and 3		FindOneBspBspInterOneCompanion(intersection, bsp1, bsp2, true, compInter1, compInter2);	else	//potentially occluded edges are 1 and 4		FindOneBspBspInterOneCompanion(intersection, bsp1, bsp2, false, compInter1, compInter2);		//=============================================================================================================	*/	//The algorithm used by the following functions finds companions correctly, but requires a legal labeling in advance.	FloatPoint p1 = intersection->GetLocation();	//debug	BspBspIntersection* inter1 = intersection;	//debug	compInter1 = FindOneBspBspInterCompanionTraverseBottom(intersection, bspCutComps);	FloatPoint p2 = intersection->GetLocation();	//debug	BspBspIntersection* inter2 = intersection;	//debug	compInter2 = FindOneBspBspInterCompanionTraverseTop(intersection, bspCutComps);}/*//This is an old function using an old algorithm.  I'm pretty sure it doesn't find companions correctly.BspBspIntersection* Drawing::FindOneBspBspInterOneCompanion(BspBspIntersection* intersection, BSpline* traverseBsp, BSpline* crossBsp, bool forward){	//Get the curve and seg of the intersection on the traversing BSpline	int curve, seg;	if (!intersection->SelfIntersection())	{		if (intersection->GetBsp1() == traverseBsp)		{			curve = intersection->GetCv1();			seg = intersection->GetSg1();		}		else		{			MyAssert(intersection->GetBsp2() == traverseBsp);			curve = intersection->GetCv2();			seg = intersection->GetSg2();		}	}	else	//Self intersection	{		int occludedEdge = intersection->DetermineOccludedEdge();		MyAssert(occludedEdge == 3 || occludedEdge == 4);		if (forward)		{			//Need to traverse forward, but only one of the two possible forward directions is occluded			if (occludedEdge == 3)			{				curve = intersection->GetCv1();				seg = intersection->GetSg1();			}			else			{				curve = intersection->GetCv2();				seg = intersection->GetSg2();			}		}		else	//backward		{			//Need to traverse backward, but only one of the two possible backward directions is occluded			if (occludedEdge == 3)			{				curve = intersection->GetCv2();				seg = intersection->GetSg2();			}			else			{				curve = intersection->GetCv1();				seg = intersection->GetSg1();			}		}	}		//See if the traversal BSpline has a whole object	WholeObject* wholeObject = NULL;	for (int i = 0; i < wholeObjects.size(); i++)		if (find(wholeObjects[i]->bsplines.begin(), wholeObjects[i]->bsplines.end(), traverseBsp) != wholeObjects[i]->bsplines.end())		{			wholeObject = wholeObjects[i];			break;		}	if (!wholeObject)		return NULL;		//Find the whole object for the cross BSpline	wholeObject = NULL;	for (int i = 0; i < wholeObjects.size(); i++)		if (find(wholeObjects[i]->bsplines.begin(), wholeObjects[i]->bsplines.end(), intersection->GetOtherBsp(traverseBsp)) != wholeObjects[i]->bsplines.end())		{			wholeObject = wholeObjects[i];			break;		}	if (!wholeObject)		return NULL;		Rect r;	if (gDebug1)	{		FloatPoint intersectionLoc = intersection->GetLocation();		SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);		ForeColor(blackColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qrOld = 1;	}		//Loop until a companion is found	GenericIntersection* prevPropInter = intersection;	int counter = 0;	//DEBUG	int layerCounter = 0;	while (true)	{		if (counter++ > traverseBsp->GetNumIntersections())	//еее Really, I think this should be an MyAssert that should never occur, but for now, just screw it			return NULL;				//Find the next intersection in the propagation around the traversal BSpline		GenericIntersection* propagatedIntersection;		if (forward)			propagatedIntersection = traverseBsp->FindNextIntersection((GenericIntersection*)prevPropInter, curve, seg);		else propagatedIntersection = traverseBsp->FindPrevIntersection((GenericIntersection*)prevPropInter, curve, seg);			if (gDebug1)		{			FloatPoint intersectionLoc = propagatedIntersection->GetLocation();			SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);			ForeColor(redColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qrOld = 1;		}				//Find the curve and seg of the traversal bsp at the propagated intersection		bool traversalArrivedOnTop;		switch (propagatedIntersection->GetType())		{			case GenericIntersection::BSP_BSP:				BspBspIntersection* bspBspInter = (BspBspIntersection*)propagatedIntersection;								if (!bspBspInter->SelfIntersection())				{					if (((BspBspIntersection*)propagatedIntersection)->GetBsp1() == traverseBsp)					{						curve = bspBspInter->GetCv1();						seg = bspBspInter->GetSg1();						traversalArrivedOnTop = true;					}					else					{						MyAssert(bspBspInter->GetBsp2() == traverseBsp);						curve = bspBspInter->GetCv2();						seg = bspBspInter->GetSg2();						traversalArrivedOnTop = false;					}				}				else	//Self intersection				{					int curve1 = bspBspInter->GetCv1();					int curve2 = bspBspInter->GetCv2();					int seg1 = bspBspInter->GetSg1();					int seg2 = bspBspInter->GetSg2();										int curveSeg = curve * BSpline::sNumSegmentsPerCurve + seg;					int curveSeg1 = curve1 * BSpline::sNumSegmentsPerCurve + seg1;					int curveSeg2 = curve2 * BSpline::sNumSegmentsPerCurve + seg2;										//Take the curve/seg that is closer to and after the present curve/seg					if ((curveSeg1 > curveSeg && curveSeg2 > curveSeg) ||						(curveSeg1 < curveSeg && curveSeg2 < curveSeg))					{						if (forward)						{							if (curveSeg1 < curveSeg2)							{								curve = curve1;								seg = seg1;								traversalArrivedOnTop = true;							}							else							{								curve = curve2;								seg = seg2;								traversalArrivedOnTop = false;							}						}						else	//backward						{							if (curveSeg1 < curveSeg2)							{								curve = curve2;								seg = seg2;								traversalArrivedOnTop = false;							}							else							{								curve = curve1;								seg = seg1;								traversalArrivedOnTop = true;							}						}					}					if (curveSeg1 > curveSeg && curveSeg2 < curveSeg)					{						if (forward)						{							curve = curve1;							seg = seg1;							traversalArrivedOnTop = true;						}						else	//backward						{							curve = curve2;							seg = seg2;							traversalArrivedOnTop = false;						}					}					else if (curveSeg2 > curveSeg && curveSeg1 < curveSeg)					{						if (forward)						{							curve = curve2;							seg = seg2;							traversalArrivedOnTop = false;						}						else	//backward						{							curve = curve1;							seg = seg1;							traversalArrivedOnTop = true;						}					}					else if (curveSeg1 == curve)					{						return NULL;	//еее	Really need to account for this instead of bailing					}					else if (curveSeg2 == curve)					{						return NULL;	//еее	Really need to account for this instead of bailing					}				}				break;			case GenericIntersection::BSP_CUT:				MyAssert(((BspCutIntersection*)propagatedIntersection)->GetBsp() == traverseBsp);				curve = ((BspCutIntersection*)propagatedIntersection)->GetCv();				seg = ((BspCutIntersection*)propagatedIntersection)->GetSg();				traversalArrivedOnTop = ((BspCutIntersection*)propagatedIntersection)->GetBspOnTop();				break;			case GenericIntersection::BSP_CUT_T:				MyAssert(((BspCutTIntersection*)propagatedIntersection)->GetBsp() == traverseBsp);				curve = ((BspCutTIntersection*)propagatedIntersection)->GetCv();				seg = ((BspCutTIntersection*)propagatedIntersection)->GetSg();				traversalArrivedOnTop = true;				break;			case GenericIntersection::CUT_CUT:				MyAssert(false);				break;		}				if (propagatedIntersection == intersection)	//Probably a self intersection on an illegal curve (partial figure eight for example)			return NULL;				//Get the occluded edge at the propagated intersection		int occludedEdge = propagatedIntersection->DetermineOccludedEdge();				//If the layer counter is zero and the next intersection is the right type, it might be the companion		if (layerCounter == 0 && propagatedIntersection->GetType() == GenericIntersection::BSP_BSP)		{			BspBspIntersection* bspBspInter = (BspBspIntersection*)propagatedIntersection;			BSpline* bsp1 = bspBspInter->GetBsp1();			BSpline* bsp2 = bspBspInter->GetBsp2();						//If the occlusion reflects back along the traversal, the propagated intersection is the companion, so quit			if (forward)			{				if (!wholeObject)				{					//Only accept the exact BSpline (misses grouped objects of BSplines)					if ((traversalArrivedOnTop && occludedEdge == 4) || (!traversalArrivedOnTop && occludedEdge == 3))						return bspBspInter;				}				else				{					//Accept any BSpline in the whole object group					if ((traversalArrivedOnTop && find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), bsp2) != wholeObject->bsplines.end() && occludedEdge == 4) ||						(!traversalArrivedOnTop && find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), bsp1) != wholeObject->bsplines.end() && occludedEdge == 3))						return bspBspInter;				}			}			else	//backward			{				if (!wholeObject)				{					//Only accept the exact BSpline (misses grouped objects of BSplines)					if ((traversalArrivedOnTop && occludedEdge == 3) || (!traversalArrivedOnTop && occludedEdge == 4))						return bspBspInter;				}				else				{					//Accept any BSpline in the whole object group					if ((traversalArrivedOnTop && find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), bsp2) != wholeObject->bsplines.end() && occludedEdge == 3) ||						(!traversalArrivedOnTop && find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), bsp1) != wholeObject->bsplines.end() && occludedEdge == 4))						return bspBspInter;				}			}		}				//Getting here means the propagated intersection wasn't the companion				//Alter the layer counter		if (propagatedIntersection->GetType() == GenericIntersection::BSP_BSP)		{			BspBspIntersection* bspBspInter = (BspBspIntersection*)propagatedIntersection;			BSpline* bsp1 = bspBspInter->GetBsp1();			BSpline* bsp2 = bspBspInter->GetBsp2();						if (forward)			{				if (!wholeObject)				{					//Only accept the exact BSpline (misses grouped objects of BSplines)					if ((traversalArrivedOnTop && occludedEdge == 3) || (!traversalArrivedOnTop && occludedEdge == 4))						layerCounter++;					else if ((traversalArrivedOnTop && occludedEdge == 4) || (!traversalArrivedOnTop && occludedEdge == 3))						layerCounter--;				}				else				{					//Accept any BSpline in the whole object group					if ((traversalArrivedOnTop && find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), bsp2) != wholeObject->bsplines.end() && occludedEdge == 3) ||						(!traversalArrivedOnTop && find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), bsp1) != wholeObject->bsplines.end() && occludedEdge == 4))						layerCounter++;					else if ((traversalArrivedOnTop && find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), bsp2) != wholeObject->bsplines.end() && occludedEdge == 4) ||						(!traversalArrivedOnTop && find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), bsp1) != wholeObject->bsplines.end() && occludedEdge == 3))						layerCounter--;				}			}			else	//backward			{				if (!wholeObject)				{					//Only accept the exact BSpline (misses grouped objects of BSplines)					if ((traversalArrivedOnTop && occludedEdge == 3) || (!traversalArrivedOnTop && occludedEdge == 4))						layerCounter++;					else if ((traversalArrivedOnTop && occludedEdge == 4) || (!traversalArrivedOnTop && occludedEdge == 3))						layerCounter--;				}				else				{					//Accept any BSpline in the whole object group					if ((traversalArrivedOnTop && find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), bsp2) != wholeObject->bsplines.end() && occludedEdge == 4) ||						(!traversalArrivedOnTop && find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), bsp1) != wholeObject->bsplines.end() && occludedEdge == 3))						layerCounter++;					else if ((traversalArrivedOnTop && find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), bsp2) != wholeObject->bsplines.end() && occludedEdge == 3) ||						(!traversalArrivedOnTop && find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), bsp1) != wholeObject->bsplines.end() && occludedEdge == 4))						layerCounter--;				}			}		}				//Keep track of the intersection that was just propagated from		prevPropInter = propagatedIntersection;	}}BspBspIntersection* Drawing::FindOneBspBspInterOneCompanion(BspBspIntersection* intersection, BSpline* bsp1, BSpline* bsp2, bool bsp1Forward, BspBspIntersection*& compInter1, BspBspIntersection*& compInter2){	Rect r;	//DEBUG		vector<GenericIntersection*> bsp1IntersTraversed, bsp2IntersTraversed;		for (int i = 0; i < 2; i++)	{		bool takeFirstFound = true;		if (intersection->SelfIntersection())		{			int occludedEdge = intersection->DetermineOccludedEdge();			MyAssert(occludedEdge == 3 || occludedEdge == 4);						int curveSeg1 = intersection->GetCv1() * BSpline::sNumSegmentsPerCurve + intersection->GetSg1();			int curveSeg2 = intersection->GetCv2() * BSpline::sNumSegmentsPerCurve + intersection->GetSg2();			if (bsp1Forward)			{				//Need to traverse forward, but only one of the two possible forward directions is occluded				if (occludedEdge == 3)					takeFirstFound = (curveSeg1 < curveSeg2);				else takeFirstFound = (curveSeg2 < curveSeg1);			}			else	//backward			{				//Need to traverse backward, but only one of the two possible backward directions is occluded				if (occludedEdge == 3)					takeFirstFound = (curveSeg2 < curveSeg1);				else takeFirstFound = (curveSeg1 < curveSeg2);			}						if (i == 1)				takeFirstFound = !takeFirstFound;		}				BSpline* bsp = (i == 0) ? bsp1 : bsp2;		int startPos = bsp->GetIntersectionIndex(intersection, takeFirstFound);		int incrementAmt = (i == 0) ? (bsp1Forward ? 1 : -1) : (bsp1Forward ? -1 : 1);				vector<GenericIntersection*> bspInters = bsp->GetIntersections();		vector<GenericIntersection*>* bspIntersTraversed = (i == 0) ? &bsp1IntersTraversed : &bsp2IntersTraversed;		for (int j = 0; j < bspInters.size(); j++)		{			int nextInterIndex = startPos + incrementAmt * j;			if (nextInterIndex < 0)				nextInterIndex += bspInters.size();			else if (nextInterIndex >= bspInters.size())				nextInterIndex -= bspInters.size();			MyAssert(nextInterIndex < bspInters.size());			bspIntersTraversed->push_back(bspInters[nextInterIndex]);		}	}		if (gDebug1)	{		for (int i = 0; i < bsp1IntersTraversed.size(); i++)		{			FloatPoint intersectionLoc = bsp1IntersTraversed[i]->GetLocation();			SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);			ForeColor(redColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qrOld = 1;						long st = TickCount();			while (TickCount() - st < 10);						intersectionLoc = bsp1IntersTraversed[i]->GetLocation();			SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);			ForeColor(whiteColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}				for (int i = 0; i < bsp2IntersTraversed.size(); i++)		{			FloatPoint intersectionLoc = bsp2IntersTraversed[i]->GetLocation();			SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);			ForeColor(greenColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qrOld = 1;						long st = TickCount();			while (TickCount() - st < 10);						intersectionLoc = bsp2IntersTraversed[i]->GetLocation();			SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);			ForeColor(whiteColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}	}		//Search along each list of inters for the first occurance from the other list.  This is done iteratively until convergence.	bool changeMade = true;	int bsp1Truncate = bsp1IntersTraversed.size() - 1, bsp2Truncate = bsp2IntersTraversed.size() - 1;	int prevBsp1Truncate = bsp1Truncate, prevBsp2Truncate = bsp2Truncate;	while (changeMade)	{		changeMade = false;		prevBsp1Truncate = bsp1Truncate;		prevBsp2Truncate = bsp2Truncate;				for (int i = 1; i <= bsp1IntersTraversed.size(); i++)		{			if (gDebug1)			{				FloatPoint intersectionLoc = bsp1IntersTraversed[i]->GetLocation();				SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);				ForeColor(redColor);				FrameRect(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qrOld = 1;			}			//			int j = 1;//			for (j = 1; j <= bsp2Truncate; j++)//			{//				if (gDebug1)//				{//					FloatPoint intersectionLoc = bsp2IntersTraversed[j]->GetLocation();//					SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);//					ForeColor(magentaColor);//					FrameOval(&r);//					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);//					//					int qrOld = 1;//				}//				//				if (gDebug1)//				{//					FloatPoint intersectionLoc = bsp2IntersTraversed[j]->GetLocation();//					SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);//					ForeColor(whiteColor);//					FrameOval(&r);//					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);//				}//				//				//if (bsp2IntersTraversed[j] == bsp1IntersTraversed[i])//				//	break;//				//				if (bsp2IntersTraversed[j]->GetType() == GenericIntersection::BSP_BSP && (BspBspIntersection*)bsp2IntersTraversed[j]->GetOtherBsp(bsp2) == bsp1)//				{//					bsp1Truncate = i;//					foundCross = true;//					break;//				}//			}			//			if (j < bsp2Truncate)//			{//				changeMade = true;//				bsp2Truncate = j;//			}						if (gDebug1)			{				FloatPoint intersectionLoc = bsp1IntersTraversed[i]->GetLocation();				SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);				ForeColor(whiteColor);				FrameRect(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			}						if (bsp1IntersTraversed[i]->GetType() == GenericIntersection::BSP_BSP && ((BspBspIntersection*)bsp1IntersTraversed[i])->GetOtherBsp(bsp1) == bsp2)			{				int j = 1;				for (j = 1; j <= bsp2Truncate; j++)					if (bsp2IntersTraversed[j] == bsp1IntersTraversed[i])						break;				if (j <= bsp2Truncate)				{					if (bsp1Truncate != i)					{						changeMade = true;						bsp1Truncate = i;					}										if (gDebug1)					{						FloatPoint intersectionLoc = bsp1IntersTraversed[i]->GetLocation();						SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);						ForeColor(magentaColor);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qrOld = 1;					}										if (gDebug1)					{						FloatPoint intersectionLoc = bsp1IntersTraversed[i]->GetLocation();						SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);						ForeColor(whiteColor);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);					}											break;				}			}		}				for (int i = 1; i <= bsp2IntersTraversed.size(); i++)		{			if (gDebug1)			{				FloatPoint intersectionLoc = bsp2IntersTraversed[i]->GetLocation();				SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);				ForeColor(blueColor);				FrameRect(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qrOld = 1;			}			//			int j = 1;//			for (j = 1; j <= bsp1Truncate; j++)//			{//				if (gDebug1)//				{//					FloatPoint intersectionLoc = bsp1IntersTraversed[j]->GetLocation();//					SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);//					ForeColor(cyanColor);//					FrameOval(&r);//					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);//					//					int qrOld = 1;//				}//				//				if (gDebug1)//				{//					FloatPoint intersectionLoc = bsp1IntersTraversed[j]->GetLocation();//					SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);//					ForeColor(whiteColor);//					FrameOval(&r);//					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);//				}//				//				//if (bsp1IntersTraversed[j] == bsp2IntersTraversed[i])//				//	break;//			}			//			if (j < bsp1Truncate)//			{//				changeMade = true;//				bsp1Truncate = j;//			}						if (gDebug1)			{				FloatPoint intersectionLoc = bsp2IntersTraversed[i]->GetLocation();				SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);				ForeColor(whiteColor);				FrameRect(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			}						if (bsp2IntersTraversed[i]->GetType() == GenericIntersection::BSP_BSP && ((BspBspIntersection*)bsp2IntersTraversed[i])->GetOtherBsp(bsp2) == bsp1)			{				int j = 1;				for (j = 1; j <= prevBsp1Truncate; j++)					if (bsp1IntersTraversed[j] == bsp2IntersTraversed[i])						break;				if (j <= prevBsp1Truncate)				{					if (bsp2Truncate != i)					{						changeMade = true;						bsp2Truncate = i;					}										if (gDebug1)					{						FloatPoint intersectionLoc = bsp2IntersTraversed[i]->GetLocation();						SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);						ForeColor(cyanColor);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qrOld = 1;					}										if (gDebug1)					{						FloatPoint intersectionLoc = bsp2IntersTraversed[i]->GetLocation();						SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);						ForeColor(whiteColor);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);					}										break;				}			}		}	}		MyAssert(bsp1IntersTraversed[bsp1Truncate]->GetType() == GenericIntersection::BSP_BSP);	MyAssert(bsp2IntersTraversed[bsp2Truncate]->GetType() == GenericIntersection::BSP_BSP);		compInter1 = (BspBspIntersection*)bsp1IntersTraversed[bsp1Truncate];	compInter2 = (BspBspIntersection*)bsp2IntersTraversed[bsp2Truncate];		if (gDebug1)	{		if (compInter1 != compInter2)		{			FloatPoint intersectionLoc = compInter1->GetLocation();			SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);			ForeColor(redColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						intersectionLoc = compInter2->GetLocation();			SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);			ForeColor(blueColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}		else		{			FloatPoint intersectionLoc = compInter1->GetLocation();			SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);			ForeColor(greenColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}				int qrOld = 1;				FloatPoint intersectionLoc = compInter1->GetLocation();		SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);		ForeColor(whiteColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				intersectionLoc = compInter2->GetLocation();		SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);		ForeColor(whiteColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}	//	//See if the traversal BSpline has a whole object//	WholeObject* wholeObject = NULL;//	for (int i = 0; i < wholeObjects.size(); i++)//		if (find(wholeObjects[i]->bsplines.begin(), wholeObjects[i]->bsplines.end(), traverseBsp) != wholeObjects[i]->bsplines.end())//		{//			wholeObject = wholeObjects[i];//			break;//		}//	if (!wholeObject)//		return NULL;//	//	//Find the whole object for the cross BSpline//	wholeObject = NULL;//	for (int i = 0; i < wholeObjects.size(); i++)//		if (find(wholeObjects[i]->bsplines.begin(), wholeObjects[i]->bsplines.end(), intersection->GetOtherBsp(traverseBsp)) != wholeObjects[i]->bsplines.end())//		{//			wholeObject = wholeObjects[i];//			break;//		}//	if (!wholeObject)//		return NULL;		MyAssert(false);}*/BspBspIntersection* Drawing::FindOneBspBspInterCompanionTraverseBottom(BspBspIntersection* intersection, vector<BspCutIntersection*>* bspCutComps){	BSpline* originalCrossBsp = intersection->GetBsp1();	BSpline* traverseBsp = intersection->GetBsp2();	int occludedEdge = intersection->DetermineOccludedEdge();	MyAssert(occludedEdge == 3 || occludedEdge == 4);	bool forward;	if (occludedEdge == 3)		forward = false;	else forward = true;		MyAssert(traverseBsp->GetAllIntersectionsLegal());	MyAssert(originalCrossBsp->GetAllIntersectionsLegal());		//Get the curve and seg of the intersection on the traversal BSpline	int curve = intersection->GetCv2();	int seg = intersection->GetSg2();		int crossCurve = intersection->GetCv1();	int crossSeg = intersection->GetSg1();		//See if the traversal BSpline has a whole object	WholeObject* wholeObject = NULL;	for (int i = 0; i < wholeObjects.size(); i++)		if (find(wholeObjects[i]->bsplines.begin(), wholeObjects[i]->bsplines.end(), traverseBsp) != wholeObjects[i]->bsplines.end())		{			wholeObject = wholeObjects[i];			break;		}	if (!wholeObject)		return NULL;	WholeObject* wo1 = wholeObject;		//Find the whole object for the cross BSpline	wholeObject = NULL;	for (int i = 0; i < wholeObjects.size(); i++)		if (find(wholeObjects[i]->bsplines.begin(), wholeObjects[i]->bsplines.end(), originalCrossBsp) != wholeObjects[i]->bsplines.end())		{			wholeObject = wholeObjects[i];			break;		}	if (!wholeObject)		return NULL;	WholeObject* wo2 = wholeObject;		Rect r;	if (gDebug1)	{		FloatPoint intersectionLoc = intersection->GetLocation();		SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);		ForeColor(blackColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qr = 1;	}		//The propagation ends when the traversal crosses the original boundary at the same depth as at the starting intersection, with adjustments along the way	int targetCrossDepth = originalCrossBsp->GetSectionDepthBeforeIntersection(intersection, crossCurve, crossSeg);	//int originalTargetCrossDepth = targetCrossDepth;		//Loop until a companion is found	GenericIntersection* prevPropInter = intersection;	int counter = 0;	//DEBUG	while (true)	{		if (counter++ > traverseBsp->GetNumIntersections())	//еее Really, I think this should be an MyAssert that should never occur, but for now, just screw it			return NULL;				//Find the next intersection in the propagation around the traversal BSpline		GenericIntersection* propagatedIntersection;		if (forward)			propagatedIntersection = traverseBsp->FindNextIntersection((GenericIntersection*)prevPropInter, curve, seg);		else propagatedIntersection = traverseBsp->FindPrevIntersection((GenericIntersection*)prevPropInter, curve, seg);				if (gDebug1)		{			FloatPoint intersectionLoc = propagatedIntersection->GetLocation();			SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);			ForeColor(redColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qr = 1;		}				//Looped all the way around, should be impossible if things are legal		if (propagatedIntersection == intersection/* && targetCrossDepth == originalTargetCrossDepth*/)	//Probably a self intersection on an illegal curve (partial figure eight for example)		{			if (gDebug1)			{				FloatPoint intersectionLoc = propagatedIntersection->GetLocation();				ForeColor(whiteColor);				SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								intersectionLoc = intersection->GetLocation();				SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			}						return NULL;		}				//Find the curve and seg of the traversal bsp at the propagated intersection		bool traversalArrivedOnTop;		switch (propagatedIntersection->GetType())		{			case GenericIntersection::BSP_BSP:				BspBspIntersection* bspBspInter = (BspBspIntersection*)propagatedIntersection;								if (!bspBspInter->SelfIntersection())				{					if (bspBspInter->GetBsp1() == traverseBsp)					{						curve = bspBspInter->GetCv1();						seg = bspBspInter->GetSg1();						crossCurve = bspBspInter->GetCv2();						crossSeg = bspBspInter->GetSg2();						traversalArrivedOnTop = true;					}					else					{						MyAssert(bspBspInter->GetBsp2() == traverseBsp);						curve = bspBspInter->GetCv2();						seg = bspBspInter->GetSg2();						crossCurve = bspBspInter->GetCv1();						crossSeg = bspBspInter->GetSg1();						traversalArrivedOnTop = false;					}				}				else	//Self intersection				{					int curve1 = bspBspInter->GetCv1();					int curve2 = bspBspInter->GetCv2();					int seg1 = bspBspInter->GetSg1();					int seg2 = bspBspInter->GetSg2();										int curveSeg = curve * BSpline::sNumSegmentsPerCurve + seg;					int curveSeg1 = curve1 * BSpline::sNumSegmentsPerCurve + seg1;					int curveSeg2 = curve2 * BSpline::sNumSegmentsPerCurve + seg2;										//Take the curve/seg that is closer to and after the present curve/seg					if ((curveSeg1 > curveSeg && curveSeg2 > curveSeg) ||						(curveSeg1 < curveSeg && curveSeg2 < curveSeg))					{						if (forward)						{							if (curveSeg1 < curveSeg2)							{								curve = curve1;								seg = seg1;								crossCurve = curve2;								crossSeg = seg2;								traversalArrivedOnTop = true;							}							else							{								curve = curve2;								seg = seg2;								crossCurve = curve1;								crossSeg = seg1;								traversalArrivedOnTop = false;							}						}						else	//backward						{							if (curveSeg1 < curveSeg2)							{								curve = curve2;								seg = seg2;								crossCurve = curve1;								crossSeg = seg1;								traversalArrivedOnTop = false;							}							else							{								curve = curve1;								seg = seg1;								crossCurve = curve2;								crossSeg = seg2;								traversalArrivedOnTop = true;							}						}					}					if (curveSeg1 > curveSeg && curveSeg2 < curveSeg)					{						if (forward)						{							curve = curve1;							seg = seg1;							crossCurve = curve2;							crossSeg = seg2;							traversalArrivedOnTop = true;						}						else	//backward						{							curve = curve2;							seg = seg2;							crossCurve = curve1;							crossSeg = seg1;							traversalArrivedOnTop = false;						}					}					else if (curveSeg2 > curveSeg && curveSeg1 < curveSeg)					{						if (forward)						{							curve = curve2;							seg = seg2;							crossCurve = curve1;							crossSeg = seg1;							traversalArrivedOnTop = false;						}						else	//backward						{							curve = curve1;							seg = seg1;							crossCurve = curve2;							crossSeg = seg2;							traversalArrivedOnTop = true;						}					}					else if (curveSeg1 == curveSeg)					{						//The first method here makes more sense, but at some point I commented it out and used the second method instead.						//The second method seems to produce bugs in some situations.  I'm not sure why I ever used it.												//Method 1						curve = curve2;						seg = seg2;						crossCurve = curve1;						crossSeg = seg1;						traversalArrivedOnTop = false;						/*						//Method 2						BSpline* bsp = bspBspInter->GetBsp1();						if (bsp->FindPrevIntersection(bspBspInter, curve1, seg1) == prevPropInter || bsp->FindNextIntersection(bspBspInter, curve1, seg1) == prevPropInter)						{							curve = curve1;							seg = seg1;							crossCurve = curve2;							crossSeg = seg2;							traversalArrivedOnTop = true;						}						else if (bsp->FindPrevIntersection(bspBspInter, curve2, seg2) == prevPropInter || bsp->FindNextIntersection(bspBspInter, curve2, seg2) == prevPropInter)						{							curve = curve2;							seg = seg2;							crossCurve = curve1;							crossSeg = seg1;							traversalArrivedOnTop = false;						}						else MyAssert(false);						*/					}					else if (curveSeg2 == curveSeg)					{						//The first method here makes more sense, but at some point I commented it out and used the second method instead.						//The second method seems to produce bugs in some situations.  I'm not sure why I ever used it.												//Method 1						curve = curve1;						seg = seg1;						crossCurve = curve2;						crossSeg = seg2;						traversalArrivedOnTop = true;						/*						//Method 2						BSpline* bsp = bspBspInter->GetBsp1();						if (bsp->FindPrevIntersection(bspBspInter, curve1, seg1) == prevPropInter || bsp->FindNextIntersection(bspBspInter, curve1, seg1) == prevPropInter)						{							curve = curve1;							seg = seg1;							crossCurve = curve2;							crossSeg = seg2;							traversalArrivedOnTop = true;						}						else if (bsp->FindPrevIntersection(bspBspInter, curve2, seg2) == prevPropInter || bsp->FindNextIntersection(bspBspInter, curve2, seg2) == prevPropInter)						{							curve = curve2;							seg = seg2;							crossCurve = curve1;							crossSeg = seg1;							traversalArrivedOnTop = false;						}						else MyAssert(false);						*/					}				}				break;			case GenericIntersection::BSP_CUT:				MyAssert(((BspCutIntersection*)propagatedIntersection)->GetBsp() == traverseBsp);				curve = ((BspCutIntersection*)propagatedIntersection)->GetCv();				seg = ((BspCutIntersection*)propagatedIntersection)->GetSg();				crossCurve = -1;				crossSeg = -1;				traversalArrivedOnTop = ((BspCutIntersection*)propagatedIntersection)->GetBspOnTop();								if (bspCutComps && find(bspCutComps->begin(), bspCutComps->end(), (BspCutIntersection*)propagatedIntersection) == bspCutComps->end())				{					//While seeking the BspBsp companion, capture any BspCut companions along the way					BSpline* bsp = ((BspCutIntersection*)propagatedIntersection)->GetBsp();					BSplineToBSplineCut* cut = ((BspCutIntersection*)propagatedIntersection)->GetCut();					WholeObject* wo1a = FindWholeObjectForBSpline(bsp);					WholeObject* wo2a = FindWholeObjectForBSpline(cut->GetBsp1());					MyAssert(wo1a == wo1 || wo1a == wo2);	//The BspCut's bsp should definitely be in the right group					if (wo2a == wo1 || wo2a == wo2)					{						if (gDebug1)						{							FloatPoint intersectionLoc = intersection->GetLocation();							SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);							ForeColor(blueColor);							FrameOval(&r);														intersectionLoc = propagatedIntersection->GetLocation();							SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);							ForeColor(magentaColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int qr = 1;						}												bspCutComps->push_back((BspCutIntersection*)propagatedIntersection);					}				}				break;			case GenericIntersection::BSP_CUT_T:				MyAssert(((BspCutTIntersection*)propagatedIntersection)->GetBsp() == traverseBsp);				curve = ((BspCutTIntersection*)propagatedIntersection)->GetCv();				seg = ((BspCutTIntersection*)propagatedIntersection)->GetSg();				crossCurve = -2;				crossSeg = -2;				traversalArrivedOnTop = true;				break;			case GenericIntersection::CUT_CUT:				MyAssert(false);				break;		}				//Get the occluded edge at the propagated intersection		occludedEdge = propagatedIntersection->DetermineOccludedEdge();				//If the traversal bsp is on bottom, and the cross bsp or whole object matches the target, and the depth is right,		//and the occlusion is reflected back along the traversal, we're at the companion		int crossDepth = -999999;		if (propagatedIntersection->GetType() == GenericIntersection::BSP_BSP && !traversalArrivedOnTop)		{			BspBspIntersection* bspBspInter = (BspBspIntersection*)propagatedIntersection;						MyAssert((curve == bspBspInter->GetCv1() && seg == bspBspInter->GetSg1()) ||					(curve == bspBspInter->GetCv2() && seg == bspBspInter->GetSg2()));			MyAssert((crossCurve == bspBspInter->GetCv1() && crossSeg == bspBspInter->GetSg1()) ||					(crossCurve == bspBspInter->GetCv2() && crossSeg == bspBspInter->GetSg2()));						BSpline* crossBsp = bspBspInter->GetBsp1();			crossDepth = crossBsp->GetSectionDepthBeforeIntersection(propagatedIntersection, crossCurve, crossSeg);						if (!wholeObject && crossBsp == originalCrossBsp && crossDepth == targetCrossDepth)			{				if ((forward && occludedEdge == 3) || (!forward && occludedEdge == 4))				{					if (gDebug1)					{						FloatPoint intersectionLoc = propagatedIntersection->GetLocation();												ForeColor(redColor);						SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qr = 1;												ForeColor(whiteColor);						SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);						FrameOval(&r);						SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												intersectionLoc = intersection->GetLocation();						SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);					}										return bspBspInter;				}			}			else if (wholeObject && find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), crossBsp) != wholeObject->bsplines.end() && crossDepth == targetCrossDepth)			{				if ((forward && occludedEdge == 3) || (!forward && occludedEdge == 4))				{					if (gDebug1)					{						FloatPoint intersectionLoc = propagatedIntersection->GetLocation();												ForeColor(redColor);						SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qr = 1;												ForeColor(whiteColor);						SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);						FrameOval(&r);						SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												intersectionLoc = intersection->GetLocation();						SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);						FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);					}										return bspBspInter;				}			}		}				//Getting here means the propagated intersection wasn't the companion				//Alter the target depth		if (propagatedIntersection->GetType() == GenericIntersection::BSP_BSP && !traversalArrivedOnTop)		{			MyAssert(crossDepth != -999999);			if ((forward && occludedEdge == 3) || (!forward && occludedEdge == 4))	//Coming out from under an edge			{				//MyAssert(crossDepth != targetCrossDepth);	// Don't want this test, fails if cross isn't in group				if (crossDepth < targetCrossDepth)					targetCrossDepth--;			}			else if ((forward && occludedEdge == 4) || (!forward && occludedEdge == 3))	//Going under an edge			{				if (crossDepth <= targetCrossDepth)					targetCrossDepth++;			}		}				//Keep track of the intersection that was just propagated from		prevPropInter = propagatedIntersection;			if (gDebug1)		{			FloatPoint intersectionLoc = propagatedIntersection->GetLocation();			SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);			ForeColor(whiteColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}	}}BspBspIntersection* Drawing::FindOneBspBspInterCompanionTraverseTop(BspBspIntersection* intersection, vector<BspCutIntersection*>* bspCutComps){	BSpline* originalCrossBsp = intersection->GetBsp2();	BSpline* traverseBsp = intersection->GetBsp1();	int occludedEdge = intersection->DetermineOccludedEdge();	MyAssert(occludedEdge == 3 || occludedEdge == 4);	bool forward;	if (occludedEdge == 3)		forward = true;	else forward = false;		MyAssert(traverseBsp->GetAllIntersectionsLegal());	MyAssert(originalCrossBsp->GetAllIntersectionsLegal());		//Get the curve and seg of the intersection on the traversal BSpline	int curve = intersection->GetCv1();	int seg = intersection->GetSg1();		int crossCurve = intersection->GetCv2();	int crossSeg = intersection->GetSg2();		//See if the traversal BSpline has a whole object	WholeObject* wholeObject = NULL;	for (int i = 0; i < wholeObjects.size(); i++)		if (find(wholeObjects[i]->bsplines.begin(), wholeObjects[i]->bsplines.end(), traverseBsp) != wholeObjects[i]->bsplines.end())		{			wholeObject = wholeObjects[i];			break;		}	if (!wholeObject)		return NULL;	WholeObject* wo1 = wholeObject;		//Find the whole object for the cross BSpline	wholeObject = NULL;	for (int i = 0; i < wholeObjects.size(); i++)		if (find(wholeObjects[i]->bsplines.begin(), wholeObjects[i]->bsplines.end(), originalCrossBsp) != wholeObjects[i]->bsplines.end())		{			wholeObject = wholeObjects[i];			break;		}	if (!wholeObject)		return NULL;	WholeObject* wo2 = wholeObject;		Rect r;	if (gDebug1)	{		FloatPoint intersectionLoc = intersection->GetLocation();		SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);		ForeColor(blueColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qr = 1;	}		//The propagation ends when the traversal crosses the original boundary at the same depth as at the starting intersection, with adjustments along the way	int targetCrossDepth;	if (forward)		targetCrossDepth = (occludedEdge == 3) ? originalCrossBsp->GetSectionDepthAfterIntersection(intersection, crossCurve, crossSeg) :											originalCrossBsp->GetSectionDepthBeforeIntersection(intersection, crossCurve, crossSeg);	else targetCrossDepth = (occludedEdge == 4) ? originalCrossBsp->GetSectionDepthAfterIntersection(intersection, crossCurve, crossSeg) :											originalCrossBsp->GetSectionDepthBeforeIntersection(intersection, crossCurve, crossSeg);	//int originalTargetCrossDepth = targetCrossDepth;		//Loop until a companion is found	GenericIntersection* prevPropInter = intersection;	int counter = 0;	//DEBUG	while (true)	{		if (counter++ > traverseBsp->GetNumIntersections())	//еее Really, I think this should be an MyAssert that should never occur, but for now, just screw it			return NULL;				//Find the next intersection in the propagation around the traversal BSpline		GenericIntersection* propagatedIntersection;		if (forward)			propagatedIntersection = traverseBsp->FindNextIntersection((GenericIntersection*)prevPropInter, curve, seg);		else propagatedIntersection = traverseBsp->FindPrevIntersection((GenericIntersection*)prevPropInter, curve, seg);				if (gDebug1)		{			FloatPoint intersectionLoc = propagatedIntersection->GetLocation();			SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);			ForeColor(greenColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qr = 1;		}				//Looped all the way around, should be impossible if things are legal		if (propagatedIntersection == intersection/* && targetCrossDepth == originalTargetCrossDepth*/)	//Probably a self intersection on an illegal curve (partial figure eight for example)		{			if (gDebug1)			{				FloatPoint intersectionLoc = propagatedIntersection->GetLocation();				ForeColor(whiteColor);				SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								intersectionLoc = intersection->GetLocation();				SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			}						return NULL;		}				//Find the curve and seg of the traversal bsp at the propagated intersection		bool traversalArrivedOnTop;		switch (propagatedIntersection->GetType())		{			case GenericIntersection::BSP_BSP:				BspBspIntersection* bspBspInter = (BspBspIntersection*)propagatedIntersection;								if (!bspBspInter->SelfIntersection())				{					if (bspBspInter->GetBsp1() == traverseBsp)					{						curve = bspBspInter->GetCv1();						seg = bspBspInter->GetSg1();						crossCurve = bspBspInter->GetCv2();						crossSeg = bspBspInter->GetSg2();						traversalArrivedOnTop = true;					}					else					{						MyAssert(bspBspInter->GetBsp2() == traverseBsp);						curve = bspBspInter->GetCv2();						seg = bspBspInter->GetSg2();						crossCurve = bspBspInter->GetCv1();						crossSeg = bspBspInter->GetSg1();						traversalArrivedOnTop = false;					}				}				else	//Self intersection				{					int curve1 = bspBspInter->GetCv1();					int curve2 = bspBspInter->GetCv2();					int seg1 = bspBspInter->GetSg1();					int seg2 = bspBspInter->GetSg2();										int curveSeg = curve * BSpline::sNumSegmentsPerCurve + seg;					int curveSeg1 = curve1 * BSpline::sNumSegmentsPerCurve + seg1;					int curveSeg2 = curve2 * BSpline::sNumSegmentsPerCurve + seg2;										//Take the curve/seg that is closer to and after the present curve/seg					if ((curveSeg1 > curveSeg && curveSeg2 > curveSeg) ||						(curveSeg1 < curveSeg && curveSeg2 < curveSeg))					{						if (forward)						{							if (curveSeg1 < curveSeg2)							{								curve = curve1;								seg = seg1;								crossCurve = curve2;								crossSeg = seg2;								traversalArrivedOnTop = true;							}							else							{								curve = curve2;								seg = seg2;								crossCurve = curve1;								crossSeg = seg1;								traversalArrivedOnTop = false;							}						}						else	//backward						{							if (curveSeg1 < curveSeg2)							{								curve = curve2;								seg = seg2;								crossCurve = curve1;								crossSeg = seg1;								traversalArrivedOnTop = false;							}							else							{								curve = curve1;								seg = seg1;								crossCurve = curve2;								crossSeg = seg2;								traversalArrivedOnTop = true;							}						}					}					if (curveSeg1 > curveSeg && curveSeg2 < curveSeg)					{						if (forward)						{							curve = curve1;							seg = seg1;							crossCurve = curve2;							crossSeg = seg2;							traversalArrivedOnTop = true;						}						else	//backward						{							curve = curve2;							seg = seg2;							crossCurve = curve1;							crossSeg = seg1;							traversalArrivedOnTop = false;						}					}					else if (curveSeg2 > curveSeg && curveSeg1 < curveSeg)					{						if (forward)						{							curve = curve2;							seg = seg2;							crossCurve = curve1;							crossSeg = seg1;							traversalArrivedOnTop = false;						}						else	//backward						{							curve = curve1;							seg = seg1;							crossCurve = curve2;							crossSeg = seg2;							traversalArrivedOnTop = true;						}					}					else if (curveSeg1 == curveSeg)					{						//The first method here makes more sense, but at some point I commented it out and used the second method instead.						//The second method seems to produce bugs in some situations.  I'm not sure why I ever used it.												//Method 1						curve = curve2;						seg = seg2;						crossCurve = curve1;						crossSeg = seg1;						traversalArrivedOnTop = false;						/*						//Method 2						BSpline* bsp = bspBspInter->GetBsp1();						if (bsp->FindPrevIntersection(bspBspInter, curve1, seg1) == prevPropInter || bsp->FindNextIntersection(bspBspInter, curve1, seg1) == prevPropInter)						{							curve = curve1;							seg = seg1;							crossCurve = curve2;							crossSeg = seg2;							traversalArrivedOnTop = true;						}						else if (bsp->FindPrevIntersection(bspBspInter, curve2, seg2) == prevPropInter || bsp->FindNextIntersection(bspBspInter, curve2, seg2) == prevPropInter)						{							curve = curve2;							seg = seg2;							crossCurve = curve1;							crossSeg = seg1;							traversalArrivedOnTop = false;						}						else MyAssert(false);						*/					}					else if (curveSeg2 == curveSeg)					{						//The first method here makes more sense, but at some point I commented it out and used the second method instead.						//The second method seems to produce bugs in some situations.  I'm not sure why I ever used it.												//Method 1						curve = curve1;						seg = seg1;						crossCurve = curve2;						crossSeg = seg2;						traversalArrivedOnTop = true;						/*						//Method 2						BSpline* bsp = bspBspInter->GetBsp1();						if (bsp->FindPrevIntersection(bspBspInter, curve1, seg1) == prevPropInter || bsp->FindNextIntersection(bspBspInter, curve1, seg1) == prevPropInter)						{							curve = curve1;							seg = seg1;							crossCurve = curve2;							crossSeg = seg2;							traversalArrivedOnTop = true;						}						else if (bsp->FindPrevIntersection(bspBspInter, curve2, seg2) == prevPropInter || bsp->FindNextIntersection(bspBspInter, curve2, seg2) == prevPropInter)						{							curve = curve2;							seg = seg2;							crossCurve = curve1;							crossSeg = seg1;							traversalArrivedOnTop = false;						}						else MyAssert(false);						*/					}				}				break;			case GenericIntersection::BSP_CUT:				MyAssert(((BspCutIntersection*)propagatedIntersection)->GetBsp() == traverseBsp);				curve = ((BspCutIntersection*)propagatedIntersection)->GetCv();				seg = ((BspCutIntersection*)propagatedIntersection)->GetSg();				crossCurve = -1;				crossSeg = -1;				traversalArrivedOnTop = ((BspCutIntersection*)propagatedIntersection)->GetBspOnTop();								if (bspCutComps && find(bspCutComps->begin(), bspCutComps->end(), (BspCutIntersection*)propagatedIntersection) == bspCutComps->end())				{					//While seeking the BspBsp companion, capture any BspCut companions along the way					BSpline* bsp = ((BspCutIntersection*)propagatedIntersection)->GetBsp();					BSplineToBSplineCut* cut = ((BspCutIntersection*)propagatedIntersection)->GetCut();					WholeObject* wo1a = FindWholeObjectForBSpline(bsp);					WholeObject* wo2a = FindWholeObjectForBSpline(cut->GetBsp1());					MyAssert(wo1a == wo1 || wo1a == wo2);	//The BspCut's bsp should definitely be in the right group					if (wo2a == wo1 || wo2a == wo2)					{						if (gDebug1)						{							FloatPoint intersectionLoc = intersection->GetLocation();							SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);							ForeColor(blueColor);							FrameOval(&r);														intersectionLoc = propagatedIntersection->GetLocation();							SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);							ForeColor(magentaColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int qr = 1;						}												bspCutComps->push_back((BspCutIntersection*)propagatedIntersection);					}				}				break;			case GenericIntersection::BSP_CUT_T:				MyAssert(((BspCutTIntersection*)propagatedIntersection)->GetBsp() == traverseBsp);				curve = ((BspCutTIntersection*)propagatedIntersection)->GetCv();				seg = ((BspCutTIntersection*)propagatedIntersection)->GetSg();				crossCurve = -2;				crossSeg = -2;				traversalArrivedOnTop = true;				break;			case GenericIntersection::CUT_CUT:				MyAssert(false);				break;		}				//Get the occluded edge at the propagated intersection		occludedEdge = propagatedIntersection->DetermineOccludedEdge();				//If the traversal bsp is on top, and the cross bsp or whole object matches the target, and the depth is right,		//and the occlusion is reflected back along the traversal, we're at the companion		int crossDepth = -999999;		if (propagatedIntersection->GetType() == GenericIntersection::BSP_BSP)		{			BspBspIntersection* bspBspInter = (BspBspIntersection*)propagatedIntersection;						MyAssert((curve == bspBspInter->GetCv1() && seg == bspBspInter->GetSg1()) ||					(curve == bspBspInter->GetCv2() && seg == bspBspInter->GetSg2()));			MyAssert((crossCurve == bspBspInter->GetCv1() && crossSeg == bspBspInter->GetSg1()) ||					(crossCurve == bspBspInter->GetCv2() && crossSeg == bspBspInter->GetSg2()));						BSpline* crossBsp = traversalArrivedOnTop ? bspBspInter->GetBsp2() : bspBspInter->GetBsp1();			if (traversalArrivedOnTop)			{				if (forward)					crossDepth = (occludedEdge == 3) ? crossBsp->GetSectionDepthAfterIntersection(propagatedIntersection, crossCurve, crossSeg) :														crossBsp->GetSectionDepthBeforeIntersection(propagatedIntersection, crossCurve, crossSeg);				else crossDepth = (occludedEdge == 4) ? crossBsp->GetSectionDepthAfterIntersection(propagatedIntersection, crossCurve, crossSeg) :														crossBsp->GetSectionDepthBeforeIntersection(propagatedIntersection, crossCurve, crossSeg);								if (!wholeObject && crossBsp == originalCrossBsp && crossDepth == targetCrossDepth)				{					if ((forward && occludedEdge == 4) || (!forward && occludedEdge == 3))					{						if (gDebug1)						{							FloatPoint intersectionLoc = propagatedIntersection->GetLocation();														ForeColor(greenColor);							SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int qr = 1;														ForeColor(whiteColor);							SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);							FrameOval(&r);							SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														intersectionLoc = intersection->GetLocation();							SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						}												return bspBspInter;					}				}				else if (wholeObject && find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), crossBsp) != wholeObject->bsplines.end() && crossDepth == targetCrossDepth)				{					if ((forward && occludedEdge == 4) || (!forward && occludedEdge == 3))					{						if (gDebug1)						{							FloatPoint intersectionLoc = propagatedIntersection->GetLocation();														ForeColor(greenColor);							SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int qr = 1;														ForeColor(whiteColor);							SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);							FrameOval(&r);							SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														intersectionLoc = intersection->GetLocation();							SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						}												return bspBspInter;					}				}			}			else	//traverse on bottom			{				MyAssert(crossBsp->GetSectionDepthBeforeIntersection(propagatedIntersection, crossCurve, crossSeg) ==						crossBsp->GetSectionDepthAfterIntersection(propagatedIntersection, crossCurve, crossSeg));				crossDepth = crossBsp->GetSectionDepthBeforeIntersection(propagatedIntersection, crossCurve, crossSeg);			}		}				//Getting here means the propagated intersection wasn't the companion				//Alter the target depth		if (propagatedIntersection->GetType() == GenericIntersection::BSP_BSP)		{			MyAssert(crossDepth != -999999);						if (!traversalArrivedOnTop)			{				if ((forward && occludedEdge == 3) || (!forward && occludedEdge == 4))	//Coming out from under an edge				{					if (crossDepth < targetCrossDepth)						targetCrossDepth--;				}				else if ((forward && occludedEdge == 4) || (!forward && occludedEdge == 3))	//Going under an edge				{					if (crossDepth <= targetCrossDepth)						targetCrossDepth++;				}			}			else	//traversal on top			{				if ((forward && occludedEdge == 4) || (!forward && occludedEdge == 3))	//Going over an exit edge				{					if (crossDepth <= targetCrossDepth)						targetCrossDepth--;				}				else if ((forward && occludedEdge == 3) || (!forward && occludedEdge == 4))	//Going over an entrance edge				{					if (crossDepth <= targetCrossDepth)						targetCrossDepth++;				}			}		}				//Keep track of the intersection that was just propagated from		prevPropInter = propagatedIntersection;			if (gDebug1)		{			FloatPoint intersectionLoc = propagatedIntersection->GetLocation();			SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);			ForeColor(whiteColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}	}}BspCutIntersection* Drawing::FindBspCutInterCompanion(BspCutIntersection* intersection){	BSpline* bsp = intersection->GetBsp();	BSplineToBSplineCut* cut = intersection->GetCut();		int occludedEdge = intersection->DetermineOccludedEdgeIgnoreTopBottom();	MyAssert(occludedEdge == 1 || occludedEdge == 2);	bool forward = (occludedEdge == 2);		//Get the curve and seg of the intersection on the traversing BSpline	int curve = intersection->GetCv();	int seg = intersection->GetSg();		//See if the traversal Cut has a whole object	BSpline* cutBsp = cut->GetBsp1();	WholeObject* wholeObject = NULL;	for (int i = 0; i < wholeObjects.size(); i++)		if (find(wholeObjects[i]->bsplines.begin(), wholeObjects[i]->bsplines.end(), cutBsp) != wholeObjects[i]->bsplines.end())		{			wholeObject = wholeObjects[i];			break;		}	if (!wholeObject)		return NULL;		//Find the whole object for the cross BSpline	wholeObject = NULL;	for (int i = 0; i < wholeObjects.size(); i++)		if (find(wholeObjects[i]->bsplines.begin(), wholeObjects[i]->bsplines.end(), bsp) != wholeObjects[i]->bsplines.end())		{			wholeObject = wholeObjects[i];			break;		}	if (!wholeObject)		return NULL;		Rect r;	if (gDebug1)	{		FloatPoint intersectionLoc = intersection->GetLocation();		SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);		ForeColor(blackColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qrBspCut = 1;	}		//Loop until a companion is found	GenericIntersection* prevPropInter = intersection;	int counter = 0;	//DEBUG	int layerCounter = 0;	while (true)	{		MyAssert(counter++ < 100);				//Find the next intersection in the propagation along the traversal Cut		GenericIntersection* propagatedIntersection;		if (forward)			propagatedIntersection = cut->FindNextIntersection((GenericIntersection*)prevPropInter);		else propagatedIntersection = cut->FindPrevIntersection((GenericIntersection*)prevPropInter);			if (gDebug1)		{			FloatPoint intersectionLoc = propagatedIntersection->GetLocation();			SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);			ForeColor(redColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qrBspCut = 1;		}				//If the propagation reaches the end of the cut, there is no companion		if (propagatedIntersection->GetType() == GenericIntersection::BSP_CUT_T)		{			if (gDebug1)			{				FloatPoint intersectionLoc = propagatedIntersection->GetLocation();				ForeColor(whiteColor);				SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								intersectionLoc = intersection->GetLocation();				SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			}						return NULL;		}				//Get the occluded edge at the propagated intersection		int occludedEdge = propagatedIntersection->DetermineOccludedEdge();				//If the layer counter is zero and the next intersection is the right type, it might be the companion		if (layerCounter == 0 && propagatedIntersection->GetType() == GenericIntersection::BSP_CUT)		{			BspCutIntersection* bspCutInter = (BspCutIntersection*)propagatedIntersection;			BSpline* bspProp = bspCutInter->GetBsp();			BSplineToBSplineCut* cutProp = bspCutInter->GetCut();						//If the occlusion reflects back along the traversal, the propagated intersection is the companion, so quit			if (forward)			{				if ((!wholeObject || find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), bspCutInter->GetBsp()) != wholeObject->bsplines.end()) &&					bspCutInter->DetermineOccludedEdgeIgnoreTopBottom() == 1)					return bspCutInter;			}			else	//backward			{				if ((!wholeObject || find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), bspCutInter->GetBsp()) != wholeObject->bsplines.end()) &&					bspCutInter->DetermineOccludedEdgeIgnoreTopBottom() == 2)					return bspCutInter;			}		}				//Getting here means the propagated intersection wasn't the companion				//Alter the layer counter		if (propagatedIntersection->GetType() == GenericIntersection::BSP_CUT)		{			BspCutIntersection* bspCutInter = (BspCutIntersection*)propagatedIntersection;			BSpline* bspProp = bspCutInter->GetBsp();			BSplineToBSplineCut* cutProp = bspCutInter->GetCut();						if (forward)			{				if (occludedEdge == 1)					layerCounter--;				else if (occludedEdge == 2)					layerCounter++;			}			else	//backward			{				if (occludedEdge == 1)					layerCounter++;				else if (occludedEdge == 2)					layerCounter--;			}		}				//The propagated intersection isn't the companion, so go to the top of the loop and propagate to the next intersection				//Keep track of the intersection that was just propagated from		prevPropInter = propagatedIntersection;			if (gDebug1)		{			FloatPoint intersectionLoc = propagatedIntersection->GetLocation();			SetRect(&r, intersectionLoc.h - 5, intersectionLoc.v - 5, intersectionLoc.h + 5, intersectionLoc.v + 5);			ForeColor(whiteColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}	}}#pragma mark -void Drawing::FindInterCompSetsForAllInters2(){	SetPort(GetWindowPort(gMainWindow->GetWindow()));	PenSize(2, 2);	Rect r;		DeleteAllCompSets();	for (int i = 0; i < intersections.size(); i++)	{		GenericIntersection* gi = intersections[i];		if (gDebug1)		{			FloatPoint intersectionLoc = intersections[i]->GetLocation();			SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);			ForeColor(yellowColor);			FrameRect(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qs = 1;		}				if (intersections[i]->GetType() == GenericIntersection::BSP_BSP)		{			//Skip intersections that are already in a companion set (might have been added to a companion set in an earlier iteration of this loop)			bool alreadyCompanioned = false;			for (int j = 0; j < interCompanionSets.size(); j++)			{				vector<GenericIntersection*>* compSet = interCompanionSets[j];				if (find(interCompanionSets[j]->begin(), interCompanionSets[j]->end(), intersections[i]) != interCompanionSets[j]->end())				{					alreadyCompanioned = true;					break;				}			}			if (alreadyCompanioned)			{				if (gDebug1)				{					FloatPoint intersectionLoc = intersections[i]->GetLocation();					SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);					ForeColor(blackColor);					FrameRect(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qs = 1;										ForeColor(whiteColor);					FrameRect(&r);				}				continue;			}						if (gDebug1)			{				FloatPoint intersectionLoc = intersections[i]->GetLocation();				SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);				ForeColor(redColor);				FrameRect(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qs = 1;			}						BspBspIntersection* bspBspInter = (BspBspIntersection*)intersections[i];			vector<BspCutIntersection*> bspCutComps;			vector<BspBspIntersection*> accumCompSet;			accumCompSet.push_back(bspBspInter);			vector<GenericIntersection*> visitedInters;			visitedInters.push_back(bspBspInter);			int occlusionCount = 0;			if (FindOneBspBspInterCompanion(bspBspInter, true, occlusionCount, &bspCutComps, bspBspInter, accumCompSet, visitedInters))			{				MyAssert(accumCompSet.size() % 2 == 0);								//No intersection should appear in multiple companion sets				for (int j = 0; j < interCompanionSets.size(); j++)					for (int k = 0; k < accumCompSet.size(); k++)						MyAssert(find(interCompanionSets[j]->begin(), interCompanionSets[j]->end(), accumCompSet[k]) == interCompanionSets[j]->end());								vector<GenericIntersection*>* interCompanionSet = new vector<GenericIntersection*>;				for (int j = 0; j < accumCompSet.size(); j++)					interCompanionSet->push_back(accumCompSet[j]);				for (int j = 0; j < bspCutComps.size(); j++)					interCompanionSet->push_back(bspCutComps[j]);				interCompanionSets.push_back(interCompanionSet);								if (gDebug1)				{					ForeColor(redColor);					for (int j = 0; j < interCompanionSet->size(); j++)					{						FloatPoint loc = (*interCompanionSet)[j]->GetLocation();						SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);						FrameOval(&r);					}					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qs = 1;										ForeColor(whiteColor);					for (int j = 0; j < interCompanionSet->size(); j++)					{						FloatPoint loc = (*interCompanionSet)[j]->GetLocation();						SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);						FrameOval(&r);					}					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				}			}		}				if (gDebug1)		{			FloatPoint intersectionLoc = intersections[i]->GetLocation();			SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);			ForeColor(whiteColor);			FrameRect(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}	}		if (gDebug1)	{		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		gMainWindow->DrawGrid();				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);				for (int i = 0; i < interCompanionSets.size(); i++)			if (interCompanionSets[i]->size() > 0)			{				switch (i % 6)				{					case 0:	ForeColor(redColor);	break;					case 1:	ForeColor(greenColor);	break;					case 2:	ForeColor(blueColor);	break;					case 3:	ForeColor(magentaColor);	break;					case 4:	ForeColor(cyanColor);	break;					case 5:	ForeColor(blackColor);	break;				}								for (int j = 0; j < interCompanionSets[i]->size(); j++)				{					FloatPoint loc = (*interCompanionSets[i])[j]->GetLocation();					SetRect(&r, loc.h - 5, loc.v - 5, loc.h + 5, loc.v + 5);					PaintOval(&r);				}			}					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		int qs = 1;				ForeColor(whiteColor);		for (int i = 0; i < interCompanionSets.size(); i++)			if (interCompanionSets[i]->size() > 0)			{				for (int j = 0; j < interCompanionSets[i]->size(); j++)				{					FloatPoint loc = (*interCompanionSets[i])[j]->GetLocation();					SetRect(&r, loc.h - 5, loc.v - 5, loc.h + 5, loc.v + 5);					PaintOval(&r);				}			}				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		PenSize(1, 1);}//return true if a legal companion set was successfully found (the traversal came back to the firstInter along its other potentially occluded segment and the accumulated companion set is even in size)bool Drawing::FindOneBspBspInterCompanion(BspBspIntersection* intersection, bool traverseFromTop, int occlusionCount, vector<BspCutIntersection*>* bspCutComps, BspBspIntersection* firstInter, vector<BspBspIntersection*>& accumCompSet, vector<GenericIntersection*> visitedInters){	BSpline* originalCrossBsp = traverseFromTop ? intersection->GetBsp2() : intersection->GetBsp1();	BSpline* traverseBsp = traverseFromTop ? intersection->GetBsp1() : intersection->GetBsp2();	int occludedEdge = intersection->DetermineOccludedEdge();	MyAssert(occludedEdge == 3 || occludedEdge == 4);	bool forward;	if (occludedEdge == 3)		forward = traverseFromTop ? true : false;	else forward = traverseFromTop ? false : true;		MyAssert(traverseBsp->GetAllIntersectionsLegal());	MyAssert(originalCrossBsp->GetAllIntersectionsLegal());		//Get the curve and seg of the intersection on the traversal BSpline	int curve = traverseFromTop ? intersection->GetCv1() :  intersection->GetCv2();	int seg = traverseFromTop ? intersection->GetSg1() :  intersection->GetSg2();		int crossCurve = traverseFromTop ? intersection->GetCv2() :  intersection->GetCv1();	int crossSeg = traverseFromTop ? intersection->GetSg2() :  intersection->GetSg1();		//See if the traversal BSpline has a whole object	WholeObject* wholeObject = NULL;	for (int i = 0; i < wholeObjects.size(); i++)		if (find(wholeObjects[i]->bsplines.begin(), wholeObjects[i]->bsplines.end(), traverseBsp) != wholeObjects[i]->bsplines.end())		{			wholeObject = wholeObjects[i];			break;		}	if (!wholeObject)		return false;	WholeObject* wo1 = wholeObject;		//Find the whole object for the cross BSpline	wholeObject = NULL;	for (int i = 0; i < wholeObjects.size(); i++)		if (find(wholeObjects[i]->bsplines.begin(), wholeObjects[i]->bsplines.end(), originalCrossBsp) != wholeObjects[i]->bsplines.end())		{			wholeObject = wholeObjects[i];			break;		}	if (!wholeObject)		return false;	WholeObject* wo2 = wholeObject;		Rect r;	if (gDebug1)	{		FloatPoint intersectionLoc = intersection->GetLocation();		SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);		ForeColor(yellowColor);		FrameOval(&r);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qs = 1;	}		vector<BspCutIntersection*> bspCutIntersAddedAlongThisTraversal;		//Loop until a companion is found	GenericIntersection* prevPropInter = intersection;	bool prevTraversalArrivedOnTop = traverseFromTop;	int counter = 0;	//DEBUG	while (true)	{		if (counter++ > traverseBsp->GetNumIntersections())	//еее Really, I think this should be an MyAssert that should never occur, but for now, just screw it			return false;				//Find the next intersection in the propagation around the traversal BSpline		GenericIntersection* propagatedIntersection;		if (forward)			propagatedIntersection = traverseBsp->FindNextIntersection((GenericIntersection*)prevPropInter, curve, seg);		else propagatedIntersection = traverseBsp->FindPrevIntersection((GenericIntersection*)prevPropInter, curve, seg);				if (gDebug1)		{			FloatPoint intersectionLoc = propagatedIntersection->GetLocation();			SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);			ForeColor(cyanColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qs = 1;		}				//Traversal of the border of the shared superregion can't intersect itself (Jordon curve).		//However, we can't definitely reject the first inter yet, so skip it at this point, it will be handled below.		/*		if (propagatedIntersection != firstInter && find(visitedInters.begin(), visitedInters.end(), propagatedIntersection) != visitedInters.end())		{			if (gDebug1)			{				FloatPoint intersectionLoc = propagatedIntersection->GetLocation();				SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);				ForeColor(blackColor);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qs = 1;								ForeColor(whiteColor);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			}			return false;		}		visitedInters.push_back(propagatedIntersection);	//If looped around to the firstInter, it will now occur on this list twice		*/		//Looped all the way around, should be impossible if things are legal		if (propagatedIntersection == intersection/* && targetCrossDepth == originalTargetCrossDepth*/)	//Probably a self intersection on an illegal curve (partial figure eight for example)		{			if (gDebug1)			{				FloatPoint intersectionLoc = propagatedIntersection->GetLocation();				ForeColor(whiteColor);				SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								intersectionLoc = intersection->GetLocation();				SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			}			return false;		}				//Find the curve and seg of the traversal bsp at the propagated intersection		bool traversalArrivedOnTop;		switch (propagatedIntersection->GetType())		{			case GenericIntersection::BSP_BSP:				BspBspIntersection* bspBspInter = (BspBspIntersection*)propagatedIntersection;								if (!bspBspInter->SelfIntersection())				{					if (bspBspInter->GetBsp1() == traverseBsp)					{						curve = bspBspInter->GetCv1();						seg = bspBspInter->GetSg1();						crossCurve = bspBspInter->GetCv2();						crossSeg = bspBspInter->GetSg2();						traversalArrivedOnTop = true;					}					else					{						MyAssert(bspBspInter->GetBsp2() == traverseBsp);						curve = bspBspInter->GetCv2();						seg = bspBspInter->GetSg2();						crossCurve = bspBspInter->GetCv1();						crossSeg = bspBspInter->GetSg1();						traversalArrivedOnTop = false;					}				}				else	//Self intersection				{					int curve1 = bspBspInter->GetCv1();					int curve2 = bspBspInter->GetCv2();					int seg1 = bspBspInter->GetSg1();					int seg2 = bspBspInter->GetSg2();										int curveSeg = curve * BSpline::sNumSegmentsPerCurve + seg;					int curveSeg1 = curve1 * BSpline::sNumSegmentsPerCurve + seg1;					int curveSeg2 = curve2 * BSpline::sNumSegmentsPerCurve + seg2;										//Take the curve/seg that is closer to and after the present curve/seg					if ((curveSeg1 > curveSeg && curveSeg2 > curveSeg) ||						(curveSeg1 < curveSeg && curveSeg2 < curveSeg))					{						if (forward)						{							if (curveSeg1 < curveSeg2)							{								curve = curve1;								seg = seg1;								crossCurve = curve2;								crossSeg = seg2;								traversalArrivedOnTop = true;							}							else							{								curve = curve2;								seg = seg2;								crossCurve = curve1;								crossSeg = seg1;								traversalArrivedOnTop = false;							}						}						else	//backward						{							if (curveSeg1 < curveSeg2)							{								curve = curve2;								seg = seg2;								crossCurve = curve1;								crossSeg = seg1;								traversalArrivedOnTop = false;							}							else							{								curve = curve1;								seg = seg1;								crossCurve = curve2;								crossSeg = seg2;								traversalArrivedOnTop = true;							}						}					}					if (curveSeg1 > curveSeg && curveSeg2 < curveSeg)					{						if (forward)						{							curve = curve1;							seg = seg1;							crossCurve = curve2;							crossSeg = seg2;							traversalArrivedOnTop = true;						}						else	//backward						{							curve = curve2;							seg = seg2;							crossCurve = curve1;							crossSeg = seg1;							traversalArrivedOnTop = false;						}					}					else if (curveSeg2 > curveSeg && curveSeg1 < curveSeg)					{						if (forward)						{							curve = curve2;							seg = seg2;							crossCurve = curve1;							crossSeg = seg1;							traversalArrivedOnTop = false;						}						else	//backward						{							curve = curve1;							seg = seg1;							crossCurve = curve2;							crossSeg = seg2;							traversalArrivedOnTop = true;						}					}					else if (curveSeg1 == curveSeg)					{						//The first method here makes more sense, but at some point I commented it out and used the second method instead.						//The second method seems to produce bugs in some situations.  I'm not sure why I ever used it.												//Method 1						curve = curve2;						seg = seg2;						crossCurve = curve1;						crossSeg = seg1;						traversalArrivedOnTop = false;						/*						//Method 2						BSpline* bsp = bspBspInter->GetBsp1();						if (bsp->FindPrevIntersection(bspBspInter, curve1, seg1) == prevPropInter || bsp->FindNextIntersection(bspBspInter, curve1, seg1) == prevPropInter)						{							curve = curve1;							seg = seg1;							crossCurve = curve2;							crossSeg = seg2;							traversalArrivedOnTop = true;						}						else if (bsp->FindPrevIntersection(bspBspInter, curve2, seg2) == prevPropInter || bsp->FindNextIntersection(bspBspInter, curve2, seg2) == prevPropInter)						{							curve = curve2;							seg = seg2;							crossCurve = curve1;							crossSeg = seg1;							traversalArrivedOnTop = false;						}						else MyAssert(false);						*/					}					else if (curveSeg2 == curveSeg)					{						//The first method here makes more sense, but at some point I commented it out and used the second method instead.						//The second method seems to produce bugs in some situations.  I'm not sure why I ever used it.												//Method 1						curve = curve1;						seg = seg1;						crossCurve = curve2;						crossSeg = seg2;						traversalArrivedOnTop = true;						/*						//Method 2						BSpline* bsp = bspBspInter->GetBsp1();						if (bsp->FindPrevIntersection(bspBspInter, curve1, seg1) == prevPropInter || bsp->FindNextIntersection(bspBspInter, curve1, seg1) == prevPropInter)						{							curve = curve1;							seg = seg1;							crossCurve = curve2;							crossSeg = seg2;							traversalArrivedOnTop = true;						}						else if (bsp->FindPrevIntersection(bspBspInter, curve2, seg2) == prevPropInter || bsp->FindNextIntersection(bspBspInter, curve2, seg2) == prevPropInter)						{							curve = curve2;							seg = seg2;							crossCurve = curve1;							crossSeg = seg1;							traversalArrivedOnTop = false;						}						else MyAssert(false);						*/					}				}				break;			case GenericIntersection::BSP_CUT:				MyAssert(((BspCutIntersection*)propagatedIntersection)->GetBsp() == traverseBsp);				curve = ((BspCutIntersection*)propagatedIntersection)->GetCv();				seg = ((BspCutIntersection*)propagatedIntersection)->GetSg();				crossCurve = -1;				crossSeg = -1;				traversalArrivedOnTop = ((BspCutIntersection*)propagatedIntersection)->GetBspOnTop();								if (bspCutComps && find(bspCutComps->begin(), bspCutComps->end(), (BspCutIntersection*)propagatedIntersection) == bspCutComps->end())				{					//While seeking the BspBsp companion, capture any BspCut companions along the way					BSpline* bsp = ((BspCutIntersection*)propagatedIntersection)->GetBsp();					BSplineToBSplineCut* cut = ((BspCutIntersection*)propagatedIntersection)->GetCut();					WholeObject* wo1a = FindWholeObjectForBSpline(bsp);					WholeObject* wo2a = FindWholeObjectForBSpline(cut->GetBsp1());					MyAssert(wo1a == wo1 || wo1a == wo2);	//The BspCut's bsp should definitely be in the right group					if (wo2a == wo1 || wo2a == wo2)					{						if (gDebug1)						{							FloatPoint intersectionLoc = intersection->GetLocation();							SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);							ForeColor(blueColor);							FrameOval(&r);														intersectionLoc = propagatedIntersection->GetLocation();							SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);							ForeColor(magentaColor);							FrameOval(&r);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int qs = 1;						}												bspCutComps->push_back((BspCutIntersection*)propagatedIntersection);						bspCutIntersAddedAlongThisTraversal.push_back((BspCutIntersection*)propagatedIntersection);					}				}				break;			case GenericIntersection::BSP_CUT_T:				MyAssert(((BspCutTIntersection*)propagatedIntersection)->GetBsp() == traverseBsp);				curve = ((BspCutTIntersection*)propagatedIntersection)->GetCv();				seg = ((BspCutTIntersection*)propagatedIntersection)->GetSg();				crossCurve = -2;				crossSeg = -2;				traversalArrivedOnTop = true;				break;			case GenericIntersection::CUT_CUT:				MyAssert(false);				break;		}				//Get the occluded edge at the propagated intersection		occludedEdge = propagatedIntersection->DetermineOccludedEdge();				//Determine if the intersection could potentially be a corner (still have to check if the crossing bsp is in the right whole object below)		bool corner = false;		if (forward && traversalArrivedOnTop && occludedEdge == 4)			corner = true;		else if (forward && !traversalArrivedOnTop && occludedEdge == 3)			corner = true;		else if (!forward && traversalArrivedOnTop && occludedEdge == 3)			corner = true;		else if (!forward && !traversalArrivedOnTop && occludedEdge == 4)			corner = true;				//When coming back to the first inter, it must approach as a corner		if (!corner && propagatedIntersection == firstInter)		{			if (gDebug1)			{				FloatPoint intersectionLoc = propagatedIntersection->GetLocation();								ForeColor(blackColor);				SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qs = 1;								ForeColor(whiteColor);				SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								intersectionLoc = intersection->GetLocation();				SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);				FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			}			return false;		}				//If the cross bsp or whole object matches the target		//and the occlusion is reflected back along the traversal, we're at a potential companion		bool failedCornerAttempt = false;		if (propagatedIntersection->GetType() == GenericIntersection::BSP_BSP)		{			BspBspIntersection* bspBspInter = (BspBspIntersection*)propagatedIntersection;						MyAssert((curve == bspBspInter->GetCv1() && seg == bspBspInter->GetSg1()) ||					(curve == bspBspInter->GetCv2() && seg == bspBspInter->GetSg2()));			MyAssert((crossCurve == bspBspInter->GetCv1() && crossSeg == bspBspInter->GetSg1()) ||					(crossCurve == bspBspInter->GetCv2() && crossSeg == bspBspInter->GetSg2()));						BSpline* crossBsp = traversalArrivedOnTop ? bspBspInter->GetBsp2() : bspBspInter->GetBsp1();						bool turnCorner = false;			if (corner)			{				if (!wholeObject && crossBsp == originalCrossBsp)				{					if (propagatedIntersection == firstInter || find(visitedInters.begin(), visitedInters.end(), propagatedIntersection) == visitedInters.end())						turnCorner = true;				}				if (wholeObject && find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), crossBsp) != wholeObject->bsplines.end())				{					if (propagatedIntersection == firstInter || find(visitedInters.begin(), visitedInters.end(), propagatedIntersection) == visitedInters.end())						turnCorner = true;				}			}						if (turnCorner)			{				if (gDebug1)				{					FloatPoint intersectionLoc = propagatedIntersection->GetLocation();										ForeColor(greenColor);					SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qs = 1;										ForeColor(whiteColor);					SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										intersectionLoc = intersection->GetLocation();					SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);					FrameOval(&r);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				}								if (propagatedIntersection == firstInter)	//The companion set is done					return (occlusionCount == 0 && accumCompSet.size() % 2 == 0);								accumCompSet.push_back(bspBspInter);				visitedInters.push_back(propagatedIntersection);				bool success = FindOneBspBspInterCompanion(bspBspInter, !traversalArrivedOnTop, occlusionCount, bspCutComps, firstInter, accumCompSet, visitedInters);				if (success)					return true;				else				{					MyAssert(accumCompSet.back() == bspBspInter);	//If this assert is always true, then instead of "finding" the iterator, we could just pop_back()					vector<BspBspIntersection*>::iterator iter = find(accumCompSet.begin(), accumCompSet.end(), bspBspInter);					MyAssert(iter != accumCompSet.end());					accumCompSet.erase(iter);					failedCornerAttempt = true;				}			}		}				visitedInters.push_back(propagatedIntersection);				//Getting here means the propagated intersection wasn't the companion				/*		      |		      |		-->-- | - - -   4		     /|\		      |		     		     		      |		     \|/	3	- - - | -->--		      |		      |		*/		if (prevPropInter->GetType() == GenericIntersection::BSP_BSP)		{			GenericIntersection* inter1 = propagatedIntersection;//!failedCornerAttempt ? propagatedIntersection : prevPropInter;			bool taot = traversalArrivedOnTop;//!failedCornerAttempt ? traversalArrivedOnTop : prevTraversalArrivedOnTop;						occludedEdge = inter1->DetermineOccludedEdge();						if (occludedEdge == 3 && taot)				occlusionCount += forward ? 1 : -1;			else if (occludedEdge == 3 && !taot)				occlusionCount += forward ? -1 : 1;			else if (occludedEdge == 4 && taot)				occlusionCount += forward ? -1 : 1;			else if (occludedEdge == 4 && !taot)				occlusionCount += forward ? 1 : -1;		}				//Keep track of the intersection that was just propagated from		prevPropInter = propagatedIntersection;		prevTraversalArrivedOnTop = traversalArrivedOnTop;			if (gDebug1)		{			FloatPoint intersectionLoc = propagatedIntersection->GetLocation();			SetRect(&r, intersectionLoc.h - 10, intersectionLoc.v - 10, intersectionLoc.h + 10, intersectionLoc.v + 10);			ForeColor(whiteColor);			FrameOval(&r);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}	}		for (int i = 0; i < bspCutIntersAddedAlongThisTraversal.size(); i++)	{		vector<BspCutIntersection*>::iterator iter = find(bspCutComps->begin(), bspCutComps->end(), bspCutIntersAddedAlongThisTraversal[i]);		MyAssert(iter != bspCutComps->end());		bspCutComps->erase(iter);	}	return false;}#pragma mark -void Drawing::DeleteAllCompSets(){	for (int i = 0; i < interCompanionSets.size(); i++)		delete interCompanionSets[i];	interCompanionSets.clear();}void Drawing::FindInterCompSetsForUnlabeledDrawing(){	clock_t startTime = clock();	clock_t accumTime = 0;		//Only used for debugging	InitAnalysisWindow();	Point mouse;	GetMouse(&mouse);	SetPort(GetWindowPort(gMainWindow->GetWindow()));		for (int i = 0; i < wholeObjects.size(); i++)		for (int j = 0; j < wholeObjects[i]->bspCutTinters.size(); j++)			MyAssert(!wholeObjects[i]->bspCutTinters[j]->GetDtored());		if (gDebug5)	{		InitAnalysisWindow();				IncrementTextV();		MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pFinding comp sets for unlabeled drawing");				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}		//Make sure every bspline has a whole object	for (int i = 0; i < bsplines.size(); i++)	{		WholeObject* wo = NULL;		FindOrCreateWholeObjectForBSpline(bsplines[i], wo);	}		MyAssert(interCompanionPairSets.size() == 0);	//This is no longer used, it should always be empty (delete it from the code at some future point).		//Get all the subregions in the drawing	vector<Subregion*> subregions;	map<unsigned long, vector<Subregion*> > boundarySectionMap;		clock_t t1 = clock();	//if (mouse.h < 100)		CollectAllSubregions(subregions, NULL, gMainWindow->GetCanvasSize(), false);	//else CollectAllSubregions(subregions, &boundarySectionMap, gMainWindow->GetCanvasSize(), false);	clock_t t2 = clock();	clock_t t3 = t2 - t1;	accumTime += t3;	if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\p    Seconds used: ");				Str255 str1;				long double timeUsedSecs = t3 / CLOCKS_PER_SEC;		FloatToPascal(timeUsedSecs, 3, str1);		DrawString(str1);				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);	}		if (!TestForMouseTermination())	{		for (int i = 0; i < subregions.size(); i++)			delete subregions[i];		return;	}		//Connect the subregions to their adjacent neighbors	t1 = clock();	//if (mouse.h < 100)		ConnectAdjacentSubregions(subregions);	//else ConnectAdjacentSubregions(subregions, &boundarySectionMap);	t2 = clock();	t3 = t2 - t1;	accumTime += t3;	if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\p    Seconds used: ");				Str255 str1;				long double timeUsedSecs = t3 / CLOCKS_PER_SEC;		FloatToPascal(timeUsedSecs, 3, str1);		DrawString(str1);				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);	}		gDebug13 = false;		if (!TestForMouseTermination())	{		for (int i = 0; i < subregions.size(); i++)			delete subregions[i];		return;	}		if (gDebug13)	{		//Draw the graph representing the neighbor relationships, the "dual" of the knot-diagram		SetPort(GetWindowPort(gMainWindow->GetWindow()));		PenSize(2, 2);				for (int i = 0; i < subregions.size(); i++)		{			switch (i % 7)			{				case 0:	ForeColor(redColor);	break;				case 1:	ForeColor(greenColor);	break;				case 2:	ForeColor(blueColor);	break;				case 3:	ForeColor(yellowColor);	break;				case 4:	ForeColor(magentaColor);	break;				case 5:	ForeColor(cyanColor);	break;				case 6:	ForeColor(blackColor);	break;			}						FloatPoint cog1;			for (int k = 0; k < subregions[i]->points.size(); k++)			{				cog1.h += subregions[i]->points[k].h;				cog1.v += subregions[i]->points[k].v;			}			cog1.h /= subregions[i]->points.size();			cog1.v /= subregions[i]->points.size();						PenSize(10, 10);			MoveTo(cog1.h - 5, cog1.v - 5);			Line(0, 0);			PenSize(2, 2);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						for (int j = 0; j < subregions[i]->enclosingNeighbors.size(); j++)			{				FloatPoint cog2;				for (int k = 0; k < subregions[i]->enclosingNeighbors[j]->points.size(); k++)				{					cog2.h += subregions[i]->enclosingNeighbors[j]->points[k].h;					cog2.v += subregions[i]->enclosingNeighbors[j]->points[k].v;				}				cog2.h /= subregions[i]->enclosingNeighbors[j]->points.size();				cog2.v /= subregions[i]->enclosingNeighbors[j]->points.size();								PenSize(10, 10);				MoveTo(cog2.h - 5, cog2.v - 5);				Line(0, 0);				PenSize(2, 2);								MoveTo(cog1.h, cog1.v);				LineTo(cog2.h, cog2.v);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qb = 1;			}		}				int qb = 1;				PenSize(1, 1);	}		//Find a legal slice for every subregion	if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		if (mouse.v < 100)			DrawString("\pFinding subregion slices 1");		else DrawString("\pFinding subregion slices 2");				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);	}	//gDebug7 = true;	gNumSliceAttempts = 0;	t1 = clock();	for (int i = 0; i < subregions.size(); i++)	{		if (!TestForMouseTermination())		{			for (int i = 0; i < subregions.size(); i++)				delete subregions[i];			return;		}				//if (mouse.v < 100)		//	FindLegalSlice(subregions[i]);		/*else */FindLegalSlice2(subregions[i]);	}	t2 = clock();	t3 = t2 - t1;	accumTime += t3;	if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\p    Seconds used: ");				Str255 str1;				long double timeUsedSecs = t3 / CLOCKS_PER_SEC;		FloatToPascal(timeUsedSecs, 3, str1);		DrawString(str1);				DrawString("\p   ");				NumToString(gNumSliceAttempts, str1);		DrawString(str1);				DrawString("\p slice attempts");				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);	}	gDebug7 = false;		//Build a list of surfaces that contribute to each subregion, with multiple contributions represented multipled times.	//In other words, if surface S is present in subregion R twice, represent S twice in R's contributing surfaces.	//This is stored with a vector of BSpline/int pairs for each subregion, where the int represents the net sum of edgedirections	//a slice from the subregion crosses for the BSpline.  Negative net sums denote enclosing surfaces that contribute to the subregion.	//gDebug13 = true;		t1 = clock();	BuildSurfaceToSubregionAssociations(subregions);	t2 = clock();	t3 = t2 - t1;	accumTime += t3;	if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\p    Seconds used: ");				Str255 str1;				long double timeUsedSecs = t3 / CLOCKS_PER_SEC;		FloatToPascal(timeUsedSecs, 3, str1);		DrawString(str1);				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);	}		//gDebug13 = false;	/*	BuildOverlappingSubsurfaces(subregions);	BuildIntersectionCompanionSets(subregions);	*/		if (!TestForMouseTermination())	{		for (int i = 0; i < subregions.size(); i++)			delete subregions[i];		return;	}		vector<SurfaceSubregionGraph*> surfaceSubregionGraphs;	t1 = clock();	BuildSurfaceSubregionGraphs(subregions, surfaceSubregionGraphs);	t2 = clock();	t3 = t2 - t1;	accumTime += t3;	if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\p    Seconds used: ");				Str255 str1;				long double timeUsedSecs = t3 / CLOCKS_PER_SEC;		FloatToPascal(timeUsedSecs, 3, str1);		DrawString(str1);				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);	}		if (!TestForMouseTermination())	{		for (int i = 0; i < subregions.size(); i++)			delete subregions[i];		for (int i = 0; i < surfaceSubregionGraphs.size(); i++)			delete surfaceSubregionGraphs[i];		return;	}		t1 = clock();	vector<OverlappingSubsurface> overlappingSubsurfaces = FindCommonSubgraphs(surfaceSubregionGraphs);	t2 = clock();	t3 = t2 - t1;	accumTime += t3;	if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\p    Seconds used: ");				Str255 str1;				long double timeUsedSecs = t3 / CLOCKS_PER_SEC;		FloatToPascal(timeUsedSecs, 3, str1);		DrawString(str1);				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);	}		if (!TestForMouseTermination())	{		for (int i = 0; i < subregions.size(); i++)			delete subregions[i];		for (int i = 0; i < surfaceSubregionGraphs.size(); i++)			delete surfaceSubregionGraphs[i];		return;	}		t1 = clock();	BuildIntersectionCompanionSetsFromOverlappingSubsurfaces(overlappingSubsurfaces);	t2 = clock();	t3 = t2 - t1;	accumTime += t3;	if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\p    Seconds used: ");				Str255 str1;				long double timeUsedSecs = t3 / CLOCKS_PER_SEC;		FloatToPascal(timeUsedSecs, 3, str1);		DrawString(str1);				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);	}		if (!TestForMouseTermination())	{		for (int i = 0; i < subregions.size(); i++)			delete subregions[i];		for (int i = 0; i < surfaceSubregionGraphs.size(); i++)			delete surfaceSubregionGraphs[i];		return;	}		t1 = clock();	InitializeCompanionSets();	t2 = clock();	t3 = t2 - t1;	accumTime += t3;	if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\p    Seconds used: ");				Str255 str1;				long double timeUsedSecs = t3 / CLOCKS_PER_SEC;		FloatToPascal(timeUsedSecs, 3, str1);		DrawString(str1);				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);	}		gDebug13 = false;		for (int i = 0; i < subregions.size(); i++)		delete subregions[i];	for (int i = 0; i < surfaceSubregionGraphs.size(); i++)		delete surfaceSubregionGraphs[i];		VerifyNothingDtored();	for (int i = 0; i < interCompanionSets.size(); i++)		for (int j = 0; j < interCompanionSets[i]->size(); j++)			MyAssert(find(intersections.begin(), intersections.end(), (*interCompanionSets[i])[j]) != intersections.end());		t2 = clock();	t3 = t2 - startTime;	if (gDebug5)	{		InitAnalysisWindow();				Str255 str1;				MoveTo(5, IncrementTextV() * 10 + 5);		NumToString(interCompanionSets.size(), str1);		DrawString(str1);		DrawString("\p comp sets found");		MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pSeconds used: ");				long double timeUsedSecs = t3 / CLOCKS_PER_SEC;		FloatToPascal(timeUsedSecs, 3, str1);		DrawString(str1);				DrawString("\p    ");				timeUsedSecs = accumTime / CLOCKS_PER_SEC;		FloatToPascal(timeUsedSecs, 3, str1);		DrawString(str1);				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);	}		for (int i = 0; i < wholeObjects.size(); i++)		for (int j = 0; j < wholeObjects[i]->bspCutTinters.size(); j++)			MyAssert(!wholeObjects[i]->bspCutTinters[j]->GetDtored());		if (gDebug13)		for (int i = 0; i < interCompanionSets.size(); i++)			if (interCompanionSets[i]->size() > 0)			{				SetPort(GetWindowPort(gMainWindow->GetWindow()));								Rect r;				GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);				EraseRect(&r);				gMainWindow->DrawGrid();								Point scrollOffset = {0, 0};				vector<BSpline*> workingBSplines;				DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);								PenSize(2, 2);				ForeColor(cyanColor);				for (int j = 0; j < interCompanionSets[i]->size(); j++)				{					FloatPoint loc = (*interCompanionSets[i])[j]->GetLocation();					SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);					FrameOval(&r);				}				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int dg3 = 1;								ForeColor(whiteColor);				for (int j = 0; j < interCompanionSets[i]->size(); j++)				{					FloatPoint loc = (*interCompanionSets[i])[j]->GetLocation();					SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);					FrameOval(&r);				}				PenSize(1, 1);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			}}void Drawing::ConnectAdjacentSubregions(vector<Subregion*> subregions){	if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pConnecting adjacent subregions 1");		//IncrementTextV();				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}		if (subregions.size() == 0)		return;		//Loop through the subregions	for (int i = 0; i < subregions.size() - 1; i++)	{		if (!TestForMouseTermination())			return;				Subregion *sr1 = subregions[i];				if (gDebug13)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));			ForeColor(yellowColor);			sr1->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qc = 1;		}				//Loop through the subregions		for (int j = i + 1; j < subregions.size(); j++)		{			if (!TestForMouseTermination())				return;						Subregion *sr2 = subregions[j];			MyAssert(sr1 && sr2);			MyAssert(sr1 != sr2);						if (gDebug13)			{				SetPort(GetWindowPort(gMainWindow->GetWindow()));				ForeColor(cyanColor);				sr2->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qc = 1;			}						//Compare the two presently selected subregions.  See if they have a common edge between them (a shared border).			bool neighbored = false;			int numSr1Osbs = sr1->obss.size();			for (int m = 0; m < sr1->obss.size(); m++)			{				OrientedBoundarySection obs1 = sr1->obss[m];				if (obs1.startInter->GetType() != GenericIntersection::CUT_CUT)					MyAssert(obs1.startCv != -1 || obs1.startInter->GetLocation().h < -999998);				if (obs1.endInter->GetType() != GenericIntersection::CUT_CUT)					MyAssert(obs1.endCv != -1 || obs1.endInter->GetLocation().h < -999998);								int numSr2Osbs = sr2->obss.size();				for (int n = 0; n < sr2->obss.size(); n++)				{					OrientedBoundarySection obs2 = sr2->obss[n];					if (obs2.startInter->GetType() != GenericIntersection::CUT_CUT)						MyAssert(obs2.startCv != -1 || obs2.startInter->GetLocation().h < -999998);					if (obs2.endInter->GetType() != GenericIntersection::CUT_CUT)						MyAssert(obs2.endCv != -1 || obs2.endInter->GetLocation().h < -999998);										//Do the two subregions have a shared border edge?					if (obs1.Opposite(obs2))					{						if (obs1.bsp)						{							MyAssert(!obs1.cut);														if (obs1.traverseForward)	//The boundary segment between sr1 and sr2 bounds into sr1							{								//I think these asserts are invalid, they can be violated legally								MyAssert(find(sr1->enclosingNeighbors.begin(), sr1->enclosingNeighbors.end(), sr2) == sr1->enclosingNeighbors.end());								MyAssert(find(sr2->enclosedNeighbors.begin(), sr2->enclosedNeighbors.end(), sr1) == sr2->enclosedNeighbors.end());								sr1->enclosingNeighbors.push_back(sr2);								sr2->enclosedNeighbors.push_back(sr1);							}							else	//The boundary segment between sr1 and sr2 bounds into sr2							{								//I think these asserts are invalid, they can be violated legally								MyAssert(find(sr1->enclosedNeighbors.begin(), sr1->enclosedNeighbors.end(), sr2) == sr1->enclosedNeighbors.end());								MyAssert(find(sr2->enclosingNeighbors.begin(), sr2->enclosingNeighbors.end(), sr1) == sr2->enclosingNeighbors.end());								sr1->enclosedNeighbors.push_back(sr2);								sr2->enclosingNeighbors.push_back(sr1);							}						}						else	//!obs1.bsp						{							//For a cut boundary, both subregions are enclosed within each other, meaning they can both spill into each other across the cut.														if (gDebug13)							{								Rect r;																PenSize(2, 2);																FloatPoint loc = obs1.cut->GetStart();								if (loc.h < 0)									loc.h = 0;								SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);								ForeColor(cyanColor);								FrameOval(&r);																loc = obs1.cut->GetEnd();								if (loc.h < 0)									loc.h = 0;								SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);								ForeColor(magentaColor);								FrameOval(&r);																PenSize(1, 1);																ForeColor(greenColor);								sr1->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));								ForeColor(redColor);								sr2->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));																int qc = 1;																PenSize(2, 2);																ForeColor(whiteColor);								loc = obs1.cut->GetStart();								if (loc.h < 0)									loc.h = 0;								SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);								FrameOval(&r);																loc = obs1.cut->GetEnd();								if (loc.h < 0)									loc.h = 0;								SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);								FrameOval(&r);																PenSize(1, 1);																ForeColor(whiteColor);								sr1->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));								sr2->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));								ForeColor(blackColor);								sr1->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);								sr2->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);							}														MyAssert(obs1.cut);							MyAssert(find(sr1->enclosedNeighbors.begin(), sr1->enclosedNeighbors.end(), sr2) == sr1->enclosedNeighbors.end());							MyAssert(find(sr2->enclosedNeighbors.begin(), sr2->enclosedNeighbors.end(), sr1) == sr2->enclosedNeighbors.end());							sr1->enclosedNeighbors.push_back(sr2);							sr2->enclosedNeighbors.push_back(sr1);							MyAssert(find(sr1->enclosingNeighbors.begin(), sr1->enclosingNeighbors.end(), sr2) == sr1->enclosingNeighbors.end());							MyAssert(find(sr2->enclosingNeighbors.begin(), sr2->enclosingNeighbors.end(), sr1) == sr2->enclosingNeighbors.end());							sr1->enclosingNeighbors.push_back(sr2);							sr2->enclosingNeighbors.push_back(sr1);						}												//Build and store the adjacency between the two subregions						SubregionAdjacency subregionAdjacency = SubregionAdjacency(sr1, sr2, UnorientedBoundarySection(obs1));						sr1->subregionAdjacencies.push_back(subregionAdjacency);						sr2->subregionAdjacencies.push_back(subregionAdjacency);												neighbored = true;												if (gDebug13)						{							SetPort(GetWindowPort(gMainWindow->GetWindow()));							ForeColor(redColor);							sr2->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));														QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int qb = 1;						}												break;					}				}								if (neighbored)					break;			}						if (gDebug13)			{				SetPort(GetWindowPort(gMainWindow->GetWindow()));				ForeColor(whiteColor);				sr2->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));								ForeColor(blackColor);				sr2->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qb = 1;			}		}				if (gDebug13)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));			ForeColor(whiteColor);			sr1->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						ForeColor(blackColor);			sr1->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qb = 1;		}				if (gDebug13)		{			InitAnalysisWindow();						MoveTo(gTextH++ * 7 + 5, gTextV * 10 + 5);			DrawString("\pе");						Rect r;			GetPortBounds(GetWindowPort(gAnalysisWindow), &r);			if (gTextH * 7 + 5 > r.right - 10)			{				gTextH = 0;				IncrementTextV();			}						QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);			SetPort(GetWindowPort(gMainWindow->GetWindow()));		}	}}void Drawing::ConnectAdjacentSubregions(vector<Subregion*> subregions, map<unsigned long, vector<Subregion*> >* boundarySectionMap){	MyAssert(boundarySectionMap);		if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pConnecting adjacent subregions 2");		//IncrementTextV();				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}		if (subregions.size() == 0)		return;		//Loop through the subregions	for (int i = 0; i < subregions.size() - 1; i++)	{		if (!TestForMouseTermination())			return;				Subregion *sr1 = subregions[i];				if (gDebug13)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));						Rect r;			GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);			EraseRect(&r);			gMainWindow->DrawGrid();						Point scrollOffset = {0, 0};			vector<BSpline*> workingBSplines;			DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);						ForeColor(yellowColor);			sr1->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qc = 1;		}				for (int j = 0; j < sr1->ubss.size(); j++)		{			UnorientedBoundarySection ubs = sr1->ubss[j];						vector<Subregion*> ubsSubregions = (*boundarySectionMap)[ubs.GetHashKey()];			MyAssert(ubsSubregions.size() == 1 || ubsSubregions.size() == 2);						if (ubsSubregions.size() == 1)			{				MyAssert(ubsSubregions[0] == sr1);								if (gDebug13)				{					SetPort(GetWindowPort(gMainWindow->GetWindow()));					ForeColor(blueColor);					sr1->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qc = 1;				}			}			else	//if (ubsSubregions.size() == 2)			{				Subregion *sr2 = (ubsSubregions[0] == sr1) ? ubsSubregions[1] : ubsSubregions[0];								if (gDebug13)				{					SetPort(GetWindowPort(gMainWindow->GetWindow()));										Rect r;					GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);					EraseRect(&r);					gMainWindow->DrawGrid();										Point scrollOffset = {0, 0};					vector<BSpline*> workingBSplines;					DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);										SetPort(GetWindowPort(gMainWindow->GetWindow()));					ForeColor(yellowColor);					sr1->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));					ForeColor(greenColor);					ubsSubregions[0]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));					ForeColor(redColor);					ubsSubregions[1]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qc = 1;				}								if (ubsSubregions[0] == sr1 || ubsSubregions[1] == sr1)				{					//Find the corresponding OrientedBoundarySegment and determine the traversal direction					bool traverseForward = true;					bool foundIt = false;					for (int k = 0; k < sr1->obss.size(); k++)						if (ubs.EqualObs(sr1->obss[k]))						{							traverseForward = sr1->obss[k].traverseForward;							foundIt = true;							break;						}					MyAssert(foundIt);										if (ubs.bsp)					{						MyAssert(!ubs.cut);												if (traverseForward)	//The boundary segment between sr1 and sr2 bounds into sr1						{							//I think these asserts are invalid, they can be violated legally							//MyAssert(find(sr1->enclosingNeighbors.begin(), sr1->enclosingNeighbors.end(), sr2) == sr1->enclosingNeighbors.end());							//MyAssert(find(sr2->enclosedNeighbors.begin(), sr2->enclosedNeighbors.end(), sr1) == sr2->enclosedNeighbors.end());							sr1->enclosingNeighbors.push_back(sr2);							sr2->enclosedNeighbors.push_back(sr1);						}						else	//The boundary segment between sr1 and sr2 bounds into sr2						{							//I think these asserts are invalid, they can be violated legally							//MyAssert(find(sr1->enclosedNeighbors.begin(), sr1->enclosedNeighbors.end(), sr2) == sr1->enclosedNeighbors.end());							//MyAssert(find(sr2->enclosingNeighbors.begin(), sr2->enclosingNeighbors.end(), sr1) == sr2->enclosingNeighbors.end());							sr1->enclosedNeighbors.push_back(sr2);							sr2->enclosingNeighbors.push_back(sr1);						}					}					else if (ubs.cut)					{							//I think these asserts are invalid, they can be violated legally							//MyAssert(find(sr1->enclosedNeighbors.begin(), sr1->enclosedNeighbors.end(), sr2) == sr1->enclosedNeighbors.end());							//MyAssert(find(sr2->enclosedNeighbors.begin(), sr2->enclosedNeighbors.end(), sr1) == sr2->enclosedNeighbors.end());							sr1->enclosedNeighbors.push_back(sr2);							sr2->enclosedNeighbors.push_back(sr1);							//I think these asserts are invalid, they can be violated legally							//MyAssert(find(sr1->enclosingNeighbors.begin(), sr1->enclosingNeighbors.end(), sr2) == sr1->enclosingNeighbors.end());							//MyAssert(find(sr2->enclosingNeighbors.begin(), sr2->enclosingNeighbors.end(), sr1) == sr2->enclosingNeighbors.end());							sr1->enclosingNeighbors.push_back(sr2);							sr2->enclosingNeighbors.push_back(sr1);					}					else					{						MyAssert(ubs.infiniteWO);						//Nothing to do here					}										//Build and store the adjacency between the two subregions					SubregionAdjacency subregionAdjacency = SubregionAdjacency(sr1, sr2, ubs);					sr1->subregionAdjacencies.push_back(subregionAdjacency);					sr2->subregionAdjacencies.push_back(subregionAdjacency);				}			}		}				if (gDebug13)		{			InitAnalysisWindow();						MoveTo(gTextH++ * 7 + 5, gTextV * 10 + 5);			DrawString("\pе");						Rect r;			GetPortBounds(GetWindowPort(gAnalysisWindow), &r);			if (gTextH * 7 + 5 > r.right - 10)			{				gTextH = 0;				IncrementTextV();			}						QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);			SetPort(GetWindowPort(gMainWindow->GetWindow()));		}	}}void Drawing::BuildSurfaceToSubregionAssociations(vector<Subregion*> subregions){	if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pBuilding surface/subregion associations");				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}		for (int i = 0; i < subregions.size(); i++)	{		if (!TestForMouseTermination())			return;				Subregion* sr = subregions[i];		//debug				if (gDebug13)		{						SetPort(GetWindowPort(gMainWindow->GetWindow()));			ForeColor(yellowColor);			subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						ForeColor(cyanColor);			FloatPoint sliceFromPoint = subregions[i]->sliceFromPoint;			PenSize(1, 1);			MoveTo(sliceFromPoint.h, sliceFromPoint.v);			LineTo(0, sliceFromPoint.v);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qc = 1;		}				//MyAssert(subregions[i]->sliceIntersections.size() > 0);		for (int j = 0; j < subregions[i]->sliceIntersections.size(); j++)		{			if (!TestForMouseTermination())				return;						CutIntersection ci = subregions[i]->sliceIntersections[j];	//debug						if (gDebug13)			{				Rect r;								PenSize(2, 2);								FloatPoint loc = subregions[i]->sliceIntersections[j].intersection->GetLocation();				if (loc.h < 0)					loc.h = 0;				SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);				ForeColor(magentaColor);				FrameOval(&r);								PenSize(1, 1);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qc = 1;			}											MyAssert(subregions[i]->sliceIntersections[j].intersection->GetType() == GenericIntersection::BSP_CUT ||					subregions[i]->sliceIntersections[j].intersection->GetType() == GenericIntersection::CUT_CUT);			if (subregions[i]->sliceIntersections[j].intersection->GetType() == GenericIntersection::BSP_CUT)			{				BspCutIntersection* bspCutInter = (BspCutIntersection*)subregions[i]->sliceIntersections[j].intersection;				BSpline* bsp = bspCutInter->GetBsp();				WholeObject* wholeObject = subregions[i]->sliceIntersections[j].crossingWholeObject;				MyAssert(wholeObject);				if (bsp)					MyAssert(wholeObject == FindWholeObjectForBSpline(bsp));				int edgeDirection = bspCutInter->GetEdgeDirection();				int enclosingWOIndex = 0;				for (enclosingWOIndex = 0; enclosingWOIndex < subregions[i]->enclosingWOs.size(); enclosingWOIndex++)					if (subregions[i]->enclosingWOs[enclosingWOIndex].first == wholeObject)						break;				if (enclosingWOIndex < subregions[i]->enclosingWOs.size())					subregions[i]->enclosingWOs[enclosingWOIndex].second += edgeDirection;				else subregions[i]->enclosingWOs.push_back(pair<WholeObject*, int>(wholeObject, edgeDirection));			}			else //if (subregions[i]->sliceIntersections[j].intersection->GetType() == GenericIntersection::CUT_CUT)			{				CutCutIntersection* cutCutInter = (CutCutIntersection*)subregions[i]->sliceIntersections[j].intersection;				BSplineToBSplineCut* cut = cutCutInter->GetCut1();				WholeObject* wholeObject = subregions[i]->sliceIntersections[j].crossingWholeObject;				MyAssert(wholeObject);				MyAssert(cut);				MyAssert(wholeObject == FindWholeObjectForCut(cut));				int enclosingWOIndex = 0;				for (enclosingWOIndex = 0; enclosingWOIndex < subregions[i]->enclosingWOs.size(); enclosingWOIndex++)					if (subregions[i]->enclosingWOs[enclosingWOIndex].first == wholeObject)						break;				if (enclosingWOIndex < subregions[i]->enclosingWOs.size())					{}//Cuts don't effect the depth, so don't do anything here			//subregions[i]->enclosingWOs[enclosingWOIndex].second += -1;				//else subregions[i]->enclosingWOs.push_back(pair<WholeObject*, int>(wholeObject, -2));		//Starting out -2 should be right actually.  It's a little weird, but I think it's right.				else subregions[i]->enclosingWOs.push_back(pair<WholeObject*, int>(wholeObject, 0));				//In some cases cut-cuts should be inited with 0, not -2.  What was the case where a -2 was the correct method?			}		}				if (gDebug13)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));			TextSize(14);			TextFace(bold);						ForeColor(blackColor);			FloatPoint cog;			for (int k = 0; k < subregions[i]->points.size(); k++)			{				cog.h += subregions[i]->points[k].h;				cog.v += subregions[i]->points[k].v;			}			cog.h /= subregions[i]->points.size();			cog.v /= subregions[i]->points.size();						for (int j = 0; j < subregions[i]->enclosingWOs.size(); j++)			{				int woIndex = GetWholeObjectIndex(subregions[i]->enclosingWOs[j].first);				Str255 str;				NumToString(woIndex, str);				PascalAppend(str, "\p: ");				Str255 str1;				NumToString(subregions[i]->enclosingWOs[j].second, str1);				PascalAppend(str, str1);				MoveTo(cog.h, cog.v + j * 14);				DrawString(str);			}						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qb = 1;						ForeColor(whiteColor);			subregions[i]->row = 0;			for (int j = 0; j < subregions[i]->enclosingWOs.size(); j++)			{				int woIndex = GetWholeObjectIndex(subregions[i]->enclosingWOs[j].first);				Str255 str;				NumToString(woIndex, str);				PascalAppend(str, "\p: ");				Str255 str1;				NumToString(subregions[i]->enclosingWOs[j].second, str1);				PascalAppend(str, str1);				MoveTo(cog.h, cog.v + subregions[i]->row++ * 14);				DrawString(str);			}						ForeColor(whiteColor);			subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			ForeColor(blackColor);			subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}				//Clean up the subregion's enclosing bsp associations by removing any associations with a count of 0 or greater (not sure if positive is actually possible), but exclude the 0s)		bool foundOne = true;		while (foundOne)		{			foundOne = false;			for (vector<pair<WholeObject*, int> >::iterator iter = subregions[i]->enclosingWOs.begin(); iter != subregions[i]->enclosingWOs.end(); iter++)				if ((*iter).second >= 0)				{					subregions[i]->enclosingWOs.erase(iter);					foundOne = true;					break;				}		}	}	/*	if (gDebug13)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));		TextSize(14);		TextFace(bold);				ForeColor(blackColor);		for (int i = 0; i < subregions.size(); i++)		{			FloatPoint cog;			for (int k = 0; k < subregions[i]->points.size(); k++)			{				cog.h += subregions[i]->points[k].h;				cog.v += subregions[i]->points[k].v;			}			cog.h /= subregions[i]->points.size();			cog.v /= subregions[i]->points.size();						for (int j = 0; j < subregions[i]->enclosingWOs.size(); j++)			{				int woIndex = GetWholeObjectIndex(subregions[i]->enclosingWOs[j].first);				Str255 str;				NumToString(woIndex, str);				PascalAppend(str, "\p: ");				Str255 str1;				NumToString(subregions[i]->enclosingWOs[j].second, str1);				PascalAppend(str, str1);				MoveTo(cog.h, cog.v + j * 14);				DrawString(str);			}		}				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qb = 1;				ForeColor(whiteColor);		for (int i = 0; i < subregions.size(); i++)		{			FloatPoint cog;			for (int k = 0; k < subregions[i]->points.size(); k++)			{				cog.h += subregions[i]->points[k].h;				cog.v += subregions[i]->points[k].v;			}			cog.h /= subregions[i]->points.size();			cog.v /= subregions[i]->points.size();						subregions[i]->row = 0;			for (int j = 0; j < subregions[i]->enclosingWOs.size(); j++)			{				int woIndex = GetWholeObjectIndex(subregions[i]->enclosingWOs[j].first);				Str255 str;				NumToString(woIndex, str);				PascalAppend(str, "\p: ");				Str255 str1;				NumToString(subregions[i]->enclosingWOs[j].second, str1);				PascalAppend(str, str1);				MoveTo(cog.h, cog.v + subregions[i]->row++ * 14);				DrawString(str);			}		}				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				qb = 1;	}	*/}void Drawing::BuildOverlappingSubsurfaces(vector<Subregion*> subregions){	/*	//Start by cleaning up the subregions' enclosing bsp associations by removing any associations with a count of 0 or greater (not sure if positive is actually possible), but exclude the 0s)	for (int i = 0; i < subregions.size(); i++)	{		bool foundOne = true;		while (foundOne)		{			foundOne = false;			for (vector<pair<BSpline*, int> >::iterator iter = subregions[i]->enclosingBsps.begin(); iter != subregions[i]->enclosingBsps.end(); iter++)				if ((*iter).second >= 0)				{					subregions[i]->enclosingBsps.erase(iter);					foundOne = true;					break;				}		}	}		//Creating BSpline to BSpline pairings for the enclosing BSplines for each subregion	for (int i = 0; i < subregions.size(); i++)	//Loop through subregions		for (int j = 0; j < subregions[i]->enclosingBsps.size(); j++)	//Loop through the BSplines		{			MyAssert(subregions[i]->enclosingBsps[j].second < 0);			for (int k = 0; k < -subregions[i]->enclosingBsps[j].second; k++)	//Loop through individual surface assocations for one BSpline				for (int m = j; m < subregions[i]->enclosingBsps.size(); m++)	//Loop through the BSplines				{					MyAssert(subregions[i]->enclosingBsps[m].second < 0);					int startN = (m > j) ? 0 : (k + 1);					for (int n = startN; n < -subregions[i]->enclosingBsps[m].second; n++)	//Loop through individual surface assocations for one BSpline					{						if (m == j && n == k)	//Don't create self-to-self pairs, it's nonsense							continue;												//Make the BSpline-to-BSpline pair and add it to the list						subregions[i]->enclosingBspPairs.push_back(pair<BSpline*, BSpline*>(subregions[i]->enclosingBsps[j].first, subregions[i]->enclosingBsps[m].first));					}				}		}		if (gDebug13)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));		TextSize(14);		TextFace(bold);				ForeColor(blackColor);		for (int i = 0; i < subregions.size(); i++)		{			FloatPoint cog;			for (int k = 0; k < subregions[i]->points.size(); k++)			{				cog.h += subregions[i]->points[k].h;				cog.v += subregions[i]->points[k].v;			}			cog.h /= subregions[i]->points.size();			cog.v /= subregions[i]->points.size();						for (int j = 0; j < subregions[i]->enclosingBspPairs.size(); j++)			{				int bspIndex1 = GetBSplineIndex(subregions[i]->enclosingBspPairs[j].first);				int bspIndex2 = GetBSplineIndex(subregions[i]->enclosingBspPairs[j].second);				Str255 str;				NumToString(bspIndex1, str);				PascalAppend(str, "\p , ");				Str255 str1;				NumToString(bspIndex2, str1);				PascalAppend(str, str1);				MoveTo(cog.h, cog.v + j * 14);				DrawString(str);			}		}				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qb = 1;	}		//Loop indefinitely until all the overlapping subsurfaces are found	while (true)	{		//Find the next subregion that has an unclaimed bsp-bsp pair		int subregionSeedIndex = 0;		for (subregionSeedIndex = 0; subregionSeedIndex < subregions.size(); subregionSeedIndex++)			if (subregions[subregionSeedIndex]->enclosingBspPairs.size() > 0)				break;				//If there are no more bsp-bsp pairs, we're done, so break out		if (subregionSeedIndex == subregions.size())			break;				if (gDebug13)		{			ForeColor(blueColor);			subregions[subregionSeedIndex]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			int qb = 1;		}				//Initialize a new overlapping subsurface		OverlappingSubsurface* os = new OverlappingSubsurface();				//Get the bsp-bsp pair that corresponds to the overlapping subsurface we are about to build		MyAssert(subregions[subregionSeedIndex]->enclosingBspPairs.size() > 0);		pair<BSpline*, BSpline*> bspBspPair = subregions[subregionSeedIndex]->enclosingBspPairs[0];				//Start a queue of subregions that need to be inspected for inclusion in the overlapping subsurface.		//Seed the queue with the seed subregion.		list<Subregion*> subregionsToInspect;		subregionsToInspect.push_back(subregions[subregionSeedIndex]);				//Traverse the queue (which may grow during the loop) until the end is reached		for (list<Subregion*>::iterator iter = subregionsToInspect.begin(); iter != subregionsToInspect.end(); iter++)		{			//Get the next subregion from the queue and see if it contains the target bsp-bsp pair			Subregion* sr = *iter;						if (gDebug13)			{				ForeColor(greenColor);				sr->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				int qb = 1;			}						vector<pair<BSpline*, BSpline*> >::iterator iter2 = find(sr->enclosingBspPairs.begin(), sr->enclosingBspPairs.end(), bspBspPair);			if (iter2 == sr->enclosingBspPairs.end())	//Try the pair both ways, since its symmetrical				iter2 = find(sr->enclosingBspPairs.begin(), sr->enclosingBspPairs.end(), pair<BSpline*, BSpline*>(bspBspPair.second, bspBspPair.first));						if (iter2 != sr->enclosingBspPairs.end())			{				if (gDebug13)				{					ForeColor(redColor);					sr->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));					int qb = 1;				}								sr->enclosingBspPairs.erase(iter2);								//Add the subregion to the overlapping subsurface				MyAssert(find(os->subregions.begin(), os->subregions.end(), sr) == os->subregions.end());				os->subregions.push_back(sr);								//Add the subregion's neighbors to the inspection queue if they aren't already in the queue				for (int i = 0; i < sr->neighbors.size(); i++)					if (find(subregionsToInspect.begin(), subregionsToInspect.end(), sr->neighbors[i]) == subregionsToInspect.end())					{						subregionsToInspect.push_back(sr->neighbors[i]);												if (gDebug13)						{							ForeColor(cyanColor);							sr->neighbors[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));							int qb = 1;						}					}			}						if (gDebug13)			{				ForeColor(whiteColor);				sr->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				int qb = 1;			}		}				if (gDebug13)		{			ForeColor(yellowColor);			for (int i = 0; i < os->subregions.size(); i++)				os->subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			int qb = 1;						ForeColor(whiteColor);			for (int i = 0; i < os->subregions.size(); i++)				os->subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			qb = 1;		}				overlappingSubsurfaces.push_back(os);	}		if (gDebug13)		TextFace(0);	*/	//========================================================================================================		//Start by cleaning up the subregions' enclosing bsp associations by removing any associations with a count of 0 or greater (not sure if positive is actually possible), but exclude the 0s)	for (int i = 0; i < subregions.size(); i++)	{		bool foundOne = true;		while (foundOne)		{			foundOne = false;			for (vector<pair<WholeObject*, int> >::iterator iter = subregions[i]->enclosingWOs.begin(); iter != subregions[i]->enclosingWOs.end(); iter++)				if ((*iter).second >= 0)				{					subregions[i]->enclosingWOs.erase(iter);					foundOne = true;					break;				}		}	}		if (!TestForMouseTermination())		return;		//Create WholeObject to WholeObject pairings for the enclosing WholeObject for each subregion	for (int i = 0; i < subregions.size(); i++)	//Loop through subregions		for (int j = 0; j < subregions[i]->enclosingWOs.size(); j++)	//Loop through the WholeObjects		{			MyAssert(subregions[i]->enclosingWOs[j].second < 0);			for (int k = 0; k < -subregions[i]->enclosingWOs[j].second; k++)	//Loop through individual surface assocations for one WholeObject				for (int m = j; m < subregions[i]->enclosingWOs.size(); m++)	//Loop through the WholeObjects				{					MyAssert(subregions[i]->enclosingWOs[m].second < 0);					int startN = (m > j) ? 0 : (k + 1);					for (int n = startN; n < -subregions[i]->enclosingWOs[m].second; n++)	//Loop through individual surface assocations for one WholeObject					{						if (m == j && n == k)	//Don't create self-to-self pairs, it's nonsense							continue;												//Make the WholeObject-to-WholeObject pair and add it to the list						//subregions[i]->enclosingWOPairs.push_back(pair<WholeObject*, WholeObject*>(subregions[i]->enclosingWOs[j].first, subregions[i]->enclosingWOs[m].first));						OverlappingSubsurface os;						os.wholeObjectPair = pair<WholeObject*, WholeObject*>(subregions[i]->enclosingWOs[j].first, subregions[i]->enclosingWOs[m].first);						os.subregions.push_back(subregions[i]);						subregions[i]->overlappingSubsurfaces.push_back(os);					}				}		}		if (!TestForMouseTermination())		return;		if (gDebug13)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));		TextSize(14);		TextFace(bold);				ForeColor(blackColor);		for (int i = 0; i < subregions.size(); i++)		{			FloatPoint cog;			for (int k = 0; k < subregions[i]->points.size(); k++)			{				cog.h += subregions[i]->points[k].h;				cog.v += subregions[i]->points[k].v;			}			cog.h /= subregions[i]->points.size();			cog.v /= subregions[i]->points.size();						subregions[i]->row = 0;			for (list<OverlappingSubsurface>::iterator iterJ = subregions[i]->overlappingSubsurfaces.begin(); iterJ != subregions[i]->overlappingSubsurfaces.end(); iterJ++)			{				int woIndex1 = GetWholeObjectIndex((*iterJ).wholeObjectPair.first);				int woIndex2 = GetWholeObjectIndex((*iterJ).wholeObjectPair.second);				Str255 str;				NumToString(woIndex1, str);				PascalAppend(str, "\p , ");				Str255 str1;				NumToString(woIndex2, str1);				PascalAppend(str, str1);				MoveTo(cog.h, cog.v + subregions[i]->row++ * 14);				DrawString(str);			}		}				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qb = 1;				PenSize(2, 2);	}		//Continue until convergence	while (true)	{		if (!TestForMouseTermination())			return;				//Find a "source" subregion (one with neighbors going out, but none coming in)		int srIndex = 0;		for (srIndex = 0; srIndex < subregions.size(); srIndex++)			if (subregions[srIndex]->enclosingNeighbors.size() > 0 && subregions[srIndex]->enclosedNeighbors.size() == 0)				break;				if (srIndex == subregions.size())	//The subregion accumulation is done, so break out.			break;				Subregion* sr1 = subregions[srIndex];				if (gDebug13)		{			ForeColor(greenColor);			sr1->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			int qb = 1;		}				//Propagate the source subregion into its enclosing neighbors		while (sr1->enclosingNeighbors.size() > 0)		{			Subregion* sr2 = sr1->enclosingNeighbors.back();	//Get the next neighbor						if (gDebug13)			{				ForeColor(cyanColor);				sr2->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				int qb = 1;			}						vector<OverlappingSubsurface*> neighborOSesUsedAlready;						//Find out if the enclosing neighbor has any wholeObject pairs that match the present subregion			list<OverlappingSubsurface>::iterator nextIterJ;			for (list<OverlappingSubsurface>::iterator iterJ = sr1->overlappingSubsurfaces.begin(); iterJ != sr1->overlappingSubsurfaces.end(); iterJ = nextIterJ)			{				nextIterJ = iterJ;				nextIterJ++;				bool merged = false;				for (list<OverlappingSubsurface>::iterator iterK = sr2->overlappingSubsurfaces.begin(); iterK != sr2->overlappingSubsurfaces.end(); iterK++)					if ((*iterJ).wholeObjectPair == (*iterK).wholeObjectPair ||						((*iterJ).wholeObjectPair.first == (*iterK).wholeObjectPair.second && (*iterJ).wholeObjectPair.second == (*iterK).wholeObjectPair.first))						if (find(neighborOSesUsedAlready.begin(), neighborOSesUsedAlready.end(), &(*iterK)) == neighborOSesUsedAlready.end())						{							//Merge the present subregion's overlapping subsurface into the enclosing subregion's overlapping subsurface							for (int m = 0; m < (*iterJ).subregions.size(); m++)								if (find((*iterK).subregions.begin(), (*iterK).subregions.end(), (*iterJ).subregions[m]) == (*iterK).subregions.end())									(*iterK).subregions.push_back((*iterJ).subregions[m]);							neighborOSesUsedAlready.push_back(&(*iterK));							merged = true;														if (gDebug13)							{								ForeColor(redColor);								sr2->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));																FloatPoint cog;								for (int k = 0; k < sr2->points.size(); k++)								{									cog.h += sr2->points[k].h;									cog.v += sr2->points[k].v;								}								cog.h /= sr2->points.size();								cog.v /= sr2->points.size();																int woIndex1 = GetWholeObjectIndex((*iterJ).wholeObjectPair.first);								int woIndex2 = GetWholeObjectIndex((*iterJ).wholeObjectPair.second);								Str255 str;								NumToString(woIndex1, str);								PascalAppend(str, "\p , ");								Str255 str1;								NumToString(woIndex2, str1);								PascalAppend(str, str1);								MoveTo(cog.h, cog.v + sr2->row++ * 14);								DrawString(str);																int qb = 1;							}														break;						}								if (merged)					sr1->overlappingSubsurfaces.erase(iterJ);			}						//Erase the neighbor connections between these two subregions			sr1->enclosingNeighbors.pop_back();			bool foundIt = false;			for (vector<Subregion*>::iterator iter = sr2->enclosedNeighbors.begin(); iter != sr2->enclosedNeighbors.end(); iter++)				if (*iter == sr1)				{					sr2->enclosedNeighbors.erase(iter);					foundIt = true;					break;				}			MyAssert(foundIt);						if (gDebug13)			{				ForeColor(whiteColor);				sr2->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				int qb = 1;			}		}		MyAssert(sr1->enclosingNeighbors.size() == 0);				if (gDebug13)		{			ForeColor(whiteColor);			sr1->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			int qb = 1;		}	}		for (int i = 0; i < subregions.size(); i++)		MyAssert(subregions[i]->enclosingNeighbors.size() == 0 && subregions[i]->enclosedNeighbors.size() == 0);		if (gDebug13)		TextFace(0);}void Drawing::BuildIntersectionCompanionSets(vector<Subregion*> subregions){	DeleteAllCompSets();		//Rebuild the new companion sets	for (int i = 0; i < subregions.size(); i++)	{		MyAssert(subregions[i]->overlappingSubsurfaces.size() <= 1);	//Not at all sure about this?  Is this definitely true?  It not, simply iterate through the list, making an overlapping subsurface for each occurrance		if (subregions[i]->overlappingSubsurfaces.size() == 0)			continue;				OverlappingSubsurface* os = &subregions[i]->overlappingSubsurfaces.front();				vector<pair<GenericIntersection*, int> > osInters;				if (gDebug13)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));			ForeColor(yellowColor);			for (int j = 0; j < os->subregions.size(); j++)				os->subregions[j]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			int qb = 1;		}				for (int j = 0; j < os->subregions.size(); j++)		{			for (int k = 0; k < os->subregions[j]->corners.size(); k++)			{				GenericIntersection* regionCorner = os->subregions[j]->corners[k];								if (gDebug13)				{					Rect r;					FloatPoint loc = regionCorner->GetLocation();					SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);					PenSize(2, 2);					ForeColor(greenColor);					FrameOval(&r);					PenSize(1, 1);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qb = 1;				}								bool foundIt = false;				for (int m = 0; m < osInters.size(); m++)				{					if (osInters[m].first == regionCorner)					{						osInters[m].second++;						foundIt = true;												if (gDebug13)						{							Rect r;							FloatPoint loc = regionCorner->GetLocation();							SetRect(&r, loc.h - 15, loc.v - 15, loc.h + 15, loc.v + 15);							PenSize(2, 2);							ForeColor(cyanColor);							FrameOval(&r);							PenSize(1, 1);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int qb = 1;						}						break;					}				}				if (!foundIt)				{					osInters.push_back(pair<GenericIntersection*, int>(regionCorner, 1));										if (gDebug13)					{						Rect r;						FloatPoint loc = regionCorner->GetLocation();						SetRect(&r, loc.h - 15, loc.v - 15, loc.h + 15, loc.v + 15);						PenSize(2, 2);						ForeColor(blueColor);						FrameOval(&r);						PenSize(1, 1);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qb = 1;					}				}								if (gDebug13)				{					Rect r;					ForeColor(whiteColor);					FloatPoint loc = regionCorner->GetLocation();					SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);					PenSize(2, 2);					FrameOval(&r);					SetRect(&r, loc.h - 15, loc.v - 15, loc.h + 15, loc.v + 15);					FrameOval(&r);					PenSize(1, 1);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qb = 1;				}			}		}				vector<GenericIntersection*>* interCompanionSet = new vector<GenericIntersection*>;				for (int j = 0; j < osInters.size(); j++)			if (osInters[j].second == 1)			{				MyAssert(osInters[j].first->GetType() == GenericIntersection::BSP_BSP);				for (int k = 0; k < interCompanionSets.size(); k++)					MyAssert(find(interCompanionSets[k]->begin(), interCompanionSets[k]->end(), osInters[j].first) == interCompanionSets[k]->end());				interCompanionSet->push_back((BspBspIntersection*)osInters[j].first);			}		MyAssert(false);	//This entire function shouldn't be called anymore.  It's obsolete.		if (interCompanionSet->size() > 0)			interCompanionSets.push_back(interCompanionSet);		else		{			delete interCompanionSet;			interCompanionSet = NULL;		}				if (gDebug13)		{			if (interCompanionSet)			{				for (int j = 0; j < interCompanionSet->size(); j++)				{					Rect r;					FloatPoint loc = (*interCompanionSet)[j]->GetLocation();					SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);					PenSize(2, 2);					ForeColor(redColor);					FrameOval(&r);					PenSize(1, 1);				}				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int qb = 1;								for (int j = 0; j < interCompanionSet->size(); j++)				{					Rect r;					FloatPoint loc = (*interCompanionSet)[j]->GetLocation();					SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);					PenSize(2, 2);					ForeColor(whiteColor);					FrameOval(&r);					PenSize(1, 1);				}				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								qb = 1;			}			else			{				SetPort(GetWindowPort(gMainWindow->GetWindow()));				ForeColor(blackColor);				for (int j = 0; j < os->subregions.size(); j++)					os->subregions[j]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				int qb = 1;			}						ForeColor(whiteColor);			for (int j = 0; j < os->subregions.size(); j++)				os->subregions[j]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			int qb = 1;		}	}}void Drawing::BuildSurfaceSubregionGraphs(vector<Subregion*> subregions, vector<SurfaceSubregionGraph*>& surfaceSubregionGraphs){	if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pBuilding surface/subregion graphs");				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}		//Verify that every BSpline has a whole object	for (int i = 0; i < bsplines.size(); i++)		MyAssert(FindWholeObjectForBSpline(bsplines[i]));		//gDebug13 = true;	if (gDebug13)	{		MyAssert(!dtored);				SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		gMainWindow->DrawGrid();				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qc = 1;	}		//Loop through the whole objects, building the graph for each one	for (int i = 0; i < wholeObjects.size(); i++)	{		//gDebug13 = true;		SurfaceSubregionGraph* surfaceSubregionGraph = BuildSurfacePerimeterGraph(wholeObjects[i], subregions);				if (gMouseTerminated)			return;				if (!surfaceSubregionGraph)			continue;				if (gDebug13)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));						Rect r;			GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);			EraseRect(&r);			gMainWindow->DrawGrid();						Point scrollOffset = {0, 0};			vector<BSpline*> workingBSplines;			DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		}				gDebug13 = false;		if (gDebug13)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));						Rect r;			GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);			r.left = 450;			r.top = 450;			EraseRect(&r);			gMainWindow->DrawGrid();						Point scrollOffset = {0, 0};			vector<BSpline*> workingBSplines;			DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);						surfaceSubregionGraph->DrawDebug(gMainWindow->CalcScrollOffset(), 0, 0, GetWindowPort(gMainWindow->GetWindow()));						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qc = 1;		}				PinchSurfaceSubregionGraphSingleNodes(surfaceSubregionGraph, wholeObjects[i], subregions);				if (gMouseTerminated)			return;				gDebug13 = false;		if (gDebug13)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));						Rect r;			GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);			r.left = 450;			r.top = 450;			EraseRect(&r);			gMainWindow->DrawGrid();						Point scrollOffset = {0, 0};			vector<BSpline*> workingBSplines;			DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);						surfaceSubregionGraph->DrawDebug(gMainWindow->CalcScrollOffset(), 450, 0, GetWindowPort(gMainWindow->GetWindow()));						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qc = 1;		}				PinchSurfaceSubregionGraphSymmetries(surfaceSubregionGraph, wholeObjects[i], subregions);				if (gMouseTerminated)			return;				gDebug13 = false;		if (gDebug13)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));						Rect r;			GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);			r.left = 450;			r.top = 450;			EraseRect(&r);			gMainWindow->DrawGrid();						Point scrollOffset = {0, 0};			vector<BSpline*> workingBSplines;			DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);						surfaceSubregionGraph->DrawDebug(gMainWindow->CalcScrollOffset(), 0, 450, GetWindowPort(gMainWindow->GetWindow()));						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qc = 1;		}				//gDebug13 = true;		AddSurfaceSubregionGraphSpills(surfaceSubregionGraph, wholeObjects[i], subregions);				if (gMouseTerminated)			return;				gDebug13 = false;		if (gDebug13)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));						Rect r;			GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);			r.right = 450;			r.bottom = 450;			EraseRect(&r);			gMainWindow->DrawGrid();						Point scrollOffset = {0, 0};			vector<BSpline*> workingBSplines;			DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);						surfaceSubregionGraph->DrawDebug(gMainWindow->CalcScrollOffset(), 0, 0, GetWindowPort(gMainWindow->GetWindow()));						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qc = 1;		}				//Might need to create edges across cuts.  Not sure.				surfaceSubregionGraphs.push_back(surfaceSubregionGraph);	}}SurfaceSubregionGraph* Drawing::BuildSurfacePerimeterGraph(WholeObject* wholeObject, vector<Subregion*> subregions){	if (gDebug13)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		gMainWindow->DrawGrid();				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		BSpline* woBsp = wholeObject->bsplines[0];	//debug		//As a starting point for building the graph, find a subregion in which this whole object is present in only one layer.	//There should always be such a "one-layer" subregion, no matter how complex the drawing is.	Subregion* seedSubregion = NULL;	vector<Subregion*> rejectedSeedSubregions;	OrientedBoundarySection startingSection;	while (true)	{		for (int i = 0; i < subregions.size(); i++)		{			if (find(rejectedSeedSubregions.begin(), rejectedSeedSubregions.end(), subregions[i]) != rejectedSeedSubregions.end())				continue;						if (gDebug13)			{				ForeColor(yellowColor);				subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				int qc = 1;			}						for (int j = 0; j < subregions[i]->enclosingWOs.size(); j++)				if (subregions[i]->enclosingWOs[j].first == wholeObject)				{					int woss = subregions[i]->enclosingWOs[j].second;					if (subregions[i]->enclosingWOs[j].second == -1)					{						if (gDebug13)						{							ForeColor(cyanColor);							subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));							int qc = 1;						}												seedSubregion = subregions[i];						break;					}				}						if (gDebug13)			{				ForeColor(whiteColor);				subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				ForeColor(blackColor);				subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);			}						if (seedSubregion)				break;		}		if (!seedSubregion)	//This should be impossible, but for debugging, let's leave it in			return NULL;				//Find a starting boundary section bordering the seed region		bool foundIt = false;		for (int j = 0; j < seedSubregion->obss.size(); j++)			if (seedSubregion->obss[j].bsp && seedSubregion->obss[j].traverseForward && find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), seedSubregion->obss[j].bsp) != wholeObject->bsplines.end())			{				startingSection = seedSubregion->obss[j];				MyAssert(startingSection.endCv != -1);				foundIt = true;				break;			}		if (!foundIt)	//Seemed like a good seed subregion, but actually it can't be used.  Add it to the reject list and try again.		{			rejectedSeedSubregions.push_back(seedSubregion);			seedSubregion = NULL;		}		else break;	//Good subregion	}	MyAssert(seedSubregion);		//Initialize the graph and add a graph node for the seed region	SurfaceSubregionGraph* surfaceSubregionGraph = new SurfaceSubregionGraph(wholeObject);	//SurfaceSubregionGraphNode* surfaceSubregionGraphNodeSeed = new SurfaceSubregionGraphNode(seedSubregion);	//surfaceSubregionGraph->nodes.push_back(surfaceSubregionGraphNodeSeed);		//Traverse the boundary of the whole object until the traversal comes back to the starting point	Subregion* presentSubregion = seedSubregion;	OrientedBoundarySection presentSection = startingSection;	SurfaceSubregionGraph::SurfaceSubregionGraphNode* prevSurfaceSubregionGraphNode = NULL;	SurfaceSubregionGraph::SurfaceSubregionGraphEdge* prevSurfaceSubregionGraphEdge = NULL;	bool traversingCutForward = true;	bool wrappedTraversal = false;	vector<int> traversedSubboundaries;	while (true)	{		if (!TestForMouseTermination())		{			delete surfaceSubregionGraph;			return NULL;		}				if (gDebug13)		{			ForeColor(yellowColor);			presentSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						Rect r;			FloatPoint loc = presentSection.startInter->GetLocation();			if (loc.h < 0)				loc.h = 0;			SetRect(&r, loc.h - 8, loc.v - 8, loc.h + 8, loc.v + 8);			PenSize(2, 2);			ForeColor(greenColor);			FrameOval(&r);			PenSize(1, 1);						loc = presentSection.endInter->GetLocation();			if (loc.h < 0)				loc.h = 0;			SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);			PenSize(2, 2);			ForeColor(redColor);			FrameOval(&r);			PenSize(1, 1);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qc = 1;		}				if (presentSection.endInter->GetType() != GenericIntersection::CUT_CUT)			MyAssert(presentSection.endCv != -1 || presentSection.endInfiniteWOsection != -1);				//Find the next intersection along the boundary after the present section, turning into and out of cuts at T junctions		GenericIntersection* endInter = presentSection.endInter;		GenericIntersection* nextInter = NULL;		if (endInter->GetType() != GenericIntersection::BSP_CUT_T)	//Not turning into or out of a cut		{			if (presentSection.bsp)			{				MyAssert(presentSection.endCv != -1 && presentSection.endSg != -1);				nextInter = presentSection.bsp->FindNextIntersection(endInter, presentSection.endCv, presentSection.endSg);			}			else if (presentSection.cut)			{				if (traversingCutForward)					nextInter = presentSection.cut->FindNextIntersection(endInter);				else nextInter = presentSection.cut->FindPrevIntersection(endInter);			}			else MyAssert(false);		}		else if (endInter != presentSection.startInter &&			presentSection.startInter->GetType() == GenericIntersection::BSP_CUT_T &&			((BspCutTIntersection*)endInter)->GetInfiniteWholeObject() &&			((BspCutTIntersection*)endInter)->GetInfiniteWholeObject() != wholeObject)	//Crossed an infinite BspCutT inter (this is similar to a BspCut inter)		{			nextInter = FindNextInfiniteSolidCut((BspCutTIntersection*)endInter, true);		}		else //Turn into or out of cut		{			BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)endInter;						if (presentSection.bsp)	//Turn into cut			{				if (bspCutTInter->GetAtStart())				{					traversingCutForward = true;					nextInter = bspCutTInter->GetCut()->FindNextIntersection(endInter);				}				else				{					traversingCutForward = false;					nextInter = bspCutTInter->GetCut()->FindPrevIntersection(endInter);				}			}			else if (presentSection.infiniteWO)			{				MyAssert(bspCutTInter->GetLocation().h < -999998);				MyAssert(!bspCutTInter->GetAtStart());				traversingCutForward = false;				nextInter = bspCutTInter->GetCut()->FindPrevIntersection(endInter);			}			else	//Turn out of cut			{				if (bspCutTInter->GetBsp())					nextInter = bspCutTInter->GetBsp()->FindNextIntersection(endInter, bspCutTInter->GetCv(), bspCutTInter->GetSg());				else				{					MyAssert(bspCutTInter->GetInfiniteWholeObject());					nextInter = FindNextInfiniteSolidCut(bspCutTInter, true);				}			}		}		MyAssert(nextInter);				if (gDebug13)		{			Rect r;			FloatPoint loc = nextInter->GetLocation();			if (loc.h < 0)				loc.h = 0;			SetRect(&r, loc.h - 12, loc.v - 12, loc.h + 12, loc.v + 12);			PenSize(2, 2);			ForeColor(blueColor);			FrameOval(&r);			PenSize(1, 1);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qc = 1;		}				//To find the next subregion and the next section, inspect the present subregion's neighboring subregions.  Find a neighbor that is bordered by the next boundary section.		Subregion* nextSubregion = NULL;		OrientedBoundarySection nextSection;		if (endInter->GetType() != GenericIntersection::BSP_CUT_T)		{			nextSection = OrientedBoundarySection(presentSection.bsp, presentSection.cut, presentSection.infiniteWO, presentSection.endInter, nextInter, presentSection.endCv, presentSection.endSg, presentSection.endInfiniteWOsection, presentSection.traverseForward);			for (int i = 0; i < presentSubregion->enclosingNeighbors.size(); i++)			{				if (gDebug13)				{					ForeColor(greenColor);					presentSubregion->enclosingNeighbors[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));					int qc = 1;				}								for (int j = 0; j < presentSubregion->enclosingNeighbors[i]->obss.size(); j++)				{					OrientedBoundarySection obssTest1 = presentSubregion->enclosingNeighbors[i]->obss[j];					if (presentSubregion->enclosingNeighbors[i]->obss[j] == nextSection)					{						if (gDebug13)						{							ForeColor(redColor);							presentSubregion->enclosingNeighbors[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));							int qc = 1;						}												nextSubregion = presentSubregion->enclosingNeighbors[i];						break;					}				}								if (gDebug13)				{					ForeColor(whiteColor);					presentSubregion->enclosingNeighbors[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));					ForeColor(blackColor);					presentSubregion->enclosingNeighbors[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);				}								if (nextSubregion)					break;			}						if (!nextSubregion)				for (int i = 0; i < presentSubregion->enclosedNeighbors.size(); i++)				{					if (gDebug13)					{						ForeColor(greenColor);						presentSubregion->enclosedNeighbors[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						int qc = 1;					}										for (int j = 0; j < presentSubregion->enclosedNeighbors[i]->obss.size(); j++)					{						OrientedBoundarySection obssTest2 = presentSubregion->enclosedNeighbors[i]->obss[j];						if (presentSubregion->enclosedNeighbors[i]->obss[j] == nextSection)						{							if (gDebug13)							{								ForeColor(redColor);								presentSubregion->enclosedNeighbors[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));								int qc = 1;							}														nextSubregion = presentSubregion->enclosedNeighbors[i];							break;						}					}										if (gDebug13)					{						ForeColor(whiteColor);						presentSubregion->enclosedNeighbors[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						ForeColor(blackColor);						presentSubregion->enclosedNeighbors[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);					}										if (nextSubregion)						break;				}		}		else if (((BspCutTIntersection*)endInter)->GetInfiniteWholeObject() &&				presentSection.infiniteWO &&				((BspCutTIntersection*)endInter)->GetInfiniteWholeObject() != wholeObject)	//Crossed an infinite BspCutT inter (this is similar to a BspCut inter)		{			MyAssert(endInter->GetLocation().h < -999998);			MyAssert(!presentSection.bsp && !presentSection.cut && presentSection.infiniteWO);			nextSection = OrientedBoundarySection(presentSection.bsp, presentSection.cut, presentSection.infiniteWO, presentSection.endInter, nextInter, presentSection.endCv, presentSection.endSg, presentSection.endInfiniteWOsection, presentSection.traverseForward);			for (int i = 0; i < presentSubregion->enclosingNeighbors.size(); i++)			{				if (gDebug13)				{					ForeColor(greenColor);					presentSubregion->enclosingNeighbors[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));					int qc = 1;				}								for (int j = 0; j < presentSubregion->enclosingNeighbors[i]->corners.size(); j++)				{					if (presentSubregion->enclosingNeighbors[i]->corners[j] == endInter)					{						int numCornerMatches = 0;						for (int k = 0; k < presentSubregion->enclosingNeighbors[i]->corners.size(); k++)							if (presentSubregion->enclosingNeighbors[i]->corners[k] == endInter)								numCornerMatches++;						MyAssert(numCornerMatches == 1 || numCornerMatches == 2);												if (numCornerMatches == 1)						{							MyAssert(presentSubregion->enclosingNeighbors[i]->corners[j]->GetType() == GenericIntersection::BSP_CUT_T);							MyAssert(((BspCutTIntersection*)presentSubregion->enclosingNeighbors[i]->corners[j])->GetInfiniteWholeObject());							MyAssert(((BspCutTIntersection*)presentSubregion->enclosingNeighbors[i]->corners[j])->GetInfiniteWholeObject() != presentSection.infiniteWO);														if (gDebug13)							{								ForeColor(redColor);								presentSubregion->enclosingNeighbors[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));								int qc = 1;							}														nextSubregion = presentSubregion->enclosingNeighbors[i];							break;						}					}				}								if (gDebug13)				{					ForeColor(whiteColor);					presentSubregion->enclosingNeighbors[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));					ForeColor(blackColor);					presentSubregion->enclosingNeighbors[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);				}								if (nextSubregion)					break;			}		}		else	//Turned into or out of a cut		{			nextSubregion = presentSubregion;			BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)endInter;			MyAssert(bspCutTInter->GetBsp() == presentSection.bsp || bspCutTInter->GetCut() == presentSection.cut);						if (presentSection.bsp)	//Turn into cut				nextSection = OrientedBoundarySection(NULL, bspCutTInter->GetCut(), NULL, presentSection.endInter, nextInter, presentSection.endCv, presentSection.endSg, presentSection.endInfiniteWOsection, bspCutTInter->GetAtStart());			else if (presentSection.infiniteWO)	//Turn into infinite cut from the infinite bspline end			{				MyAssert(presentSection.endInfiniteWOsection != -1);				nextSection = OrientedBoundarySection(NULL, bspCutTInter->GetCut(), NULL, presentSection.endInter, nextInter, presentSection.endCv, presentSection.endSg, presentSection.endInfiniteWOsection, bspCutTInter->GetAtStart());			}			else	//Turn out of cut			{				if (bspCutTInter->GetBsp())	//T junction at a normal (not infinite) bspline					nextSection = OrientedBoundarySection(bspCutTInter->GetBsp(), NULL, NULL, presentSection.endInter, nextInter, presentSection.endCv, presentSection.endSg, presentSection.endInfiniteWOsection, true);				else	//T junction at an infinite bspline				{					MyAssert(bspCutTInter->GetLocation().h < 0);					WholeObject* infiniteWO = bspCutTInter->GetInfiniteWholeObject();					MyAssert(infiniteWO);					MyAssert(presentSection.endInfiniteWOsection != -1);					nextSection = OrientedBoundarySection(NULL, NULL, infiniteWO, presentSection.endInter, nextInter, presentSection.endCv, presentSection.endSg, presentSection.endInfiniteWOsection, true);				}			}		}				if (!nextSubregion)	//It's possible the next subregion is the present subregion.  This can happen when crossing a cut.		{			if (gDebug13)			{				ForeColor(greenColor);				presentSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				int qc = 1;			}						for (int j = 0; j < presentSubregion->obss.size(); j++)			{				OrientedBoundarySection obssTest1 = presentSubregion->obss[j];				if (presentSubregion->obss[j] == nextSection)				{					if (gDebug13)					{						ForeColor(redColor);						presentSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						int qc = 1;					}										nextSubregion = presentSubregion;					break;				}			}						if (gDebug13)			{				ForeColor(whiteColor);				presentSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				ForeColor(blackColor);				presentSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);			}		}		MyAssert(nextSubregion);		if (!nextSubregion)			return NULL;	//DEBUG	only еее				//Finish filling in the next section.		//It looks like the following code doesn't do anything, since it first tests for equality and then performs an assignment on two seemingly identical section structs.		//However, the curve and segment at the end of the section are ambiguous and need to be resolved in this manner.		switch (nextSection.startInter->GetType())		{			case GenericIntersection::BSP_BSP:				//Will be handled below				break;			case GenericIntersection::BSP_CUT:				nextSection.startCv = ((BspCutIntersection*)nextSection.startInter)->GetCv();				nextSection.startSg = ((BspCutIntersection*)nextSection.startInter)->GetSg();				break;			case GenericIntersection::BSP_CUT_T:				nextSection.startCv = ((BspCutTIntersection*)nextSection.startInter)->GetCv();				nextSection.startSg = ((BspCutTIntersection*)nextSection.startInter)->GetSg();				nextSection.startInfiniteWOsection = ((BspCutTIntersection*)nextSection.startInter)->GetInfiniteWOsection();				break;			case GenericIntersection::CUT_CUT:				break;		}		switch (nextSection.endInter->GetType())		{			case GenericIntersection::BSP_BSP:				//Will be handled below				break;			case GenericIntersection::BSP_CUT:				nextSection.endCv = ((BspCutIntersection*)nextSection.endInter)->GetCv();				nextSection.endSg = ((BspCutIntersection*)nextSection.endInter)->GetSg();				break;			case GenericIntersection::BSP_CUT_T:				nextSection.endCv = ((BspCutTIntersection*)nextSection.endInter)->GetCv();				nextSection.endSg = ((BspCutTIntersection*)nextSection.endInter)->GetSg();				nextSection.endInfiniteWOsection = ((BspCutTIntersection*)nextSection.endInter)->GetInfiniteWOsection();				break;			case GenericIntersection::CUT_CUT:				break;		}				bool foundIt = false;		for (int j = 0; j < nextSubregion->obss.size(); j++)			if (nextSubregion->obss[j].bsp && nextSubregion->obss[j].traverseForward && nextSubregion->obss[j] == nextSection)			{				if (nextSubregion->obss[j].endInter->GetType() != GenericIntersection::CUT_CUT)					MyAssert(nextSubregion->obss[j].endCv != -1 || nextSubregion->obss[j].endInfiniteWOsection != -1);				nextSection = nextSubregion->obss[j];				foundIt = true;				break;			}			else if (nextSubregion->obss[j].cut && nextSubregion->obss[j] == nextSection)			{				if (nextSubregion->obss[j].endInter->GetType() != GenericIntersection::CUT_CUT)					MyAssert(nextSubregion->obss[j].endCv != -1 || nextSubregion->obss[j].endInfiniteWOsection != -1);				nextSection = nextSubregion->obss[j];				foundIt = true;				break;			}				if (!foundIt)	//Should only happen with infinite cuts			nextSection.subboundaryIndex = 0;				if (nextSection.endInter->GetType() != GenericIntersection::CUT_CUT)			MyAssert(nextSection.endCv != -1 || nextSection.endInfiniteWOsection != -1);				//Find the crossed section's bsp or cut		if ((nextSubregion != presentSubregion /*&& endInter->GetType() != GenericIntersection::BSP_CUT_T*/) || wrappedTraversal)		{			BSpline* crossedBSpline = NULL;			BSplineToBSplineCut* crossedCut = NULL;			if (presentSection.bsp)				switch (presentSection.endInter->GetType())				{					case GenericIntersection::BSP_BSP:						BspBspIntersection* bspBspInter = (BspBspIntersection*)presentSection.endInter;						crossedBSpline = bspBspInter->GetOtherBsp(presentSection.bsp);						break;					case GenericIntersection::BSP_CUT:						BspCutIntersection* bspCutInter = (BspCutIntersection*)presentSection.endInter;						crossedCut = bspCutInter->GetCut();						break;					case GenericIntersection::BSP_CUT_T:						break;					case GenericIntersection::CUT_CUT:						MyAssert(false);						break;				}			else if (presentSection.infiniteWO)				switch (presentSection.endInter->GetType())				{					case GenericIntersection::BSP_BSP:						MyAssert(false);						break;					case GenericIntersection::BSP_CUT:						MyAssert(false);						break;					case GenericIntersection::BSP_CUT_T:						BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)presentSection.endInter;						crossedCut = bspCutTInter->GetCut();						break;					case GenericIntersection::CUT_CUT:						MyAssert(false);						break;				}			else	//presentSection.cut				switch (presentSection.endInter->GetType())				{					case GenericIntersection::BSP_BSP:						MyAssert(false);						break;					case GenericIntersection::BSP_CUT:						BspCutIntersection* bspCutInter = (BspCutIntersection*)presentSection.endInter;						crossedBSpline = bspCutInter->GetBsp();						break;					case GenericIntersection::BSP_CUT_T:						break;					case GenericIntersection::CUT_CUT:						CutCutIntersection* cutCutInter = (CutCutIntersection*)presentSection.endInter;						crossedCut = cutCutInter->GetOtherCut(presentSection.cut);						break;				}			MyAssert(!crossedBSpline || !crossedCut);						//Find the crossed section's subboundary and the traversed section's subboundary			int crossedSubboundary = 0, traversedSubboundary = 0;			bool crossedIntoSurface = true;			if (crossedBSpline)			{				MyAssert(!crossedCut);				int crossedSectionStartCv = -1, crossedSectionStartSg = -1;				int traversedSectionStartCv = -1, traversedSectionStartSg = -1;				switch (presentSection.endInter->GetType())				{					case GenericIntersection::BSP_BSP:						BspBspIntersection* bspBspInter = (BspBspIntersection*)presentSection.endInter;						bool traversingOnTop = true;						if (!bspBspInter->SelfIntersection())							traversingOnTop = (bspBspInter->GetBsp1() == presentSection.bsp);						else	//Self intersection						{							if (bspBspInter->GetCv1() == nextSection.startCv && bspBspInter->GetSg1() == nextSection.startSg)								traversingOnTop = true;							else							{								MyAssert(bspBspInter->GetCv2() == nextSection.startCv && bspBspInter->GetSg2() == nextSection.startSg);								traversingOnTop = false;							}						}												if (traversingOnTop)						{							crossedSectionStartCv = bspBspInter->GetCv2();							crossedSectionStartSg = bspBspInter->GetSg2();						}						else						{							crossedSectionStartCv = bspBspInter->GetCv1();							crossedSectionStartSg = bspBspInter->GetSg1();						}												switch (presentSection.startInter->GetType())						{							case GenericIntersection::BSP_BSP:								BspBspIntersection* bspBspInter1 = (BspBspIntersection*)presentSection.startInter;								bool traversingOnTop1 = true;								if (!bspBspInter1->SelfIntersection())									traversingOnTop1 = (bspBspInter1->GetBsp1() == presentSection.bsp);								else	//Self intersection								{									if (bspBspInter1->GetCv1() == presentSection.startCv && bspBspInter1->GetSg1() == presentSection.startSg)										traversingOnTop1 = true;									else									{										MyAssert(bspBspInter1->GetCv2() == presentSection.startCv && bspBspInter1->GetSg2() == presentSection.startSg);										traversingOnTop1 = false;									}								}																if (traversingOnTop1)								{									traversedSectionStartCv = bspBspInter1->GetCv1();									traversedSectionStartSg = bspBspInter1->GetSg1();								}								else								{									traversedSectionStartCv = bspBspInter1->GetCv2();									traversedSectionStartSg = bspBspInter1->GetSg2();								}								break;							case GenericIntersection::BSP_CUT:								BspCutIntersection* bspCutInter = (BspCutIntersection*)presentSection.startInter;								if (presentSection.bsp)								{									traversedSectionStartCv = bspCutInter->GetCv();									traversedSectionStartSg = bspCutInter->GetSg();								}								else								{									MyAssert(false);	//Is this possible?  I'm not at all sure.									traversedSectionStartCv = traversedSectionStartSg = -1;								}								break;							case GenericIntersection::BSP_CUT_T:								MyAssert(presentSection.bsp && !presentSection.cut);								BspCutTIntersection* bspCutTInter1 = (BspCutTIntersection*)presentSection.startInter;								traversedSectionStartCv = bspCutTInter1->GetCv();								traversedSectionStartSg = bspCutTInter1->GetSg();								break;							case GenericIntersection::CUT_CUT:								MyAssert(false);	//Not implemented yet								break;						}												bool dg1 = gDebug13;						//gDebug13 = false;												int occludedEdge = bspBspInter->DetermineOccludedEdge();						UnorientedBoundarySection crossedUbs, traversedUbs;						MyAssert(!crossedCut);						if (traversingOnTop)						{							if (occludedEdge == 3)							{								crossedUbs = UnorientedBoundarySection(crossedBSpline, crossedCut, NULL, presentSection.endInter, crossedBSpline->FindPrevIntersection(presentSection.endInter, crossedSectionStartCv, crossedSectionStartSg), crossedSectionStartCv, crossedSectionStartSg, -1, false);								crossedSubboundary = crossedBSpline->FindSubboundaryForSection(crossedUbs);								crossedIntoSurface = true;							}							else	//occludedEdge == 4							{								crossedUbs = UnorientedBoundarySection(crossedBSpline, crossedCut, NULL, presentSection.endInter, crossedBSpline->FindNextIntersection(presentSection.endInter, crossedSectionStartCv, crossedSectionStartSg), crossedSectionStartCv, crossedSectionStartSg, -1, true);								crossedSubboundary = crossedBSpline->FindSubboundaryForSection(crossedUbs);								crossedIntoSurface = false;							}						}						else //not traversingOnTop						{							if (occludedEdge == 3)							{								crossedUbs = UnorientedBoundarySection(crossedBSpline, crossedCut, NULL, presentSection.endInter, crossedBSpline->FindNextIntersection(presentSection.endInter, crossedSectionStartCv, crossedSectionStartSg), crossedSectionStartCv, crossedSectionStartSg, -1, true);								crossedSubboundary = crossedBSpline->FindSubboundaryForSection(crossedUbs);								crossedIntoSurface = false;							}							else	//occludedEdge == 4							{								crossedUbs = UnorientedBoundarySection(crossedBSpline, crossedCut, NULL, presentSection.endInter, crossedBSpline->FindPrevIntersection(presentSection.endInter, crossedSectionStartCv, crossedSectionStartSg), crossedSectionStartCv, crossedSectionStartSg, -1, false);								crossedSubboundary = crossedBSpline->FindSubboundaryForSection(crossedUbs);								crossedIntoSurface = true;							}						}												MyAssert(!presentSection.infiniteWO);						traversedUbs = UnorientedBoundarySection(presentSection.bsp, presentSection.cut, presentSection.infiniteWO, presentSection.startInter, presentSection.endInter, traversedSectionStartCv, traversedSectionStartSg, -1, true);						MyAssert(presentSection.bsp && !presentSection.cut);						traversedSubboundary = presentSection.bsp->FindSubboundaryForSection(traversedUbs);												if (gDebug13)						{							Rect r;							PenSize(2, 2);														FloatPoint loc = crossedUbs.startInter->GetLocation();							if (loc.h < 0)								loc.h = 0;							SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);							ForeColor(magentaColor);							PaintOval(&r);														FloatPoint loc2 = crossedUbs.endInter->GetLocation();							if (loc2.h < 0)								loc2.h = 0;							SetRect(&r, loc2.h - 6, loc2.v - 6, loc2.h + 6, loc2.v + 6);							ForeColor(cyanColor);							PaintOval(&r);														ForeColor(blackColor);							TextFace(bold);							TextSize(18);							Str255 str;							NumToString(crossedSubboundary, str);							MoveTo((loc.h + loc2.h) / 2, (loc.v + loc2.v) / 2);							DrawString(str);														QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);							int qc = 1;														ForeColor(whiteColor);							loc = crossedUbs.startInter->GetLocation();							if (loc.h < 0)								loc.h = 0;							SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);							PaintOval(&r);														loc2 = crossedUbs.endInter->GetLocation();							if (loc2.h < 0)								loc2.h = 0;							SetRect(&r, loc2.h - 6, loc2.v - 6, loc2.h + 6, loc2.v + 6);							PaintOval(&r);														MoveTo((loc.h + loc2.h) / 2, (loc.v + loc2.v) / 2);							DrawString(str);														PenSize(1, 1);						}												gDebug13 = dg1;						break;					case GenericIntersection::BSP_CUT:						BspCutIntersection* bspCutInter = (BspCutIntersection*)presentSection.endInter;						crossedSectionStartCv = bspCutInter->GetCv();						crossedSectionStartSg = bspCutInter->GetSg();						BspCutIntersection* bspCutInter1 = (BspCutIntersection*)presentSection.startInter;						traversedSectionStartCv = bspCutInter1->GetCv();						traversedSectionStartSg = bspCutInter1->GetSg();												bool dg2 = gDebug13;						//gDebug13 = false;												int occludedEdge1 = bspCutInter->DetermineOccludedEdgeIgnoreTopBottom();						MyAssert(!crossedCut);						if ((occludedEdge1 == 1 && !traversingCutForward) || (occludedEdge1 == 2 && traversingCutForward))						{							crossedUbs = UnorientedBoundarySection(crossedBSpline, crossedCut, NULL, presentSection.endInter, crossedBSpline->FindPrevIntersection(presentSection.endInter, crossedSectionStartCv, crossedSectionStartSg), crossedSectionStartCv, crossedSectionStartSg, -1, false);							crossedSubboundary = crossedBSpline->FindSubboundaryForSection(crossedUbs);							crossedIntoSurface = true;						}						else						{							crossedUbs = UnorientedBoundarySection(crossedBSpline, crossedCut, NULL, presentSection.endInter, crossedBSpline->FindNextIntersection(presentSection.endInter, crossedSectionStartCv, crossedSectionStartSg), crossedSectionStartCv, crossedSectionStartSg, -1, true);							crossedSubboundary = crossedBSpline->FindSubboundaryForSection(crossedUbs);							crossedIntoSurface = false;						}												MyAssert(!presentSection.infiniteWO);						traversedUbs = UnorientedBoundarySection(presentSection.bsp, presentSection.cut, presentSection.infiniteWO, presentSection.startInter, presentSection.endInter, traversedSectionStartCv, traversedSectionStartSg, -1, true);						MyAssert(!presentSection.bsp && presentSection.cut);						traversedSubboundary = 0;	//Is this the right way to do this?  It gets set more precisely for a bspline than for a cut.												gDebug13 = dg2;												if (gDebug13)						{							Rect r;							PenSize(2, 2);														FloatPoint loc = crossedUbs.startInter->GetLocation();							if (loc.h < 0)								loc.h = 0;							SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);							ForeColor(magentaColor);							PaintOval(&r);														FloatPoint loc2 = crossedUbs.endInter->GetLocation();							if (loc2.h < 0)								loc2.h = 0;							SetRect(&r, loc2.h - 6, loc2.v - 6, loc2.h + 6, loc2.v + 6);							ForeColor(cyanColor);							PaintOval(&r);														ForeColor(blackColor);							TextFace(bold);							TextSize(18);							Str255 str;							NumToString(crossedSubboundary, str);							MoveTo((loc.h + loc2.h) / 2, (loc.v + loc2.v) / 2);							DrawString(str);														QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);							int qc = 1;														ForeColor(whiteColor);							loc = crossedUbs.startInter->GetLocation();							if (loc.h < 0)								loc.h = 0;							SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);							PaintOval(&r);														loc2 = crossedUbs.endInter->GetLocation();							if (loc2.h < 0)								loc2.h = 0;							SetRect(&r, loc2.h - 6, loc2.v - 6, loc2.h + 6, loc2.v + 6);							PaintOval(&r);														MoveTo((loc.h + loc2.h) / 2, (loc.v + loc2.v) / 2);							DrawString(str);														PenSize(1, 1);						}						break;					case GenericIntersection::BSP_CUT_T:						MyAssert(false);						break;					case GenericIntersection::CUT_CUT:						MyAssert(false);						break;				}			}	//End if (crossedBSpline)						if (!wrappedTraversal)	//Create a graph node, add it to the graph, and connect it to the previous node			{				SurfaceSubregionGraph::SurfaceSubregionGraphNode* surfaceSubregionGraphNode = new SurfaceSubregionGraph::SurfaceSubregionGraphNode(presentSubregion);				surfaceSubregionGraphNode->crossedSubboundaries.push_back(crossedSubboundary);				surfaceSubregionGraphNode->uncrossableSubboundaries.push_back(traversedSubboundary);				for (int i = 0; i < traversedSubboundaries.size(); i++)					surfaceSubregionGraphNode->uncrossableSubboundaries.push_back(traversedSubboundaries[i]);				surfaceSubregionGraph->nodes.push_back(surfaceSubregionGraphNode);								if (prevSurfaceSubregionGraphEdge)				{					MyAssert(!prevSurfaceSubregionGraphEdge->nodeTo);					prevSurfaceSubregionGraphEdge->nodeTo = surfaceSubregionGraphNode;				}								SurfaceSubregionGraph::SurfaceSubregionGraphEdge* surfaceSubregionGraphEdge = new SurfaceSubregionGraph::SurfaceSubregionGraphEdge(surfaceSubregionGraphNode, NULL, crossedBSpline, crossedCut, crossedSubboundary, crossedIntoSurface);				surfaceSubregionGraph->edges.push_back(surfaceSubregionGraphEdge);				surfaceSubregionGraphNode->fromToEdgePairs.push_back(pair<SurfaceSubregionGraph::SurfaceSubregionGraphEdge*, SurfaceSubregionGraph::SurfaceSubregionGraphEdge*>(prevSurfaceSubregionGraphEdge, surfaceSubregionGraphEdge));								prevSurfaceSubregionGraphNode = surfaceSubregionGraphNode;				prevSurfaceSubregionGraphEdge = surfaceSubregionGraphEdge;			}			else	//Connect the last node in the traversal to the first node in the traversal			{				if (surfaceSubregionGraph->nodes.size() > 0)				{					SurfaceSubregionGraph::SurfaceSubregionGraphNode* firstSurfaceSubregionGraphNode = surfaceSubregionGraph->nodes.front();					SurfaceSubregionGraph::SurfaceSubregionGraphNode* lastSurfaceSubregionGraphNode = surfaceSubregionGraph->nodes.back();					MyAssert(firstSurfaceSubregionGraphNode->fromToEdgePairs.size() > 0);										MyAssert(!firstSurfaceSubregionGraphNode->fromToEdgePairs[0].first);					firstSurfaceSubregionGraphNode->fromToEdgePairs[0].first = lastSurfaceSubregionGraphNode->fromToEdgePairs.back().second;										MyAssert(!lastSurfaceSubregionGraphNode->fromToEdgePairs.back().second->nodeTo);					lastSurfaceSubregionGraphNode->fromToEdgePairs.back().second->nodeTo = firstSurfaceSubregionGraphNode;				}				else				{					SurfaceSubregionGraph::SurfaceSubregionGraphNode* surfaceSubregionGraphNode = new SurfaceSubregionGraph::SurfaceSubregionGraphNode(presentSubregion);					surfaceSubregionGraphNode->crossedSubboundaries.push_back(crossedSubboundary);					surfaceSubregionGraphNode->uncrossableSubboundaries.push_back(traversedSubboundary);					for (int i = 0; i < traversedSubboundaries.size(); i++)						surfaceSubregionGraphNode->uncrossableSubboundaries.push_back(traversedSubboundaries[i]);					surfaceSubregionGraph->nodes.push_back(surfaceSubregionGraphNode);				}			}						traversedSubboundaries.clear();		}		else		{			MyAssert(nextSubregion == presentSubregion);			if (presentSection.bsp)			{				int traversedSectionStartCv = -1, traversedSectionStartSg = -1;								switch (presentSection.startInter->GetType())				{					case GenericIntersection::BSP_BSP:						BspBspIntersection* bspBspInter1 = (BspBspIntersection*)presentSection.startInter;						bool traversingOnTop1 = true;						if (!bspBspInter1->SelfIntersection())							traversingOnTop1 = (bspBspInter1->GetBsp1() == presentSection.bsp);						else	//Self intersection						{							if (bspBspInter1->GetCv1() == presentSection.startCv && bspBspInter1->GetSg1() == presentSection.startSg)								traversingOnTop1 = true;							else							{								MyAssert(bspBspInter1->GetCv2() == presentSection.startCv && bspBspInter1->GetSg2() == presentSection.startSg);								traversingOnTop1 = false;							}						}												if (traversingOnTop1)						{							traversedSectionStartCv = bspBspInter1->GetCv1();							traversedSectionStartSg = bspBspInter1->GetSg1();						}						else						{							traversedSectionStartCv = bspBspInter1->GetCv2();							traversedSectionStartSg = bspBspInter1->GetSg2();						}						break;					case GenericIntersection::BSP_CUT:						BspCutIntersection* bspCutInter1 = (BspCutIntersection*)presentSection.startInter;						traversedSectionStartCv = bspCutInter1->GetCv();						traversedSectionStartSg = bspCutInter1->GetSg();						break;					case GenericIntersection::BSP_CUT_T:						MyAssert(presentSection.bsp && !presentSection.cut);						BspCutTIntersection* bspCutTInter1 = (BspCutTIntersection*)presentSection.startInter;						traversedSectionStartCv = bspCutTInter1->GetCv();						traversedSectionStartSg = bspCutTInter1->GetSg();						break;					case GenericIntersection::CUT_CUT:						MyAssert(false);	//Not implemented yet						break;				}								bool dg3 = gDebug13;				gDebug13 = false;								MyAssert(!presentSection.infiniteWO);				UnorientedBoundarySection traversedUbs = UnorientedBoundarySection(presentSection.bsp, presentSection.cut, presentSection.infiniteWO, presentSection.startInter, presentSection.endInter, traversedSectionStartCv, traversedSectionStartSg, -1, true);				traversedSubboundaries.push_back(presentSection.bsp->FindSubboundaryForSection(traversedUbs));								gDebug13 = dg3;			}		}				if (gDebug13)		{			ForeColor(whiteColor);			presentSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			ForeColor(blackColor);			presentSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);						ForeColor(whiteColor);						Rect r;			FloatPoint loc = presentSection.startInter->GetLocation();			if (loc.h < 0)				loc.h = 0;			SetRect(&r, loc.h - 8, loc.v - 8, loc.h + 8, loc.v + 8);			PenSize(2, 2);			FrameOval(&r);			PenSize(1, 1);						loc = presentSection.endInter->GetLocation();			if (loc.h < 0)				loc.h = 0;			SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);			PenSize(2, 2);			FrameOval(&r);			PenSize(1, 1);						loc = nextInter->GetLocation();			if (loc.h < 0)				loc.h = 0;			SetRect(&r, loc.h - 12, loc.v - 12, loc.h + 12, loc.v + 12);			PenSize(2, 2);			FrameOval(&r);			PenSize(1, 1);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}				if (nextSection.endInter->GetType() != GenericIntersection::CUT_CUT)			MyAssert(nextSection.endCv != -1 || nextSection.endInfiniteWOsection != -1);				//Advance the traversal		presentSubregion = nextSubregion;		presentSection = nextSection;				if (wrappedTraversal)			break;		if (presentSection == startingSection)			wrappedTraversal = true;	}		return surfaceSubregionGraph;}void Drawing::PinchSurfaceSubregionGraphSingleNodes(SurfaceSubregionGraph*& surfaceSubregionGraph, WholeObject* wholeObject, vector<Subregion*> subregions){	if (gDebug13)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		gMainWindow->DrawGrid();				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		//Build a list of all the single nodes for this surface	vector<Subregion*> singleSubregions;	for (int i = 0; i < subregions.size(); i++)	{		if (gDebug13)		{			ForeColor(yellowColor);			subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			int qc = 1;		}				for (int j = 0; j < subregions[i]->enclosingWOs.size(); j++)			if (subregions[i]->enclosingWOs[j].first == wholeObject)			{				int woss = subregions[i]->enclosingWOs[j].second;				if (subregions[i]->enclosingWOs[j].second == -1)				{					if (gDebug13)					{						ForeColor(cyanColor);						subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						int qc = 1;					}										singleSubregions.push_back(subregions[i]);					break;				}			}				if (gDebug13)		{			ForeColor(whiteColor);			subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			ForeColor(blackColor);			subregions[i]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);			int qc = 1;		}	}		//Build graph nodes for each single node.  These nodes will then accumulate the union of the singles that need to be pinched in the graph.	vector<SurfaceSubregionGraph::SurfaceSubregionGraphNode*> singleNodes;	for (int i = 0; i < singleSubregions.size(); i++)		singleNodes.push_back(new SurfaceSubregionGraph::SurfaceSubregionGraphNode(singleSubregions[i]));		//Make a new vector of nodes and put the single nodes in it	vector<SurfaceSubregionGraph::SurfaceSubregionGraphNode*> newNodeVec;	for (int i = 0; i < singleNodes.size(); i++)		newNodeVec.push_back(singleNodes[i]);	int newNodeVecSingleNodesSize = newNodeVec.size();	//debug		//Go through the graph, one node at a time, merging single nodes into the newly created single nodes, and deleting the nodes along the way	int numNodesMerged = 0, numNodesAdded = 0;	//debug	for (int i = 0; i < surfaceSubregionGraph->nodes.size(); i++)	{		if (!TestForMouseTermination())			return;				SurfaceSubregionGraph::SurfaceSubregionGraphNode* surfaceSubregionGraphNode = surfaceSubregionGraph->nodes[i];		Subregion* sr1 = surfaceSubregionGraphNode->subregion;	//debug				if (gDebug13)		{			ForeColor(yellowColor);			sr1->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			int qc = 1;		}				if (find(singleSubregions.begin(), singleSubregions.end(), surfaceSubregionGraphNode->subregion) != singleSubregions.end())		{			if (gDebug13)			{				ForeColor(cyanColor);				surfaceSubregionGraphNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				int qc = 1;			}						//Find the merge-node corresponding to this subregion			SurfaceSubregionGraph::SurfaceSubregionGraphNode* singleNode = NULL;			for (int j = 0; j < singleNodes.size(); j++)				if (singleNodes[j]->subregion == surfaceSubregionGraphNode->subregion)				{					singleNode = singleNodes[j];					break;				}			MyAssert(singleNode);						if (gDebug13 && singleNode->fromToEdgePairs.size() > 0)			{				ForeColor(redColor);				surfaceSubregionGraphNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				int qc = 1;			}						//Merge the node from the graph into the single node			for (int j = 0; j < surfaceSubregionGraphNode->crossedSubboundaries.size(); j++)				if (find(singleNode->crossedSubboundaries.begin(), singleNode->crossedSubboundaries.end(), surfaceSubregionGraphNode->crossedSubboundaries[j]) == singleNode->crossedSubboundaries.end())					singleNode->crossedSubboundaries.push_back(surfaceSubregionGraphNode->crossedSubboundaries[j]);			for (int j = 0; j < surfaceSubregionGraphNode->uncrossableSubboundaries.size(); j++)				if (find(singleNode->uncrossableSubboundaries.begin(), singleNode->uncrossableSubboundaries.end(), surfaceSubregionGraphNode->uncrossableSubboundaries[j]) == singleNode->uncrossableSubboundaries.end())					singleNode->uncrossableSubboundaries.push_back(surfaceSubregionGraphNode->uncrossableSubboundaries[j]);						MyAssert(surfaceSubregionGraphNode->fromToEdgePairs.size() <= 1);			if (surfaceSubregionGraphNode->fromToEdgePairs.size() == 1)			{				//The edge will be pointing to the old node, not the new single node, but this will be fixed below				singleNode->fromToEdgePairs.push_back(surfaceSubregionGraphNode->fromToEdgePairs[0]);								//Replace the node in the graph with the single node, fix the edges				MyAssert(surfaceSubregionGraphNode->fromToEdgePairs[0].first->nodeTo == surfaceSubregionGraphNode && surfaceSubregionGraphNode->fromToEdgePairs[0].second->nodeFrom == surfaceSubregionGraphNode);				MyAssert(singleNode->fromToEdgePairs.back() == surfaceSubregionGraphNode->fromToEdgePairs[0]);				surfaceSubregionGraphNode->fromToEdgePairs[0].first->nodeTo = surfaceSubregionGraphNode->fromToEdgePairs[0].second->nodeFrom = singleNode;			}						delete surfaceSubregionGraphNode;						numNodesMerged++;		}		else		{			if (gDebug13)			{				ForeColor(blueColor);				surfaceSubregionGraphNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				int qc = 1;			}						newNodeVec.push_back(surfaceSubregionGraphNode);	//Not a single node, so put it in the new node vector						numNodesAdded++;		}				if (gDebug13)		{			ForeColor(whiteColor);			sr1->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			ForeColor(blackColor);			sr1->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);			int qc = 1;		}	}		if (gDebug13)	{		for (int i = 0; i < newNodeVec.size(); i++)			if (newNodeVec[i]->fromToEdgePairs.size() == 0)			{				ForeColor(redColor);				newNodeVec[i]->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			}		int qc = 1;		for (int i = 0; i < newNodeVec.size(); i++)			if (newNodeVec[i]->fromToEdgePairs.size() == 1)			{				ForeColor(greenColor);				newNodeVec[i]->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			}		qc = 1;		for (int i = 0; i < newNodeVec.size(); i++)			if (newNodeVec[i]->fromToEdgePairs.size() >= 2)			{				ForeColor(yellowColor);				newNodeVec[i]->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			}		qc = 1;	}		//Copy over the new node vector	surfaceSubregionGraph->nodes.clear();	for (int i = 0; i < newNodeVec.size(); i++)		surfaceSubregionGraph->nodes.push_back(newNodeVec[i]);		//Just for debugging, remake the edges vector	surfaceSubregionGraph->edges.clear();	for (int i = 0; i < surfaceSubregionGraph->nodes.size(); i++)	{		SurfaceSubregionGraph::SurfaceSubregionGraphNode* surfaceSubregionGraphNode = surfaceSubregionGraph->nodes[i];		for (int j = 0; j < surfaceSubregionGraphNode->fromToEdgePairs.size(); j++)			surfaceSubregionGraph->edges.push_back(surfaceSubregionGraphNode->fromToEdgePairs[j].second);	}		if (gDebug13)		int qc = 1;}void Drawing::PinchSurfaceSubregionGraphSymmetries(SurfaceSubregionGraph*& surfaceSubregionGraph, WholeObject* wholeObject, vector<Subregion*> subregions){	if (gDebug13)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		gMainWindow->DrawGrid();				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		while (true)	{		//Find a symmetry		bool foundSymmetry = false;		for (int i = 0; i < surfaceSubregionGraph->nodes.size(); i++)		{			if (!TestForMouseTermination())				return;						SurfaceSubregionGraph::SurfaceSubregionGraphNode* graphNode = surfaceSubregionGraph->nodes[i];						if (gDebug13)			{				SetPort(GetWindowPort(gMainWindow->GetWindow()));								Rect r;				GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);				EraseRect(&r);				gMainWindow->DrawGrid();								Point scrollOffset = {0, 0};				vector<BSpline*> workingBSplines;				DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								ForeColor(yellowColor);				graphNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				int qc = 1;			}						for (int j = 0; j < graphNode->fromToEdgePairs.size(); j++)			{				for (int k = j; k < graphNode->fromToEdgePairs.size(); k++)				{					SurfaceSubregionGraph::SurfaceSubregionGraphEdge* fromEdgeA = graphNode->fromToEdgePairs[j].first;					SurfaceSubregionGraph::SurfaceSubregionGraphEdge* toEdgeB = graphNode->fromToEdgePairs[k].second;										if (gDebug13)					{						ForeColor(magentaColor);						fromEdgeA->nodeFrom->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						ForeColor(yellowColor);						fromEdgeA->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						ForeColor(cyanColor);						toEdgeB->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));												int qc = 1;												ForeColor(whiteColor);						fromEdgeA->nodeFrom->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						fromEdgeA->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						toEdgeB->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						ForeColor(blackColor);						fromEdgeA->nodeFrom->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);						fromEdgeA->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);						toEdgeB->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);					}										if (fromEdgeA->nodeFrom != toEdgeB->nodeTo && fromEdgeA->IsSymmetrical(toEdgeB))					{						MyAssert(fromEdgeA->nodeFrom->subregion == toEdgeB->nodeTo->subregion);												if (gDebug13)						{							ForeColor(redColor);							fromEdgeA->nodeFrom->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));							ForeColor(yellowColor);							fromEdgeA->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));							ForeColor(blueColor);							toEdgeB->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));														int qc = 1;														ForeColor(whiteColor);							fromEdgeA->nodeFrom->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));							fromEdgeA->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));							toEdgeB->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));							ForeColor(blackColor);							fromEdgeA->nodeFrom->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);							fromEdgeA->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);							toEdgeB->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);						}												//Merge the latter node into the former node						SurfaceSubregionGraph::SurfaceSubregionGraphNode* nodeToDelete = toEdgeB->nodeTo;												for (int k = 0; k < nodeToDelete->crossedSubboundaries.size(); k++)							if (find(fromEdgeA->nodeFrom->crossedSubboundaries.begin(), fromEdgeA->nodeFrom->crossedSubboundaries.end(), nodeToDelete->crossedSubboundaries[k]) == fromEdgeA->nodeFrom->crossedSubboundaries.end())								fromEdgeA->nodeFrom->crossedSubboundaries.push_back(nodeToDelete->crossedSubboundaries[k]);						for (int k = 0; k < nodeToDelete->uncrossableSubboundaries.size(); k++)							if (find(fromEdgeA->nodeFrom->uncrossableSubboundaries.begin(), fromEdgeA->nodeFrom->uncrossableSubboundaries.end(), nodeToDelete->uncrossableSubboundaries[k]) == fromEdgeA->nodeFrom->uncrossableSubboundaries.end())								fromEdgeA->nodeFrom->uncrossableSubboundaries.push_back(nodeToDelete->uncrossableSubboundaries[k]);												for (int k = 0; k < nodeToDelete->fromToEdgePairs.size(); k++)						{							SurfaceSubregionGraph::SurfaceSubregionGraphEdge* toEdge2 = nodeToDelete->fromToEdgePairs[k].second;							MyAssert(toEdge2->nodeFrom == nodeToDelete);														toEdgeB->nodeTo = fromEdgeA->nodeFrom;							toEdge2->nodeFrom = fromEdgeA->nodeFrom;														nodeToDelete->fromToEdgePairs[k].first->nodeTo = fromEdgeA->nodeFrom;							nodeToDelete->fromToEdgePairs[k].second->nodeFrom = fromEdgeA->nodeFrom;							MyAssert(fromEdgeA->nodeFrom != nodeToDelete);							fromEdgeA->nodeFrom->fromToEdgePairs.push_back(nodeToDelete->fromToEdgePairs[k]);						}												//Delete the latter node						bool foundIt = false;						for (vector<SurfaceSubregionGraph::SurfaceSubregionGraphNode*>::iterator iter = surfaceSubregionGraph->nodes.begin(); iter != surfaceSubregionGraph->nodes.end(); iter++)							if (*iter == nodeToDelete)							{								surfaceSubregionGraph->nodes.erase(iter);								foundIt = true;								break;							}						MyAssert(foundIt);						delete nodeToDelete;												foundSymmetry = true;						break;					}				}								if (foundSymmetry)					break;			}						if (gDebug13)			{				ForeColor(whiteColor);				graphNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				ForeColor(blackColor);				graphNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);				int qc = 1;			}						if (foundSymmetry)				break;		}				if (gDebug13)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));						Rect r;			GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);			r.top = 450;			EraseRect(&r);			gMainWindow->DrawGrid();						Point scrollOffset = {0, 0};			vector<BSpline*> workingBSplines;			DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);						surfaceSubregionGraph->DrawDebug(gMainWindow->CalcScrollOffset(), 0, 450, GetWindowPort(gMainWindow->GetWindow()));						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qc = 1;		}				if (!foundSymmetry)			break;	}}void Drawing::AddSurfaceSubregionGraphSpills(SurfaceSubregionGraph*& surfaceSubregionGraph, WholeObject* wholeObject, vector<Subregion*> subregions){	if (gDebug13)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		gMainWindow->DrawGrid();				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		list<SurfaceSubregionGraph::SurfaceSubregionGraphNode*> newNodes;	int q1 = 99;	for (int i = 0; i < surfaceSubregionGraph->nodes.size(); i++)	{		if (i == q1)		{			int q2 = 1;		}		AddSurfaceSubregionGraphSpillsForOneNode(surfaceSubregionGraph->nodes[i], surfaceSubregionGraph, wholeObject, subregions, newNodes);				if (gMouseTerminated)			return;	}		for (list<SurfaceSubregionGraph::SurfaceSubregionGraphNode*>::iterator i = newNodes.begin(); i != newNodes.end(); i++)		surfaceSubregionGraph->nodes.push_back(*i);		for (list<SurfaceSubregionGraph::SurfaceSubregionGraphNode*>::iterator i = newNodes.begin(); i != newNodes.end(); i++)	{		int numNewNodes = newNodes.size();		list<SurfaceSubregionGraph::SurfaceSubregionGraphNode*>::iterator j = newNodes.end();		j--;		AddSurfaceSubregionGraphSpillsForOneNode(*i, surfaceSubregionGraph, wholeObject, subregions, newNodes);				if (gMouseTerminated)			return;				if (newNodes.size() != numNewNodes)		{			//I'm not sure why I used to think this was limited to 1.  Is it?			//MyAssert(newNodes.size() == numNewNodes + 1);			//surfaceSubregionGraph->nodes.push_back(newNodes.back());						list<SurfaceSubregionGraph::SurfaceSubregionGraphNode*>::iterator k = j;			k++;			for (; k != newNodes.end(); k++)				surfaceSubregionGraph->nodes.push_back(*k);		}	}}void Drawing::AddSurfaceSubregionGraphSpillsForOneNode(SurfaceSubregionGraph::SurfaceSubregionGraphNode* surfaceSubregionGraphNode, SurfaceSubregionGraph*& surfaceSubregionGraph, WholeObject* wholeObject, vector<Subregion*> subregions, list<SurfaceSubregionGraph::SurfaceSubregionGraphNode*>& newNodes){	if (gDebug13)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		gMainWindow->DrawGrid();				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		Subregion* subregion = surfaceSubregionGraphNode->subregion;		bool foundIt = false;	for (int j = 0; j < subregion->enclosingWOs.size(); j++)		if (subregion->enclosingWOs[j].first == wholeObject)		{			foundIt = true;			break;		}	//gDebug13 = false;	if (!foundIt)	{		//gDebug13 = true;		//MyAssert(false);	//Just an assert to cause a semi-permanent breakpoint		return;	//No real harm seems to come from just abandoning at this point, although there may be an underlying bug, I'm not sure.	}		if (gDebug13)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		gMainWindow->DrawGrid();				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				ForeColor(yellowColor);		subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				int qc = 1;	}		//Assert that the node's crossed subboundaries do not match any of the uncrossable subboundaries	for (int j = 0; j < surfaceSubregionGraphNode->crossedSubboundaries.size(); j++)		for (int k = 0; k < surfaceSubregionGraphNode->uncrossableSubboundaries.size(); k++)			if (!(surfaceSubregionGraphNode->crossedSubboundaries[j] != surfaceSubregionGraphNode->uncrossableSubboundaries[k]))			{				if (gDebug13)				{					ForeColor(redColor);					subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));					int qc = 1;				}				//MyAssert(false);	//Will legally fail for a cut subboundary			}		//Loop through the node's subregion's obss to find the subregion	for (int j = 0; j < subregion->obss.size(); j++)	{		OrientedBoundarySection obs1 = subregion->obss[j];	//debug				if (gDebug13)		{			Rect r;						PenSize(2, 2);						FloatPoint loc = subregion->obss[j].startInter->GetLocation();			if (loc.h < 0)				loc.h = 0;			SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);			ForeColor(magentaColor);			FrameOval(&r);						FloatPoint loc2 = subregion->obss[j].endInter->GetLocation();			if (loc2.h < 0)				loc2.h = 0;			SetRect(&r, loc2.h - 6, loc2.v - 6, loc2.h + 6, loc2.v + 6);			ForeColor(cyanColor);			FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			int qc = 1;						ForeColor(whiteColor);			loc = subregion->obss[j].startInter->GetLocation();			if (loc.h < 0)				loc.h = 0;			SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);			FrameOval(&r);						loc2 = subregion->obss[j].endInter->GetLocation();			if (loc2.h < 0)				loc2.h = 0;			SetRect(&r, loc2.h - 6, loc2.v - 6, loc2.h + 6, loc2.v + 6);			FrameOval(&r);		}				if (!TestForMouseTermination())			return;				//Skip infinite surfaces		if (subregion->obss[j].infiniteWO)		{			MyAssert(!subregion->obss[j].bsp && !subregion->obss[j].cut);			continue;		}				if (gDebug13)		{			OrientedBoundarySection obs2;	//debug			Subregion* obsSubregion = NULL;			for (int k = 0; k < subregion->enclosedNeighbors.size(); k++)			{				for (int m = 0; m < subregion->enclosedNeighbors[k]->obss.size(); m++)				{					obs2 = subregion->enclosedNeighbors[k]->obss[m];					if (subregion->obss[j].Opposite(subregion->enclosedNeighbors[k]->obss[m]))					{						obsSubregion = subregion->enclosedNeighbors[k];						ForeColor(greenColor);						break;					}				}				if (obsSubregion)					break;			}			if (!obsSubregion)				for (int k = 0; k < subregion->enclosingNeighbors.size(); k++)				{					for (int m = 0; m < subregion->enclosingNeighbors[k]->obss.size(); m++)					{						obs2 = subregion->enclosingNeighbors[k]->obss[m];						if (subregion->obss[j].Opposite(subregion->enclosingNeighbors[k]->obss[m]))						{							obsSubregion = subregion->enclosingNeighbors[k];							ForeColor(cyanColor);							break;						}					}					if (obsSubregion)						break;				}			MyAssert(obsSubregion);						if (obsSubregion)			{				obsSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				int qc = 1;								ForeColor(whiteColor);				obsSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				ForeColor(blackColor);				obsSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);			}		}				if (gDebug13)		{			ForeColor(yellowColor);			subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						int qc = 1;		}				if (gDebug13)		{			Rect r;						PenSize(2, 2);						FloatPoint loc = subregion->obss[j].startInter->GetLocation();			if (loc.h < 0)				loc.h = 0;			SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);			ForeColor(magentaColor);			FrameOval(&r);						FloatPoint loc2 = subregion->obss[j].endInter->GetLocation();			if (loc2.h < 0)				loc2.h = 0;			SetRect(&r, loc2.h - 6, loc2.v - 6, loc2.h + 6, loc2.v + 6);			ForeColor(cyanColor);			FrameOval(&r);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			int qc = 1;						ForeColor(whiteColor);			loc = subregion->obss[j].startInter->GetLocation();			if (loc.h < 0)				loc.h = 0;			SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);			FrameOval(&r);						loc2 = subregion->obss[j].endInter->GetLocation();			if (loc2.h < 0)				loc2.h = 0;			SetRect(&r, loc2.h - 6, loc2.v - 6, loc2.h + 6, loc2.v + 6);			FrameOval(&r);		}				//Skip cut sections		if (subregion->obss[j].cut)		{			MyAssert(!subregion->obss[j].bsp);			continue;		}				//Skip forward sections.  We only want enclosed neighbors, not enclosing neighbors.	 Let all cut obss pass through though.		if (subregion->obss[j].traverseForward && subregion->obss[j].bsp)			continue;				//If the section's subboundary index is in the node's uncrossable boundaries list, skip the section		int spillSubboundaryIndex = subregion->obss[j].subboundaryIndex;		bool skipIt = false;		for (int k = 0; k < surfaceSubregionGraphNode->uncrossableSubboundaries.size(); k++)			if (surfaceSubregionGraphNode->uncrossableSubboundaries[k] == spillSubboundaryIndex)			{				skipIt = true;				break;			}		if (skipIt)			continue;				//Find the subregion that the section spills into.  It must be one of the enclosed neighbors.		Subregion* spillToSubregion = NULL;		for (int k = 0; k < subregion->enclosedNeighbors.size(); k++)		{			if (gDebug13)			{				ForeColor(blueColor);				subregion->enclosedNeighbors[k]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				int qc = 1;			}						for (int m = 0; m < subregion->enclosedNeighbors[k]->obss.size(); m++)				if (subregion->obss[j].Opposite(subregion->enclosedNeighbors[k]->obss[m]))				{					spillToSubregion = subregion->enclosedNeighbors[k];					break;				}			if (spillToSubregion)				break;						if (gDebug13)			{				ForeColor(whiteColor);				subregion->enclosedNeighbors[k]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				ForeColor(blackColor);				subregion->enclosedNeighbors[k]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);				int qc = 1;			}		}		MyAssert(spillToSubregion);				if (gDebug13)		{			ForeColor(magentaColor);			spillToSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			int qc = 1;		}				//If the node already has an edge to a node of the spill-to region crossing the section, skip the spill		skipIt = false;		for (int k = 0; k < surfaceSubregionGraphNode->fromToEdgePairs.size(); k++)		{			pair<SurfaceSubregionGraph::SurfaceSubregionGraphEdge*, SurfaceSubregionGraph::SurfaceSubregionGraphEdge*> fromToEdgePair = surfaceSubregionGraphNode->fromToEdgePairs[k];			MyAssert(fromToEdgePair.first->nodeTo->subregion == subregion &&					fromToEdgePair.second->nodeFrom->subregion == subregion);			if (fromToEdgePair.first->nodeFrom->subregion == spillToSubregion &&				fromToEdgePair.first->crossedSubboundary == spillSubboundaryIndex)			{				skipIt = true;				break;			}			else if (fromToEdgePair.second->nodeTo->subregion == spillToSubregion &&					fromToEdgePair.second->crossedSubboundary == spillSubboundaryIndex)			{				skipIt = true;				break;			}		}		if (skipIt)		{			if (gDebug13)			{				ForeColor(blackColor);				spillToSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				int qc = 1;			}			continue;		}		for (int k = 0; k < surfaceSubregionGraphNode->spillEdges.size(); k++)		{			SurfaceSubregionGraph::SurfaceSubregionGraphEdge* spillEdge = surfaceSubregionGraphNode->spillEdges[k];			MyAssert(spillEdge->nodeFrom->subregion == subregion || spillEdge->nodeTo->subregion == subregion);						if (spillEdge->crossedSubboundary == spillSubboundaryIndex)				if (spillEdge->nodeFrom->subregion == spillToSubregion || spillEdge->nodeTo->subregion == spillToSubregion)				{					skipIt = true;					break;				}		}		if (skipIt)		{			if (gDebug13)			{				ForeColor(blackColor);				spillToSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				int qc = 1;			}			continue;		}				if (gDebug13)		{			ForeColor(yellowColor);			subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));			ForeColor(redColor);			spillToSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						int qc = 1;		}				//Find a node with the spill-to region that isn't uncrossable for the section and doesn't already have an edge for the spill section.  Create an edge to the node.		//If a spill node is not found, add a new node.		bool foundIt = false;		for (int k = 0; k < surfaceSubregionGraph->nodes.size() + newNodes.size(); k++)		{			SurfaceSubregionGraph::SurfaceSubregionGraphNode* possibleSpillToNode = NULL;			if (k < surfaceSubregionGraph->nodes.size())				possibleSpillToNode = surfaceSubregionGraph->nodes[k];			else			{				int c = 0;				for (list<SurfaceSubregionGraph::SurfaceSubregionGraphNode*>::iterator m = newNodes.begin(); m != newNodes.end(); m++, c++)					if (surfaceSubregionGraph->nodes.size() + c == k)					{						possibleSpillToNode = *m;						break;					}			}			MyAssert(possibleSpillToNode);						//Wrong subregion			if (possibleSpillToNode->subregion != spillToSubregion)				continue;						//Is the node's section uncrossable			skipIt = false;			for (int m = 0; m < possibleSpillToNode->uncrossableSubboundaries.size(); m++)				if (possibleSpillToNode->uncrossableSubboundaries[m] == spillSubboundaryIndex)				{					skipIt = true;					break;				}			if (skipIt)				continue;						//Does the node already have an edge for this section			skipIt = false;			for (int m = 0; m < possibleSpillToNode->fromToEdgePairs.size(); m++)				if (possibleSpillToNode->fromToEdgePairs[m].first->crossedSubboundary == spillSubboundaryIndex &&					possibleSpillToNode->fromToEdgePairs[m].first->nodeFrom->subregion == subregion)				{					skipIt = true;					break;				}			if (skipIt)				continue;			for (int m = 0; m < possibleSpillToNode->fromToEdgePairs.size(); m++)				if (possibleSpillToNode->fromToEdgePairs[m].second->crossedSubboundary == spillSubboundaryIndex &&					possibleSpillToNode->fromToEdgePairs[m].second->nodeTo->subregion == subregion)				{					skipIt = true;					break;				}			if (skipIt)				continue;			for (int m = 0; m < possibleSpillToNode->spillEdges.size(); m++)				if (possibleSpillToNode->spillEdges[m]->crossedSubboundary == spillSubboundaryIndex &&					//possibleSpillToNode->spillEdges[m]->GetOtherSubregion(spillToSubregion) == subregion)					possibleSpillToNode->spillEdges[m]->GetOtherNode(possibleSpillToNode)->subregion == subregion)				{					skipIt = true;					break;				}			if (skipIt)				continue;						if (gDebug13)			{				ForeColor(blueColor);				spillToSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));								int qc = 1;			}						//Create the spill			SurfaceSubregionGraph::SurfaceSubregionGraphEdge* newEdge = new SurfaceSubregionGraph::SurfaceSubregionGraphEdge(surfaceSubregionGraphNode, possibleSpillToNode, subregion->obss[j].bsp, NULL, spillSubboundaryIndex, true);			surfaceSubregionGraph->edges.push_back(newEdge);			surfaceSubregionGraphNode->spillEdges.push_back(newEdge);			possibleSpillToNode->spillEdges.push_back(newEdge);			foundIt = true;			break;		}		if (!foundIt)	//Create a new node for the spill to region		{			if (gDebug13)			{				ForeColor(yellowColor);				subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				ForeColor(blackColor);				spillToSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));								int qc = 1;			}						SurfaceSubregionGraph::SurfaceSubregionGraphNode* newSpillToNode = new SurfaceSubregionGraph::SurfaceSubregionGraphNode(spillToSubregion);			newNodes.push_back(newSpillToNode);			newSpillToNode->crossedSubboundaries.push_back(spillSubboundaryIndex);						SurfaceSubregionGraph::SurfaceSubregionGraphEdge* newEdge = new SurfaceSubregionGraph::SurfaceSubregionGraphEdge(surfaceSubregionGraphNode, newSpillToNode, subregion->obss[j].bsp, NULL, spillSubboundaryIndex, true);			surfaceSubregionGraph->edges.push_back(newEdge);			surfaceSubregionGraphNode->spillEdges.push_back(newEdge);			newSpillToNode->spillEdges.push_back(newEdge);		}	}		//Spill across cuts, creating edges between nodes that border along a cut	for (int i = 0; i < subregion->subregionAdjacencies.size(); i++)		if (subregion->subregionAdjacencies[i].ubs.cut)		{			BSplineToBSplineCut* cut = subregion->subregionAdjacencies[i].ubs.cut;			Subregion* cutNeighborSubregion = subregion->subregionAdjacencies[i].GetOtherSubregion(subregion);						//Skip this cut spill if the two subregions don't enclose the same whole object			bool foundIt = false;			for (int j = 0; j < subregion->enclosingWOs.size(); j++)				if (subregion->enclosingWOs[j].first == wholeObject)				{					foundIt = true;					break;				}			if (!foundIt)			{				//gDebug13 = true;				MyAssert(false);	//Just an assert to cause a semi-permanent breakpoint			}						if (gDebug13)			{				Rect r;								PenSize(2, 2);								FloatPoint loc = cut->GetStart();				if (loc.h < 0)					loc.h = 0;				SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);				ForeColor(cyanColor);				FrameOval(&r);								loc = cut->GetEnd();				if (loc.h < 0)					loc.h = 0;				SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);				ForeColor(magentaColor);				FrameOval(&r);								PenSize(1, 1);								ForeColor(yellowColor);				subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				ForeColor(greenColor);				cutNeighborSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));								int qc = 1;			}						foundIt = false;			for (int j = 0; j < cutNeighborSubregion->enclosingWOs.size(); j++)				if (cutNeighborSubregion->enclosingWOs[j].first == wholeObject)				{					foundIt = true;					break;				}			if (!foundIt)				continue;						bool dg = gDebug13;			//gDebug13 = true;						if (gDebug13)			{				Rect r;								PenSize(2, 2);								FloatPoint loc = cut->GetStart();				if (loc.h < 0)					loc.h = 0;				SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);				ForeColor(cyanColor);				FrameOval(&r);								loc = cut->GetEnd();				if (loc.h < 0)					loc.h = 0;				SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);				ForeColor(magentaColor);				FrameOval(&r);								PenSize(1, 1);								ForeColor(yellowColor);				subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				ForeColor(greenColor);				cutNeighborSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));								int qc = 1;			}						foundIt = false;			for (int j = 0; j < surfaceSubregionGraph->nodes.size(); j++)	//Loop through the graph's nodes (not very efficient to search the global list of nodes, but oh well				if (surfaceSubregionGraph->nodes[j]->subregion == cutNeighborSubregion)	//Does the node's subregion match the cut section's other subregion?				{					SurfaceSubregionGraph::SurfaceSubregionGraphNode* cutNeighborNode = surfaceSubregionGraph->nodes[j];										//gDebug13 = true;					if (gDebug13)					{						ForeColor(yellowColor);						subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						ForeColor(magentaColor);						cutNeighborNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));												int qc = 1;						/*						for (int k = 0; k < surfaceSubregionGraphNode->fromToEdgePairs.size(); k++)						{							MyAssert(surfaceSubregionGraphNode->fromToEdgePairs[k].first->nodeTo == surfaceSubregionGraphNode && surfaceSubregionGraphNode->fromToEdgePairs[k].second->nodeFrom == surfaceSubregionGraphNode);							SurfaceSubregionGraph::SurfaceSubregionGraphNode* fromNode = surfaceSubregionGraphNode->fromToEdgePairs[k].first->nodeFrom;							SurfaceSubregionGraph::SurfaceSubregionGraphNode* toNode = surfaceSubregionGraphNode->fromToEdgePairs[k].second->nodeTo;														ForeColor(cyanColor);							fromNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));							ForeColor(blueColor);							toNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));														int qc = 1;														ForeColor(whiteColor);							fromNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));							toNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));							ForeColor(blackColor);							fromNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);							toNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);														ForeColor(yellowColor);							subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));							ForeColor(magentaColor);							cutNeighborNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						}												qc = 1;						*/					}										//Not all nodes getting to this point in the search will count.  We have to compare the crossed and uncrossable boundaries.					bool cantSpill = false;					for (int k = 0; k < surfaceSubregionGraphNode->crossedSubboundaries.size(); k++)						if (find(cutNeighborNode->uncrossableSubboundaries.begin(), cutNeighborNode->uncrossableSubboundaries.end(), surfaceSubregionGraphNode->crossedSubboundaries[k]) != cutNeighborNode->uncrossableSubboundaries.end())						{							cantSpill = true;							break;						}					if (!cantSpill)					{						for (int k = 0; k < cutNeighborNode->crossedSubboundaries.size(); k++)							if (find(surfaceSubregionGraphNode->uncrossableSubboundaries.begin(), surfaceSubregionGraphNode->uncrossableSubboundaries.end(), cutNeighborNode->crossedSubboundaries[k]) != surfaceSubregionGraphNode->uncrossableSubboundaries.end())							{								cantSpill = true;								break;							}						if (!cantSpill)						{							foundIt = true;							if (gDebug13)							{								ForeColor(cyanColor);								cutNeighborNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));																int qc = 1;							}														//If the edge was already spilled from the other direction, skip it							bool alreadySpilled = false;							for (int k = 0; k < surfaceSubregionGraphNode->spillEdges.size(); k++)							{								if (gDebug13)								{									ForeColor(blackColor);									surfaceSubregionGraphNode->spillEdges[k]->GetOtherNode(surfaceSubregionGraphNode)->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));																		int qc = 1;								}																if (surfaceSubregionGraphNode->spillEdges[k]->GetOtherNode(surfaceSubregionGraphNode) == cutNeighborNode)								{									if (gDebug13)									{										ForeColor(blueColor);										cutNeighborNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));																				int qc = 1;									}																		alreadySpilled = true;									break;								}																if (gDebug13)								{									ForeColor(whiteColor);									surfaceSubregionGraphNode->spillEdges[k]->GetOtherNode(surfaceSubregionGraphNode)->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));									ForeColor(blackColor);									surfaceSubregionGraphNode->spillEdges[k]->GetOtherNode(surfaceSubregionGraphNode)->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);								}							}														if (!alreadySpilled)							{								if (gDebug13)								{									ForeColor(redColor);									cutNeighborNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));																		int qc = 1;								}																SurfaceSubregionGraph::SurfaceSubregionGraphEdge* newEdge = new SurfaceSubregionGraph::SurfaceSubregionGraphEdge(surfaceSubregionGraphNode, cutNeighborNode, NULL, cut, 0, true);								surfaceSubregionGraph->edges.push_back(newEdge);								surfaceSubregionGraphNode->spillEdges.push_back(newEdge);								cutNeighborNode->spillEdges.push_back(newEdge);							}						}					}										if (gDebug13)					{						ForeColor(whiteColor);						cutNeighborNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));						ForeColor(blackColor);						cutNeighborNode->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);					}										if (foundIt)						break;				}			if (!foundIt)			{				//gDebug13 = true;				//MyAssert(false);	//Just an assert to cause a semi-permanent breakpoint			}						if (gDebug13)			{				Rect r;								PenSize(2, 2);								FloatPoint loc = cut->GetStart();				if (loc.h < 0)					loc.h = 0;				SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);				ForeColor(cyanColor);				FrameOval(&r);								loc = cut->GetEnd();				if (loc.h < 0)					loc.h = 0;				SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);				ForeColor(magentaColor);				FrameOval(&r);								PenSize(1, 1);								ForeColor(greenColor);				subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				ForeColor(redColor);				cutNeighborSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));								int qc = 1;			}						if (gDebug13)			{				Rect r;								PenSize(2, 2);								ForeColor(whiteColor);				FloatPoint loc = cut->GetStart();				if (loc.h < 0)					loc.h = 0;				SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);				FrameOval(&r);								loc = cut->GetEnd();				if (loc.h < 0)					loc.h = 0;				SetRect(&r, loc.h - 6, loc.v - 6, loc.h + 6, loc.v + 6);				FrameOval(&r);								PenSize(1, 1);								ForeColor(whiteColor);				subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				cutNeighborSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));				ForeColor(blackColor);				subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);				cutNeighborSubregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);								int qc = 1;			}						gDebug13 = dg;		}}vector<OverlappingSubsurface> Drawing::FindCommonSubgraphs(vector<SurfaceSubregionGraph*>& surfaceSubregionGraphs){	if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pFinding common subgraphs");				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}		if (gDebug13)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		gMainWindow->DrawGrid();				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		//gDebug13 = true;	vector<OverlappingSubsurface> overlappingSubsurfaces;	for (int i = 0; i < surfaceSubregionGraphs.size(); i++)	//Loop through the whole object graphs	{		if (!TestForMouseTermination())		{			overlappingSubsurfaces.clear();			return overlappingSubsurfaces;		}				SurfaceSubregionGraph* graph1 = surfaceSubregionGraphs[i];		for (int j = i; j < surfaceSubregionGraphs.size(); j++)	//Loop through the whole object graphs		{			if (!TestForMouseTermination())			{				overlappingSubsurfaces.clear();				return overlappingSubsurfaces;			}						SurfaceSubregionGraph* graph2 = surfaceSubregionGraphs[j];			for (int m = 0; m < graph1->nodes.size(); m++)	//Loop through the first graph's nodes			{				int startN = ((graph1 != graph2) ? 0 : (m + 1));				for (int n = startN; n < graph2->nodes.size(); n++)	//Loop through the second graph's nodes				{					if (!TestForMouseTermination())					{						overlappingSubsurfaces.clear();						return overlappingSubsurfaces;					}										//Be careful about how self-overlaps are detected					if (graph1->nodes[m] == graph2->nodes[n])					{						MyAssert(graph1 == graph2 && i == j);						continue;					}										if (graph1->nodes[m]->subregion == graph2->nodes[n]->subregion)	//Do the graphs share a common node?  If so, that node will form the source of a "paint-spill" graph exploration for the largest graph intersection involving that node.					{						if (gDebug13)						{							SetPort(GetWindowPort(gMainWindow->GetWindow()));														Rect r;							GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);							r.left = 450;							r.top = 450;							EraseRect(&r);							gMainWindow->DrawGrid();														Point scrollOffset = {0, 0};							vector<BSpline*> workingBSplines;							DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);														QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int qc = 1;						}												if (gDebug13)						{							ForeColor(redColor);							graph1->nodes[m]->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));							int qc = 1;						}												OverlappingSubsurface os;						os.wholeObjectPair.first = graph1->wholeObject;						os.wholeObjectPair.second = graph2->wholeObject;												list<pair<SurfaceSubregionGraph::SurfaceSubregionGraphNode*, SurfaceSubregionGraph::SurfaceSubregionGraphNode*> > frontier;						frontier.push_back(pair<SurfaceSubregionGraph::SurfaceSubregionGraphNode*, SurfaceSubregionGraph::SurfaceSubregionGraphNode*>(graph1->nodes[m], graph2->nodes[n]));						list<pair<SurfaceSubregionGraph::SurfaceSubregionGraphNode*, SurfaceSubregionGraph::SurfaceSubregionGraphNode*> >::iterator iter = frontier.begin();						while (iter != frontier.end())	//While there are new frontier subregions left to explore						{							if (!TestForMouseTermination())							{								overlappingSubsurfaces.clear();								return overlappingSubsurfaces;							}							/*							//A fairly arbitrary attempt to speed things up.  This could legally fail if there was a truly large, but legal, overlapping subsurface.							if (os.subregions.size() > 20)							{								gDebug13 = true;								if (gDebug13)								{									SetPort(GetWindowPort(gMainWindow->GetWindow()));																		Rect r;									GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);									EraseRect(&r);									gMainWindow->DrawGrid();																		Point scrollOffset = {0, 0};									vector<BSpline*> workingBSplines;									DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);																		ForeColor(blueColor);									for (int q = 0; q < os.subregions.size(); q++)										os.subregions[q]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));																		int qc = 1;								}																overlappingSubsurfaces.clear();								break;							}							*/							if (gDebug13)							{								SetPort(GetWindowPort(gMainWindow->GetWindow()));																Rect r;								GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);								r.left = 450;								r.top = 450;								EraseRect(&r);								gMainWindow->DrawGrid();																Point scrollOffset = {0, 0};								vector<BSpline*> workingBSplines;								DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);																QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);							}														if (gDebug13)							{								ForeColor(greenColor);								(*iter).first->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));								int qc = 1;							}														SurfaceSubregionGraph::SurfaceSubregionGraphNode* node1 = (*iter).first;							SurfaceSubregionGraph::SurfaceSubregionGraphNode* node2 = (*iter).second;														MyAssert(node1->subregion == node2->subregion);														//Add the new subregion to the common subgraph							if (find(os.subregions.begin(), os.subregions.end(), node1->subregion) == os.subregions.end())								os.subregions.push_back(node1->subregion);														//Make a list of node1's neighbors							vector<SurfaceSubregionGraph::SurfaceSubregionGraphNode*> node1neighbors;							for (int k = 0; k < node1->fromToEdgePairs.size(); k++)							{								if (find(node1neighbors.begin(), node1neighbors.end(), node1->fromToEdgePairs[k].first->nodeFrom) == node1neighbors.end())								{									node1neighbors.push_back(node1->fromToEdgePairs[k].first->nodeFrom);									if (gDebug13)									{										ForeColor(blueColor);										node1->fromToEdgePairs[k].first->nodeFrom->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										int qc = 1;										ForeColor(whiteColor);										node1->fromToEdgePairs[k].first->nodeFrom->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										ForeColor(blackColor);										node1->fromToEdgePairs[k].first->nodeFrom->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);									}								}								if (find(node1neighbors.begin(), node1neighbors.end(), node1->fromToEdgePairs[k].second->nodeTo) == node1neighbors.end())								{									node1neighbors.push_back(node1->fromToEdgePairs[k].second->nodeTo);									if (gDebug13)									{										ForeColor(blueColor);										node1->fromToEdgePairs[k].second->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										int qc = 1;										ForeColor(whiteColor);										node1->fromToEdgePairs[k].second->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										ForeColor(blackColor);										node1->fromToEdgePairs[k].second->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);									}								}							}							for (int k = 0; k < node1->spillEdges.size(); k++)							{								SurfaceSubregionGraph::SurfaceSubregionGraphNode* neighbor = node1->spillEdges[k]->GetOtherNode(node1);								if (find(node1neighbors.begin(), node1neighbors.end(), neighbor) == node1neighbors.end())								{									node1neighbors.push_back(neighbor);									if (gDebug13)									{										ForeColor(blueColor);										neighbor->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										int qc = 1;										ForeColor(whiteColor);										neighbor->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										ForeColor(blackColor);										neighbor->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);									}								}							}														//Make a list of node2's neighbors							vector<SurfaceSubregionGraph::SurfaceSubregionGraphNode*> node2neighbors;							for (int k = 0; k < node2->fromToEdgePairs.size(); k++)							{								if (find(node2neighbors.begin(), node2neighbors.end(), node2->fromToEdgePairs[k].first->nodeFrom) == node2neighbors.end())								{									node2neighbors.push_back(node2->fromToEdgePairs[k].first->nodeFrom);									if (gDebug13)									{										ForeColor(cyanColor);										node2->fromToEdgePairs[k].first->nodeFrom->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										int qc = 1;										ForeColor(whiteColor);										node2->fromToEdgePairs[k].first->nodeFrom->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										ForeColor(blackColor);										node2->fromToEdgePairs[k].first->nodeFrom->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);									}								}								if (find(node2neighbors.begin(), node2neighbors.end(), node2->fromToEdgePairs[k].second->nodeTo) == node2neighbors.end())								{									node2neighbors.push_back(node2->fromToEdgePairs[k].second->nodeTo);									if (gDebug13)									{										ForeColor(cyanColor);										node2->fromToEdgePairs[k].second->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										int qc = 1;										ForeColor(whiteColor);										node2->fromToEdgePairs[k].second->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										ForeColor(blackColor);										node2->fromToEdgePairs[k].second->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);									}								}							}							for (int k = 0; k < node2->spillEdges.size(); k++)							{								SurfaceSubregionGraph::SurfaceSubregionGraphNode* neighbor = node2->spillEdges[k]->GetOtherNode(node2);								if (find(node2neighbors.begin(), node2neighbors.end(), neighbor) == node2neighbors.end())								{									node2neighbors.push_back(neighbor);									if (gDebug13)									{										ForeColor(cyanColor);										neighbor->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										int qc = 1;										ForeColor(whiteColor);										neighbor->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										ForeColor(blackColor);										neighbor->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()), false);									}								}							}														//Look for neighbors common to both nodes, adding any commonalities to the frontier list							for (int p = 0; p < node1neighbors.size(); p++)								for (int q = 0; q < node2neighbors.size(); q++)									if (node1neighbors[p]->subregion == node2neighbors[q]->subregion && find(os.subregions.begin(), os.subregions.end(), node1neighbors[p]->subregion) == os.subregions.end())										if (find(node2neighbors.begin(), node2neighbors.end(), node1neighbors[p]) == node2neighbors.end() &&											find(node1neighbors.begin(), node1neighbors.end(), node2neighbors[q]) == node1neighbors.end())										{											frontier.push_back(pair<SurfaceSubregionGraph::SurfaceSubregionGraphNode*, SurfaceSubregionGraph::SurfaceSubregionGraphNode*>(node1neighbors[p], node2neighbors[q]));											if (gDebug13)											{												ForeColor(yellowColor);												node1neighbors[p]->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));												int qc = 1;											}										}										else MyAssert(graph1 == graph2);							/*							//The "set" method used below tends to run a tad slower than the "vector" method above.  Oh well.														//Make a list of node1's neighbors							set<SurfaceSubregionGraph::SurfaceSubregionGraphNode*> node1neighbors;							for (int k = 0; k < node1->fromToEdgePairs.size(); k++)							{								if (find(node1neighbors.begin(), node1neighbors.end(), node1->fromToEdgePairs[k].first->nodeFrom) == node1neighbors.end())								{									node1neighbors.insert(node1->fromToEdgePairs[k].first->nodeFrom);									if (gDebug13)									{										ForeColor(blueColor);										node1->fromToEdgePairs[k].first->nodeFrom->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										int qc = 1;									}								}								if (find(node1neighbors.begin(), node1neighbors.end(), node1->fromToEdgePairs[k].second->nodeTo) == node1neighbors.end())								{									node1neighbors.insert(node1->fromToEdgePairs[k].second->nodeTo);									if (gDebug13)									{										ForeColor(blueColor);										node1->fromToEdgePairs[k].second->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										int qc = 1;									}								}							}							for (int k = 0; k < node1->spillEdges.size(); k++)							{								SurfaceSubregionGraph::SurfaceSubregionGraphNode* neighbor = node1->spillEdges[k]->GetOtherNode(node1);								if (find(node1neighbors.begin(), node1neighbors.end(), neighbor) == node1neighbors.end())								{									node1neighbors.insert(neighbor);									if (gDebug13)									{										ForeColor(blueColor);										neighbor->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										int qc = 1;									}								}							}														//Make a list of node2's neighbors							set<SurfaceSubregionGraph::SurfaceSubregionGraphNode*> node2neighbors;							for (int k = 0; k < node2->fromToEdgePairs.size(); k++)							{								if (find(node2neighbors.begin(), node2neighbors.end(), node2->fromToEdgePairs[k].first->nodeFrom) == node2neighbors.end())								{									node2neighbors.insert(node2->fromToEdgePairs[k].first->nodeFrom);									if (gDebug13)									{										ForeColor(cyanColor);										node2->fromToEdgePairs[k].first->nodeFrom->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										int qc = 1;									}								}								if (find(node2neighbors.begin(), node2neighbors.end(), node2->fromToEdgePairs[k].second->nodeTo) == node2neighbors.end())								{									node2neighbors.insert(node2->fromToEdgePairs[k].second->nodeTo);									if (gDebug13)									{										ForeColor(cyanColor);										node2->fromToEdgePairs[k].second->nodeTo->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										int qc = 1;									}								}							}							for (int k = 0; k < node2->spillEdges.size(); k++)							{								SurfaceSubregionGraph::SurfaceSubregionGraphNode* neighbor = node2->spillEdges[k]->GetOtherNode(node2);								if (find(node2neighbors.begin(), node2neighbors.end(), neighbor) == node2neighbors.end())								{									node2neighbors.insert(neighbor);									if (gDebug13)									{										ForeColor(cyanColor);										neighbor->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));										int qc = 1;									}								}							}														//Look for neighbors common to both nodes, adding any commonalities to the frontier list							for (set<SurfaceSubregionGraph::SurfaceSubregionGraphNode*>::iterator p = node1neighbors.begin(); p != node1neighbors.end(); p++)								for (set<SurfaceSubregionGraph::SurfaceSubregionGraphNode*>::iterator q = node2neighbors.begin(); q != node2neighbors.end(); q++)									if ((*p)->subregion == (*q)->subregion &&										find(os.subregions.begin(), os.subregions.end(), (*p)->subregion) == os.subregions.end())										if (find(node2neighbors.begin(), node2neighbors.end(), *p) == node2neighbors.end() &&											find(node1neighbors.begin(), node1neighbors.end(), *q) == node1neighbors.end())										{											frontier.push_back(pair<SurfaceSubregionGraph::SurfaceSubregionGraphNode*, SurfaceSubregionGraph::SurfaceSubregionGraphNode*>(*p, *q));											if (gDebug13)											{												ForeColor(yellowColor);												(*p)->subregion->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));												int qc = 1;											}										}										else MyAssert(graph1 == graph2);							*/							iter++;						}												if (gDebug13)						{							ForeColor(magentaColor);							for (int k = 0; k < os.subregions.size(); k++)								os.subregions[k]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));							int qc = 1;						}												//Only add the new overlapping subsurface if it wasn't already found						bool foundIt = false;						for (int p = 0; p < overlappingSubsurfaces.size(); p++)						{							foundIt = false;							if ((overlappingSubsurfaces[p].wholeObjectPair.first == os.wholeObjectPair.first && overlappingSubsurfaces[p].wholeObjectPair.second == os.wholeObjectPair.second) ||								(overlappingSubsurfaces[p].wholeObjectPair.first == os.wholeObjectPair.second && overlappingSubsurfaces[p].wholeObjectPair.second == os.wholeObjectPair.first))								if (overlappingSubsurfaces[p].subregions.size() == os.subregions.size())								{									foundIt = true;									for (int q = 0; q < overlappingSubsurfaces[p].subregions.size(); q++)										if (find(os.subregions.begin(), os.subregions.end(), overlappingSubsurfaces[p].subregions[q]) == os.subregions.end())										{											foundIt = false;											break;										}								}							if (foundIt)							{								if (gDebug13)								{									for (int k = 0; k < os.subregions.size(); k++)									{										ForeColor(blackColor);										os.subregions[k]->DrawDebug(gMainWindow->CalcScrollOffset(), GetWindowPort(gMainWindow->GetWindow()));									}									int qc = 1;								}								break;							}						}												if (!foundIt && os.subregions.size() > 0)							overlappingSubsurfaces.push_back(os);												//gDebug13 = false;					}				}			}		}	}	gDebug13 = false;		return overlappingSubsurfaces;}void Drawing::BuildIntersectionCompanionSetsFromOverlappingSubsurfaces(vector<OverlappingSubsurface> overlappingSubsurfaces){	if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pBuilding companion sets");				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}		if (gDebug13)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		gMainWindow->DrawGrid();				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		DeleteAllCompSets();		//gDebug13 = true;	for (int i = 0; i < overlappingSubsurfaces.size(); i++)	{		if (!TestForMouseTermination())			return;				if (gDebug13)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));						Rect r;			GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);			EraseRect(&r);			gMainWindow->DrawGrid();						Point scrollOffset = {0, 0};			vector<BSpline*> workingBSplines;			DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qc = 1;		}				OverlappingSubsurface os = overlappingSubsurfaces[i];		vector<pair<GenericIntersection*, int> > cornerHits;		for (int j = 0; j < os.subregions.size(); j++)			for (int k = 0; k < os.subregions[j]->corners.size(); k++)			{				GenericIntersection* corner = os.subregions[j]->corners[k];								if (gDebug13)				{					Rect r;					FloatPoint loc = corner->GetLocation();					SetRect(&r, loc.h - 7, loc.v - 7, loc.h + 7, loc.v + 7);					PenSize(2, 2);					ForeColor(greenColor);					FrameOval(&r);					PenSize(1, 1);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int qc = 1;				}								pair<GenericIntersection*, int>* cornerHit = NULL;				for (int m = 0; m < cornerHits.size(); m++)					if (cornerHits[m].first == corner)					{						cornerHit = &cornerHits[m];						break;					}								if (!cornerHit)				{					cornerHits.push_back(pair<GenericIntersection*, int>(corner, 1));										if (gDebug13)					{						Rect r;						FloatPoint loc = corner->GetLocation();						SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);						PenSize(2, 2);						ForeColor(redColor);						FrameOval(&r);						PenSize(1, 1);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qc = 1;					}				}				else				{					cornerHit->second++;										if (gDebug13)					{						Rect r;						FloatPoint loc = corner->GetLocation();						SetRect(&r, loc.h - (10 + (cornerHit->second - 1) * 3), loc.v - (10 + (cornerHit->second - 1) * 3), loc.h + (10 + (cornerHit->second - 1) * 3), loc.v + (10 + (cornerHit->second - 1) * 3));						PenSize(2, 2);						ForeColor(cyanColor);						FrameOval(&r);						PenSize(1, 1);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int qc = 1;					}				}			}				if (gDebug13)		{			int q = 1;		}				//All corners with a hit of 1 are members of the companion set		vector<GenericIntersection*>* interCompanionSet = new vector<GenericIntersection*>;		bool foundBspBsp = false;		for (int j = 0; j < cornerHits.size(); j++)			if (cornerHits[j].second == 1)			{				GenericIntersection* gi = cornerHits[j].first;	//debug								if (cornerHits[j].first->GetType() != GenericIntersection::BSP_BSP)				{					if (gDebug13)					{						ForeColor(redColor);						PenSize(2, 2);						for (int k = 0; k < cornerHits.size(); k++)						{							FloatPoint loc = cornerHits[k].first->GetLocation();							Rect r;							SetRect(&r, loc.h - (10 + k * 2), loc.v - (10 + k * 2), loc.h + (10 + k * 2), loc.v + (10 + k * 2));							FrameOval(&r);						}						PenSize(1, 1);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qc = 1;					}					//MyAssert(false);										//Ditch this "presumed" companion set					interCompanionSet->clear();					break;				}								BspBspIntersection* bspBspInter = (BspBspIntersection*)cornerHits[j].first;								MyAssert(find(interCompanionSet->begin(), interCompanionSet->end(), bspBspInter) == interCompanionSet->end());								//Don't duplicate a companion (presumably duplicating its entire set unless there is a bug in the set finding algorithm)				bool foundIt = false;				for (int k = 0; k < interCompanionSets.size(); k++)					if (find(interCompanionSets[k]->begin(), interCompanionSets[k]->end(), bspBspInter) != interCompanionSets[k]->end())					{						foundIt = true;						break;					}								if (!foundIt)					interCompanionSet->push_back(bspBspInter);				else				{					interCompanionSet->clear();					break;				}								foundBspBsp = true;			}			else if (cornerHits[j].second == 2 && cornerHits[j].first->GetType() == GenericIntersection::BSP_CUT)			{				BspCutIntersection* bspCutInter = (BspCutIntersection*)cornerHits[j].first;				BSplineToBSplineCut* cut = bspCutInter->GetCut();												MyAssert(find(interCompanionSet->begin(), interCompanionSet->end(), bspCutInter) == interCompanionSet->end());								interCompanionSet->push_back(bspCutInter);			}				if (!foundBspBsp)			interCompanionSet->clear();				//For any BspCut inters in the new comp set, make sure the both the bsp and the cut are in the same two surfaces as those involved in any BspBsp inters		WholeObject *wo1 = NULL, *wo2 = NULL;		for (int j = 0; j < interCompanionSet->size(); j++)			if ((*interCompanionSet)[j]->GetType() == GenericIntersection::BSP_BSP)			{				wo1 = FindWholeObjectForBSpline(((BspBspIntersection*)(*interCompanionSet)[j])->GetBsp1());				wo2 = FindWholeObjectForBSpline(((BspBspIntersection*)(*interCompanionSet)[j])->GetBsp2());				break;			}		if (wo1 && wo2)		{			bool foundOne = true;			while (foundOne)			{				foundOne = false;				for (vector<GenericIntersection*>::iterator k = interCompanionSet->begin(); k != interCompanionSet->end(); k++)					if ((*k)->GetType() == GenericIntersection::BSP_CUT)					{						BSpline* bsp = ((BspCutIntersection*)(*k))->GetBsp();						BSplineToBSplineCut* cut = ((BspCutIntersection*)(*k))->GetCut();						WholeObject* wo1a = FindWholeObjectForBSpline(bsp);						WholeObject* wo2a = FindWholeObjectForBSpline(cut->GetBsp1());						MyAssert(wo1a == wo1 || wo1a == wo2);	//The BspCut's bsp should definitely be in the right group						if (wo2a != wo1 && wo2a != wo2)						{							interCompanionSet->erase(k);							foundOne = true;							break;						}					}			}		}				if (gDebug13 && interCompanionSet->size() > 0)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));						Rect r;			GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);			EraseRect(&r);			gMainWindow->DrawGrid();						Point scrollOffset = {0, 0};			vector<BSpline*> workingBSplines;			DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);						PenSize(2, 2);			ForeColor(greenColor);			for (int j = 0; j < interCompanionSet->size(); j++)			{				FloatPoint loc = (*interCompanionSet)[j]->GetLocation();				SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);				FrameOval(&r);			}			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			int qc = 1;						ForeColor(whiteColor);			for (int j = 0; j < interCompanionSet->size(); j++)			{				FloatPoint loc = (*interCompanionSet)[j]->GetLocation();				SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);				FrameOval(&r);			}			PenSize(1, 1);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		}				if (interCompanionSet->size() > 0)			interCompanionSets.push_back(interCompanionSet);		else delete interCompanionSet;	}		//gDebug13 = true;	if (gDebug13)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		gMainWindow->DrawGrid();				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);				PenSize(2, 2);		for (int i = 0; i < interCompanionSets.size(); i++)			if (interCompanionSets[i]->size() > 0)			{				switch (i % 6)				{					case 0:	ForeColor(redColor);	break;					case 1:	ForeColor(greenColor);	break;					case 2:	ForeColor(blueColor);	break;					case 3:	ForeColor(magentaColor);	break;					case 4:	ForeColor(cyanColor);	break;					case 5:	ForeColor(blackColor);	break;				}								for (int j = 0; j < interCompanionSets[i]->size(); j++)				{					FloatPoint loc = (*interCompanionSets[i])[j]->GetLocation();					SetRect(&r, loc.h - 5, loc.v - 5, loc.h + 5, loc.v + 5);					PaintOval(&r);				}			}					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		int dg3 = 1;				ForeColor(whiteColor);		for (int i = 0; i < interCompanionSets.size(); i++)			if (interCompanionSets[i]->size() > 0)			{				for (int j = 0; j < interCompanionSets[i]->size(); j++)				{					FloatPoint loc = (*interCompanionSets[i])[j]->GetLocation();					SetRect(&r, loc.h - 5, loc.v - 5, loc.h + 5, loc.v + 5);					PaintOval(&r);				}			}		PenSize(1, 1);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}	gDebug13 = false;		//Remove duplicate companion sets.  This shouldn't be necessary, but sometimes it happens.  Some kind of a bug.	bool foundOne = true;	while (foundOne)	{		foundOne = false;		for (vector<vector<GenericIntersection*>*>::iterator i = interCompanionSets.begin(); i != interCompanionSets.end(); i++)		{			vector<vector<GenericIntersection*>*>::iterator j = i;			j++;			for (; j != interCompanionSets.end(); j++)			{				for (int k = 0; k < (*j)->size(); k++)					if (find((*i)->begin(), (*i)->end(), (*(*j))[k]) != (*i)->end())					{						MyAssert(false);	//I don't think this should happen.  This entire code block should be unnecessary.						delete *j;						interCompanionSets.erase(j);						foundOne = true;						break;					}				if (foundOne)					break;			}			if (foundOne)				break;		}	}}void Drawing::InitializeCompanionSets(){	if (gDebug5)	{		InitAnalysisWindow();				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pInitializing companion sets");				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}		if (gDebug13)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		gMainWindow->DrawGrid();				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		//gDebug13 = true;	for (int i = 0; i < interCompanionSets.size(); i++)	{		if (!TestForMouseTermination())			return;				if (gDebug13)		{			SetPort(GetWindowPort(gMainWindow->GetWindow()));						Rect r;			GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);			EraseRect(&r);			gMainWindow->DrawGrid();						Point scrollOffset = {0, 0};			vector<BSpline*> workingBSplines;			DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						ClearBrandNewIntersections();			DrawIntersections(MainWindow::KNOT_MODE, scrollOffset, false);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			int qe = 1;		}				vector<GenericIntersection*> interCompanionSet = *interCompanionSets[i];				if (gDebug13)		{			PenSize(2, 2);			ForeColor(blueColor);			for (int j = 0; j < interCompanionSet.size(); j++)			{				Rect r;				FloatPoint loc = interCompanionSet[j]->GetLocation();				SetRect(&r, loc.h - 20, loc.v - 20, loc.h + 20, loc.v + 20);				FrameOval(&r);			}			PenSize(1, 1);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			int qe = 1;		}				int firstInterIndex = 0;		while (interCompanionSet[firstInterIndex]->GetType() != GenericIntersection::BSP_BSP)			firstInterIndex++;		MyAssert(firstInterIndex < interCompanionSet.size());				//Keep track of which intersections have been visited during the boundary traversal		BspBspIntersection* startInter = (BspBspIntersection*)interCompanionSet[firstInterIndex];		vector<GenericIntersection*> intersVisited;		intersVisited.push_back(startInter);				if (gDebug13)		{			Rect r;			FloatPoint loc = startInter->GetLocation();			SetRect(&r, loc.h - 18, loc.v - 18, loc.h + 18, loc.v + 18);			PenSize(2, 2);			ForeColor(blackColor);			FrameOval(&r);			PenSize(1, 1);			QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			int qe = 1;		}				//If the starting inter is a self inter, initialize the prev inter in the traversal		GenericIntersection* lastInter = NULL;		if (startInter->SelfIntersection())		{			MyAssert(startInter->GetType() == GenericIntersection::BSP_BSP);						BSpline* bsp1b = startInter->GetBsp1();			BSpline* bsp2b = startInter->GetBsp2();			int cv1b = startInter->GetCv1();			int cv2b = startInter->GetCv2();			int sg1b = startInter->GetSg1();			int sg2b = startInter->GetSg2();			int occludedEdgeb = startInter->DetermineOccludedEdge();			MyAssert(occludedEdgeb == 3 || occludedEdgeb == 4);			/*			if (occludedEdgeb == 3)				lastInter = bsp2a->FindPrevIntersection(startInter, cv2a, sg2a);			else lastInter = bsp1a->FindPrevIntersection(startInter, cv1a, sg1a);			*/			if (occludedEdgeb == 3)				lastInter = bsp1b->FindPrevIntersection(startInter, cv1b, sg1b);			else lastInter = bsp2b->FindPrevIntersection(startInter, cv2b, sg2b);						//intersVisited.pop_back();			//intersVisited.push_back(lastInter);						if (gDebug13)			{				SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;				FloatPoint loc = lastInter->GetLocation();				SetRect(&r, loc.h - 18, loc.v - 18, loc.h + 18, loc.v + 18);				PenSize(2, 2);				ForeColor(blackColor);				FrameOval(&r);				PenSize(1, 1);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qe = 1;			}		}				//The traversal keeps track of whether it left the last companion on top or on bottom at the last companion.  This needs to be initialized for the startInter though.		bool leftLastCompanionOnTop = true;		MyAssert(startInter->GetType() == GenericIntersection::BSP_BSP);		BSpline* bsp1 = startInter->GetBsp1();		BSpline* bsp2 = startInter->GetBsp2();		int cv1 = startInter->GetCv1();		int cv2 = startInter->GetCv2();		int sg1 = startInter->GetSg1();		int sg2 = startInter->GetSg2();		int occludedEdge = startInter->DetermineOccludedEdge();		MyAssert(occludedEdge == 3 || occludedEdge == 4);		if (occludedEdge == 3)	//Potentially occluded segments are 2 and 3			leftLastCompanionOnTop = true;		else	//occludedEdge == 4, so potentially occluded segments are 1 and 4			leftLastCompanionOnTop = false;				BSpline* traverseBsp = (leftLastCompanionOnTop ? startInter->GetBsp1() : startInter->GetBsp2());				//Traverse the boundary		BSpline* lastTraversalBsp = NULL;		while (intersVisited.size() <= interCompanionSet.size())		{			MyAssert(intersVisited.back()->GetType() == GenericIntersection::BSP_BSP || intersVisited.back()->GetType() == GenericIntersection::BSP_CUT);						if (gDebug13)			{				Rect r;				FloatPoint loc = intersVisited.back()->GetLocation();				SetRect(&r, loc.h - 12, loc.v - 12, loc.h + 12, loc.v + 12);				PenSize(2, 2);				ForeColor(yellowColor);				FrameOval(&r);				PenSize(1, 1);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int qe = 1;			}						GenericIntersection* nextInter = NULL;			bool traversalArrivedOnTop = true;						if (intersVisited.back()->GetType() == GenericIntersection::BSP_BSP)			{				BspBspIntersection* thisInter = (BspBspIntersection*)intersVisited.back();								BSpline* bsp1 = thisInter->GetBsp1();				BSpline* bsp2 = thisInter->GetBsp2();				int cv1 = thisInter->GetCv1();				int cv2 = thisInter->GetCv2();				int sg1 = thisInter->GetSg1();				int sg2 = thisInter->GetSg2();				int occludedEdge = thisInter->DetermineOccludedEdge();				MyAssert(occludedEdge == 3 || occludedEdge == 4);								if (occludedEdge == 3)	//Potentially occluded segments are 2 and 3				{					nextInter = thisInter;					int numTries = 0;					do	//Loop until the next companion is found					{						if (gDebug13)						{							Rect r;							FloatPoint loc = nextInter->GetLocation();							SetRect(&r, loc.h - 14, loc.v - 14, loc.h + 14, loc.v + 14);							PenSize(2, 2);							ForeColor(greenColor);							FrameOval(&r);							PenSize(1, 1);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);							int qe = 1;						}												switch (nextInter->GetType())						{							case GenericIntersection::BSP_BSP:								BspBspIntersection* nextBspBspInter1 = ((BspBspIntersection*)nextInter);								if (!nextBspBspInter1->SelfIntersection())								{									if (nextBspBspInter1->GetBsp1() == bsp1)									{										cv1 = nextBspBspInter1->GetCv1();										sg1 = nextBspBspInter1->GetSg1();									}									else									{										cv1 = nextBspBspInter1->GetCv2();										sg1 = nextBspBspInter1->GetSg2();									}								}								else	//Self intersection								{									MyAssert(nextBspBspInter1->GetBsp1() == bsp1);									MyAssert(nextBspBspInter1->GetBsp1() == nextBspBspInter1->GetBsp2());																		int nextCv1 = nextBspBspInter1->GetCv1();									int nextSg1 = nextBspBspInter1->GetSg1();									int nextCv2 = nextBspBspInter1->GetCv2();									int nextSg2 = nextBspBspInter1->GetSg2();																		GenericIntersection* prev1 = bsp1->FindPrevIntersection(nextBspBspInter1, nextCv1, nextSg1);									GenericIntersection* next1 = bsp1->FindNextIntersection(nextBspBspInter1, nextCv1, nextSg1);									GenericIntersection* prev2 = bsp1->FindPrevIntersection(nextBspBspInter1, nextCv2, nextSg2);									GenericIntersection* next2 = bsp1->FindNextIntersection(nextBspBspInter1, nextCv2, nextSg2);									//MyAssert(next1 != lastInter && next2 != lastInter);	//Not sure if this is true									MyAssert(prev1 == lastInter || prev2 == lastInter);									if (numTries != 0)	//Traversing between corners (between members of the companion set)									{										if (prev1 == lastInter)										{											cv1 = nextCv1;											sg1 = nextSg1;										}										else										{											cv1 = nextCv2;											sg1 = nextSg2;										}									}									else	//Turning a corner									{										cv1 = nextCv1;										sg1 = nextSg1;									}								}								break;							case GenericIntersection::BSP_CUT:								cv1 = ((BspCutIntersection*)nextInter)->GetCv();								sg1 = ((BspCutIntersection*)nextInter)->GetSg();								break;							case GenericIntersection::BSP_CUT_T:								cv1 = ((BspCutTIntersection*)nextInter)->GetCv();								sg1 = ((BspCutTIntersection*)nextInter)->GetSg();								break;							default:								MyAssert(false);								break;						}												lastInter = nextInter;						nextInter = bsp1->FindNextIntersection(nextInter, cv1, sg1);												if (gDebug13)						{							SetPort(GetWindowPort(gMainWindow->GetWindow()));							Rect r;							FloatPoint loc = nextInter->GetLocation();							SetRect(&r, loc.h - 16, loc.v - 16, loc.h + 16, loc.v + 16);							PenSize(2, 2);							ForeColor(cyanColor);							FrameOval(&r);							PenSize(1, 1);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);							int qe = 1;						}					} while (numTries++ < bsp1->GetNumIntersections() && find(interCompanionSet.begin(), interCompanionSet.end(), nextInter) == interCompanionSet.end());					MyAssert(numTries < bsp1->GetNumIntersections());				}				else	//occludedEdge == 4, so potentially occluded segments are 1 and 4				{					nextInter = thisInter;					int numTries = 0;					do	//Loop until the next companion is found					{						if (gDebug13)						{							Rect r;							FloatPoint loc = nextInter->GetLocation();							SetRect(&r, loc.h - 14, loc.v - 14, loc.h + 14, loc.v + 14);							PenSize(2, 2);							ForeColor(redColor);							FrameOval(&r);							PenSize(1, 1);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);							int qe = 1;						}												switch (nextInter->GetType())						{							case GenericIntersection::BSP_BSP:								BspBspIntersection* nextBspBspInter2 = ((BspBspIntersection*)nextInter);								if (!nextBspBspInter2->SelfIntersection())								{									if (nextBspBspInter2->GetBsp2() == bsp2)									{										cv2 = nextBspBspInter2->GetCv2();										sg2 = nextBspBspInter2->GetSg2();									}									else									{										cv2 = nextBspBspInter2->GetCv1();										sg2 = nextBspBspInter2->GetSg1();									}								}								else	//Self intersection								{									MyAssert(nextBspBspInter2->GetBsp1() == bsp2);									MyAssert(nextBspBspInter2->GetBsp1() == nextBspBspInter2->GetBsp2());																		int nextCv1b = nextBspBspInter2->GetCv1();									int nextSg1b = nextBspBspInter2->GetSg1();									int nextCv2b = nextBspBspInter2->GetCv2();									int nextSg2b = nextBspBspInter2->GetSg2();																		GenericIntersection* prev1b = bsp2->FindPrevIntersection(nextBspBspInter2, nextCv1b, nextSg1b);									GenericIntersection* next1b = bsp2->FindNextIntersection(nextBspBspInter2, nextCv1b, nextSg1b);									GenericIntersection* prev2b = bsp2->FindPrevIntersection(nextBspBspInter2, nextCv2b, nextSg2b);									GenericIntersection* next2b = bsp2->FindNextIntersection(nextBspBspInter2, nextCv2b, nextSg2b);									//MyAssert(next1b != lastInter && next2b != lastInter);	//Not sure if this is true									MyAssert(prev1b == lastInter || prev2b == lastInter);									if (numTries != 0)	//Traversing between corners (between members of the companion set)									{										if (prev1b == lastInter)										{											cv2 = nextCv1b;											sg2 = nextSg1b;										}										else										{											cv2 = nextCv2b;											sg2 = nextSg2b;										}									}									else	//Turning a corner									{										cv2 = nextCv2b;										sg2 = nextSg2b;									}								}								break;							case GenericIntersection::BSP_CUT:								cv2 = ((BspCutIntersection*)nextInter)->GetCv();								sg2 = ((BspCutIntersection*)nextInter)->GetSg();								break;							case GenericIntersection::BSP_CUT_T:								cv2 = ((BspCutTIntersection*)nextInter)->GetCv();								sg2 = ((BspCutTIntersection*)nextInter)->GetSg();								break;							default:								MyAssert(false);								break;						}												lastInter = nextInter;						nextInter = bsp2->FindNextIntersection(nextInter, cv2, sg2);												if (gDebug13)						{							SetPort(GetWindowPort(gMainWindow->GetWindow()));							Rect r;							FloatPoint loc = nextInter->GetLocation();							SetRect(&r, loc.h - 16, loc.v - 16, loc.h + 16, loc.v + 16);							PenSize(2, 2);							ForeColor(magentaColor);							FrameOval(&r);							PenSize(1, 1);							QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);							int qe = 1;						}					} while (numTries++ < bsp2->GetNumIntersections() && find(interCompanionSet.begin(), interCompanionSet.end(), nextInter) == interCompanionSet.end());					MyAssert(numTries < bsp2->GetNumIntersections());				}								MyAssert(nextInter);								//Determine whether the traversal arrived at this companion on top or bottom				traversalArrivedOnTop = true;				if (nextInter->GetType() == GenericIntersection::BSP_BSP)				{					BspBspIntersection* nextBspBspInter = (BspBspIntersection*)nextInter;					if (!nextBspBspInter->SelfIntersection())						traversalArrivedOnTop = (nextBspBspInter->GetBsp1() == traverseBsp);					else	//Self intersection					{						//Find the four intersections in all four directions from the new intersection						GenericIntersection* topPrev = ((BspBspIntersection*)nextInter)->GetBsp1()->FindPrevIntersection(((BspBspIntersection*)nextInter), ((BspBspIntersection*)nextInter)->GetCv1(), ((BspBspIntersection*)nextInter)->GetSg1());						GenericIntersection* topNext = ((BspBspIntersection*)nextInter)->GetBsp1()->FindNextIntersection(((BspBspIntersection*)nextInter), ((BspBspIntersection*)nextInter)->GetCv1(), ((BspBspIntersection*)nextInter)->GetSg1());						GenericIntersection* botPrev = ((BspBspIntersection*)nextInter)->GetBsp2()->FindPrevIntersection(((BspBspIntersection*)nextInter), ((BspBspIntersection*)nextInter)->GetCv2(), ((BspBspIntersection*)nextInter)->GetSg2());						GenericIntersection* botNext = ((BspBspIntersection*)nextInter)->GetBsp2()->FindNextIntersection(((BspBspIntersection*)nextInter), ((BspBspIntersection*)nextInter)->GetCv2(), ((BspBspIntersection*)nextInter)->GetSg2());												//Use the match between the intersection the traversal came from and the correct neighbor from the new 						//intersection to determine if the traversal arrived at the new intersection on the top or the bottom												if (!lastInter->SelfIntersection())	//Not a traversal between two self intersections						{							//Exactly one of the following four tests should succeed (no more, no less).  Otherwise it's still ambiguous and it's not working properly.							//Theoretically, this could be converted into an if/else once I'm confident in the MyAsserts (confident only one test passes).							//This same code is found in FindOneIntersectionOneSubregion()							bool foundIt = false;							if (lastInter == topPrev)							{								foundIt = true;								traversalArrivedOnTop = true;							}							if (lastInter == topNext)							{								MyAssert(!foundIt);								foundIt = true;								traversalArrivedOnTop = true;							}							if (lastInter == botPrev)							{								MyAssert(!foundIt);								foundIt = true;								traversalArrivedOnTop = false;							}							if (lastInter == botNext)							{								MyAssert(!foundIt);								foundIt = true;								traversalArrivedOnTop = false;							}							MyAssert(foundIt);						}						else	//Traversal from self intersection, therefore traversal between two self intersections						{							MyAssert(lastInter->SelfIntersection());							MyAssert(nextInter->SelfIntersection());							MyAssert(((BspBspIntersection*)lastInter)->GetBsp1() == ((BspBspIntersection*)nextInter)->GetBsp1());														if (lastInter == nextInter)	//Traversal between the same intersection							{								traversalArrivedOnTop = !leftLastCompanionOnTop;							}							else	//Traversal between two different self-intersections							{								//Given the curve-segment that the traversal started from, only one of the two curve-segments at the next intersection								//can directly follow the starting curve-segment.  Find it.																int totalCurveSegments = traverseBsp->GetCurvePoints()->size() * BSpline::sNumSegmentsPerCurve;																//Get the curve-segment that started the traversal								int cvStart = leftLastCompanionOnTop ? ((BspBspIntersection*)lastInter)->GetCv1() : ((BspBspIntersection*)lastInter)->GetCv2();								int sgStart = leftLastCompanionOnTop ? ((BspBspIntersection*)lastInter)->GetSg1() : ((BspBspIntersection*)lastInter)->GetSg2();								int cvSg = cvStart * totalCurveSegments + sgStart;																//Get the two curve-segments at the next intersection								int cv1 = ((BspBspIntersection*)nextInter)->GetCv1();								int cv2 = ((BspBspIntersection*)nextInter)->GetCv2();								int sg1 = ((BspBspIntersection*)nextInter)->GetSg1();								int sg2 = ((BspBspIntersection*)nextInter)->GetSg2();								int cvSg1 = cv1 * totalCurveSegments + sg1;								int cvSg2 = cv2 * totalCurveSegments + sg2;								MyAssert(cvSg1 != cvSg2);																//Determine which curve-segment directly follows or preceeds, depending on the traverseForward (which is always true when traversing a companion set boundary)								if ((cvSg1 > cvSg && cvSg2 > cvSg) || (cvSg1 < cvSg && cvSg2 < cvSg))								{									if (cvSg1 < cvSg2)										traversalArrivedOnTop = true;									else traversalArrivedOnTop = false;								}								else if (cvSg1 > cvSg && cvSg2 < cvSg)									traversalArrivedOnTop = true;								else if (cvSg1 < cvSg && cvSg2 > cvSg)									traversalArrivedOnTop = false;								else	//one of the new intersection's curve-segments matches the starting curve-segments								{									MyAssert(cvSg1 != cvSg || cvSg2 != cvSg);	//I'm pretty sure this should be impossible																		vector<vector<FloatPoint>*> curvePoints = *traverseBsp->GetCurvePoints();									FloatPoint cvSgStartLoc = (*curvePoints[cvStart])[sgStart];																		//Get the distance from the curve segment start to this intersection									double lastInterSegPos = LineSegmentLength(cvSgStartLoc, lastInter->GetLocation());																		//Get the distance from the curve segment start to the next intersection									double nextInterSegPos = LineSegmentLength(cvSgStartLoc, nextInter->GetLocation());																		//Figure out which curve-segment at the next intersection directly follows or preceeds this intersection from the starting curve-segment									if (cvSg1 == cvSg && cvSg2 != cvSg)									{										if (nextInterSegPos > lastInterSegPos)											traversalArrivedOnTop = true;										else traversalArrivedOnTop = false;									}									else if (cvSg2 == cvSg && cvSg1 != cvSg)									{										if (nextInterSegPos > lastInterSegPos)											traversalArrivedOnTop = false;										else traversalArrivedOnTop = true;									}									else MyAssert(false);	//I'm pretty sure this should be impossible								}							}						}					}									}				else				{					MyAssert(nextInter->GetType() == GenericIntersection::BSP_CUT);					BspCutIntersection* nextBspCutInter = (BspCutIntersection*)nextInter;					if (!nextBspCutInter->SelfIntersection())						traversalArrivedOnTop = nextBspCutInter->GetBspOnTop();				}			}			else	//BspCut companion			{				MyAssert(intersVisited.back()->GetType() == GenericIntersection::BSP_CUT);				BspCutIntersection* thisInter = (BspCutIntersection*)intersVisited.back();								BSpline* bsp = thisInter->GetBsp();				int cv = thisInter->GetCv();				int sg = thisInter->GetSg();								nextInter = thisInter;				int numTries = 0;				do				{					if (gDebug13)					{						Rect r;						FloatPoint loc = nextInter->GetLocation();						SetRect(&r, loc.h - 14, loc.v - 14, loc.h + 14, loc.v + 14);						PenSize(2, 2);						ForeColor(greenColor);						FrameOval(&r);						PenSize(1, 1);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qe = 1;					}										lastInter = nextInter;					nextInter = bsp->FindNextIntersection(nextInter, cv, sg);										if (gDebug13)					{						SetPort(GetWindowPort(gMainWindow->GetWindow()));						Rect r;						FloatPoint loc = nextInter->GetLocation();						SetRect(&r, loc.h - 16, loc.v - 16, loc.h + 16, loc.v + 16);						PenSize(2, 2);						ForeColor(cyanColor);						FrameOval(&r);						PenSize(1, 1);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int qe = 1;					}				} while (numTries++ < bsp->GetNumIntersections() && find(interCompanionSet.begin(), interCompanionSet.end(), nextInter) == interCompanionSet.end());				MyAssert(numTries < bsp->GetNumIntersections());								MyAssert(nextInter);								//Determine whether the traversal arrived at this companion on top or bottom				traversalArrivedOnTop = true;				if (nextInter->GetType() == GenericIntersection::BSP_BSP)				{					BspBspIntersection* nextBspBspInter = (BspBspIntersection*)nextInter;					if (!nextBspBspInter->SelfIntersection())						traversalArrivedOnTop = (nextBspBspInter->GetBsp1() == traverseBsp);					else	//Self intersection					{						//Find the four intersections in all four directions from the new intersection						GenericIntersection* topPrev = ((BspBspIntersection*)nextInter)->GetBsp1()->FindPrevIntersection(((BspBspIntersection*)nextInter), ((BspBspIntersection*)nextInter)->GetCv1(), ((BspBspIntersection*)nextInter)->GetSg1());						GenericIntersection* topNext = ((BspBspIntersection*)nextInter)->GetBsp1()->FindNextIntersection(((BspBspIntersection*)nextInter), ((BspBspIntersection*)nextInter)->GetCv1(), ((BspBspIntersection*)nextInter)->GetSg1());						GenericIntersection* botPrev = ((BspBspIntersection*)nextInter)->GetBsp2()->FindPrevIntersection(((BspBspIntersection*)nextInter), ((BspBspIntersection*)nextInter)->GetCv2(), ((BspBspIntersection*)nextInter)->GetSg2());						GenericIntersection* botNext = ((BspBspIntersection*)nextInter)->GetBsp2()->FindNextIntersection(((BspBspIntersection*)nextInter), ((BspBspIntersection*)nextInter)->GetCv2(), ((BspBspIntersection*)nextInter)->GetSg2());												//Use the match between the intersection the traversal came from and the correct neighbor from the new 						//intersection to determine if the traversal arrived at the new intersection on the top or the bottom												if (!lastInter->SelfIntersection())	//Not a traversal between two self intersections						{							//Exactly one of the following four tests should succeed (no more, no less).  Otherwise it's still ambiguous and it's not working properly.							//Theoretically, this could be converted into an if/else once I'm confident in the MyAsserts (confident only one test passes).							//This same code is found in FindOneIntersectionOneSubregion()							bool foundIt = false;							if (lastInter == topPrev)							{								foundIt = true;								traversalArrivedOnTop = true;							}							if (lastInter == topNext)							{								MyAssert(!foundIt);								foundIt = true;								traversalArrivedOnTop = true;							}							if (lastInter == botPrev)							{								MyAssert(!foundIt);								foundIt = true;								traversalArrivedOnTop = false;							}							if (lastInter == botNext)							{								MyAssert(!foundIt);								foundIt = true;								traversalArrivedOnTop = false;							}							MyAssert(foundIt);						}						else	//Traversal from self intersection, therefore traversal between two self intersections						{							MyAssert(lastInter->SelfIntersection());							MyAssert(nextInter->SelfIntersection());							MyAssert(((BspBspIntersection*)lastInter)->GetBsp1() == ((BspBspIntersection*)nextInter)->GetBsp1());														if (lastInter == nextInter)	//Traversal between the same intersection							{								traversalArrivedOnTop = !leftLastCompanionOnTop;							}							else	//Traversal between two different self-intersections							{								//Given the curve-segment that the traversal started from, only one of the two curve-segments at the next intersection								//can directly follow the starting curve-segment.  Find it.																int totalCurveSegments = traverseBsp->GetCurvePoints()->size() * BSpline::sNumSegmentsPerCurve;																//Get the curve-segment that started the traversal								int cvStart = leftLastCompanionOnTop ? ((BspBspIntersection*)lastInter)->GetCv1() : ((BspBspIntersection*)lastInter)->GetCv2();								int sgStart = leftLastCompanionOnTop ? ((BspBspIntersection*)lastInter)->GetSg1() : ((BspBspIntersection*)lastInter)->GetSg2();								int cvSg = cvStart * totalCurveSegments + sgStart;																//Get the two curve-segments at the next intersection								int cv1 = ((BspBspIntersection*)nextInter)->GetCv1();								int cv2 = ((BspBspIntersection*)nextInter)->GetCv2();								int sg1 = ((BspBspIntersection*)nextInter)->GetSg1();								int sg2 = ((BspBspIntersection*)nextInter)->GetSg2();								int cvSg1 = cv1 * totalCurveSegments + sg1;								int cvSg2 = cv2 * totalCurveSegments + sg2;								MyAssert(cvSg1 != cvSg2);																//Determine which curve-segment directly follows or preceeds, depending on the traverseForward (which is always true when traversing a companion set boundary)								if ((cvSg1 > cvSg && cvSg2 > cvSg) || (cvSg1 < cvSg && cvSg2 < cvSg))								{									if (cvSg1 < cvSg2)										traversalArrivedOnTop = true;									else traversalArrivedOnTop = false;								}								else if (cvSg1 > cvSg && cvSg2 < cvSg)									traversalArrivedOnTop = true;								else if (cvSg1 < cvSg && cvSg2 > cvSg)									traversalArrivedOnTop = false;								else	//one of the new intersection's curve-segments matches the starting curve-segments								{									MyAssert(cvSg1 != cvSg || cvSg2 != cvSg);	//I'm pretty sure this should be impossible																		vector<vector<FloatPoint>*> curvePoints = *traverseBsp->GetCurvePoints();									FloatPoint cvSgStartLoc = (*curvePoints[cvStart])[sgStart];																		//Get the distance from the curve segment start to this intersection									double lastInterSegPos = LineSegmentLength(cvSgStartLoc, lastInter->GetLocation());																		//Get the distance from the curve segment start to the next intersection									double nextInterSegPos = LineSegmentLength(cvSgStartLoc, nextInter->GetLocation());																		//Figure out which curve-segment at the next intersection directly follows or preceeds this intersection from the starting curve-segment									if (cvSg1 == cvSg && cvSg2 != cvSg)									{										if (nextInterSegPos > lastInterSegPos)											traversalArrivedOnTop = true;										else traversalArrivedOnTop = false;									}									else if (cvSg2 == cvSg && cvSg1 != cvSg)									{										if (nextInterSegPos > lastInterSegPos)											traversalArrivedOnTop = false;										else traversalArrivedOnTop = true;									}									else MyAssert(false);	//I'm pretty sure this should be impossible								}							}						}					}									}				else				{					MyAssert(nextInter->GetType() == GenericIntersection::BSP_CUT);					BspCutIntersection* nextBspCutInter = (BspCutIntersection*)nextInter;					if (!nextBspCutInter->SelfIntersection())						traversalArrivedOnTop = nextBspCutInter->GetBspOnTop();				}							}						if (traversalArrivedOnTop != leftLastCompanionOnTop)				nextInter->FlipTopBottom();						if (nextInter->GetType() == GenericIntersection::BSP_BSP)			{				leftLastCompanionOnTop = !leftLastCompanionOnTop;				traverseBsp = (leftLastCompanionOnTop ? ((BspBspIntersection*)nextInter)->GetBsp1() : ((BspBspIntersection*)nextInter)->GetBsp2());			}			else MyAssert(nextInter->GetType() == GenericIntersection::BSP_CUT);						intersVisited.push_back(nextInter);		}	}		if (gDebug13)	{		SetPort(GetWindowPort(gMainWindow->GetWindow()));				Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		gMainWindow->DrawGrid();				Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				ClearBrandNewIntersections();		DrawIntersections(MainWindow::KNOT_MODE, scrollOffset, false);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);		int qe = 1;	}}#pragma mark -bool Drawing::FindControlPoint(FloatPoint point, int& controlPoint, BSpline*& bsp){	controlPoint = -1;	bsp = NULL;	for (vector<BSpline*>::iterator i = bsplines.begin(); i != bsplines.end(); i++)	{		int cp = (*i)->FindControlPoint(FloatPoint(point));		if (cp != -1)		{			controlPoint = cp;			bsp = *i;			return true;		}	}		return false;}bool Drawing::FindIntersectionPoint(FloatPoint point, int& intersectionPoint){	intersectionPoint = -1;		int dist, minDist = 999999;	int minDistIntersectionIndex = -1;	for (int i = 0; i < intersections.size(); i++)	{		FloatPoint intersectionLoc = intersections[i]->GetLocation();				//Pull infinite BspCutT inters to the edge of the canvas		if (intersectionLoc.h < -999998)			intersectionLoc.h = 0;				//Find the distance from the point to the intersection		dist = max(fabs(point.h - intersectionLoc.h), fabs(point.v - intersectionLoc.v));		if (dist < minDist)		{			minDist = dist;			minDistIntersectionIndex = i;		}	}		if (minDist <= gFindPointDist)	{		intersectionPoint = minDistIntersectionIndex;		return true;	}		return false;}bool Drawing::FindControlBoundarySegment(FloatPoint point, int& controlBoundarySegment, BSpline*& bsp){	controlBoundarySegment = -1;	bsp = NULL;	for (vector<BSpline*>::iterator i = bsplines.begin(); i != bsplines.end(); i++)	{		int cbs = (*i)->FindControlBoundarySegment(FloatPoint(point));		if (cbs != -1)		{			controlBoundarySegment = cbs;			bsp = *i;			return true;		}	}		return false;}bool Drawing::FindCurveSegment(FloatPoint point, int& curveSegment, BSpline*& bsp){	curveSegment = -1;	bsp = NULL;	for (vector<BSpline*>::iterator i = bsplines.begin(); i != bsplines.end(); i++)	{		int cs = (*i)->FindCurveSegment(FloatPoint(point));		if (cs != -1)		{			curveSegment = cs;			bsp = *i;			return true;		}	}		return false;}#pragma mark -void Drawing::InitAnalysisWindow(){	if (gDebug5)	{		SetPort(GetWindowPort(gAnalysisWindow));		TextSize(9);				if (gTextV < 8)			gTextV = 8;	}}void Drawing::ClearAnalysisWindow(){	if (gDebug5)	{		InitAnalysisWindow();				Rect r;		GetPortBounds(GetWindowPort(gAnalysisWindow), &r);		EraseRect(&r);				gTextV = 8;		gTextH = 0;				WriteSearchParameters();	}}void Drawing::WriteSearchParameters(){	if (gDebug5)	{		InitAnalysisWindow();				Rect bounds;		GetPortBounds(GetWindowPort(gAnalysisWindow), &bounds);		Rect r = { bounds.top, bounds.left, bounds.bottom, bounds.right };		r.bottom = 70;		EraseRect(&r);				ForeColor(blackColor);		PenSize(1, 1);		MoveTo(0, r.bottom);		LineTo(r.right, r.bottom);				int textV = 1;				Str255 str1;				MoveTo(5, textV++ * 10 + 5);		DrawString("\pLabeling Method: ");		NumToString(gLabelingMethod, str1);		DrawString(str1);				if (gLabelingMethod != 0)		{			RGBColor gray = { 32768, 32768, 32768 };			RGBForeColor(&gray);		}				MoveTo(5, textV++ * 10 + 5);		DrawString("\pCompanion Set Method: ");		NumToString(gCompanionSetMethod, str1);		DrawString(str1);				MoveTo(5, textV++ * 10 + 5);		DrawString("\pSection Enumeration Method: ");		NumToString(gDepthEnumerationMethod, str1);		DrawString(str1);				MoveTo(5, textV++ * 10 + 5);		DrawString("\pBounding Method: ");		NumToString(gBoundingMethod, str1);		DrawString(str1);				MoveTo(5, textV++ * 10 + 5);		DrawString("\pTree Search Method: ");		NumToString(gTreeSearchMethod, str1);		DrawString(str1);				MoveTo(5, textV++ * 10 + 5);		DrawString("\pTime Limits: ");		NumToString((int)(labelAttemptWithSolutionTimeLimitSeconds * gTimeLimitScalar), str1);		DrawString(str1);		DrawString("\p     ");		NumToString((int)(labelAttemptWithoutSolutionTimeLimitSeconds * gTimeLimitScalar), str1);		DrawString(str1);				ForeColor(blackColor);				if (gDebug5)		{			MoveTo(bounds.right - 10, 10);			DrawString("\pе");		}		if (gDebug14)		{			MoveTo(bounds.right - 10, 20);			DrawString("\pе");		}		if (gDebug12)		{			MoveTo(bounds.right - 10, 30);			DrawString("\pе");		}				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);	}}int Drawing::IncrementTextV(){	gTextV++;	if (gTextV < 8)		gTextV = 8;		Rect r;	GetPortBounds(GetWindowPort(gAnalysisWindow), &r);	if (gTextV * 10 > r.bottom - 20)	{		//r.top = 67;		ClearAnalysisWindow();		gTextV = 8;	}	return gTextV;}//Return true if *not* terminated, in other words, true is "success" or "yes" on "should I keep going?"bool Drawing::TestForMouseTermination(){	//return true;	//This will disable mouse termination so mouse events never terminate the operation that is being performed.		if (gMouseTerminated)		return false;		bool mouseDown = Button();	SetPort(GetWindowPort(gMainWindow->GetWindow()));	Point mouseLoc;	GetMouse(&mouseLoc);		if (((mouseDownAtStartOfAttempt || mouseSensitive) &&			(mouseLoc.h != mouseLocAtStartOfAttempt.h || mouseLoc.v != mouseLocAtStartOfAttempt.v)) ||		(!mouseDownAtStartOfAttempt && mouseDown))	{		if (gDebug5)		{			InitAnalysisWindow();						IncrementTextV();			MoveTo(5, IncrementTextV() * 10 + 5);			DrawString("\pMouse terminated");			gTextH = 0;						QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);			SetPort(GetWindowPort(gMainWindow->GetWindow()));		}				gMouseTerminated = true;				return false;	}		return true;}void Drawing::FlipIntersection(int intersectionPoint){	MyAssert(intersectionPoint >= 0 && intersectionPoint < intersections.size());	intersections[intersectionPoint]->FlipTopBottom();	intersections[intersectionPoint]->SetHardConstraint(!intersections[intersectionPoint]->GetHardConstraint());}void Drawing::ToggleIntersectionPermanentContraint(int intersectionPoint){	MyAssert(intersectionPoint >= 0 && intersectionPoint < intersections.size());	intersections[intersectionPoint]->SetPermanentHardConstraint(!intersections[intersectionPoint]->GetPermanentHardConstraint());}void Drawing::SetIntersectionPermanentContraint(int intersectionPoint, bool toggleCompSet, bool constraint){	//Find the companion set for the intersection	int compSetIndex = -1;	bool foundIt = false;	if (toggleCompSet)		for (compSetIndex = 0; compSetIndex < interCompanionSets.size(); compSetIndex++)	//Loop through the sets			if (find(interCompanionSets[compSetIndex]->begin(), interCompanionSets[compSetIndex]->end(), intersections[intersectionPoint]) != interCompanionSets[compSetIndex]->end())			{				foundIt = true;				break;			}		if (!foundIt)		intersections[intersectionPoint]->SetPermanentHardConstraint(constraint);	else		for (int i = 0; i < interCompanionSets[compSetIndex]->size(); i++)			(*interCompanionSets[compSetIndex])[i]->SetPermanentHardConstraint(constraint);}void Drawing::ReallocateCurvePoints(){	for (vector<BSpline*>::iterator i = bsplines.begin(); i != bsplines.end(); i++)		(*i)->ReallocateCurvePoints();}void Drawing::CleanUpIntersections(){	//for (vector<BSpline*>::iterator i = bsplines.begin(); i != bsplines.end(); i++)	//	(*i)->CleanUpIntersections(bsplines, bsplinePairCuts);		/*	for (int i = 0; i < bsplines.size(); i++)	{		vector<int>* depths = bsplines[i]->GetSectionDepths();		int *d = new int[depths->size()];		for (int j = 0; j < depths->size(); j++)			d[j] = (*depths)[j];	}	*/}#pragma mark -void Drawing::EqualizeNumberOfSections(){	for (vector<BSpline*>::iterator i = bsplines.begin(); i != bsplines.end(); i++)		(*i)->EqualizeNumberOfSections();}		bool Drawing::ChangeObjectRGB(BSpline* bsp, Point where){	//Find the whole object for the BSpline	int wholeObjectIndex = -1;	for (int j = 0; j < wholeObjects.size(); j++)		if (find(wholeObjects[j]->bsplines.begin(), wholeObjects[j]->bsplines.end(), bsp) != wholeObjects[j]->bsplines.end())		{			wholeObjectIndex = j;			break;		}		//Can't change color of illegal BSplines (which have no object)	if (wholeObjectIndex == -1)		return false;		//Get the old color	SurfaceTraits surfaceTraits;	bool foundIt = false;	for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)		if (wholeObjects[wholeObjectIndex]->bsplines[j]->GetWindingNumber() > 0)		{			surfaceTraits = wholeObjects[wholeObjectIndex]->bsplines[j]->GetSurfaceTraits();			foundIt = true;			break;		}	if (!foundIt)	{		for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)			if (wholeObjects[wholeObjectIndex]->bsplines[j]->GetWindingNumber() == 0)			{				surfaceTraits = wholeObjects[wholeObjectIndex]->bsplines[j]->GetSurfaceTraits();				foundIt = true;				break;			}	}	if (!foundIt)	{		for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)			if (wholeObjects[wholeObjectIndex]->bsplines[j]->GetWindingNumber() < 0)			{				surfaceTraits = wholeObjects[wholeObjectIndex]->bsplines[j]->GetSurfaceTraits();				foundIt = true;				break;			}	}	MyAssert(foundIt);		sOldSurfaceTraits = surfaceTraits;		//Get the new color	SurfaceTraits newSurfaceTraits = sOldSurfaceTraits;		int colorMethod = 2;	if (colorMethod == 0)	{		if (!GetColor(where, "\pSelect a new color.", &sOldSurfaceTraits.interiorColor, &newSurfaceTraits.interiorColor))			return false;				//Black signifies no color, so don't let it be chosen		if (newSurfaceTraits.interiorColor.red == 0)			newSurfaceTraits.interiorColor.red = 1;		if (newSurfaceTraits.interiorColor.green == 0)			newSurfaceTraits.interiorColor.green = 1;		if (newSurfaceTraits.interiorColor.blue == 0)			newSurfaceTraits.interiorColor.blue = 1;				//Set the color for all the BSplines in the group		for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)			wholeObjects[wholeObjectIndex]->bsplines[j]->SetSurfaceTraits(newSurfaceTraits);	}	else if (colorMethod == 1)	{		ColorPickerInfo cpi;		cpi.theColor.color.rgb.red = sOldSurfaceTraits.interiorColor.red;		cpi.theColor.color.rgb.green = sOldSurfaceTraits.interiorColor.green;		cpi.theColor.color.rgb.blue = sOldSurfaceTraits.interiorColor.blue;		cpi.theColor.profile = NULL;		cpi.dstProfile = NULL;	//Use default profile		cpi.placeWhere = kCenterOnMainScreen;	//Doesn't seem to work, but oh well!		cpi.dialogOrigin = where;	//Doesn't seem to work, but oh well!		cpi.pickerType = 0;	//Use last used type		if (!gEventProcUPP)			gEventProcUPP = NewUserEventUPP(ColorPickerEventProc);		cpi.eventProc = gEventProcUPP;		if (!sColorChangedUPP)			sColorChangedUPP = NewColorChangedUPP(ColorPickerColorChangedDrawing);		cpi.colorProc = sColorChangedUPP;		cpi.colorProcData = wholeObjectIndex;	//user data passed to color changed callback		cpi.prompt[0] = 0;	//This dialog has no text prompt		cpi.mInfo.editMenuID = 130;		cpi.mInfo.cutItem = 4;		cpi.mInfo.copyItem = 5;		cpi.mInfo.pasteItem = 6;		cpi.mInfo.clearItem = 7;		cpi.mInfo.undoItem = 1;				OSErr err = PickColor(&cpi);		if (err == noErr && cpi.newColorChosen)		{			newSurfaceTraits.interiorColor.red = cpi.theColor.color.rgb.red;			newSurfaceTraits.interiorColor.green = cpi.theColor.color.rgb.green;			newSurfaceTraits.interiorColor.blue = cpi.theColor.color.rgb.blue;						//Black signifies no color, so don't let it be chosen			if (newSurfaceTraits.interiorColor.red == 0)				newSurfaceTraits.interiorColor.red = 1;			if (newSurfaceTraits.interiorColor.green == 0)				newSurfaceTraits.interiorColor.green = 1;			if (newSurfaceTraits.interiorColor.blue == 0)				newSurfaceTraits.interiorColor.blue = 1;						//Set the color for all the BSplines in the group			for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)				wholeObjects[wholeObjectIndex]->bsplines[j]->SetSurfaceTraits(newSurfaceTraits);		}		else		{			//Set the color for all the BSplines in the group			for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)				wholeObjects[wholeObjectIndex]->bsplines[j]->SetSurfaceTraits(sOldSurfaceTraits);		}	}	else if (colorMethod == 2)	{		NColorPickerInfo ncpi;		ncpi.theColor.color.rgb.red = sOldSurfaceTraits.interiorColor.red;		ncpi.theColor.color.rgb.green = sOldSurfaceTraits.interiorColor.green;		ncpi.theColor.color.rgb.blue = sOldSurfaceTraits.interiorColor.blue;		ncpi.theColor.profile = NULL;		ncpi.dstProfile = NULL;	//Use default profile		ncpi.placeWhere = kCenterOnMainScreen;	//Doesn't seem to work, but oh well!		ncpi.dialogOrigin = where;	//Doesn't seem to work, but oh well!		ncpi.pickerType = 0;	//Use last used type		if (!gEventProcUPP)			gEventProcUPP = NewUserEventUPP(ColorPickerEventProc);		ncpi.eventProc = gEventProcUPP;		if (!sColorNChangedUPP)			sColorNChangedUPP = NewNColorChangedUPP(NColorPickerColorChangedDrawing);		ncpi.colorProc = sColorNChangedUPP;		ncpi.colorProcData = wholeObjectIndex;	//user data passed to color changed callback		ncpi.prompt[0] = 0;	//This dialog has no text prompt		ncpi.mInfo.editMenuID = 130;		ncpi.mInfo.cutItem = 4;		ncpi.mInfo.copyItem = 5;		ncpi.mInfo.pasteItem = 6;		ncpi.mInfo.clearItem = 7;		ncpi.mInfo.undoItem = 1;				OSErr err = NPickColor(&ncpi);		if (err == noErr && ncpi.newColorChosen)		{			newSurfaceTraits.interiorColor.red = ncpi.theColor.color.rgb.red;			newSurfaceTraits.interiorColor.green = ncpi.theColor.color.rgb.green;			newSurfaceTraits.interiorColor.blue = ncpi.theColor.color.rgb.blue;						//Black signifies no color, so don't let it be chosen			if (newSurfaceTraits.interiorColor.red == 0)				newSurfaceTraits.interiorColor.red = 1;			if (newSurfaceTraits.interiorColor.green == 0)				newSurfaceTraits.interiorColor.green = 1;			if (newSurfaceTraits.interiorColor.blue == 0)				newSurfaceTraits.interiorColor.blue = 1;						//Set the color for all the BSplines in the group			for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)				wholeObjects[wholeObjectIndex]->bsplines[j]->SetSurfaceTraits(newSurfaceTraits);		}		else		{			//Set the color for all the BSplines in the group			for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)				wholeObjects[wholeObjectIndex]->bsplines[j]->SetSurfaceTraits(sOldSurfaceTraits);		}	}		return true;}pascal void Drawing::ColorPickerColorChangedDrawing(SInt32 userData, PMColor *newColor){	int wholeObjectIndex = (int)userData;		SurfaceTraits newSurfaceTraits = sOldSurfaceTraits;		newSurfaceTraits.interiorColor.red = newColor->color.rgb.red;	newSurfaceTraits.interiorColor.green = newColor->color.rgb.green;	newSurfaceTraits.interiorColor.blue = newColor->color.rgb.blue;		//Black signifies no color, so don't let it be chosen	if (newSurfaceTraits.interiorColor.red == 0)		newSurfaceTraits.interiorColor.red = 1;	if (newSurfaceTraits.interiorColor.green == 0)		newSurfaceTraits.interiorColor.green = 1;	if (newSurfaceTraits.interiorColor.blue == 0)		newSurfaceTraits.interiorColor.blue = 1;		//Set the color for all the BSplines in the group	vector<WholeObject*> wholeObjects = gDrawing->GetWholeObjects();	for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)		wholeObjects[wholeObjectIndex]->bsplines[j]->SetSurfaceTraits(newSurfaceTraits);		gMainWindow->Redraw();}pascal void Drawing::NColorPickerColorChangedDrawing(SInt32 userData, NPMColor *newColor){	int wholeObjectIndex = (int)userData;		SurfaceTraits newSurfaceTraits = sOldSurfaceTraits;		newSurfaceTraits.interiorColor.red = newColor->color.rgb.red;	newSurfaceTraits.interiorColor.green = newColor->color.rgb.green;	newSurfaceTraits.interiorColor.blue = newColor->color.rgb.blue;		//Black signifies no color, so don't let it be chosen	if (newSurfaceTraits.interiorColor.red == 0)		newSurfaceTraits.interiorColor.red = 1;	if (newSurfaceTraits.interiorColor.green == 0)		newSurfaceTraits.interiorColor.green = 1;	if (newSurfaceTraits.interiorColor.blue == 0)		newSurfaceTraits.interiorColor.blue = 1;		//Set the color for all the BSplines in the group	vector<WholeObject*> wholeObjects = gDrawing->GetWholeObjects();	for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)		wholeObjects[wholeObjectIndex]->bsplines[j]->SetSurfaceTraits(newSurfaceTraits);		gMainWindow->Redraw();}bool Drawing::ChangeObjectReflectance(BSpline* bsp, double newReflectance){	//Find the whole object for the BSpline	int wholeObjectIndex = -1;	for (int j = 0; j < wholeObjects.size(); j++)		if (find(wholeObjects[j]->bsplines.begin(), wholeObjects[j]->bsplines.end(), bsp) != wholeObjects[j]->bsplines.end())		{			wholeObjectIndex = j;			break;		}		//Can't change reflectance of illegal BSplines (which have no object)	if (wholeObjectIndex == -1)		return false;		//Get the old color	bool foundIt = false;	for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)		if (wholeObjects[wholeObjectIndex]->bsplines[j]->GetWindingNumber() > 0)		{			sOldSurfaceTraits = wholeObjects[wholeObjectIndex]->bsplines[j]->GetSurfaceTraits();			foundIt = true;			break;		}	if (!foundIt)	{		for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)			if (wholeObjects[wholeObjectIndex]->bsplines[j]->GetWindingNumber() == 0)			{				sOldSurfaceTraits = wholeObjects[wholeObjectIndex]->bsplines[j]->GetSurfaceTraits();				foundIt = true;				break;			}	}	if (!foundIt)	{		for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)			if (wholeObjects[wholeObjectIndex]->bsplines[j]->GetWindingNumber() < 0)			{				sOldSurfaceTraits = wholeObjects[wholeObjectIndex]->bsplines[j]->GetSurfaceTraits();				foundIt = true;				break;			}	}	MyAssert(foundIt);		SurfaceTraits newSurfaceTraits = sOldSurfaceTraits;	newSurfaceTraits.interiorReflectance = newReflectance;		//Set the color for all the BSplines in the group	for (int j = 0; j < wholeObjects[wholeObjectIndex]->bsplines.size(); j++)		wholeObjects[wholeObjectIndex]->bsplines[j]->SetSurfaceTraits(newSurfaceTraits);		return true;}//Keeps the highest section of the highest BSpline at depth 0, but makes no attempt to close gaps between BSplines.//Gap closing is handled by VerticallyCompactDrawingvoid Drawing::NormalizeDepths(){	//for (int i = 0; i < bsplines.size(); i++)	//	MyAssert(bsplines[i]->GetAllIntersectionsLegal(true));		int minDepth = 999999;	for (vector<BSpline*>::iterator i = bsplines.begin(); i != bsplines.end(); i++)	{		vector<int> sectionDepths = *(*i)->GetSectionDepths();				//Find the min depth for one BSpline		int oneBSplineMinDepth = 999999;		for (int i = 0; i < sectionDepths.size(); i++)			if (sectionDepths[i] < oneBSplineMinDepth)				oneBSplineMinDepth = sectionDepths[i];				//Take the global min depth		if (oneBSplineMinDepth < minDepth)			minDepth = oneBSplineMinDepth;	}	for (vector<BSplineToBSplineCut*>::iterator i = bsplinePairCuts.begin(); i != bsplinePairCuts.end(); i++)	{		vector<int> sectionDepths = *(*i)->GetSectionDepths();				//Find the min depth for one BSpline		int oneBSplineMinDepth = 999999;		for (int i = 0; i < sectionDepths.size(); i++)			if (sectionDepths[i] < oneBSplineMinDepth)				oneBSplineMinDepth = sectionDepths[i];				//Take the global min depth		if (oneBSplineMinDepth < minDepth)			minDepth = oneBSplineMinDepth;	}		if (minDepth != 0)	{		for (vector<BSpline*>::iterator i = bsplines.begin(); i != bsplines.end(); i++)			(*i)->PushPullBSpline(-minDepth);		for (vector<BSplineToBSplineCut*>::iterator i = bsplinePairCuts.begin(); i != bsplinePairCuts.end(); i++)			(*i)->PushPullCut(-minDepth);	}		//for (int i = 0; i < bsplines.size(); i++)	//	MyAssert(bsplines[i]->GetAllIntersectionsLegal(true));}//Make sure that every depth in the drawing's depth range is represented by a boundary section somewhere in the drawingvoid Drawing::VerticallyCompactDrawing(){	//This really doesn't work (although at the same time I suspect it is totally unnecessary).	//Since depths are chosen for the search based on the max possible depth range per section,	//it might be impossible get vertically uncompacted labelings.  I'm not sure.		/*	for (int i = 0; i < bsplines.size(); i++)		MyAssert(bsplines[i]->GetAllIntersectionsLegal(true));			//Loop over the whole objects	bool changeWasMade = true;	while (changeWasMade)	{		changeWasMade = false;		for (int i = 0; i < wholeObjects.size(); i++)		{			//Find the smallest gap depth for all the BSplines in this object			int minObjectGapDepth = 999999;			for (int j = 0; j < wholeObjects[i]->bsplines.size(); j++)			{				int minBSplineGapDepth = wholeObjects[i]->bsplines[j]->GetMinIntersectionGap();				if (minBSplineGapDepth < minObjectGapDepth)					minObjectGapDepth = minBSplineGapDepth;			}						//Find the smallest gap depth for all the Cuts in this object			for (int j = 0; j < wholeObjects[i]->bsplines.size(); j++)			{				vector<BSplineToBSplineCut*> cuts = GetCutsForOneBSpline(wholeObjects[i]->bsplines[j]);				for (int k = 0; k < cuts.size(); k++)				{					int minBSplineGapDepth = cuts[k]->GetMinIntersectionGap();					if (minBSplineGapDepth < minObjectGapDepth)						minObjectGapDepth = minBSplineGapDepth;				}			}						//If the object has a gap, pull the entire object up			if (minObjectGapDepth != 999999 && minObjectGapDepth > 0)			{				//PushPull the BSplines				for (int j = 0; j < wholeObjects[i]->bsplines.size(); j++)					wholeObjects[i]->bsplines[j]->PushPullBSpline(-minObjectGapDepth);								//PushPull the Cuts				for (int j = 0; j < bsplinePairCuts.size(); j++)					if (find(wholeObjects[i]->bsplines.begin(), wholeObjects[i]->bsplines.end(), bsplinePairCuts[j]->GetBsp1()) != wholeObjects[i]->bsplines.end() ||						find(wholeObjects[i]->bsplines.begin(), wholeObjects[i]->bsplines.end(), bsplinePairCuts[j]->GetBsp2()) != wholeObjects[i]->bsplines.end())						bsplinePairCuts[j]->PushPullCut(-minObjectGapDepth);								changeWasMade = true;				break;			}		}	}		for (int i = 0; i < bsplines.size(); i++)		MyAssert(bsplines[i]->GetAllIntersectionsLegal(true));	*/}