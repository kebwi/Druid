#ifndef __SUBREGION__#define __SUBREGION__#include "FloatPoint.h"#include "Subboundaries.h"#include "Colors.h"#include <vector.h>#include <list.h>#include <utility.h>	//for pairusing namespace std;class WholeObject;class BspBspIntersection;class OverlappingSubsurface;class SubregionAdjacency;class Subregion{	public:		vector<GenericIntersection*> corners;		vector<OrientedBoundarySection> obss;		vector<UnorientedBoundarySection> ubss;		vector<FloatPoint> points;		int furthestLeftPointIdx;		vector<Subregion*> enclosingNeighbors, enclosedNeighbors;	//This is a directed relationship.  Neighbors won't be symmetric, thus there are two arrays for storing them.		vector<SubregionAdjacency> subregionAdjacencies;	//One for every edge of the subregion		//vector<pair<BSpline*, int> > enclosingBsps;	//For each BSpline, the number of rightward edges along the subregion's slice		//vector<pair<BSpline*, BSpline*> > enclosingBspPairs;	//Every combo from enclosingBsps		vector<pair<WholeObject*, int> > enclosingWOs;	//For each WholeObject, the number of leftward edges along the subregion's slice (negative values denote a net accumulation of more rightward edges than leftward edges)		list<OverlappingSubsurface> overlappingSubsurfaces;		//vector<pair<BSpline*, int> > sectionBspDepths;		vector<pair<WholeObject*, int> > sectionWODepths;		vector<pair<WholeObject*, SurfaceTraits> > layerSurfaceTraits;		vector<Subregion*> requiredPredrawnSubregions;		RGBColor color;		//bool emptySubregion;	//A subregion with no associated surfaces		bool subregionDrawn;		FloatPoint sliceFromPoint;		vector<CutIntersection> sliceIntersections;				int row;	//Just for debugging				Subregion();		~Subregion();		void DeleteAllIntersections();		bool DetermineSubregionColor2();		bool Draw(Point scrollOffset, CGrafPtr debugGrafPtr);		void DrawDebug(Point scrollOffset, CGrafPtr debugGrafPtr, bool thick = true);};struct OverlappingSubsurface{	pair<WholeObject*, WholeObject*> wholeObjectPair;	vector<Subregion*> subregions;};struct SubregionAdjacency{	Subregion *sr1, *sr2;	UnorientedBoundarySection ubs;		SubregionAdjacency(Subregion *sr1I, Subregion *sr2I, UnorientedBoundarySection ubsI) : sr1(sr1I), sr2(sr2I), ubs(ubsI)	{ }		Subregion* GetOtherSubregion(Subregion* sr)	{		return (sr1 == sr) ? sr2 : sr1;	}		private:		SubregionAdjacency();	//Declare away};struct SurfaceSubregionGraph{	struct SurfaceSubregionGraphEdge;		struct SurfaceSubregionGraphNode	{		Subregion* subregion;		vector<int> crossedSubboundaries;	//index of subboundaries between self-intersections.  If a surface is not self-overlapping, this index will always be 0.		vector<int> uncrossableSubboundaries;		vector<pair<SurfaceSubregionGraphEdge*, SurfaceSubregionGraphEdge*> > fromToEdgePairs;		vector<SurfaceSubregionGraphEdge*> spillEdges;				SurfaceSubregionGraphNode(Subregion* sr) : subregion(sr)		{ }				private:			SurfaceSubregionGraphNode();	//Declare away	};		struct SurfaceSubregionGraphEdge	{		SurfaceSubregionGraphNode *nodeFrom, *nodeTo;		BSpline *crossedBSpline;		BSplineToBSplineCut *crossedCut;		int crossedSubboundary;		bool crossedIntoSurface;				SurfaceSubregionGraphEdge(SurfaceSubregionGraphNode *nf, SurfaceSubregionGraphNode *nt, BSpline *cbsp, BSplineToBSplineCut *cc, int csb, bool cis) : nodeFrom(nf), nodeTo(nt), crossedBSpline(cbsp), crossedCut(cc), crossedSubboundary(csb), crossedIntoSurface(cis)		{			//MyAssert((crossedBSpline && !crossedCut) || (!crossedBSpline && crossedCut));	//Not true at T junctions			MyAssert(!crossedBSpline || !crossedCut);		}				bool IsSymmetrical(SurfaceSubregionGraphEdge* toEdge)		{			MyAssert(nodeTo == toEdge->nodeFrom);			if (nodeFrom->subregion != toEdge->nodeTo->subregion)				return false;			if (crossedBSpline != toEdge->crossedBSpline || crossedCut != toEdge->crossedCut)				return false;			if (crossedSubboundary != toEdge->crossedSubboundary || crossedIntoSurface != !toEdge->crossedIntoSurface)				return false;			return true;		}				SurfaceSubregionGraphNode* GetOtherNode(SurfaceSubregionGraphNode* ssgn)		{			return (nodeFrom == ssgn) ? nodeTo : nodeFrom;		}		/*		Subregion* GetOtherSubregion(Subregion* sr)		{			return (nodeFrom->subregion == sr) ? nodeTo->subregion : nodeFrom->subregion;		}		*/		private:			SurfaceSubregionGraphEdge();	//Declare away	};		WholeObject* wholeObject;	vector<SurfaceSubregionGraphNode*> nodes;	vector<SurfaceSubregionGraphEdge*> edges;	//debug only		SurfaceSubregionGraph(WholeObject* wo) : wholeObject(wo)	{ }		~SurfaceSubregionGraph()	{		for (int i = 0; i < nodes.size(); i++)			delete nodes[i];		nodes.clear();		for (int i = 0; i < edges.size(); i++)			delete edges[i];		edges.clear();	}		void DrawDebug(Point scrollOffset, int offsetH, int offsetV, CGrafPtr debugGrafPtr);		private:		SurfaceSubregionGraph();	//Declare away};#endif