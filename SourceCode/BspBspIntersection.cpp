#include "BspBspIntersection.h"#include "BSpline.h"#include "Drawing.h"#include "trigConstants.h"#include "MainWindow.h"	//еее DEBUG#include <math.h>#include <vector.h>#include <algorithm.h>#include <string>#include <sstream>using namespace::std;//******************************************************************************//Extern Globalsextern MainWindow* gMainWindow;//******************************************************************************//Function Prototypes	//	In this file	//	In external files		//	main.cppvoid MyAssert(bool condition);		//lineEquations.cppdouble LineSegmentAngle(FloatPoint p1, FloatPoint p2);#pragma mark -BspBspIntersection::BspBspIntersection(Drawing* theDrawing) : GenericIntersection(GenericIntersection::BSP_BSP, theDrawing){}BspBspIntersection::BspBspIntersection(Drawing* theDrawing, FloatPoint locInit, BSpline *bsp1init, BSpline *bsp2init,	int initBsp1index, int initBsp2index, int initCv1, int initCv2, int initSg1, int initSg2) :	GenericIntersection(GenericIntersection::BSP_BSP, theDrawing, locInit),	bsp1(bsp1init), bsp2(bsp2init), bsp1index(initBsp1index), bsp2index(initBsp2index),	cv1(initCv1), cv2(initCv2), seg1(initSg1), seg2(initSg2), deleteDir1(0), deleteDir2(0){	MyAssert(!dtored);	MyAssert(bsp1 && bsp2);	DetermineOccludedEdge();	//Sets the delete directions}BspBspIntersection::BspBspIntersection(BspBspIntersection& intersection, Drawing* d, BSpline *bsp1init, BSpline *bsp2init) :	GenericIntersection(intersection, d){	bsp1index = intersection.bsp1index;	bsp2index = intersection.bsp2index;	cv1 = intersection.cv1;	cv2 = intersection.cv2;	seg1 = intersection.seg1;	seg2 = intersection.seg2;		bsp1 = bsp1init;	bsp2 = bsp2init;		MyAssert(bsp1 && bsp2);	MyAssert(!dtored);	TestForAdjacentSegments();}BspBspIntersection::~BspBspIntersection(){	MyAssert(!dtored);		if (bsp1)		bsp1->RemoveIntersection(cv1, (GenericIntersection*)this, true, deleteDir1);	MyAssert(!dtored);		if (bsp2 != bsp1)	{		if (bsp2)			bsp2->RemoveIntersection(cv2, (GenericIntersection*)this, true, deleteDir2);		MyAssert(!dtored);	}		//dtored will be set true in the GenericIntersection dtor}BSpline* BspBspIntersection::GetBsp1(){	MyAssert(!dtored);	return bsp1;}BSpline* BspBspIntersection::GetBsp2(){	MyAssert(!dtored);	return bsp2;}BSpline* BspBspIntersection::GetOtherBsp(BSpline* bsp){	MyAssert(!dtored);	MyAssert(bsp1 && bsp2);	MyAssert(bsp1 == bsp || bsp2 == bsp);	return (bsp1 == bsp) ? bsp2 : bsp1;}int BspBspIntersection::GetBsp1Index(){	MyAssert(!dtored);	MyAssert(bsp1);	return bsp1index;}int BspBspIntersection::GetBsp2Index(){	MyAssert(!dtored);	MyAssert(bsp2);	return bsp2index;}int BspBspIntersection::GetCv1(){	MyAssert(!dtored);	return cv1;}int BspBspIntersection::GetCv2(){	MyAssert(!dtored);	return cv2;}int BspBspIntersection::GetSg1(){	MyAssert(!dtored);	return seg1;}int BspBspIntersection::GetSg2(){	MyAssert(!dtored);	return seg2;}bool BspBspIntersection::SelfIntersection(){	MyAssert(!dtored);	return (bsp1 == bsp2);}#pragma mark -void BspBspIntersection::FlipTopBottom(){	MyAssert(!dtored);		BSpline* bspTemp = bsp1;	int bspIndexTemp = bsp1index;	int cvTemp = cv1;	int segTemp = seg1;		bsp1 = bsp2;	bsp1index = bsp2index;	cv1 = cv2;	seg1 = seg2;		bsp2 = bspTemp;	bsp2index = bspIndexTemp;	cv2 = cvTemp;	seg2 = segTemp;		int occludedEdge = DetermineOccludedEdge();	MyAssert(occludedEdge == 3 || occludedEdge == 4);}//1:cv1end1, 2:cv1end2, 3:cv2end1, 4:cv2end2int BspBspIntersection::DetermineOccludedEdge(){	MyAssert(!dtored);		//Get the endpoints of the segments	FloatPoint seg1end1 = bsp1->GetCurvePoint(cv1, seg1);	FloatPoint seg1end2 = bsp1->GetCurvePoint(cv1, seg1 + 1);	FloatPoint seg2end1 = bsp2->GetCurvePoint(cv2, seg2);	FloatPoint seg2end2 = bsp2->GetCurvePoint(cv2, seg2 + 1);		//Get the angle of the endpoints from the intersection	double seg1end1angle = LineSegmentAngle(location, seg1end1);	double seg1end2angle = LineSegmentAngle(location, seg1end2);	double seg2end1angle = LineSegmentAngle(location, seg2end1);	double seg2end2angle = LineSegmentAngle(location, seg2end2);		//It's possible an endpoint might be practically on top of the intersection	MyAssert(seg1end1 != location || seg1end2 != location);	MyAssert(seg2end1 != location || seg2end2 != location);	if (seg1end1 == location)	{		seg1end1angle = seg1end2angle + Pi;		if (seg1end1angle >= PiTimes2)			seg1end1angle -= PiTimes2;	}	else if (seg1end2 == location)	{		seg1end2angle = seg1end1angle + Pi;		if (seg1end2angle >= PiTimes2)			seg1end2angle -= PiTimes2;	}	if (seg2end1 == location)	{		seg2end1angle = seg2end2angle + Pi;		if (seg2end1angle >= PiTimes2)			seg2end1angle -= PiTimes2;	}	else if (seg2end2 == location)	{		seg2end2angle = seg2end1angle + Pi;		if (seg2end2angle >= PiTimes2)			seg2end2angle -= PiTimes2;	}		//Sanity check.  The corresponding angles should differ by Pi.	double angleDiff = fabs(seg1end1angle - seg1end2angle);	double piMinusAngleDiff = Pi - angleDiff;	MyAssert(fabs(Pi - angleDiff) < .1);		angleDiff = fabs(seg2end1angle - seg2end2angle);	piMinusAngleDiff = Pi - angleDiff;	MyAssert(fabs(Pi - angleDiff) < .1);		if (false)	{		ForeColor(blackColor);		Rect r;		SetRect(&r, location.h - 5, location.v - 5, location.h + 5, location.v + 5);		FrameOval(&r);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);	}		//Sanity check.  The angles for the two segments should alternate when ordered,	//meaning that when sorted, the angles should go seg1, seg2, seg1, seg2, or seg2, seg1, seg2, seg1	vector<double> angles;	angles.push_back(seg1end1angle);	angles.push_back(seg1end2angle);	angles.push_back(seg2end1angle);	angles.push_back(seg2end2angle);	sort(angles.begin(), angles.end());		bool anglesAreSane = false;	if (angles[0] == seg1end1angle && angles[2] == seg1end2angle)		anglesAreSane = true;	if (angles[0] == seg1end2angle && angles[2] == seg1end1angle)		anglesAreSane = true;	if (angles[0] == seg2end1angle && angles[2] == seg2end2angle)		anglesAreSane = true;	if (angles[0] == seg2end2angle && angles[2] == seg2end1angle)		anglesAreSane = true;	MyAssert(anglesAreSane);		//Find the occluded edge	int occludedAngleIndex;		if (angles[0] == seg1end1angle)		occludedAngleIndex = 3;	else if (angles[1] == seg1end1angle)		occludedAngleIndex = 0;	else if (angles[2] == seg1end1angle)		occludedAngleIndex = 1;	else if (angles[3] == seg1end1angle)		occludedAngleIndex = 2;		int occludedEdge;		if (angles[occludedAngleIndex] == seg1end1angle)		occludedEdge = 1;	else if (angles[occludedAngleIndex] == seg1end2angle)		occludedEdge = 2;	else if (angles[occludedAngleIndex] == seg2end1angle)		occludedEdge = 3;	else	{		MyAssert(angles[occludedAngleIndex] == seg2end2angle);		occludedEdge = 4;	}		MyAssert(occludedEdge == 3 || occludedEdge == 4);	if (occludedEdge == 3)	{		deleteDir1 = 0;		deleteDir2 = -1;	}	else if (occludedEdge == 4)	{		deleteDir1 = -1;		deleteDir2 = 0;	}		return occludedEdge;}bool BspBspIntersection::IntersectionLegal(){	MyAssert(!dtored);		int occludedEdge = DetermineOccludedEdge();	MyAssert(occludedEdge == 3 || occludedEdge == 4);		//Get the four depths at the intersection	int bsp1End1D = bsp1->GetSectionDepthBeforeIntersection(this, cv1, seg1);	int bsp1End2D = bsp1->GetSectionDepthAfterIntersection(this, cv1, seg1);	int bsp2End1D = bsp2->GetSectionDepthBeforeIntersection(this, cv2, seg2);	int bsp2End2D = bsp2->GetSectionDepthAfterIntersection(this, cv2, seg2);		//Check the depths for legality	if (bsp1End1D != bsp1End2D)		return false;		if (occludedEdge == 3 && bsp2End1D != bsp2End2D + 1)		return false;	else if (occludedEdge == 4 && bsp2End2D != bsp2End1D + 1)		return false;		if (min(bsp2End1D, bsp2End2D) < bsp1End1D)		return false;		return true;}//Make sure that, in the case of a self intersection, the intersection isn't on two adjacent segmentsvoid BspBspIntersection::TestForAdjacentSegments(){	MyAssert(!dtored);	if (!SelfIntersection())		return;		MyAssert(fabs((cv1 * BSpline::sNumSegmentsPerCurve + seg1) - (cv2 * BSpline::sNumSegmentsPerCurve + seg2)) > 1);}void BspBspIntersection::IncreaseCurve(BSpline *bsp, int curve){	MyAssert(!dtored);		if (bsp1 == bsp && cv1 == curve)		cv1++;	if (bsp2 == bsp && cv2 == curve)		cv2++;}void BspBspIntersection::DecreaseCurve(BSpline *bsp, int curve){	MyAssert(!dtored);		if (bsp1 == bsp && cv1 == curve)		cv1--;	if (bsp2 == bsp && cv2 == curve)		cv2--;}void BspBspIntersection::IncreaseSeg(BSpline *bsp, int numCrvs, int cv, int sg){	MyAssert(!dtored);	MyAssert(bsp1 != bsp2 || (cv != -1 && sg != -1));		bool firstBsp = true;	if (bsp1 == bsp2)	{		if (cv == cv1 && sg == seg1)			firstBsp = true;		else if (cv == cv2 && sg == seg2)			firstBsp = false;		else MyAssert(false);	}		if ((bsp1 != bsp2 && bsp == bsp1) || (bsp1 == bsp2 && firstBsp))	{		seg1++;		if (seg1 >= BSpline::sNumSegmentsPerCurve)		{			seg1 = 0;			cv1++;			if (cv1 >= numCrvs)				cv1 = 0;		}	}	else if ((bsp1 != bsp2 && bsp == bsp2) || (bsp1 == bsp2 && !firstBsp))	{		seg2++;		if (seg2 >= BSpline::sNumSegmentsPerCurve)		{			seg2 = 0;			cv2++;			if (cv2 >= numCrvs)				cv2 = 0;		}	}	else MyAssert(false);}void BspBspIntersection::DecreaseSeg(BSpline *bsp, int numCrvs, int cv, int sg){	MyAssert(!dtored);	MyAssert(bsp1 != bsp2 || (cv != -1 && sg != -1));		bool firstBsp = true;	if (bsp1 == bsp2)	{		if (cv == cv1 && sg == seg1)			firstBsp = true;		else if (cv == cv2 && sg == seg2)			firstBsp = false;		else MyAssert(false);	}		if ((bsp1 != bsp2 && bsp == bsp1) || (bsp1 == bsp2 && firstBsp))	{		seg1--;		if (seg1 < 0)		{			seg1 = BSpline::sNumSegmentsPerCurve - 1;			cv1--;			if (cv1 < 0)				cv1 = numCrvs - 1;		}	}	else if ((bsp1 != bsp2 && bsp == bsp2) || (bsp1 == bsp2 && !firstBsp))	{		seg2--;		if (seg2 < 0)		{			seg2 = BSpline::sNumSegmentsPerCurve - 1;			cv2--;			if (cv2 < 0)				cv2 = numCrvs - 1;		}	}	else MyAssert(false);}void BspBspIntersection::DecreaseBsp1index(){	MyAssert(!dtored);	bsp1index--;}void BspBspIntersection::DecreaseBsp2index(){	MyAssert(!dtored);	bsp2index--;}void BspBspIntersection::SetCurvesAndSegs(int newCv1, int newSg1, int newCv2, int newSg2){	MyAssert(!dtored);	cv1 = newCv1;	cv2 = newCv2;	seg1 = newSg1;	seg2 = newSg2;}void BspBspIntersection::SetNullBsp(BSpline* bsp){	MyAssert(!dtored);		if (bsp1 == bsp)	{		bsp1 = NULL;		bsp1index = -1;		cv1 = -1;		seg1 = -1;	}	if (bsp2 == bsp)	{		bsp2 = NULL;		bsp2index = -1;		cv2 = -1;		seg2 = -1;	}}void BspBspIntersection::SetDeleteDir1(int value){	deleteDir1 = value;}void BspBspIntersection::SetDeleteDir2(int value){	deleteDir2 = value;}#pragma mark -void BspBspIntersection::DumpFileData(short fRefNum, double fileVersion){	MyAssert(!dtored);		string st;	ostringstream oss;		oss << "  " << GenericIntersection::BSP_BSP << "\n";		oss << "  " << location.h << " " << location.v << "\n";		oss << "  " << bsp1index << " " << bsp2index << "\n";	oss << "  " << cv1 << " " << cv2 << " " << seg1 << " " << seg2 << "\n";	oss << "  " << deleteDir1 << " " << deleteDir2 << "\n";		st += oss.str();	long strLen = st.length();	OSErr err = FSWrite(fRefNum, &strLen, st.c_str());}void BspBspIntersection::LoadFileData(istringstream& iss, double fileVersion){	//The intersection was already read off the stream		iss >> location.h >> location.v;		iss >> bsp1index >> bsp2index;	vector<BSpline*> bsplines = drawing->GetBSplines();	MyAssert(bsp1index < bsplines.size() && bsp2index < bsplines.size());	bsp1 = bsplines[bsp1index];	bsp2 = bsplines[bsp2index];		iss >> cv1 >> cv2 >> seg1 >> seg2;	iss >> deleteDir1 >> deleteDir2;}