#include "Subboundaries.h"#include "BSpline.h"#include "BSplineToBSplineCut.h"#include "Drawing.h"//******************************************************************************//Extern Globals//******************************************************************************//Global Declarations//******************************************************************************//Function Prototypes	//	In external files		//	main.cppvoid MyAssert(bool condition);#pragma mark -OrientedBoundarySection::OrientedBoundarySection() : bsp(NULL), cut(NULL), infiniteWO(NULL), startInter(NULL), endInter(NULL), startCv(-1), startSg(-1), startInfiniteWOsection(-1), endInfiniteWOsection(-1), subboundaryIndex(-1), traverseForward(true){}OrientedBoundarySection::OrientedBoundarySection(BSpline* bspI, BSplineToBSplineCut* cutI, WholeObject* iwoI, GenericIntersection *si, GenericIntersection *ei, int scv, int ssg, int sich, bool tf) :	bsp(bspI), cut(cutI), infiniteWO(iwoI), startInter(si), endInter(ei), startCv(scv), startSg(ssg), startInfiniteWOsection(sich), endCv(-1), endSg(-1), endInfiniteWOsection(-1), subboundaryIndex(-1), traverseForward(tf){	//MyAssert((bsp && !cut) || (!bsp && cut));	MyAssert(!bsp || !cut);	MyAssert((!bsp && !cut) || !infiniteWO);}const bool OrientedBoundarySection::OrientedBoundarySection::operator==(const OrientedBoundarySection& obs){	return (bsp == obs.bsp && cut == obs.cut && infiniteWO == obs.infiniteWO &&			startInter == obs.startInter && endInter == obs.endInter &&			startCv == obs.startCv && startSg == obs.startSg &&// startInfiniteWOsection == obs.startInfiniteWOsection &&// endCv == obs.endCv && endSg == obs.endSg && endInfiniteWOsection == obs.endInfiniteWOsection &&			traverseForward == obs.traverseForward);}bool OrientedBoundarySection::OrientedBoundarySection::Opposite(const OrientedBoundarySection& obs){	MyAssert((bsp && !cut && !infiniteWO) || (!bsp && cut && !infiniteWO) || (!bsp && !cut && infiniteWO));	if (bsp)		return (bsp == obs.bsp &&				startInter == obs.endInter && endInter == obs.startInter &&				startCv == obs.endCv && startSg == obs.endSg && endCv == obs.startCv && endSg == obs.startSg &&				traverseForward == !obs.traverseForward);	else if (cut)		return (cut == obs.cut &&				startInter == obs.endInter && endInter == obs.startInter);// &&				//startCv == obs.endCv && startSg == obs.endSg && endCv == obs.startCv && endSg == obs.startSg &&				//traverseForward == !obs.traverseForward);	else if (infiniteWO)		return (infiniteWO == obs.infiniteWO &&				startInter == obs.endInter && endInter == obs.startInter);	else MyAssert(false);}//====================================================================================================================//====================================================================================================================//====================================================================================================================UnorientedBoundarySection::UnorientedBoundarySection() : bsp(NULL), cut(NULL), infiniteWO(NULL), startInter(NULL), endInter(NULL), startCv(-1), startSg(-1), endCv(-1), endSg(-1), subboundaryIndex(-1), hashKey(0), hashKeyGenerated(false){}UnorientedBoundarySection::UnorientedBoundarySection(BSpline* bspI, BSplineToBSplineCut* cutI, WholeObject* iwoI, GenericIntersection *ia, GenericIntersection *ib, int scv, int ssg, int sich, bool polarity) :	bsp(bspI), cut(cutI), infiniteWO(iwoI), subboundaryIndex(-1), hashKey(0), hashKeyGenerated(false){	if (polarity)	{		startInter = ia;		endInter = ib;		startCv = scv;		startSg = ssg;				endCv = -1;		endSg = -1;	}	else	{		startInter = ib;		endInter = ia;		startCv = -1;		startSg = -1;		endCv = scv;		endSg = ssg;	}		//MyAssert((bsp && !cut) || (!bsp && cut));	//Not necessarily true	MyAssert(!bsp || !cut);	MyAssert((!bsp && !cut) || !infiniteWO);}UnorientedBoundarySection::UnorientedBoundarySection(const OrientedBoundarySection& obs) :	bsp(obs.bsp), cut(obs.cut), infiniteWO(obs.infiniteWO), startInter(obs.startInter), subboundaryIndex(obs.subboundaryIndex), hashKey(0), hashKeyGenerated(false){	if (obs.traverseForward)	{		startInter = obs.startInter;		endInter = obs.endInter;		startCv = obs.startCv;		startSg = obs.startSg;		startInfiniteWOsection = obs.startInfiniteWOsection;		endCv = obs.endCv;		endSg = obs.endSg;		endInfiniteWOsection = obs.endInfiniteWOsection;	}	else	{		startInter = obs.endInter;		endInter = obs.startInter;		startCv = obs.endCv;		startSg = obs.endSg;		startInfiniteWOsection = obs.endInfiniteWOsection;		endCv = obs.startCv;		endSg = obs.startSg;		endInfiniteWOsection = obs.startInfiniteWOsection;	}		//MyAssert((bsp && !cut) || (!bsp && cut));	//Not necessarily true	MyAssert(!bsp || !cut);}const bool UnorientedBoundarySection::operator==(const UnorientedBoundarySection& ubs){	if (bsp)		return (bsp == ubs.bsp &&					((startInter == ubs.startInter && endInter == ubs.endInter &&						startCv == ubs.startCv && startSg == ubs.startSg// && endCv == ubs.endCv && endSg == ubs.endSg						) ||					(startInter == ubs.endInter && endInter == ubs.startInter &&						startCv == ubs.endCv && startSg == ubs.endSg// && endCv == ubs.startCv && endSg == ubs.startSg						)));	else if (cut)		return (cut == ubs.cut &&				((startInter == ubs.startInter && endInter == ubs.endInter) ||				(startInter == ubs.endInter && endInter == ubs.startInter)));	else if (infiniteWO)		return (infiniteWO == ubs.infiniteWO &&				((startInter == ubs.startInter && endInter == ubs.endInter &&					startInfiniteWOsection && ubs.startInfiniteWOsection// && endInfiniteWOsection && ubs.endInfiniteWOsection						) ||				(startInter == ubs.endInter && endInter == ubs.startInter &&					startInfiniteWOsection && ubs.endInfiniteWOsection// && endInfiniteWOsection && ubs.startInfiniteWOsection						)));	else MyAssert(false);}/*int UnorientedBoundarySection::FindSubboundarySection(){	if (cut)	{		MyAssert(!bsp);		return 0;	}		return bsp->FindSelfIntersectionSubboundaryForSection(this);}*/bool UnorientedBoundarySection::EqualObs(const OrientedBoundarySection& obs){	return (obs.bsp == bsp && obs.cut == cut && obs.infiniteWO == infiniteWO &&			(obs.startInter == startInter && obs.endInter == endInter &&				obs.startCv == startCv && obs.startSg == startSg && obs.endCv == endCv && obs.endSg == endSg &&				obs.startInfiniteWOsection == startInfiniteWOsection && obs.endInfiniteWOsection == endInfiniteWOsection) ||			(obs.startInter == endInter && obs.endInter == startInter &&				obs.startCv == endCv && obs.startSg == endSg && obs.endCv == startCv && obs.endSg == startSg &&				obs.startInfiniteWOsection == endInfiniteWOsection && obs.endInfiniteWOsection == startInfiniteWOsection));}unsigned long UnorientedBoundarySection::GetHashKey(){	if (hashKeyGenerated)		return hashKey;		MyAssert(hashKey == 0);	MyAssert(subboundaryIndex != -1);		if (bsp)	{		hashKey += (bsp->GetBSplineIndex() << 26) & (63 << 26);		hashKey += (startCv << 15) & (31 << 15);		hashKey += (startSg << 10) & (31 << 10);		hashKey += (endCv << 5) & (31 << 5);		hashKey += endSg;//(endSg << 0) & (31 << 0);	}	else if (cut)	{		hashKey += (cut->GetCutIndex() << 20) & (63 << 20);		hashKey += (cut->GetIntersectionIndex(startInter) << 14) & (63 << 14);		MyAssert(cut->FindNextIntersection(startInter) == endInter);	}	else if (infiniteWO)	{		//Not implemented yet		//hashKey += (infiniteWO->GetWholeObjectIndex() << 20) & (63 << 20);		//hashKey += (infiniteWO->GetIntersectionIndex(startInter) << 14) & (63 << 14);	}	else MyAssert(false);		hashKeyGenerated = true;	return hashKey;}bool UnorientedBoundarySection::operator()(UnorientedBoundarySection ubs1, UnorientedBoundarySection ubs2) const{	if (ubs1 == ubs2)		return false;	//return (ubs1.bsp < ubs2.bsp);		if (ubs1.bsp < ubs2.bsp)	{		SysBeep(1);		return true;	}	return false;}