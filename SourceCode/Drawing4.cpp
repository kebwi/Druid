#include "Drawing.h"#include "MinimalDrawing.h"#include "BSpline.h"#include "BSplineToBSplineCut.h"#include "GenericIntersection.h"#include "BspBspIntersection.h"#include "BspCutIntersection.h"#include "BspCutTIntersection.h"#include "CutCutIntersection.h"#include "MainWindow.h"	//еее#include "FloatPoint.h"#include "Colors.h"#include "trigConstants.h"#include "Random.h"#include "PascalStringUtil.h"#include <ColorPicker.h>#include <time.h>#include <algorithm.h>#include <utility.h> //for pair#include <math.h>#include <list.h>#include <vector.h>#include <string>#include <sstream>using namespace::std;//******************************************************************************//Extern Globalsextern WindowPtr gAnalysisWindow;	//еееextern Colors gColors;extern MainWindow* gMainWindow;extern Drawing *gDrawing;extern int gPointRadius;extern int gFindPointDist;extern UserEventUPP gEventProcUPP;extern unsigned long Drawing::sTreeWalk;extern SurfaceTraits Drawing::sOldSurfaceTraits;extern ColorChangedUPP Drawing::sColorChangedUPP;extern NColorChangedUPP Drawing::sColorNChangedUPP;extern int gLabelingMethod;	//0:	tree search							//1:	uniquely determine from companion setextern int gCompanionSetMethod;	//0:	don't use companion sets								//1:	use companion sets to order search, but not to truncate search								//2:	use companion sets to truncate searchextern int gDepthEnumerationMethod;	//0:	use half the number of intersections on a boundary as the enumeration limit and enumerate from the first intersection on the boundary									//1:	find the depth range for each section of a boundary to use as the enumeration limit and enumerate from the deepest range intersection on the boundary (stupid idea, purely for comparative purposes)									//2:	find the depth range for each section of a boundary to use as the enumeration limit and enumerate from the shallowest range intersection on the boundaryextern int gBoundingMethod;	//0:	no bounding							//1:	boundingextern int gTreeSearchMethod;	//0:	depth-first-search								//1:	iterative deepening								//2:	breadth-first-searchextern float gTimeLimitScalar;extern bool gMouseTerminated;extern bool gDebug;extern bool gDebug1;extern bool gDebug3;extern bool gDebug5;extern bool gDebug6;extern bool gDebug7;extern bool gDebug8;extern bool gDebug10;extern bool gDebug11;extern int gTextH;extern int gTextV;extern vector<pair<GenericIntersection*, int> > gInterDists;extern int gHorizon;//******************************************************************************//Global Declarationsbool gAttemptToImproveCutsWithManyInters = false;double lineSegmentProjectSlop = .01;//******************************************************************************//Function Prototypes	//	In external files		//	main.cppvoid MyAssert(bool condition);pascal Boolean ColorPickerEventProc(EventRecord *event);		//lineEquations.cppdouble LineSegmentLength(FloatPoint p1, FloatPoint p2);double LineSegmentAngle(FloatPoint p1, FloatPoint p2);FloatPoint ProjectPointAtAngle(FloatPoint origin, double angle, double segLength);int LineCrossLineDirection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2);bool LineSegmentIntersection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2, FloatPoint &intersection);bool LineSegmentIntersection(FloatPoint pA1, FloatPoint pA2, FloatPoint pB1, FloatPoint pB2,							FloatPoint &intersection, double& lineSegInter1, double& lineSegInter2);#pragma mark -void Drawing::VerifyPrevCuts(){	//Make sure there are no duplicate cuts	if (prevCuts.size() > 0)		for (int i = 0; i < prevCuts.size() - 1; i++)			for (int j = i + 1; j < prevCuts.size(); j++)			{				PrevCut* pc1 = prevCuts[i];				PrevCut* pc2 = prevCuts[j];								if ((pc1->bsp1 == pc2->bsp1 && pc1->bsp2 == pc2->bsp2) ||					(pc1->bsp1 == pc2->bsp2 && pc1->bsp2 == pc2->bsp1))					MyAssert(false);			}		//Make sure all cuts connect "live" BSplines	for (int i = 0; i < prevCuts.size(); i++)		if (prevCuts[i]->bsp2)		{			PrevCut* pc = prevCuts[i];						MyAssert(!pc->bsp1->dtored);			MyAssert(!pc->bsp2->dtored);						if (find(bsplines.begin(), bsplines.end(), pc->bsp1) == bsplines.end() ||				find(bsplines.begin(), bsplines.end(), pc->bsp2) == bsplines.end())				MyAssert(false);		}}void Drawing::VerifyNothingDtored(){	MyAssert(!dtored);		for (int i = 0; i < bsplines.size(); i++)	{		MyAssert(!bsplines[i]->dtored);		bsplines[i]->VerifyNothingDtored();	}		for (int i = 0; i < bsplinePairCuts.size(); i++)	{		MyAssert(!bsplinePairCuts[i]->dtored);		bsplinePairCuts[i]->VerifyNothingDtored();	}		for (int i = 0; i < intersections.size(); i++)		MyAssert(!intersections[i]->GetDtored());		for (int i = 0; i < brandNewIntersections.size(); i++)		MyAssert(!brandNewIntersections[i]->GetDtored());}bool Drawing::FindPreviousBSplineToSpecificBSplineCut(BSpline* bsp1, BSpline* bsp2, int& cv1, int& cv2, int& sg1, int& sg2, FloatPoint& lnPt1, FloatPoint& lnPt2){	MyAssert(bsp1 != bsp2);		VerifyPrevCuts();		//Find a prevCut if it exists	int segIndex, nextSegIndex;	vector<vector<FloatPoint>*> *curvePoints1 = NULL, *curvePoints2 = NULL;		for (int i = 0; i < prevCuts.size(); i++)	{		if (prevCuts[i]->bsp1 == bsp1 && prevCuts[i]->bsp2 == bsp2)		{			curvePoints1 = bsp1->GetCurvePoints();			int bsp1TotalCurveSegs = curvePoints1->size() * BSpline::sNumSegmentsPerCurve;			MyAssert(bsp1TotalCurveSegs > 0);						int bsp2TotalCurveSegs = 0;			if (bsp2)			{				curvePoints2 = bsp2->GetCurvePoints();				bsp2TotalCurveSegs = curvePoints2->size() * BSpline::sNumSegmentsPerCurve;				MyAssert(bsp2TotalCurveSegs > 0);			}						cv1 = prevCuts[i]->cv1;			sg1 = prevCuts[i]->sg1;			cv2 = bsp2 ? prevCuts[i]->cv2 : -1;			sg2 = bsp2 ? prevCuts[i]->sg2 : -1;						segIndex = cv1 * BSpline::sNumSegmentsPerCurve + sg1;			nextSegIndex = (segIndex + 1) % bsp1TotalCurveSegs;						MyAssert(cv1 < curvePoints1->size());			MyAssert(sg1 < (*curvePoints1)[cv1]->size());			MyAssert(nextSegIndex / BSpline::sNumSegmentsPerCurve < curvePoints1->size());			MyAssert(nextSegIndex % BSpline::sNumSegmentsPerCurve < (*curvePoints1)[nextSegIndex / BSpline::sNumSegmentsPerCurve]->size());						lnPt1.h = ((*(*curvePoints1)[cv1])[sg1].h +						(*(*curvePoints1)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].h) / 2;			lnPt1.v = ((*(*curvePoints1)[cv1])[sg1].v +						(*(*curvePoints1)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].v) / 2;						if (bsp2)			{				segIndex = cv2 * BSpline::sNumSegmentsPerCurve + sg2;				nextSegIndex = (segIndex + 1) % bsp2TotalCurveSegs;								MyAssert(cv2 < curvePoints2->size());				MyAssert(sg2 < (*curvePoints2)[cv2]->size());				MyAssert(nextSegIndex / BSpline::sNumSegmentsPerCurve < curvePoints2->size());				MyAssert(nextSegIndex % BSpline::sNumSegmentsPerCurve < (*curvePoints2)[nextSegIndex / BSpline::sNumSegmentsPerCurve]->size());								lnPt2.h = ((*(*curvePoints2)[cv2])[sg2].h +							(*(*curvePoints2)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].h) / 2;				lnPt2.v = ((*(*curvePoints2)[cv2])[sg2].v +							(*(*curvePoints2)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].v) / 2;			}			else lnPt2.h = lnPt2.v = -1;						return true;		}		else if (prevCuts[i]->bsp2 == bsp1 && prevCuts[i]->bsp1 == bsp2)		{			curvePoints1 = bsp2->GetCurvePoints();			int bsp1TotalCurveSegs = curvePoints1->size() * BSpline::sNumSegmentsPerCurve;			MyAssert(bsp1TotalCurveSegs > 0);						int bsp2TotalCurveSegs = 0;			if (bsp2)			{				curvePoints2 = bsp1->GetCurvePoints();				bsp2TotalCurveSegs = curvePoints2->size() * BSpline::sNumSegmentsPerCurve;				MyAssert(bsp2TotalCurveSegs > 0);			}						cv1 = bsp2 ? prevCuts[i]->cv2 : -1;			sg1 = bsp2 ? prevCuts[i]->sg2 : -1;			cv2 = prevCuts[i]->cv1;			sg2 = prevCuts[i]->sg1;						if (bsp2)			{				segIndex = cv1 * BSpline::sNumSegmentsPerCurve + sg1;				nextSegIndex = (segIndex + 1) % bsp2TotalCurveSegs;								MyAssert(cv1 < curvePoints2->size());				MyAssert(sg1 < (*curvePoints2)[cv1]->size());				MyAssert(nextSegIndex / BSpline::sNumSegmentsPerCurve < curvePoints2->size());				MyAssert(nextSegIndex % BSpline::sNumSegmentsPerCurve < (*curvePoints2)[nextSegIndex / BSpline::sNumSegmentsPerCurve]->size());								lnPt1.h = ((*(*curvePoints2)[cv1])[sg1].h +							(*(*curvePoints2)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].h) / 2;				lnPt1.v = ((*(*curvePoints2)[cv1])[sg1].v +							(*(*curvePoints2)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].v) / 2;			}			else lnPt1.h = lnPt1.v = -1;						segIndex = cv2 * BSpline::sNumSegmentsPerCurve + sg2;			nextSegIndex = (segIndex + 1) % bsp1TotalCurveSegs;						MyAssert(cv2 < curvePoints1->size());			MyAssert(sg2 < (*curvePoints1)[cv2]->size());			MyAssert(nextSegIndex / BSpline::sNumSegmentsPerCurve < curvePoints1->size());			MyAssert(nextSegIndex % BSpline::sNumSegmentsPerCurve < (*curvePoints1)[nextSegIndex / BSpline::sNumSegmentsPerCurve]->size());						lnPt2.h = ((*(*curvePoints1)[cv2])[sg2].h +						(*(*curvePoints1)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].h) / 2;			lnPt2.v = ((*(*curvePoints1)[cv2])[sg2].v +						(*(*curvePoints1)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].v) / 2;									return true;		}	}	return false;}bool Drawing::FindPreviousBSplineToAnyBSplineCut(BSpline* bsp1, BSpline*& bsp2, int& cv1, int& cv2, int& sg1, int& sg2, FloatPoint& lnPt1, FloatPoint& lnPt2, PrevCut*& prevCut, int whichPrevCut){	//Search for a previously saved infinite cut		//=============================================================================	//	Old method, take the first prev cut found	//	//Make sure to keep old/new method enabling here in sync with CreateCutFromPrevCut().	/*	bsp2 = NULL;	if (FindPreviousBSplineToSpecificBSplineCut(bsp1, bsp2, cv1, cv2, sg1, sg2, lnPt1, lnPt2))		return true;		//Search for a previously saved BSpline to BSpline cut	for (int i = 0; i < bsplines.size(); i++)		if (bsplines[i] != bsp1)		{			bsp2 = bsplines[i];			if (FindPreviousBSplineToSpecificBSplineCut(bsp1, bsp2, cv1, cv2, sg1, sg2, lnPt1, lnPt2))				return true;		}		return false;	*/	//=============================================================================		//=============================================================================	//	New method, keep trying incrementally found prev cuts until a satisfactory prev cut is found	//	Make sure to keep old/new method enabling here in sync with FindPreviousBSplineToAnyBSplineCut().		MyAssert(whichPrevCut >= 1);	VerifyPrevCuts();		bool success = false;		int prevCutStart = 0;	for (int cnt = 0; cnt < whichPrevCut; cnt++)	{		//Find a prevCut if it exists		//int segIndex, nextSegIndex;		//vector<vector<FloatPoint>*> *curvePoints1 = NULL, *curvePoints2 = NULL;				success = false;		for (int i = prevCutStart; i < prevCuts.size(); i++)		{			prevCutStart = i + 1;	//prevCutStart is the position in the prevCut list where the next loop through prevCuts will start from						bsp2 = NULL;			if (prevCuts[i]->bsp1 == bsp1 || prevCuts[i]->bsp2 == bsp1)			{				BSpline* newBsp2 = NULL;				if (cnt == whichPrevCut - 1)				{					prevCut = prevCuts[i];										vector<vector<FloatPoint>*> *curvePoints1 = NULL, *curvePoints2 = NULL;					int bsp1TotalCurveSegs = 0, bsp2TotalCurveSegs = 0;					int segIndex1, nextSegIndex1, segIndex2, nextSegIndex2;					if (prevCuts[i]->bsp1 == bsp1)					{						curvePoints1 = prevCuts[i]->bsp1->GetCurvePoints();						bsp1TotalCurveSegs = curvePoints1->size() * BSpline::sNumSegmentsPerCurve;						cv1 = prevCuts[i]->cv1;						sg1 = prevCuts[i]->sg1;						segIndex1 = cv1 * BSpline::sNumSegmentsPerCurve + sg1;						nextSegIndex1 = (segIndex1 + 1) % bsp1TotalCurveSegs;						if (prevCuts[i]->bsp2)						{							curvePoints2 = prevCuts[i]->bsp2->GetCurvePoints();							bsp2TotalCurveSegs = curvePoints2->size() * BSpline::sNumSegmentsPerCurve;							cv2 = prevCuts[i]->cv2;							sg2 = prevCuts[i]->sg2;							segIndex2 = cv2 * BSpline::sNumSegmentsPerCurve + sg2;							nextSegIndex2 = (segIndex2 + 1) % bsp2TotalCurveSegs;							newBsp2 = prevCuts[i]->bsp2;						}					}					else	//if (prevCuts[i]->bsp2 == bsp1)					{						curvePoints1 = prevCuts[i]->bsp2->GetCurvePoints();						bsp1TotalCurveSegs = curvePoints1->size() * BSpline::sNumSegmentsPerCurve;						cv1 = prevCuts[i]->cv2;						sg1 = prevCuts[i]->sg2;						segIndex1 = cv1 * BSpline::sNumSegmentsPerCurve + sg1;						nextSegIndex1 = (segIndex1 + 1) % bsp1TotalCurveSegs;						if (prevCuts[i]->bsp1)						{							curvePoints2 = prevCuts[i]->bsp1->GetCurvePoints();							bsp2TotalCurveSegs = curvePoints2->size() * BSpline::sNumSegmentsPerCurve;							cv2 = prevCuts[i]->cv1;							sg2 = prevCuts[i]->sg1;							segIndex2 = cv2 * BSpline::sNumSegmentsPerCurve + sg2;							nextSegIndex2 = (segIndex2 + 1) % bsp2TotalCurveSegs;							newBsp2 = prevCuts[i]->bsp1;						}					}										if (curvePoints1)					{						MyAssert(cv1 < curvePoints1->size());						MyAssert(sg1 < (*curvePoints1)[cv1]->size());						MyAssert(nextSegIndex1 / BSpline::sNumSegmentsPerCurve < curvePoints1->size());						MyAssert(nextSegIndex1 % BSpline::sNumSegmentsPerCurve < (*curvePoints1)[nextSegIndex1 / BSpline::sNumSegmentsPerCurve]->size());												lnPt1.h = ((*(*curvePoints1)[cv1])[sg1].h +									(*(*curvePoints1)[nextSegIndex1 / BSpline::sNumSegmentsPerCurve])[nextSegIndex1 % BSpline::sNumSegmentsPerCurve].h) / 2;						lnPt1.v = ((*(*curvePoints1)[cv1])[sg1].v +									(*(*curvePoints1)[nextSegIndex1 / BSpline::sNumSegmentsPerCurve])[nextSegIndex1 % BSpline::sNumSegmentsPerCurve].v) / 2;					}					else lnPt1.h = lnPt1.v = -1;										if (curvePoints2)					{						MyAssert(cv2 < curvePoints2->size());						MyAssert(sg2 < (*curvePoints2)[cv2]->size());						MyAssert(nextSegIndex2 / BSpline::sNumSegmentsPerCurve < curvePoints2->size());						MyAssert(nextSegIndex2 % BSpline::sNumSegmentsPerCurve < (*curvePoints2)[nextSegIndex2 / BSpline::sNumSegmentsPerCurve]->size());												lnPt2.h = ((*(*curvePoints2)[cv2])[sg2].h +									(*(*curvePoints2)[nextSegIndex2 / BSpline::sNumSegmentsPerCurve])[nextSegIndex2 % BSpline::sNumSegmentsPerCurve].h) / 2;						lnPt2.v = ((*(*curvePoints2)[cv2])[sg2].v +									(*(*curvePoints2)[nextSegIndex2 / BSpline::sNumSegmentsPerCurve])[nextSegIndex2 % BSpline::sNumSegmentsPerCurve].v) / 2;					}					else lnPt2.h = lnPt2.v = -1;									}								bsp2 = newBsp2;				success = true;				break;			}			/*			if (prevCuts[i]->bsp1 == bsp1)			{				if (cnt == whichPrevCut - 1)				{					curvePoints1 = bsp1->GetCurvePoints();					int bsp1TotalCurveSegs = curvePoints1->size() * BSpline::sNumSegmentsPerCurve;					MyAssert(bsp1TotalCurveSegs > 0);										int bsp2TotalCurveSegs = 0;					if (prevCuts[i]->bsp2)					{						curvePoints2 = prevCuts[i]->bsp2->GetCurvePoints();						bsp2TotalCurveSegs = curvePoints2->size() * BSpline::sNumSegmentsPerCurve;						MyAssert(bsp2TotalCurveSegs > 0);					}										cv1 = prevCuts[i]->cv1;					sg1 = prevCuts[i]->sg1;					cv2 = prevCuts[i]->cv2;					sg2 = prevCuts[i]->sg2;										segIndex = cv1 * BSpline::sNumSegmentsPerCurve + sg1;					nextSegIndex = (segIndex + 1) % bsp1TotalCurveSegs;										MyAssert(cv1 < curvePoints1->size());					MyAssert(sg1 < (*curvePoints1)[cv1]->size());					MyAssert(nextSegIndex / BSpline::sNumSegmentsPerCurve < curvePoints1->size());					MyAssert(nextSegIndex % BSpline::sNumSegmentsPerCurve < (*curvePoints1)[nextSegIndex / BSpline::sNumSegmentsPerCurve]->size());										lnPt1.h = ((*(*curvePoints1)[cv1])[sg1].h +								(*(*curvePoints1)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].h) / 2;					lnPt1.v = ((*(*curvePoints1)[cv1])[sg1].v +								(*(*curvePoints1)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].v) / 2;										if (prevCuts[i]->bsp2)					{						segIndex = cv2 * BSpline::sNumSegmentsPerCurve + sg2;						nextSegIndex = (segIndex + 1) % bsp2TotalCurveSegs;												MyAssert(cv2 < curvePoints2->size());						MyAssert(sg2 < (*curvePoints2)[cv2]->size());						MyAssert(nextSegIndex / BSpline::sNumSegmentsPerCurve < curvePoints2->size());						MyAssert(nextSegIndex % BSpline::sNumSegmentsPerCurve < (*curvePoints2)[nextSegIndex / BSpline::sNumSegmentsPerCurve]->size());												lnPt2.h = ((*(*curvePoints2)[cv2])[sg2].h +									(*(*curvePoints2)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].h) / 2;						lnPt2.v = ((*(*curvePoints2)[cv2])[sg2].v +									(*(*curvePoints2)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].v) / 2;					}					else lnPt2.h = lnPt2.v = -1;				}								bsp2 = prevCuts[i]->bsp2;				success = true;				break;			}			else if (prevCuts[i]->bsp2 == bsp1)			{				if (cnt == whichPrevCut - 1)				{					curvePoints1 = bsp1->GetCurvePoints();					int bsp1TotalCurveSegs = curvePoints1->size() * BSpline::sNumSegmentsPerCurve;					MyAssert(bsp1TotalCurveSegs > 0);										int bsp2TotalCurveSegs = 0;					if (prevCuts[i]->bsp1)					{						curvePoints2 = prevCuts[i]->bsp1->GetCurvePoints();						bsp2TotalCurveSegs = curvePoints2->size() * BSpline::sNumSegmentsPerCurve;						MyAssert(bsp2TotalCurveSegs > 0);					}										cv1 = prevCuts[i]->cv2;					sg1 = prevCuts[i]->sg2;					cv2 = prevCuts[i]->cv1;					sg2 = prevCuts[i]->sg1;										if (prevCuts[i]->bsp1)					{						segIndex = cv1 * BSpline::sNumSegmentsPerCurve + sg1;						nextSegIndex = (segIndex + 1) % bsp2TotalCurveSegs;												MyAssert(cv1 < curvePoints2->size());						MyAssert(sg1 < (*curvePoints2)[cv1]->size());						MyAssert(nextSegIndex / BSpline::sNumSegmentsPerCurve < curvePoints2->size());						MyAssert(nextSegIndex % BSpline::sNumSegmentsPerCurve < (*curvePoints2)[nextSegIndex / BSpline::sNumSegmentsPerCurve]->size());												lnPt1.h = ((*(*curvePoints2)[cv1])[sg1].h +									(*(*curvePoints2)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].h) / 2;						lnPt1.v = ((*(*curvePoints2)[cv1])[sg1].v +									(*(*curvePoints2)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].v) / 2;					}					else lnPt1.h = lnPt1.v = -1;										segIndex = cv2 * BSpline::sNumSegmentsPerCurve + sg2;					nextSegIndex = (segIndex + 1) % bsp1TotalCurveSegs;										MyAssert(cv2 < curvePoints1->size());					MyAssert(sg2 < (*curvePoints1)[cv2]->size());					MyAssert(nextSegIndex / BSpline::sNumSegmentsPerCurve < curvePoints1->size());					MyAssert(nextSegIndex % BSpline::sNumSegmentsPerCurve < (*curvePoints1)[nextSegIndex / BSpline::sNumSegmentsPerCurve]->size());										lnPt2.h = ((*(*curvePoints1)[cv2])[sg2].h +								(*(*curvePoints1)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].h) / 2;					lnPt2.v = ((*(*curvePoints1)[cv2])[sg2].v +								(*(*curvePoints1)[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].v) / 2;				}								bsp2 = prevCuts[i]->bsp1;				success = true;				break;			}			*/		}				if (!success)			break;	}		return success;}void Drawing::FindFurthestLeftInfiniteBSplineCut(BSpline* bsp, int& cv, int& sg, FloatPoint& lnPt){	lnPt.h = 999999;		vector<vector<FloatPoint>*> curvePoints = *bsp->GetCurvePoints();	for (int i = 0; i < curvePoints.size(); i++)		for (int j = 0; j < BSpline::sNumSegmentsPerCurve; j++)			if ((*curvePoints[i])[j].h < lnPt.h)			{				lnPt = (*curvePoints[i])[j];				cv = i;				sg = j;			}}bool Drawing::CurveSegAlreadyCut(BSpline* bsp, int cv, int sg){	for (int i = 0; i < bsplinePairCuts.size(); i++)		if ((bsplinePairCuts[i]->GetBsp1() == bsp && bsplinePairCuts[i]->GetCv1() == cv && bsplinePairCuts[i]->GetSg1() == sg) ||			(bsplinePairCuts[i]->GetBsp2() == bsp && bsplinePairCuts[i]->GetCv2() == cv && bsplinePairCuts[i]->GetSg2() == sg))			return true;	return false;}void Drawing::FindRandomBSplineToBSplineCut(BSpline* bsp1, BSpline* bsp2, int& cv1, int& cv2, int& sg1, int& sg2, FloatPoint& lnPt1, FloatPoint& lnPt2){	MyAssert(bsp1 != bsp2);		//MyAssert(BSpline::sNumSegmentsPerCurve >= 2);		int segIndex, nextSegIndex;		vector<vector<FloatPoint>*> curvePoints1 = *bsp1->GetCurvePoints();	int bsp1TotalCurveSegs = curvePoints1.size() * BSpline::sNumSegmentsPerCurve;	MyAssert(bsp1TotalCurveSegs > 0);		bool cvSgAlreadyCut = true;	while (cvSgAlreadyCut)	{		cvSgAlreadyCut = false;				segIndex = RandZeroInt(bsp1TotalCurveSegs);		nextSegIndex = (segIndex + 1) % bsp1TotalCurveSegs;				cv1 = segIndex / BSpline::sNumSegmentsPerCurve;		sg1 = segIndex % BSpline::sNumSegmentsPerCurve;				if (CurveSegAlreadyCut(bsp1, cv1, sg1))			cvSgAlreadyCut = true;	}		lnPt1.h = ((*curvePoints1[cv1])[sg1].h +				(*curvePoints1[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].h) / 2;	lnPt1.v = ((*curvePoints1[cv1])[sg1].v +				(*curvePoints1[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].v) / 2;		if (bsp2)	{		vector<vector<FloatPoint>*> curvePoints2 = *bsp2->GetCurvePoints();		int bsp2TotalCurveSegs = curvePoints2.size() * BSpline::sNumSegmentsPerCurve;		MyAssert(bsp2TotalCurveSegs > 0);				cvSgAlreadyCut = true;		while (cvSgAlreadyCut)		{			cvSgAlreadyCut = false;						segIndex = RandZeroInt(bsp2TotalCurveSegs);			nextSegIndex = (segIndex + 1) % bsp2TotalCurveSegs;						cv2 = segIndex / BSpline::sNumSegmentsPerCurve;			sg2 = segIndex % BSpline::sNumSegmentsPerCurve;						if (CurveSegAlreadyCut(bsp2, cv2, sg2))				cvSgAlreadyCut = true;		}				lnPt2.h = ((*curvePoints2[cv2])[sg2].h +					(*curvePoints2[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].h) / 2;		lnPt2.v = ((*curvePoints2[cv2])[sg2].v +					(*curvePoints2[nextSegIndex / BSpline::sNumSegmentsPerCurve])[nextSegIndex % BSpline::sNumSegmentsPerCurve].v) / 2;	}	else cv2 = sg2 = lnPt2.h = lnPt2.v = -1;}void Drawing::SaveBSplineToBSplineCut(BSplineToBSplineCut* cut){	//Keep cuts structured so that the hole is at the beginning.	//This doesn't work properly yet.	/*	if (cut->GetBsp1()->GetWindingNumber() > 0)	{		MyAssert(cut->GetBsp2()->GetWindingNumber() < 0);		cut->Invert();	}	*/	int cutIndex = -1;		bsplinePairCuts.push_back(cut);	cutIndex = bsplinePairCuts.size() - 1;		//Add the cut's intersections to the other objects, and where necessary, the other objects to the intersections	vector<GenericIntersection*> cutInters = cut->GetIntersections();		//еее DEBUG	vector<int> sectionDepths = *((BspCutTIntersection*)cutInters[0])->GetBsp()->GetSectionDepths();	int* sdStartPre = new int[sectionDepths.size()];	for (int ii = 0; ii < sectionDepths.size(); ii++)		sdStartPre[ii] = sectionDepths[ii];	int* sdEndPre = NULL;	if (((BspCutTIntersection*)cutInters[cutInters.size() - 1])->GetBsp())	{		sectionDepths = *((BspCutTIntersection*)cutInters[cutInters.size() - 1])->GetBsp()->GetSectionDepths();		sdEndPre = new int[sectionDepths.size()];		for (int ii = 0; ii < sectionDepths.size(); ii++)			sdEndPre[ii] = sectionDepths[ii];	}		for (int i = 0; i < cutInters.size(); i++)	{		MyAssert(!cutInters[i]->GetDtored());				switch (cutInters[i]->GetType())		{			case GenericIntersection::BSP_BSP:				MyAssert(false);				break;			case GenericIntersection::BSP_CUT:				MyAssert(!((BspCutIntersection*)cutInters[i])->GetBsp()->dtored);				((BspCutIntersection*)cutInters[i])->GetBsp()->AddIntersection(((BspCutIntersection*)cutInters[i])->GetCv(),																				((BspCutIntersection*)cutInters[i])->GetSg(),																				cutInters[i], true);				((BspCutIntersection*)cutInters[i])->SetCut(cut, cutIndex);				break;			case GenericIntersection::BSP_CUT_T:				if (((BspCutTIntersection*)cutInters[i])->GetBsp())				{					MyAssert(!((BspCutTIntersection*)cutInters[i])->GetBsp()->dtored);					((BspCutTIntersection*)cutInters[i])->GetBsp()->AddIntersection(((BspCutTIntersection*)cutInters[i])->GetCv(),																					((BspCutTIntersection*)cutInters[i])->GetSg(),																					cutInters[i], true);				}				((BspCutTIntersection*)cutInters[i])->SetCut(cut, cutIndex);				break;			case GenericIntersection::CUT_CUT:				MyAssert(!((CutCutIntersection*)cutInters[i])->GetCut1()->dtored);				MyAssert(!((CutCutIntersection*)cutInters[i])->GetCut2()->dtored);				if (((CutCutIntersection*)cutInters[i])->GetCut1() == cut)				{					((CutCutIntersection*)cutInters[i])->SetCut1(cut, cutIndex);					((CutCutIntersection*)cutInters[i])->GetCut2()->AddIntersection(cutInters[i], true);				}				else if (((CutCutIntersection*)cutInters[i])->GetCut2() == cut)				{					((CutCutIntersection*)cutInters[i])->SetCut2(cut, cutIndex);					((CutCutIntersection*)cutInters[i])->GetCut1()->AddIntersection(cutInters[i], true);				}				else MyAssert(false);				break;		}	}		//еее DEBUG	sectionDepths = *((BspCutTIntersection*)cutInters[0])->GetBsp()->GetSectionDepths();	int* sdStartPost = new int[sectionDepths.size()];	for (int ii = 0; ii < sectionDepths.size(); ii++)		sdStartPost[ii] = sectionDepths[ii];	int* sdEndPost = NULL;	if (((BspCutTIntersection*)cutInters[cutInters.size() - 1])->GetBsp())	{		sectionDepths = *((BspCutTIntersection*)cutInters[cutInters.size() - 1])->GetBsp()->GetSectionDepths();		sdEndPost = new int[sectionDepths.size()];		for (int ii = 0; ii < sectionDepths.size(); ii++)			sdEndPost[ii] = sectionDepths[ii];	}		cut->GetAllIntersectionsLegal(true);		//еее DEBUG	delete [] sdStartPre;	if (sdEndPre)		delete [] sdEndPre;	delete [] sdStartPost;	if (sdEndPost)		delete [] sdEndPost;		//Remember the coordinates of the cut for future use	vector<PrevCut*>::iterator iter;	for (iter = prevCuts.begin(); iter != prevCuts.end(); iter++)		if ((*iter)->bsp1 == cut->GetBsp1() && (*iter)->bsp2 == cut->GetBsp2() ||			(*iter)->bsp1 == cut->GetBsp2() && (*iter)->bsp2 == cut->GetBsp1())			break;	if (iter != prevCuts.end())	//Prev cut already exists, so update it	{		if ((*iter)->bsp1 == cut->GetBsp1())		{			(*iter)->bsp1 = cut->GetBsp1();			(*iter)->bsp2 = cut->GetBsp2();			(*iter)->cv1 = cut->GetCv1();			(*iter)->cv2 = cut->GetCv2();			(*iter)->sg1 = cut->GetSg1();			(*iter)->sg2 = cut->GetSg2();			(*iter)->numInters = cut->GetNumIntersections();		}		else	//not really necessary, could use the first method for both cases, but whatever...		{			(*iter)->bsp1 = cut->GetBsp2();			(*iter)->bsp2 = cut->GetBsp1();			(*iter)->cv1 = cut->GetCv2();			(*iter)->cv2 = cut->GetCv1();			(*iter)->sg1 = cut->GetSg2();			(*iter)->sg2 = cut->GetSg1();			(*iter)->numInters = cut->GetNumIntersections();		}				MyAssert(prevCuts.size() > 0);		VerifyPrevCuts();	}	else// if (cut->GetBsp2())	//Prev cut doesn't exist yet, so create it	{		PrevCut* prevCut = new PrevCut;		prevCut->bsp1 = cut->GetBsp1();		prevCut->bsp2 = cut->GetBsp2();		prevCut->cv1 = cut->GetCv1();		prevCut->cv2 = cut->GetCv2();		prevCut->sg1 = cut->GetSg1();		prevCut->sg2 = cut->GetSg2();		prevCut->numInters = cut->GetNumIntersections();		prevCuts.push_back(prevCut);				MyAssert(prevCuts.size() > 0);		VerifyPrevCuts();	}		//Update the ends of the cut	//Shouldn't be necessary	//cut->RecalcStartEndLocs();}void Drawing::GroupBSplineAndSaveBSplineToBSplineCut(BSpline* bsp, BSplineToBSplineCut* cut, int infiniteCutEndingDepth){	MyAssert(cut->GetBsp1() == bsp || cut->GetBsp2() == bsp);		//Make sure the ends of the new cut are legal	vector<int> cutDepths = *cut->GetSectionDepths();	MyAssert(cut->GetBsp1() == bsp);	int bsp1Depth = bsp->GetArbitraryCurveSegCenterDepth(cut->GetCv1(), cut->GetSg1());	if (cut->GetBsp2())	{		MyAssert(bsp1Depth == cutDepths[0]);		int bsp2Depth = cut->GetBsp2()->GetArbitraryCurveSegCenterDepth(cut->GetCv2(), cut->GetSg2());		MyAssert(bsp2Depth == cutDepths[cutDepths.size() - 1]);	}		SaveBSplineToBSplineCut(cut);		//The cut worked.  The hole and solid are part of the same surface.  Add the hole to the solid's object, if necessary.	cut->GetAllIntersectionsLegal(true);		WholeObject* wholeObject;	if (infiniteCutEndingDepth == -1)		MyAssert(FindOrCreateWholeObjectForBSpline(bsp, wholeObject, infiniteCutEndingDepth));	else FindOrCreateWholeObjectForBSpline(bsp, wholeObject, infiniteCutEndingDepth);		if (!cut->GetBsp2())	//Infinite cut	{		//Not true when finding bette cuts		//MyAssert(wholeObject->bsplines.size() == 1);				//If there is a whole object with the correct background depth, or a whole object that already contains the same hole, add the hole to it and merge the whole objects.		//Else create a new object for the hole.		for (int j = 0; j < wholeObjects.size(); j++)			if (wholeObjects[j] != wholeObject)			{				WholeObject* wholeObject1 = wholeObjects[j];								bool mergeWholeObjects = false;								//Does the whole object already contain this hole?				if (find(wholeObject1->bsplines.begin(), wholeObject1->bsplines.end(), bsp) != wholeObject1->bsplines.end())					mergeWholeObjects = true;								//Does the whole object already represent this hole's infinite depth?				if (!mergeWholeObjects)					for (int k = 0; k < wholeObject1->bgDepths.size(); k++)						if (wholeObject1->bgDepths[k] == infiniteCutEndingDepth)						{							mergeWholeObjects = true;							break;						}								if (mergeWholeObjects)				{					//Find another bspline in the whole object.  Then get its surface traits.					MyAssert(wholeObject1->bsplines.size() > 0);					SurfaceTraits surfaceTraits = wholeObject1->bsplines[0]->GetSurfaceTraits();										//Delete this bspline's group and merge its group into the already existing infinite cut group					//MyAssert(find(wholeObject1->bsplines.begin(), wholeObject1->bsplines.end(), bsp) == wholeObject1->bsplines.end());					bsp->SetSurfaceTraits(surfaceTraits);					wholeObject1->bsplines.push_back(bsp);										for (int k = 0; k < wholeObject->bspCutTinters.size(); k++)					{						MyAssert(find(wholeObject1->bspCutTinters.begin(), wholeObject1->bspCutTinters.end(), wholeObject->bspCutTinters[k]) == wholeObject1->bspCutTinters.end());						wholeObject->bspCutTinters[k]->SetInfiniteWholeObject(wholeObject1);						wholeObject1->bspCutTinters.push_back(wholeObject->bspCutTinters[k]);					}										delete wholeObject;					vector<WholeObject*>::iterator iter = find(wholeObjects.begin(), wholeObjects.end(), wholeObject);					MyAssert(iter != wholeObjects.end());					wholeObjects.erase(iter);					wholeObject = wholeObject1;				}			}				if (find(wholeObject->bgDepths.begin(), wholeObject->bgDepths.end(), infiniteCutEndingDepth) == wholeObject->bgDepths.end())			wholeObject->bgDepths.push_back(infiniteCutEndingDepth);	}	else	//bsp to bsp cut (not an infinite cut)	{		//Find the whole object corresponding to the hole		vector<WholeObject*>::iterator holeWholeObjectIter;		for (holeWholeObjectIter = wholeObjects.begin(); holeWholeObjectIter != wholeObjects.end(); holeWholeObjectIter++)			if (find((*holeWholeObjectIter)->bsplines.begin(), (*holeWholeObjectIter)->bsplines.end(), bsp) != (*holeWholeObjectIter)->bsplines.end())				break;			MyAssert(holeWholeObjectIter != wholeObjects.end());		MyAssert(wholeObject == *holeWholeObjectIter);				//Find the whole object corresponding to the solid		MyAssert(cut->GetBsp1() == bsp && cut->GetBsp2() != bsp);		BSpline* otherBsp = cut->GetBsp2();		vector<WholeObject*>::iterator solidWholeObjectIter;		for (solidWholeObjectIter = wholeObjects.begin(); solidWholeObjectIter != wholeObjects.end(); solidWholeObjectIter++)			if (find((*solidWholeObjectIter)->bsplines.begin(), (*solidWholeObjectIter)->bsplines.end(), otherBsp) != (*solidWholeObjectIter)->bsplines.end())				break;				if (solidWholeObjectIter != wholeObjects.end())		{			WholeObject* wholeObject2 = NULL;			MyAssert(FindOrCreateWholeObjectForBSpline(otherBsp, wholeObject2));			MyAssert(wholeObject2 == *solidWholeObjectIter);						//If the hole isn't already part of the solid's object, add it and transitively any of its object BSplines to the solid's object			if (*solidWholeObjectIter != wholeObject)			{				//Find the bspline in the solid object with the highest winding number.  Then get its surface traits.				BSpline* solidObject = (*solidWholeObjectIter)->bsplines[0];				for (int i = 1; i < (*solidWholeObjectIter)->bsplines.size(); i++)					if ((*solidWholeObjectIter)->bsplines[i]->GetWindingNumber() > solidObject->GetWindingNumber())						solidObject = (*solidWholeObjectIter)->bsplines[i];				SurfaceTraits surfaceTraits = solidObject->GetSurfaceTraits();								//Add all of the hole's whole object's BSplines to the solid's whole object.  Also update the surface traits.				for (int k = 0; k < wholeObject->bsplines.size(); k++)					if (find((*solidWholeObjectIter)->bsplines.begin(), (*solidWholeObjectIter)->bsplines.end(), wholeObject->bsplines[k]) == (*solidWholeObjectIter)->bsplines.end())					{						(*solidWholeObjectIter)->bsplines.push_back(wholeObject->bsplines[k]);						wholeObject->bsplines[k]->SetSurfaceTraits(surfaceTraits);					}								for (int k = 0; k < wholeObject->bspCutTinters.size(); k++)				{					MyAssert(find((*solidWholeObjectIter)->bspCutTinters.begin(), (*solidWholeObjectIter)->bspCutTinters.end(), wholeObject->bspCutTinters[k]) == (*solidWholeObjectIter)->bspCutTinters.end());					wholeObject->bspCutTinters[k]->SetInfiniteWholeObject(*solidWholeObjectIter);					(*solidWholeObjectIter)->bspCutTinters.push_back(wholeObject->bspCutTinters[k]);				}								//Destroy the hole's whole object				delete wholeObject;				wholeObjects.erase(holeWholeObjectIter);			}		}	}}/*void Drawing::RemoveBSplineToBSplineCut(BSpline* bsp1, BSpline* bsp2){	for (vector<BSplineToBSplineCut*>::iterator i = bsplinePairCuts.begin(); i != bsplinePairCuts.end(); i++)		if (((*i)->GetBsp1() == bsp1 && (*i)->GetBsp2() == bsp2) || ((*i)->GetBsp2() == bsp1 && (*i)->GetBsp1() == bsp2))		{			delete *i;			bsplinePairCuts.erase(i);			break;		}}*/void Drawing::DeleteBSplineToBSplineCut(BSplineToBSplineCut* cut){	MyAssert(cut && !cut->dtored);		vector<GenericIntersection*> cutInters = cut->GetIntersections();	for (int j = 0; j < cutInters.size(); j++)	{		MyAssert(!cutInters[j]->GetDtored());				//The following code NULLs the cut's intersection's bspline and cut pointers, but I don't think that should be done here.		/*		switch (cutInters[j]->GetType())		{			case GenericIntersection::BSP_BSP:				MyAssert(false);				break;			case GenericIntersection::BSP_CUT:				((BspCutIntersection*)cutInters[j])->SetNullBsp();				((BspCutIntersection*)cutInters[j])->SetNullCut();				break;			case GenericIntersection::BSP_CUT_T:				((BspCutTIntersection*)cutInters[j])->SetNullBsp();				((BspCutTIntersection*)cutInters[j])->SetNullCut();				break;			case GenericIntersection::CUT_CUT:				MyAssert(((CutCutIntersection*)cutInters[j])->GetCut1());				MyAssert(((CutCutIntersection*)cutInters[j])->GetCut2());				((CutCutIntersection*)cutInters[j])->SetNullCut(((CutCutIntersection*)cutInters[j])->GetCut1());				((CutCutIntersection*)cutInters[j])->SetNullCut(((CutCutIntersection*)cutInters[j])->GetCut2());				break;		}		*/		vector<GenericIntersection*>::iterator iter = find(brandNewIntersections.begin(), brandNewIntersections.end(), cutInters[j]);		if (iter != brandNewIntersections.end())			brandNewIntersections.erase(iter);	}		delete cut;}vector<LineSegCurveIntersection> Drawing::FindCutIntersections(double lineSegAngle, FloatPoint lnPt1, FloatPoint lnPt2, bool& success){	MyAssert(false);	/*	vector<LineSegCurveIntersection> lineSegInters;		//Loop through every single BSpline, finding any intersections on the line segment with any BSplines	FloatPoint cvPt1, cvPt2;	FloatPoint intersectionLoc;	double lineInter1, lineInter2;	for (int k = 0; k < bsplines.size(); k++)	//Loop through all BSplines	{		vector<vector<FloatPoint>*>* curvePoints3 = bsplines[k]->GetCurvePoints();		for (int m = 0; m < curvePoints3->size(); m++)	//Loop through the BSpline's curves			for (int n = 0; n < BSpline::sNumSegmentsPerCurve; n++)	//Loop through the curve segs on one of the BSpline's curves			{				//Get the two endpoints of the curve segment				cvPt1 = (*(*curvePoints3)[m])[n];				if (n == BSpline::sNumSegmentsPerCurve - 1)					cvPt2 = (*(*curvePoints3)[(m + 1) % curvePoints3->size()])[0];				else cvPt2 = (*(*curvePoints3)[m])[n + 1];								//Find out if the curve segment intersects the primary test line seg defined in the passed in parameters				if (LineSegmentIntersection(lnPt1, lnPt2, cvPt1, cvPt2, intersectionLoc, lineInter1, lineInter2))				{					//Getting here means the curve segment does intersect the test line seg										int edgeDirection = LineCrossLineDirection(lnPt1, lnPt2, cvPt1, cvPt2);					if (edgeDirection != 0)					{						//Calculate the distance of the intersection from the start of the line segment						double dist = LineSegmentLength(lnPt1, intersectionLoc);												//Create a little struct to hold the necessary information about the intersection,						//primarily its edge direction and its distance from the start of the test line seg						LineSegCurveIntersection lineSegCurveIntersection;						lineSegCurveIntersection.bspline = bsplines[k];						lineSegCurveIntersection.crv = m;						lineSegCurveIntersection.seg = n;						lineSegCurveIntersection.location = intersectionLoc;						lineSegCurveIntersection.lineSegStartDistance = dist;						lineSegCurveIntersection.edgeDirection = edgeDirection;						lineSegInters.push_back(lineSegCurveIntersection);					}				}			}	}		//еее	int s1 = lineSegInters.size();		LineSegCurveIntersectionSort lscis;	sort(lineSegInters.begin(), lineSegInters.end(), lscis);		//еее	LineSegCurveIntersection* arr = new LineSegCurveIntersection[lineSegInters.size()];	for (int z = 0; z < lineSegInters.size(); z++)		arr[z] = lineSegInters[z];	int s2 = lineSegInters.size();		success = (lineSegInters.size() >= 2);		return lineSegInters;	*/}vector<CutIntersection> Drawing::FindCutIntersections(BSplineToBSplineCut* cut, double lineSegAngle, FloatPoint lnPt1, FloatPoint lnPt2, bool& success){	vector<CutIntersection> cutIntersections;	bool illegalInfiniteCut = false;	//Only applies to infinite cuts, means nothing for normal cuts		//Loop through every single BSpline, finding any intersections on the line segment with any BSplines	FloatPoint cvPt1, cvPt2;	FloatPoint intersectionLoc;	double lineInter1, lineInter2;	bool foundStart = false, foundEnd = false, horizontalStartSeg = false;	for (int k = 0; k < bsplines.size(); k++)	//Loop through all BSplines	{		vector<vector<FloatPoint>*>* curvePoints = bsplines[k]->GetCurvePoints();		for (int m = 0; m < curvePoints->size(); m++)	//Loop through the BSpline's curves			for (int n = 0; n < BSpline::sNumSegmentsPerCurve; n++)	//Loop through the curve segs on one of the BSpline's curves			{				//Get the two endpoints of the curve segment				cvPt1 = (*(*curvePoints)[m])[n];				if (n == BSpline::sNumSegmentsPerCurve - 1)					cvPt2 = (*(*curvePoints)[(m + 1) % curvePoints->size()])[0];				else cvPt2 = (*(*curvePoints)[m])[n + 1];								//Find out if the curve segment intersects the primary test line seg defined in the passed in parameters				if (LineSegmentIntersection(lnPt1, lnPt2, cvPt1, cvPt2, intersectionLoc, lineInter1, lineInter2))				{					//Getting here means the curve segment does intersect the test line seg										int edgeDirection = LineCrossLineDirection(lnPt1, lnPt2, cvPt1, cvPt2);					if (edgeDirection != 0)					{						//Calculate the distance of the intersection from the start of the line segment						double distToStart = LineSegmentLength(lnPt1, intersectionLoc);												//Create a little struct to hold the necessary information about the intersection,						//primarily its distance from the start of the test line seg						CutIntersection cutIntersection;												//If the intersection is really really close to the endpoint of the cut, assume it						//actually IS the end of the cut and make a T junction for it.  Otherwise make a normal intersection.						double distToEnd = LineSegmentLength(lnPt2, intersectionLoc);												if (bsplines[k] == cut->GetBsp1() && m == cut->GetCv1() && n == cut->GetSg1() &&							distToStart < lineSegmentProjectSlop + .01)	//Make a T junction for the start of a cut						{							MyAssert(!foundStart);							BspCutTIntersection* bspCutTInter = new BspCutTIntersection(this, intersectionLoc, bsplines[k], cut,								GetBSplineIndex(bsplines[k]), GetCutIndex(cut), m, n, -1, edgeDirection, true);														cutIntersection.intersection = bspCutTInter;														foundStart = true;						}						else if (bsplines[k] == cut->GetBsp2() && m == cut->GetCv2() && n == cut->GetSg2() &&							distToEnd < lineSegmentProjectSlop + .01)	//Make a T junction for the end of a cut						{							MyAssert(!foundEnd);							BspCutTIntersection* bspCutTInter = new BspCutTIntersection(this, intersectionLoc, bsplines[k], cut,								GetBSplineIndex(bsplines[k]), GetCutIndex(cut), m, n, -1, edgeDirection, false);														cutIntersection.intersection = bspCutTInter;														foundEnd = true;						}						else	//Make a nonT junction for the middle of a cut						{							bool bspOnTop = (bsplines[k]->GetArbitraryCurvePointDepth(m, n, intersectionLoc) <=											cut->GetArbitraryPointDepth(intersectionLoc));														BspCutIntersection* bspCutInter = new BspCutIntersection(this, intersectionLoc, bsplines[k], cut,								GetBSplineIndex(bsplines[k]), GetCutIndex(cut), m, n, bspOnTop, edgeDirection);														cutIntersection.intersection = bspCutInter;														//if (bsplines[k] == cut->GetBsp1())							//	illegalInfiniteCut = true;						}												cutIntersection.distFromStart = distToStart;												cutIntersections.push_back(cutIntersection);					}				}				else				{					//The ends of the cut should have been detected as intersections.  Just make sure that happened.					//However, this can produce a false negative if the line segment and the cut are both perfectly					//horizontal.  The intersection at the end of the cut will then be missed and this is acceptable.					if (cvPt1.v != cvPt2.v)					{						MyAssert(bsplines[k] != cut->GetBsp1() || m != cut->GetCv1() || n != cut->GetSg1());						MyAssert(bsplines[k] != cut->GetBsp2() || m != cut->GetCv2() || n != cut->GetSg2());					}					else					{						horizontalStartSeg = true;					}				}			}	}		//Necessary stuff for infinite cuts	if (!cut->GetBsp2())	{		MyAssert(!foundEnd);				//Make a fake T junction at the end of the cut		BspCutTIntersection* bspCutTInter = new BspCutTIntersection(this, lnPt2, NULL, cut,																	-1, GetCutIndex(cut), -1, -1, -1, -1, false);				CutIntersection cutIntersection;		cutIntersection.intersection = bspCutTInter;		cutIntersection.distFromStart = LineSegmentLength(lnPt1, lnPt2);		cutIntersections.push_back(cutIntersection);				foundEnd = true;	}		MyAssert((foundStart || horizontalStartSeg) && (foundEnd || !cut->GetBsp2()));		//Loop through all existing Cuts, finding any intersections on the line segment with any Cuts	for (int i = 0; i < bsplinePairCuts.size(); i++)	{		if (bsplinePairCuts[i] == cut)			continue;				FloatPoint startLoc = cut->GetStart();		FloatPoint endLoc = cut->GetEnd();		FloatPoint otherStartLoc = bsplinePairCuts[i]->GetStart();		FloatPoint otherEndLoc = bsplinePairCuts[i]->GetEnd();				FloatPoint intersectionLoc;				if (LineSegmentIntersection(startLoc, endLoc, otherStartLoc, otherEndLoc, intersectionLoc))		{			CutIntersection cutIntersection;						//Calculate the distance of the intersection from the start of the line segment			double distToStart = LineSegmentLength(lnPt1, intersectionLoc);						//Make the intersection			CutCutIntersection* cutCutInter = new CutCutIntersection(this, intersectionLoc,				cut, bsplinePairCuts[i], GetCutIndex(cut), GetCutIndex(bsplinePairCuts[i]), false);						MyAssert(!cutCutInter->GetDtored());						cutIntersection.intersection = cutCutInter;			cutIntersection.distFromStart = distToStart;						cutIntersections.push_back(cutIntersection);		}	}		CutIntersectionSort cis;	sort(cutIntersections.begin(), cutIntersections.end(), cis);		int ciSize = cutIntersections.size();	int numTs = 0;	for (int i = 0; i < cutIntersections.size(); i++)	{		if (cutIntersections[i].intersection->GetType() == GenericIntersection::BSP_CUT_T)			numTs++;		cut->AddIntersection(cutIntersections[i].intersection, cutIntersections[i].intersection->GetType() != GenericIntersection::BSP_CUT_T, false);	}	cut->VerifyBackupsMatchPresent();		success = (cutIntersections.size() >= 2);		if (illegalInfiniteCut && !cut->GetBsp2())		success = false;		return cutIntersections;}WholeObject* Drawing::FindWholeObjectForBSpline(BSpline* bsp, int infiniteCutEndingDepth){	if (!bsp)		return NULL;		//Find the whole object for this BSpline	WholeObject* wholeObject = NULL;	for (int i = 0; i < wholeObjects.size(); i++)		if (find(wholeObjects[i]->bsplines.begin(), wholeObjects[i]->bsplines.end(), bsp) != wholeObjects[i]->bsplines.end())			//if (infiniteCutEndingDepth == -1 || wholeObjects[i]->bgDepths.size() == 0 ||			//	find(wholeObjects[i]->bgDepths.begin(), wholeObjects[i]->bgDepths.end(), infiniteCutEndingDepth) != wholeObjects[i]->bgDepths.end())			{				wholeObject = wholeObjects[i];				break;			}		return wholeObject;}WholeObject* Drawing::FindWholeObjectForCut(BSplineToBSplineCut* cut){	BSpline *bsp1 = cut->GetBsp1(), *bsp2 = cut->GetBsp2();		//Find the whole object for the bsps at the start and end of the cut		WholeObject* wholeObject1 = FindWholeObjectForBSpline(bsp1, -1);	WholeObject* wholeObject2 = FindWholeObjectForBSpline(bsp2, -1);	//Just for an assert	MyAssert(wholeObject1 == wholeObject2);	//This fails sometimes with wholeObject2 == NULL.  What's going on?  Is this okay?		return wholeObject1;}//Return true if whole object is found, false if whole object needs to be createdbool Drawing::FindOrCreateWholeObjectForBSpline(BSpline* bsp, WholeObject*& wholeObject, int infiniteCutEndingDepth){	//Find the whole object for this BSpline	wholeObject = FindWholeObjectForBSpline(bsp, infiniteCutEndingDepth);		//If no object is found, create one and add it to the test list	if (!wholeObject)	{		wholeObject = new WholeObject();		wholeObject->bsplines.push_back(bsp);		wholeObjects.push_back(wholeObject);		return false;	}		return true;}bool Drawing::TestCut(BSplineToBSplineCut* cut, int& cutEndingDepth){	MyAssert(cut);		BSpline* testBsp = cut->GetBsp1();	BSpline* otherBsp = cut->GetBsp2();		if ((testBsp && cut->GetCv1() >= testBsp->GetNumControlPoints()) || (otherBsp && cut->GetCv2() >= otherBsp->GetNumControlPoints()))		return false;	//This can happen when deleting a control point and trying to use an old PrevCut that uses a curve past the end of the BSpline as a result of the deletion		bool testFinalDepth = (otherBsp != NULL);		FloatPoint lnPt1 = cut->GetStart();	FloatPoint lnPt2 = cut->GetEnd();		double lineSegAngle = LineSegmentAngle(lnPt1, lnPt2);	//Extend the ends a tad bit	FloatPoint projectedLnPt1 = ProjectPointAtAngle(lnPt1, lineSegAngle + Pi, lineSegmentProjectSlop);	FloatPoint projectedLnPt2 = ProjectPointAtAngle(lnPt2, lineSegAngle, lineSegmentProjectSlop);		//еее	if (gDebug3)	{		/*		Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		gMainWindow->DrawGrid();				PenSize(1, 1);		Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		*/		PenSize(5, 5);				ForeColor(magentaColor);		MoveTo(lnPt1.h - 2, lnPt1.v - 2);		Line(0, 0);				ForeColor(blackColor);		MoveTo(lnPt2.h - 2, lnPt2.v - 2);		Line(0, 0);				ForeColor(cyanColor);		PenSize(2, 2);		MoveTo(projectedLnPt1.h, projectedLnPt1.v);		LineTo(projectedLnPt2.h, projectedLnPt2.v);		PenSize(1, 1);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int dg3 = 1;	}		//Try to keep Cuts "clean" and managable.  One way to help this is to require that cuts not have any minutely close intersections.	//So start off by rejecting a cut if its start and end points are too close to any existing intersections.	/*	//This doesn't make any sense.  Why would the cut have any intersections if the intersections aren't found until the call to	//FindCutIntersections() below?  This only returns intersections when called on an old, preexisting cut, but such cuts	//have already been tested...so what's the point?	vector<GenericIntersection*> cutInters = cut->GetIntersections();	for (int i = 0; i < intersections.size(); i++)	{		if (find(cutInters.begin(), cutInters.end(), intersections[i]) != cutInters.end())			continue;				double startDist = LineSegmentLength(lnPt1, intersections[i]->GetLocation());		double endDist = LineSegmentLength(lnPt2, intersections[i]->GetLocation());		if (startDist < 5 || endDist < 5)			return false;	}	*/	//Make a list of all the intersections along the line segment and then sort them in order along the segment	bool success;	vector<CutIntersection> cutDistInters;	cutDistInters = FindCutIntersections(cut, lineSegAngle, projectedLnPt1, projectedLnPt2, success);		if (!success)		return false;		if (testFinalDepth && cutDistInters.size() < 2)		return false;		//It is possible that the search for cut intersections has accidentally inferred CutT intersections	//in the middle of a cut, which is obviously impossible.  If this has occurred, abort the cut.	//This can happen when a BSpline is very very thin.	for (int i = 1; i < cutDistInters.size() - 1; i++)		if (cutDistInters[i].intersection->GetType() == GenericIntersection::BSP_CUT_T)			return false;		//If the cut originates from a perfectly horizontal segment, the first intersection will have been missed, so abort.	if (cutDistInters[0].intersection->GetType() != GenericIntersection::BSP_CUT_T)		return false;		MyAssert(cutDistInters.size() > 0);		//Get the first intersection on the cut	MyAssert(cutDistInters[0].intersection->GetType() == GenericIntersection::BSP_CUT_T);	BspCutTIntersection* firstInter = (BspCutTIntersection*)cutDistInters[0].intersection;		if (cut->GetBsp2())		MyAssert(cutDistInters[cutDistInters.size() - 1].intersection->GetType() == GenericIntersection::BSP_CUT_T);		if (!otherBsp)	//infinite cut to an infinitely distant background boundary		if (firstInter->GetBsp() != testBsp)			return false;		if (otherBsp)	//cut between two BSplines (not an infinite cut)		if ((firstInter->GetBsp() != testBsp || ((BspCutTIntersection*)cutDistInters[cutDistInters.size() - 1].intersection)->GetBsp() != otherBsp) &&			(firstInter->GetBsp() != otherBsp || ((BspCutTIntersection*)cutDistInters[cutDistInters.size() - 1].intersection)->GetBsp() != testBsp))			return false;		//Traverse the gap between the intersection indexes just found (the gap might not exist, meaning the two intersections are adjacent on the test line seg).	//Count the number of left edges and the number of right edges, including the two ends.	//The two ends must be left and right respectively, meaning they must enter into the surface from their locations on the surface's boundary, and not into empty space.	if (!testFinalDepth ||		(firstInter->GetEdgeDirection() == 1 && ((BspCutTIntersection*)cutDistInters[cutDistInters.size() - 1].intersection)->GetEdgeDirection() == -1))	/*EDGE DIRECTION MARKER*/	{		//Traverse the line segment in the relevant region and track the depth changes along the way		cutEndingDepth = firstInter->GetBsp()->GetArbitraryCurvePointDepth(firstInter->GetCv(), firstInter->GetSg(), firstInter->GetLocation());		int startingDepth = cutEndingDepth;		BSpline* emptySpaceEdge = NULL;		bool crossedEmptySpace = false;				cut->SetSectionDepthAfterIntersection(firstInter, startingDepth);				//The following statement would make legal cuts in one direction, but not in the other, so there is no real point in using it.		//BTW, using this requires turning off the test above that checks the edge directions of the two endpoints of the cut (text search for "EDGE DIRECTION MARKER".		if (!testFinalDepth)			if (firstInter->GetEdgeDirection() == -1)			{				emptySpaceEdge = firstInter->GetBsp();				crossedEmptySpace = true;			}				//I realize it looks like this statement is backwards, but the final test is performed *after* the loop is finished		int terminatingCount = (true/*testFinalDepth*/ ? (cutDistInters.size() - 1) : cutDistInters.size());				//Loop through the cut's intersections		for (int k = 1; k < terminatingCount; k++)		{			switch (cutDistInters[k].intersection->GetType())			{				case GenericIntersection::BSP_BSP:					MyAssert(false);					break;				case GenericIntersection::BSP_CUT:					MyAssert(k != 0 && (k != cutDistInters.size() - 1 || !testFinalDepth));										BspCutIntersection* bspCutInter = (BspCutIntersection*)cutDistInters[k].intersection;										int bspCutIntersectionDepth = bspCutInter->GetBsp()->GetArbitraryCurvePointDepth(bspCutInter->GetCv(), bspCutInter->GetSg(), bspCutInter->GetLocation());										bool presentDepthMatchesBspCutIntersectionDepth = (cutEndingDepth == bspCutIntersectionDepth);										//If not in empty space, weave the depth up and down as appropriate.					//If in empty space, and the bspCutIntersection's bspline doesn't end the empty space, do nothing.					//If in empty space, and the bspCutIntersectoin's bspline ends the empty space, reassign the depth and continue traversing.					int edgeDirection = bspCutInter->GetEdgeDirection();					if (!emptySpaceEdge)					{						if (edgeDirection == 1 && bspCutIntersectionDepth <= cutEndingDepth)						{							cutEndingDepth += edgeDirection;							bspCutInter->SetBspOnTop(true);	//Seems redundant with the intersection's ctor, but actually it is necessary						}						else if (edgeDirection == -1 && bspCutIntersectionDepth < cutEndingDepth)						{							cutEndingDepth += edgeDirection;							bspCutInter->SetBspOnTop(true);	//Seems redundant with the intersection's ctor, but actually it is necessary						}						else bspCutInter->SetBspOnTop(false);	//Seems redundant with the intersection's ctor, but actually it is necessary												cut->SetSectionDepthAfterIntersection(cutDistInters[k].intersection, cutEndingDepth);					}					else if (bspCutInter->GetBsp() == emptySpaceEdge &&						presentDepthMatchesBspCutIntersectionDepth && edgeDirection == 1)					{						cutEndingDepth = bspCutIntersectionDepth;						emptySpaceEdge = NULL;						bspCutInter->SetBspOnTop(false);	//Seems redundant with the intersection's ctor, but actually it is necessary					}										//If entering empty space, remember the bspline that bounds the empty space					if (!emptySpaceEdge && presentDepthMatchesBspCutIntersectionDepth && edgeDirection == -1)					{						emptySpaceEdge = bspCutInter->GetBsp();						crossedEmptySpace = true;					}					break;				case GenericIntersection::BSP_CUT_T:					MyAssert(false);					break;				case GenericIntersection::CUT_CUT:					MyAssert(k != 0 && k != cutDistInters.size() - 1);										//CutCut intersections are simple.  The depth is the same on both sides of the intersection for both cuts.					cut->SetSectionDepthAfterIntersection(cutDistInters[k].intersection, cut->GetSectionDepthBeforeIntersection(cutDistInters[k].intersection));					break;				default:					MyAssert(false);			}						if (crossedEmptySpace)	//The cut is automatically invalid, no reason to continue weaving it				break;		}				//If the traversal ended at the right depth, group the two BSplines		int finalDepth = -1;		if (testFinalDepth && !crossedEmptySpace)			finalDepth = ((BspCutTIntersection*)cutDistInters[cutDistInters.size() - 1].intersection)->GetBsp()->GetArbitraryCurvePointDepth(															((BspCutTIntersection*)cutDistInters[cutDistInters.size() - 1].intersection)->GetCv(),															((BspCutTIntersection*)cutDistInters[cutDistInters.size() - 1].intersection)->GetSg(),															((BspCutTIntersection*)cutDistInters[cutDistInters.size() - 1].intersection)->GetLocation());				//If the test was a success, return true		if (!crossedEmptySpace && !emptySpaceEdge && (!testFinalDepth || cutEndingDepth == finalDepth))		{			//еее			if (gDebug3)			{				PenSize(7, 7);								ForeColor(magentaColor);				MoveTo(lnPt1.h - 4, lnPt1.v - 4);				Line(0, 0);								ForeColor(blackColor);				MoveTo(lnPt2.h - 4, lnPt2.v - 4);				Line(0, 0);								PenSize(3, 3);								ForeColor(yellowColor);				MoveTo(projectedLnPt1.h - 1, projectedLnPt1.v - 1);				LineTo(projectedLnPt2.h - 1, projectedLnPt2.v - 1);								PenSize(1, 1);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int dg3 = 1;			}						return true;		}	}		//The test failed, return false	return false;}/*void Drawing::FindWholeObjects(vector<BSpline*> testBSplines){	//еее	SetPort(GetWindowPort(gMainWindow->GetWindow()));		if (gDebug3)	{		Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int dg3 = 1;	}		//Verify that this Drawing's new intersections have the appropriate BSpline and Cut pointers and indexes	//еее	for (int i = 0; i < intersections.size(); i++)	{		MyAssert(intersections[i]->GetDrawing() == this);		switch (intersections[i]->GetType())		{			case GenericIntersection::BSP_BSP:				BspBspIntersection* bspBspInter = (BspBspIntersection*)intersections[i];								MyAssert(bspBspInter->GetBsp1() == bsplines[bspBspInter->GetBsp1Index()]);				MyAssert(bspBspInter->GetBsp2() == bsplines[bspBspInter->GetBsp2Index()]);				break;			case GenericIntersection::BSP_CUT:				BspCutIntersection* bspCutInter = (BspCutIntersection*)intersections[i];								MyAssert(bspCutInter->GetBsp() == bsplines[bspCutInter->GetBspIndex()]);				MyAssert(bspCutInter->GetCut() == bsplinePairCuts[bspCutInter->GetCutIndex()]);				break;			case GenericIntersection::BSP_CUT_T:				BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)intersections[i];								if (bspCutTInter->GetBsp())					MyAssert(bspCutTInter->GetBsp() == bsplines[bspCutTInter->GetBspIndex()]);				MyAssert(bspCutTInter->GetCut() == bsplinePairCuts[bspCutTInter->GetCutIndex()]);				break;			case GenericIntersection::CUT_CUT:				CutCutIntersection* cutCutInter = (CutCutIntersection*)intersections[i];								MyAssert(cutCutInter->GetCut1() == bsplinePairCuts[cutCutInter->GetCut1Index()]);				MyAssert(cutCutInter->GetCut2() == bsplinePairCuts[cutCutInter->GetCut2Index()]);				break;		}	}		//еее	for (int i = 0; i < testBSplines.size(); i++)		MyAssert(testBSplines[i]->GetNumControlPoints() > 0);		//Remove any illegal BSplines from their whole objects	for (int i = 0; i < bsplines.size(); i++)		if (bsplines[i]->GetNumControlPoints() < 3 || !bsplines[i]->GetAllIntersectionsLegal())			for (vector<WholeObject*>::iterator ii = wholeObjects.begin(); ii != wholeObjects.end(); ii++)			{				MyAssert((*ii)->bsplines.size() > 0);				vector<BSpline*>::iterator jj = find((*ii)->bsplines.begin(), (*ii)->bsplines.end(), bsplines[i]);				if (jj != (*ii)->bsplines.end())				{					if ((*ii)->bsplines.size() > 1)	//If there are multiple BSplines in the object, just remove the BSpline in question					{						(*ii)->bsplines.erase(jj);						break;					}					else	//If the object only has the BSpline in question, kill the whole object					{						delete *ii;						wholeObjects.erase(ii);						break;					}				}			}		//Add any BSplines that don't have a group to the test list	for (int i = 0; i < bsplines.size(); i++)	{		if (find(testBSplines.begin(), testBSplines.end(), bsplines[i]) != testBSplines.end())			continue;				bool hasAnObject = false;		for (int j = 0; j < wholeObjects.size(); j++)			if (find(wholeObjects[j]->bsplines.begin(), wholeObjects[j]->bsplines.end(), bsplines[i]) != wholeObjects[j]->bsplines.end())			{				hasAnObject = true;				break;			}				if (!hasAnObject && bsplines[i]->GetNumControlPoints() >= 3 && bsplines[i]->GetAllIntersectionsLegal())			testBSplines.push_back(bsplines[i]);	}		//For any BSpline in the test list, add all other BSplines sharing a whole object with it to the test list	for (int i = 0; i < testBSplines.size(); i++)		for (int j = 0; j < wholeObjects.size(); j++)			if (find(wholeObjects[j]->bsplines.begin(), wholeObjects[j]->bsplines.end(), testBSplines[i]) != wholeObjects[j]->bsplines.end())			{				for (int k = 0; k < wholeObjects[j]->bsplines.size(); k++)				{					MyAssert(wholeObjects[j]->bsplines[k]->GetNumControlPoints() >= 3 && wholeObjects[j]->bsplines[k]->GetAllIntersectionsLegal());					if (find(testBSplines.begin(), testBSplines.end(), wholeObjects[j]->bsplines[k]) == testBSplines.end())						testBSplines.push_back(wholeObjects[j]->bsplines[k]);				}				break;			}		//Remove any incomplete or illegal BSplines from the test list	bool foundOne = true;	while (foundOne)	{		foundOne = false;		for (vector<BSpline*>::iterator i = testBSplines.begin(); i != testBSplines.end(); i++)			if ((*i)->GetNumControlPoints() < 3 || !(*i)->GetAllIntersectionsLegal())			{				testBSplines.erase(i);				foundOne = true;				break;			}	}		//Make sure every bspline is in a whole object	for (int i = 0; i < bsplines.size(); i++)	{		WholeObject* wholeObject = NULL;		FindOrCreateWholeObjectForBSpline(bsplines[i], wholeObject);		MyAssert(wholeObject);	}		//еее	for (int i = 0; i < bsplines.size(); i++)	{		WholeObject* bspWholeObject = NULL;		for (int k = 0; k < wholeObjects.size(); k++)			if (find(wholeObjects[k]->bsplines.begin(), wholeObjects[k]->bsplines.end(), bsplines[i]) != wholeObjects[k]->bsplines.end())			{				bspWholeObject = wholeObjects[k];				break;			}		MyAssert(bspWholeObject);	}		//Remove all testBSplines from their whole objects into solitary whole objects.	//They will be added back into their proper whole objects as required.	//This is easier than carefully removing bsplines if and when necessary.	for (int i = 0; i < testBSplines.size(); i++)	{		//Find the whole object for this BSpline		WholeObject* wholeObject = NULL;		FindOrCreateWholeObjectForBSpline(testBSplines[i], wholeObject);		MyAssert(wholeObject);				if (wholeObject->bsplines.size() > 1)		{			//There are multiple bsplines in this whole object, so remove the testBSpline into its own whole object			vector<BSpline*>::iterator iter = find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), testBSplines[i]);			MyAssert(iter != wholeObject->bsplines.end());			wholeObject->bsplines.erase(iter);						wholeObject = NULL;			MyAssert(!FindOrCreateWholeObjectForBSpline(testBSplines[i], wholeObject));			MyAssert(wholeObject);			MyAssert(wholeObject->bsplines.size() == 1);			MyAssert(wholeObject->bsplines[0] == testBSplines[i]);		}		else wholeObject->bgDepth = -999999;				//Find any cuts corresponding to the testBSplines and remove them too		bool foundOne = true;		while (foundOne)		{			foundOne = false;			for (int j = 0; j < bsplinePairCuts.size(); j++)				if (bsplinePairCuts[j]->GetBsp1() == testBSplines[i] || bsplinePairCuts[j]->GetBsp2() == testBSplines[i])				{					RemoveCut(bsplinePairCuts[j]);					foundOne = true;					break;				}		}	}		//Remove cuts for illegal BSplines	foundOne = true;	for (int i = 0; i < bsplinePairCuts.size(); i++)	{		foundOne = false;		if (!bsplinePairCuts[i]->GetBsp1()->GetAllIntersectionsLegal() ||			(bsplinePairCuts[i]->GetBsp2() && !bsplinePairCuts[i]->GetBsp2()->GetAllIntersectionsLegal()))		{			RemoveCut(bsplinePairCuts[i]);			foundOne = true;			break;		}	}		//Remove all cuts between pairs of solids	for (int i = 0; i < bsplines.size(); i++)	{		if (bsplines[i]->GetWindingNumber() < 0)	//Skip holes			continue;				for (int j = 0; j < bsplines.size(); j++)			if (bsplines[j]->GetWindingNumber() > 0)				RemoveBSplineToBSplineCut(bsplines[i], bsplines[j]);	}		VerifyPrevCuts();		for (int i = 0; i < testBSplines.size(); i++)		MyAssert(testBSplines[i]->GetNumControlPoints() >= 3 && testBSplines[i]->GetAllIntersectionsLegal());		if (testBSplines.size() == 0)	{		int k = 1;	}		//Assert that all bsplines have a whole object	for (int i = 0; i < bsplines.size(); i++)	{		WholeObject* bspWholeObject = NULL;		for (int k = 0; k < wholeObjects.size(); k++)			if (find(wholeObjects[k]->bsplines.begin(), wholeObjects[k]->bsplines.end(), bsplines[i]) != wholeObjects[k]->bsplines.end())			{				bspWholeObject = wholeObjects[k];				break;			}		MyAssert(bspWholeObject);	}		//Loop over the testBSplines	for (int i = 0; i < testBSplines.size(); i++)	{		int testBSplineIndex = i;	//еее		BSpline* testBsp = testBSplines[i];			MyAssert(testBSplines[i]->GetNumControlPoints() >= 3 && testBSplines[i]->GetAllIntersectionsLegal());				//Find the whole object for this BSpline		WholeObject* wholeObject = NULL;		FindOrCreateWholeObjectForBSpline(testBSplines[i], wholeObject);		MyAssert(wholeObject);				if (testBSplines[i]->GetWindingNumber() > 0)	//Skip solids			continue;				//Two major passes.  On the first pass, search for any prev saved cut at all and test that saved cut first.		//On the second pass, start looking for new cuts.		bool foundAnyPrevCut = false;	//debug only		for (int anyPrevCutSearchPass = 0; anyPrevCutSearchPass < 2; anyPrevCutSearchPass++)		{			int cv1, cv2, sg1, sg2;			FloatPoint lnPt1, lnPt2;	//For debug only			bool foundPrev = false;						//Determine if there is a saved cut for this bspline to any other bspline, or to an infinite boundry			BSpline* cutOtherBsp = NULL;			if (anyPrevCutSearchPass == 0 && !FindPreviousBSplineToAnyBSplineCut(testBSplines[i], cutOtherBsp, cv1, cv2, sg1, sg2, lnPt1, lnPt2))			{				anyPrevCutSearchPass++;				foundAnyPrevCut = true;			}						//First thing to do is test the hole against an infinitely distant boundary solid			bool infiniteBoundaryFound = false;			if ((anyPrevCutSearchPass == 0 && !cutOtherBsp) || anyPrevCutSearchPass == 1)			{				int cutEndingDepth;								for (int iii = 0; iii < testBSplines.size(); iii++)					MyAssert(testBSplines[iii]->GetNumControlPoints() >= 3 && testBSplines[iii]->GetAllIntersectionsLegal());								vector<vector<FloatPoint>*>* curvePoints1 = testBSplines[i]->GetCurvePoints();				int bsp1TotalCurveSegs = curvePoints1->size() * BSpline::sNumSegmentsPerCurve;				int maxNumCutAttempts = sqrt(bsp1TotalCurveSegs);				BSplineToBSplineCut* bestCut = NULL;								for (int numCutAttempts = 0; numCutAttempts < maxNumCutAttempts; numCutAttempts++)				{					foundPrev = false;										if (numCutAttempts == 0)					{						if (anyPrevCutSearchPass == 1)							foundPrev = FindPreviousBSplineToSpecificBSplineCut(testBSplines[i], NULL, cv1, cv2, sg1, sg2, lnPt1, lnPt2);						else//MUST BE TRUE if (anyPrevCutSearchPass == 0 && !cutOtherBsp)						{							foundPrev = true;						}					}										if (!foundPrev)						FindRandomBSplineToBSplineCut(testBSplines[i], NULL, cv1, cv2, sg1, sg2, lnPt1, lnPt2);											int initSectionDepth = testBSplines[i]->GetArbitraryCurveSegCenterDepth(0, 0);					BSplineToBSplineCut* infiniteCut = new BSplineToBSplineCut(this, testBSplines[i], NULL, cv1, sg1, -1, -1, initSectionDepth);					bool goodCut = TestCut(infiniteCut, cutEndingDepth);					if (goodCut)					{						//еее						if (gDebug3)						{							double lineSegAngle;														lineSegAngle = LineSegmentAngle(lnPt1, lnPt2);							FloatPoint projectedLnPt1 = ProjectPointAtAngle(lnPt1, lineSegAngle + Pi, 1);							FloatPoint projectedLnPt2 = ProjectPointAtAngle(lnPt2, lineSegAngle, 1);														PenSize(7, 7);														ForeColor(magentaColor);							MoveTo(lnPt1.h - 4, lnPt1.v - 4);							Line(0, 0);														ForeColor(blackColor);							MoveTo(lnPt2.h - 4, lnPt2.v - 4);							Line(0, 0);														PenSize(3, 3);														ForeColor(yellowColor);							MoveTo(projectedLnPt1.h - 2, projectedLnPt1.v - 2);							LineTo(projectedLnPt2.h - 2, projectedLnPt2.v - 2);														PenSize(1, 1);														QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int dg3 = 1;						}												if (!bestCut)	//No best cut yet, so take this cut							bestCut = infiniteCut;						else if (bestCut && bestCut->GetNumIntersections() > infiniteCut->GetNumIntersections())	//New cut is better than the previous best cut						{							DeleteBSplineToBSplineCut(bestCut);														bestCut = infiniteCut;						}						else goodCut = false;	//New cut isn't good enough					}										if (!goodCut)					{						//еее						if (gDebug3)						{							ForeColor(whiteColor);							MoveTo(infiniteCut->GetStart().h, infiniteCut->GetStart().v);							LineTo(infiniteCut->GetEnd().h, infiniteCut->GetEnd().v);														QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);														int dg3 = 1;						}												DeleteBSplineToBSplineCut(infiniteCut);					}				}	//End loop over cut attempts								if (bestCut)				{					//MyAssert(wholeObject->bgDepth == -999999);										//If there is a whole object with the correct background depth, add the hole to it.					//Else create a new object for the hole.					bool foundOne = false;					for (int j = 0; j < wholeObjects.size(); j++)						if (wholeObjects[j]->bgDepth == cutEndingDepth)						{							MyAssert(find(wholeObjects[j]->bsplines.begin(), wholeObjects[j]->bsplines.end(), testBSplines[i]) == wholeObjects[j]->bsplines.end());							wholeObjects[j]->bsplines.push_back(testBSplines[i]);														delete wholeObject;							vector<WholeObject*>::iterator iter = find(wholeObjects.begin(), wholeObjects.end(), wholeObject);							MyAssert(iter != wholeObjects.end());							wholeObjects.erase(iter);														foundOne = true;						}										if (!foundOne)					{						//Make a new object for the hole						MyAssert(wholeObject);						//еееMyAssert(wholeObject->bsplines.size() == 1);						wholeObject->bgDepth = cutEndingDepth;					}										//Remove all cuts for this BSpline					//еееfor (int j = 0; j < bsplines.size(); j++)						//еееRemoveBSplineToBSplineCut(testBSplines[i], bsplines[j]);										infiniteBoundaryFound = true;										SaveBSplineToBSplineCut(bestCut);										anyPrevCutSearchPass++;				}			}	//End condition on found prev infinite cut or second pass						//If the hole didn't find an infinite boundary, proceed to check it against all solids			if ((anyPrevCutSearchPass == 0 && cutOtherBsp) || (anyPrevCutSearchPass == 1 && !infiniteBoundaryFound))			{					//double maxNumCutAttemptsScaler = 1.0 / 32.0;	//Will be scaled up by factors of 2 until it reaches 1.0				BSplineToBSplineCut* bestCut = NULL;				bool objectAlreadyGrouped = false;				//while (maxNumCutAttemptsScaler <= 1.0)				for (double maxNumCutAttemptsScaler = 1.0 / 32.0; maxNumCutAttemptsScaler <= 1.0; maxNumCutAttemptsScaler *= 2.0)				{					//Loop over the bsplines					for (int j = 0; j < bsplines.size(); j++)					{						if (testBSplines[i] == bsplines[j])	//Skip self-checks instantly, the test doesn't even make sense in such a case							continue;												if (bsplines[j]->GetWindingNumber() < 0)	//Skip ungrouped holes						{							WholeObject* testWholeObject = NULL;							for (int k = 0; k < wholeObjects.size(); k++)								if (find(wholeObjects[k]->bsplines.begin(), wholeObjects[k]->bsplines.end(), bsplines[j]) != wholeObjects[k]->bsplines.end())								{									testWholeObject = wholeObjects[k];									break;								}							MyAssert(testWholeObject && testWholeObject->bsplines.size() > 0);							if (testWholeObject->bgDepth == -999999)							{								//for (int k = 0; k < testWholeObject->bsplines.size(); k++)								//	MyAssert(testWholeObject->bsplines[k]->GetWindingNumber() < 0);	//Should this be true for figure-eights too?								continue;							}						}												if (!bsplines[j]->GetAllIntersectionsLegal())	//Don't check illegal BSplines							continue;												if (bsplines[j]->GetNumControlPoints() < 3)	//Skip incomplete BSplines							continue;												//Create a whole object for the solid, if necessary						WholeObject* wholeObject2 = NULL;						FindOrCreateWholeObjectForBSpline(bsplines[j], wholeObject2);												if (wholeObject == wholeObject2)	//These two objects are already grouped, we can stop looking for a cut (there should already be one found by the other object)						{							objectAlreadyGrouped = true;							break;						}												//Calculate how many cut attempts to make						vector<vector<FloatPoint>*>* curvePoints1 = testBSplines[i]->GetCurvePoints();						int bsp1TotalCurveSegs = curvePoints1->size() * BSpline::sNumSegmentsPerCurve;												vector<vector<FloatPoint>*>* curvePoints2 = bsplines[j]->GetCurvePoints();						int bsp2TotalCurveSegs = curvePoints2->size() * BSpline::sNumSegmentsPerCurve;												int maxNumCutAttempts = sqrt(bsp1TotalCurveSegs * bsp2TotalCurveSegs) * maxNumCutAttemptsScaler;	//Scales with the product												//Loop over the cut attempts						int numCutAttempts = 0;						for (numCutAttempts = 0; numCutAttempts < maxNumCutAttempts; numCutAttempts++)						{							BSpline* otherBsp = (anyPrevCutSearchPass == 0) ? cutOtherBsp : bsplines[j];														foundPrev = false;														if (numCutAttempts == 0)							{								if (anyPrevCutSearchPass == 1)									foundPrev = FindPreviousBSplineToSpecificBSplineCut(testBSplines[i], otherBsp, cv1, cv2, sg1, sg2, lnPt1, lnPt2);								else//MUST BE TRUE if (anyPrevCutSearchPass == 0 && !cutOtherBsp)								{									foundPrev = true;								}							}														if (!foundPrev)								FindRandomBSplineToBSplineCut(testBSplines[i], otherBsp, cv1, cv2, sg1, sg2, lnPt1, lnPt2);														int cutEndingDepthNotUsed;	//Not really used here, only used in the infinite boundary test above														int initSectionDepth = testBSplines[i]->GetArbitraryCurveSegCenterDepth(cv1, sg1);							BSplineToBSplineCut* bspBspCut = new BSplineToBSplineCut(this, testBSplines[i], otherBsp, cv1, sg1, cv2, sg2, initSectionDepth);							bool goodCut = TestCut(bspBspCut, cutEndingDepthNotUsed);							if (goodCut)	//Cut is acceptable, but is it the best possible cut?  Check this here.							{								//еее								if (gDebug3)								{									double lineSegAngle;																		lineSegAngle = LineSegmentAngle(lnPt1, lnPt2);									FloatPoint projectedLnPt1 = ProjectPointAtAngle(lnPt1, lineSegAngle + Pi, 1);									FloatPoint projectedLnPt2 = ProjectPointAtAngle(lnPt2, lineSegAngle, 1);																		PenSize(7, 7);																		ForeColor(magentaColor);									MoveTo(lnPt1.h - 4, lnPt1.v - 4);									Line(0, 0);																		ForeColor(blackColor);									MoveTo(lnPt2.h - 4, lnPt2.v - 4);									Line(0, 0);																		PenSize(3, 3);																		ForeColor(yellowColor);									MoveTo(projectedLnPt1.h - 2, projectedLnPt1.v - 2);									LineTo(projectedLnPt2.h - 2, projectedLnPt2.v - 2);																		PenSize(1, 1);																		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);																		int dg3 = 1;								}																//Make sure the ends of the new cut are legal								vector<int> cutDepths = *bspBspCut->GetSectionDepths();								int bsp1Depth = testBSplines[i]->GetArbitraryCurveSegCenterDepth(cv1, sg1);								MyAssert(bsp1Depth == cutDepths[0]);								int bsp2Depth = otherBsp->GetArbitraryCurveSegCenterDepth(cv2, sg2);								MyAssert(bsp2Depth == cutDepths[cutDepths.size() - 1]);																if (!bestCut)	//No best cut yet, so take this cut									bestCut = bspBspCut;								else if (bestCut && bestCut->GetNumIntersections() > bspBspCut->GetNumIntersections())	//New cut is better than the previous best cut								{									DeleteBSplineToBSplineCut(bestCut);																		bestCut = bspBspCut;								}								else goodCut = false;	//New cut isn't good enough							}	//End processing of possibly good cut														if (!goodCut)	//Cut test failed or cut wasn't good enough							{								//еее								if (gDebug3)								{									ForeColor(whiteColor);									MoveTo(bspBspCut->GetStart().h, bspBspCut->GetStart().v);									LineTo(bspBspCut->GetEnd().h, bspBspCut->GetEnd().v);																		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);																		int dg3 = 1;								}																if (foundPrev)									RemoveBSplineToBSplineCut(testBSplines[i], otherBsp);																DeleteBSplineToBSplineCut(bspBspCut);							}	//End removal of bad cut														VerifyPrevCuts();														if (bestCut && bestCut->GetNumIntersections() == 2)	//A better cut is impossible, so break out								break;						}	//End loop over cut attempts												if (bestCut && bestCut->GetNumIntersections() == 2)	//A better cut is impossible, so break out							break;					}	//End loop over bsplines										for (int iii = 0; iii < testBSplines.size(); iii++)						MyAssert(testBSplines[iii]->GetNumControlPoints() >= 3 && testBSplines[iii]->GetAllIntersectionsLegal());										//maxNumCutAttemptsScaler *= 2.0;										if (objectAlreadyGrouped)						break;										if (bestCut && bestCut->GetNumIntersections() == 2)	//A better cut is impossible, so break out						break;				}	//end loop over maxNumCutAttemptsScaler								if (bestCut)	//A cut was found, so save it				{					//Make sure the ends of the new cut are legal					vector<int> cutDepths = *bestCut->GetSectionDepths();					MyAssert(bestCut->GetBsp1() == testBSplines[i]);					int bsp1Depth = testBSplines[i]->GetArbitraryCurveSegCenterDepth(bestCut->GetCv1(), bestCut->GetSg1());					MyAssert(bsp1Depth == cutDepths[0]);					int bsp2Depth = bestCut->GetBsp2()->GetArbitraryCurveSegCenterDepth(bestCut->GetCv2(), bestCut->GetSg2());					MyAssert(bsp2Depth == cutDepths[cutDepths.size() - 1]);										//Save the cut that was discovered					//SaveBSplineToBSplineCut(testBSplines[i], otherBsp, cv1, cv2, sg1, sg2);					SaveBSplineToBSplineCut(bestCut);										//The cut worked.  The hole and solid are part of the same surface.  Add the hole to the solid's object, if necessary.					bestCut->GetAllIntersectionsLegal(true);										//Find the whole object corresponding to the hole					vector<WholeObject*>::iterator holeWholeObjectIter;					for (holeWholeObjectIter = wholeObjects.begin(); holeWholeObjectIter != wholeObjects.end(); holeWholeObjectIter++)						if (find((*holeWholeObjectIter)->bsplines.begin(), (*holeWholeObjectIter)->bsplines.end(), testBSplines[i]) != (*holeWholeObjectIter)->bsplines.end())							break;									MyAssert(holeWholeObjectIter != wholeObjects.end());					MyAssert(wholeObject == *holeWholeObjectIter);										//Find the whole object corresponding to the solid					MyAssert(bestCut->GetBsp1() == testBSplines[i] && bestCut->GetBsp2() != testBSplines[i]);					BSpline* otherBsp = bestCut->GetBsp2();					vector<WholeObject*>::iterator solidWholeObjectIter;					for (solidWholeObjectIter = wholeObjects.begin(); solidWholeObjectIter != wholeObjects.end(); solidWholeObjectIter++)						if (find((*solidWholeObjectIter)->bsplines.begin(), (*solidWholeObjectIter)->bsplines.end(), otherBsp) != (*solidWholeObjectIter)->bsplines.end())							break;										MyAssert(solidWholeObjectIter != wholeObjects.end());										WholeObject* wholeObject2 = NULL;					MyAssert(FindOrCreateWholeObjectForBSpline(otherBsp, wholeObject2));					MyAssert(wholeObject2 == *solidWholeObjectIter);										//If the hole isn't already part of the solid's object, add it and transitively any of its object BSplines to the solid's object					if (*solidWholeObjectIter != wholeObject)					{						//Add all of the hole's whole object's BSplines to the solid's whole object						for (int k = 0; k < wholeObject->bsplines.size(); k++)							if (find((*solidWholeObjectIter)->bsplines.begin(), (*solidWholeObjectIter)->bsplines.end(), wholeObject->bsplines[k]) == (*solidWholeObjectIter)->bsplines.end())								(*solidWholeObjectIter)->bsplines.push_back(wholeObject->bsplines[k]);												//Destroy the hole's whole object						delete wholeObject;						wholeObjects.erase(holeWholeObjectIter);					}										anyPrevCutSearchPass++;				}	//End condition on finding bestCut			}	//End condition on (!infiniteBoundaryFound)		}	//End loop over two major passes (anyPrevCutSearchPass), one to test prev saved cuts, and one to find new cuts				for (int iii = 0; iii < testBSplines.size(); iii++)			MyAssert(testBSplines[iii]->GetNumControlPoints() >= 3 && testBSplines[iii]->GetAllIntersectionsLegal());	}	//end for loop over test bsplines		//There might be intersections in the "brand new" list that shouldn't exist at all	foundOne = true;	while (foundOne)	{		foundOne = false;		for (vector<GenericIntersection*>::iterator i = brandNewIntersections.begin(); i != brandNewIntersections.end(); i++)			if (find(intersections.begin(), intersections.end(), *i) == intersections.end())			{				brandNewIntersections.erase(i);				foundOne = true;				break;			}	}		VerifyPrevCuts();		//After all the whole objects are found, sync up the colors for the objects.	//Colors for all negative winding number BSplines should be set to black inside their BSplines, so we don't have to worry about that.	//Likewise, a whole object should have at once one positive winding number BSpline.	//However, 0 winding number BSplines need to be synced	for (int i = 0; i < wholeObjects.size(); i++)	{		//Discard "black" colors, this signifies uncolored				//Make a list of all the positive winding number colors		vector<pair<RGBColor, double> > colors;		for (int j = 0; j < wholeObjects[i]->bsplines.size(); j++)			if (wholeObjects[i]->bsplines[j]->GetWindingNumber() > 0 &&					(wholeObjects[i]->bsplines[j]->GetSurfaceTraits().first.red != 0 ||					wholeObjects[i]->bsplines[j]->GetSurfaceTraits().first.green != 0 ||					wholeObjects[i]->bsplines[j]->GetSurfaceTraits().first.blue != 0))				colors.push_back(wholeObjects[i]->bsplines[j]->GetSurfaceTraits());				//If there isn't a pos wind num color, go with 0 wind num		if (colors.size() == 0)			for (int j = 0; j < wholeObjects[i]->bsplines.size(); j++)				if (wholeObjects[i]->bsplines[j]->GetWindingNumber() == 0 &&						(wholeObjects[i]->bsplines[j]->GetSurfaceTraits().first.red != 0 ||						wholeObjects[i]->bsplines[j]->GetSurfaceTraits().first.green != 0 ||						wholeObjects[i]->bsplines[j]->GetSurfaceTraits().first.blue != 0))					colors.push_back(wholeObjects[i]->bsplines[j]->GetSurfaceTraits());				//If there isn't a 0 wind num color, go with neg wind num		if (colors.size() == 0)			for (int j = 0; j < wholeObjects[i]->bsplines.size(); j++)				if (wholeObjects[i]->bsplines[j]->GetWindingNumber() < 0 &&						(wholeObjects[i]->bsplines[j]->GetSurfaceTraits().first.red != 0 ||						wholeObjects[i]->bsplines[j]->GetSurfaceTraits().first.green != 0 ||						wholeObjects[i]->bsplines[j]->GetSurfaceTraits().first.blue != 0))					colors.push_back(wholeObjects[i]->bsplines[j]->GetSurfaceTraits());				if (colors.size() > 0)			//Take the first one (arbitrary of course)			for (int j = 0; j < wholeObjects[i]->bsplines.size(); j++)				wholeObjects[i]->bsplines[j]->SetSurfaceTraits(colors[0]);	}		//Make a list of every intersection associated with a newly formed group	if (gCompanionSetMethod != 0)	{		vector<GenericIntersection*> intersToComp;		bool legalLabeling = true;		for (int i = 0; i < testBSplines.size(); i++)		{			if (gDebug3)			{				Point scrollOffset = {0, 0};				vector<BSpline*> workingBSplines;				DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int dg3 = 1;			}						//Get the intersections on bsplines in the group			vector<BSpline*> groupBSplines;			GetBSplinesInGroupFromBSpline(testBSplines[i], groupBSplines);						for (int j = 0; j < groupBSplines.size(); j++)				MyAssert(groupBSplines[j]->GetAllIntersectionsLegal(true));						for (int j = 0; j < groupBSplines.size(); j++)			{				vector<GenericIntersection*> bspInters = groupBSplines[j]->GetIntersections();				for (int k = 0; k < bspInters.size(); k++)					if (bspInters[k]->GetType() == GenericIntersection::BSP_BSP)					{						if (!((BspBspIntersection*)bspInters[k])->GetBsp1()->GetAllIntersectionsLegal(false))							legalLabeling = false;						if (!((BspBspIntersection*)bspInters[k])->GetBsp2()->GetAllIntersectionsLegal(false))							legalLabeling = false;						intersToComp.push_back(bspInters[k]);					}					else if (bspInters[k]->GetType() == GenericIntersection::BSP_CUT)					{						if (!((BspCutIntersection*)bspInters[k])->GetBsp()->GetAllIntersectionsLegal(false))							legalLabeling = false;						if (!((BspCutIntersection*)bspInters[k])->GetCut()->GetAllIntersectionsLegal(false))							legalLabeling = false;						intersToComp.push_back(bspInters[k]);					}			}						//Get the intersections on cuts in the group			for (int j = 0; j < bsplinePairCuts.size(); j++)				if (find(groupBSplines.begin(), groupBSplines.end(), bsplinePairCuts[j]->GetBsp1()) != groupBSplines.end() ||					find(groupBSplines.begin(), groupBSplines.end(), bsplinePairCuts[j]->GetBsp2()) != groupBSplines.end())				{					MyAssert(bsplinePairCuts[j]->GetAllIntersectionsLegal(true));										vector<GenericIntersection*> cutInters = bsplinePairCuts[j]->GetIntersections();					for (int k = 0; k < cutInters.size(); k++)						if (cutInters[k]->GetType() == GenericIntersection::BSP_CUT)						{							if (!((BspCutIntersection*)cutInters[k])->GetBsp()->GetAllIntersectionsLegal(false))								legalLabeling = false;							if (!((BspCutIntersection*)cutInters[k])->GetCut()->GetAllIntersectionsLegal(false))								legalLabeling = false;							intersToComp.push_back(cutInters[k]);						}				}		}		if (legalLabeling)			FindInterCompSetsForInters(intersToComp);	}		//Not really necessary here, I think, but helpful for debugging	FindBSplineSectionMaxPossibleDepthsV4();}*/#pragma mark -void Drawing::DuplicateCut(BSplineToBSplineCut* cut, BSpline* bsp1, BSpline* bsp2){	WholeObject* wholeObject1;	MyAssert(!FindOrCreateWholeObjectForBSpline(bsp1, wholeObject1));	WholeObject* wholeObject2;	MyAssert(!FindOrCreateWholeObjectForBSpline(bsp2, wholeObject2));		BSplineToBSplineCut* dupCut = new BSplineToBSplineCut(this, bsp1, bsp2, cut->GetCv1(), cut->GetSg1(),														cut->GetCv2(), cut->GetSg2(), 0);		FloatPoint lnPt1 = dupCut->GetStart();	FloatPoint lnPt2 = dupCut->GetEnd();	double lineSegAngle = LineSegmentAngle(lnPt1, lnPt2);	//Extend the ends a tad bit	FloatPoint projectedLnPt1 = ProjectPointAtAngle(lnPt1, lineSegAngle + Pi, lineSegmentProjectSlop);	FloatPoint projectedLnPt2 = ProjectPointAtAngle(lnPt2, lineSegAngle, lineSegmentProjectSlop);	bool success;	FindCutIntersections(dupCut, lineSegAngle, projectedLnPt1, projectedLnPt2, success);	MyAssert(success);		GroupBSplineAndSaveBSplineToBSplineCut(bsp1, dupCut, -1);}void Drawing::CreateManualCut(BSpline* bsp, int curveSegment){	int numControlPoints = bsp->GetNumControlPoints();	MyAssert(curveSegment >= 0 && curveSegment < BSpline::sNumSegmentsPerCurve * numControlPoints);		if (!manualCutStartBsp)	{		manualCutStartBsp = bsp;		manualCutStartSeg = curveSegment;		return;	}		if (bsp == manualCutStartBsp)	{		SysBeep(1);		ResetManualCut();		return;	}		int cv1 = manualCutStartSeg / BSpline::sNumSegmentsPerCurve;	int sg1 = manualCutStartSeg % BSpline::sNumSegmentsPerCurve;	int cv2 = curveSegment / BSpline::sNumSegmentsPerCurve;	int sg2 = curveSegment % BSpline::sNumSegmentsPerCurve;		int initSectionDepth = manualCutStartBsp->GetArbitraryCurveSegCenterDepth(cv1, sg1);	//Try to keep the manual cuts looking more or less like discovered cuts, with the start on the hole and the end on the solid (although cuts can be between two holes)	BSplineToBSplineCut* testCut = NULL;	BSpline* cutStartBsp = NULL;	if ((manualCutStartBsp->GetWindingNumber() < 0 && bsp->GetWindingNumber() > 0) ||		(manualCutStartBsp->GetWindingNumber() < 0 && bsp->GetWindingNumber() < 0))	{		testCut = new BSplineToBSplineCut(this, manualCutStartBsp, bsp, cv1, sg1, cv2, sg2, initSectionDepth);		cutStartBsp = manualCutStartBsp;	}	else// if (manualCutStartBsp->GetWindingNumber() > 0 && bsp->GetWindingNumber() < 0)	{		testCut = new BSplineToBSplineCut(this, bsp, manualCutStartBsp, cv2, sg2, cv1, sg1, initSectionDepth);		cutStartBsp = bsp;	}		int cutEndingDepth = -1;	bool goodCut = TestCut(testCut, cutEndingDepth);	if (goodCut)	{		MyAssert(FindWholeObjectForBSpline(manualCutStartBsp));		MyAssert(FindWholeObjectForBSpline(bsp));		GroupBSplineAndSaveBSplineToBSplineCut(cutStartBsp, testCut, cutEndingDepth);	}	else	{		SysBeep(1);				//Throw away the test cut		testCut->NullAllBspsAndCuts();		DeleteBSplineToBSplineCut(testCut);	}		ResetManualCut();}void Drawing::ResetManualCut(){	manualCutStartBsp = NULL;	manualCutStartSeg = -1;}bool Drawing::CreatingManualCut(){	return (manualCutStartBsp != NULL);}#pragma mark -void Drawing::PrepareToFindWholeObjects(vector<BSpline*>& testBSplines, bool dontGroupIllegalBSplines, bool onlyPrepareTestBSplines){	if (!onlyPrepareTestBSplines)	{		//Verify that this Drawing's new intersections have the appropriate BSpline and Cut pointers and indexes		//еее		for (int i = 0; i < intersections.size(); i++)		{			MyAssert(intersections[i]->GetDrawing() == this);			switch (intersections[i]->GetType())			{				case GenericIntersection::BSP_BSP:					BspBspIntersection* bspBspInter = (BspBspIntersection*)intersections[i];										MyAssert(bspBspInter->GetBsp1() == bsplines[bspBspInter->GetBsp1Index()]);					MyAssert(bspBspInter->GetBsp2() == bsplines[bspBspInter->GetBsp2Index()]);					break;				case GenericIntersection::BSP_CUT:					BspCutIntersection* bspCutInter = (BspCutIntersection*)intersections[i];										MyAssert(bspCutInter->GetBsp() == bsplines[bspCutInter->GetBspIndex()]);					MyAssert(bspCutInter->GetCut() == bsplinePairCuts[bspCutInter->GetCutIndex()]);					break;				case GenericIntersection::BSP_CUT_T:					BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)intersections[i];										if (bspCutTInter->GetBsp())						MyAssert(bspCutTInter->GetBsp() == bsplines[bspCutTInter->GetBspIndex()]);					MyAssert(bspCutTInter->GetCut() == bsplinePairCuts[bspCutTInter->GetCutIndex()]);					break;				case GenericIntersection::CUT_CUT:					CutCutIntersection* cutCutInter = (CutCutIntersection*)intersections[i];										MyAssert(cutCutInter->GetCut1() == bsplinePairCuts[cutCutInter->GetCut1Index()]);					MyAssert(cutCutInter->GetCut2() == bsplinePairCuts[cutCutInter->GetCut2Index()]);					break;			}		}				//еее		for (int i = 0; i < testBSplines.size(); i++)			MyAssert(testBSplines[i]->GetNumControlPoints() > 0);				//Remove all illegal bsplines into solitary whole objects		for (int i = 0; i < bsplines.size(); i++)			if (!bsplines[i]->GetAllIntersectionsLegal())			{				//Find the whole object for this BSpline				WholeObject* wholeObject = NULL;				FindOrCreateWholeObjectForBSpline(bsplines[i], wholeObject);				MyAssert(wholeObject);								if (wholeObject->bsplines.size() > 1)				{					//There are multiple bsplines in this whole object, so remove the bspline into its own whole object					vector<BSpline*>::iterator iter = find(wholeObject->bsplines.begin(), wholeObject->bsplines.end(), bsplines[i]);					MyAssert(iter != wholeObject->bsplines.end());					wholeObject->bsplines.erase(iter);										wholeObject = NULL;					MyAssert(!FindOrCreateWholeObjectForBSpline(bsplines[i], wholeObject));					MyAssert(wholeObject);					MyAssert(wholeObject->bsplines.size() == 1);					MyAssert(wholeObject->bsplines[0] == bsplines[i]);				}				else wholeObject->bgDepths.clear();								//Find any cuts corresponding to the bsplines and remove them too				bool foundOne = true;				while (foundOne)				{					foundOne = false;					for (int j = 0; j < bsplinePairCuts.size(); j++)						if (bsplinePairCuts[j]->GetBsp1() == bsplines[i] || bsplinePairCuts[j]->GetBsp2() == bsplines[i])						{							RemoveCut(bsplinePairCuts[j], false);							foundOne = true;							break;						}				}			}				//Add any BSplines that don't have a group to the test list		for (int i = 0; i < bsplines.size(); i++)		{			if (find(testBSplines.begin(), testBSplines.end(), bsplines[i]) != testBSplines.end())				continue;						bool hasAnObject = false;			for (int j = 0; j < wholeObjects.size(); j++)				if (find(wholeObjects[j]->bsplines.begin(), wholeObjects[j]->bsplines.end(), bsplines[i]) != wholeObjects[j]->bsplines.end())				{					hasAnObject = true;					break;				}						if (!hasAnObject && bsplines[i]->GetNumControlPoints() >= 3 && bsplines[i]->GetAllIntersectionsLegal())				testBSplines.push_back(bsplines[i]);		}				//For any BSpline in the test list, add all other BSplines sharing a whole object with it to the test list		for (int i = 0; i < testBSplines.size(); i++)			for (int j = 0; j < wholeObjects.size(); j++)				if (find(wholeObjects[j]->bsplines.begin(), wholeObjects[j]->bsplines.end(), testBSplines[i]) != wholeObjects[j]->bsplines.end())				{					for (int k = 0; k < wholeObjects[j]->bsplines.size(); k++)					{						//The following MyAssert is only valid after finding a legal labeling.						//However, searching for cuts can be triggered midway through a labeling attempt in a specific effort to find and delete illegal cuts before continuing with the labeling attempt.						//MyAssert(wholeObjects[j]->bsplines[k]->GetNumControlPoints() >= 3 && wholeObjects[j]->bsplines[k]->GetAllIntersectionsLegal(true));												if (find(testBSplines.begin(), testBSplines.end(), wholeObjects[j]->bsplines[k]) == testBSplines.end())							testBSplines.push_back(wholeObjects[j]->bsplines[k]);					}					break;				}				//Remove any incomplete or illegal BSplines from the test list		bool foundOne = true;		if (dontGroupIllegalBSplines)		{			while (foundOne)			{				foundOne = false;				for (vector<BSpline*>::iterator i = testBSplines.begin(); i != testBSplines.end(); i++)					if ((*i)->GetNumControlPoints() < 3 || !(*i)->GetAllIntersectionsLegal())					{						testBSplines.erase(i);						foundOne = true;						break;					}			}		}				//Remove cuts for illegal BSplines		foundOne = true;		for (int i = 0; i < bsplinePairCuts.size(); i++)		{			foundOne = false;			if (!bsplinePairCuts[i]->GetBsp1()->GetAllIntersectionsLegal() ||				(bsplinePairCuts[i]->GetBsp2() && !bsplinePairCuts[i]->GetBsp2()->GetAllIntersectionsLegal()))			{				MyAssert(false);	//Is this possible?  We already separated illegal bsplines into individual whole objects above				RemoveCut(bsplinePairCuts[i], true);				foundOne = true;				break;			}		}				VerifyPrevCuts();				if (dontGroupIllegalBSplines)			for (int i = 0; i < testBSplines.size(); i++)				MyAssert(testBSplines[i]->GetNumControlPoints() >= 3 && testBSplines[i]->GetAllIntersectionsLegal());				//Make sure every bspline is in a whole object		for (int i = 0; i < bsplines.size(); i++)		{			WholeObject* wholeObject = NULL;			FindOrCreateWholeObjectForBSpline(bsplines[i], wholeObject);			MyAssert(wholeObject);		}				//Assert that all bsplines have a whole object		//еее		for (int i = 0; i < bsplines.size(); i++)		{			WholeObject* bspWholeObject = NULL;			for (int k = 0; k < wholeObjects.size(); k++)				if (find(wholeObjects[k]->bsplines.begin(), wholeObjects[k]->bsplines.end(), bsplines[i]) != wholeObjects[k]->bsplines.end())				{					bspWholeObject = wholeObjects[k];					break;				}			MyAssert(bspWholeObject);		}				for (int i = 0; i < testBSplines.size(); i++)			MyAssert(testBSplines[i]->GetNumControlPoints() >= 3 && testBSplines[i]->GetAllIntersectionsLegal());	}		//Remove all cuts for testBSplines	for (int i = 0; i < testBSplines.size(); i++)	{		bool foundOne = true;		while (foundOne)		{			foundOne = false;			for (int j = 0; j < bsplinePairCuts.size(); j++)				if (bsplinePairCuts[j]->GetBsp1() == testBSplines[i] || bsplinePairCuts[j]->GetBsp2() == testBSplines[i])				{					RemoveCut(bsplinePairCuts[j], false);					foundOne = true;					break;				}		}	}		for (int i = 0; i < testBSplines.size(); i++)		MyAssert(testBSplines[i]->GetNumControlPoints() >= 3 && testBSplines[i]->GetAllIntersectionsLegal());		//Remove all testBSplines from their whole objects into solitary whole objects.	//They will be added back into their proper whole objects as required.	//This is easier than carefully removing bsplines if and when necessary.	for (int i = 0; i < testBSplines.size(); i++)	{		//Find the whole object for this BSpline		WholeObject* wholeObject2 = NULL;		FindOrCreateWholeObjectForBSpline(testBSplines[i], wholeObject2);		MyAssert(wholeObject2);				if (wholeObject2->bsplines.size() > 1)		{			//There are multiple bsplines in this whole object, so remove the testBSpline into its own whole object			vector<BSpline*>::iterator iter = find(wholeObject2->bsplines.begin(), wholeObject2->bsplines.end(), testBSplines[i]);			MyAssert(iter != wholeObject2->bsplines.end());			wholeObject2->bsplines.erase(iter);						wholeObject2 = NULL;			MyAssert(!FindOrCreateWholeObjectForBSpline(testBSplines[i], wholeObject2));			MyAssert(wholeObject2);			MyAssert(wholeObject2->bsplines.size() == 1);			MyAssert(wholeObject2->bsplines[0] == testBSplines[i]);			MyAssert(wholeObject2->bgDepths.size() == 0);			MyAssert(wholeObject2->bspCutTinters.size() == 0);		}		else		{			wholeObject2->bgDepths.clear();			MyAssert(wholeObject2->bspCutTinters.size() == 0);			/*			for (int j = 0; j < wholeObject2->bspCutTinters.size(); j++)			{				MyAssert(wholeObject2->bspCutTinters[j]->GetInfiniteWholeObject() == wholeObject2);				wholeObject2->bspCutTinters[j]->SetInfiniteWholeObject(NULL);			}			wholeObject2->bspCutTinters.clear();			*/		}	}		for (int i = 0; i < testBSplines.size(); i++)		MyAssert(testBSplines[i]->GetNumControlPoints() >= 3 && testBSplines[i]->GetAllIntersectionsLegal());		//Assert that all bsplines have a whole object	//еее	for (int i = 0; i < bsplines.size(); i++)	{		WholeObject* bspWholeObject = NULL;		for (int k = 0; k < wholeObjects.size(); k++)			if (find(wholeObjects[k]->bsplines.begin(), wholeObjects[k]->bsplines.end(), bsplines[i]) != wholeObjects[k]->bsplines.end())			{				bspWholeObject = wholeObjects[k];				break;			}		MyAssert(bspWholeObject);	}}BSplineToBSplineCut* Drawing::CreateCutFromPrevCut(BSpline* bsp, int& cutEndingDepth, bool& alreadyCut){	int cv1, cv2, sg1, sg2;	FloatPoint lnPt1, lnPt2;	//For debug only		BSpline* cutOtherBsp = NULL;	//Will remain NULL if an infinite cut is found		//=============================================================================	//	Old method, take the first prev cut found	//	//Make sure to keep old/new method enabling here in sync with FindPreviousBSplineToAnyBSplineCut().	/*	int notUsedByOldMethod = 1;	//Just a filler to fit the old method ftn call to the new method ftn signature	if (!FindPreviousBSplineToAnyBSplineCut(bsp, cutOtherBsp, cv1, cv2, sg1, sg2, lnPt1, lnPt2, notUsedByOldMethod))		return NULL;	//Prev cut was not found	*/	//=============================================================================		//=============================================================================	//	New method, keep trying incrementally found prev cuts until a satisfactory prev cut is found	//	Make sure to keep old/new method enabling here in sync with FindPreviousBSplineToAnyBSplineCut().		vector<pair<PrevCut*, pair<FloatPoint, FloatPoint> > > thisBspPrevCuts;	bool success = false;	int cnt = 1;	while (true)	{		cutOtherBsp = NULL;	//Will remain NULL if an infinite cut is found		PrevCut* prevCut = NULL;		success = FindPreviousBSplineToAnyBSplineCut(bsp, cutOtherBsp, cv1, cv2, sg1, sg2, lnPt1, lnPt2, prevCut, cnt++);				if (!success)			break;	//Prev cut was not found				if (bsp->GetWindingNumber() < 0 && cutOtherBsp)	//Skip ungrouped holes		{			vector<BSpline*> checkedBSplines;			if (!ConnectedHole(cutOtherBsp, checkedBSplines, NULL))				success = false;	//Prev cut connects this bsp to a disconnected hole bsp, so skip it and look for the next prev cut		}				if (success)		{			pair<PrevCut*, pair<FloatPoint, FloatPoint> > prevCutInfo;			prevCutInfo.first = prevCut;			prevCutInfo.second.first = lnPt1;			prevCutInfo.second.second = lnPt2;			thisBspPrevCuts.push_back(prevCutInfo);		}				if (gDebug3)		{			double lineSegAngle = (lnPt2.h != -1) ? LineSegmentAngle(lnPt1, lnPt2) : Pi;			FloatPoint projectedLnPt1 = ProjectPointAtAngle(lnPt1, lineSegAngle + Pi, 1);			FloatPoint projectedLnPt2 = (lnPt2.h != -1) ? ProjectPointAtAngle(lnPt2, lineSegAngle, 1) : projectedLnPt1;			if (lnPt2.h == -1)				projectedLnPt2.h = 0;						PenSize(7, 7);						ForeColor(magentaColor);			MoveTo(lnPt1.h - 4, lnPt1.v - 4);			Line(0, 0);						ForeColor(blackColor);			MoveTo(lnPt2.h - 4, lnPt2.v - 4);			Line(0, 0);						PenSize(3, 3);						success ? ForeColor(greenColor) : ForeColor(redColor);			MoveTo(projectedLnPt1.h - 2, projectedLnPt1.v - 2);			LineTo(projectedLnPt2.h - 2, projectedLnPt2.v - 2);						PenSize(1, 1);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int dg3 = 1;		}	}	if (thisBspPrevCuts.size() == 0)		return NULL;	pair<PrevCut*, pair<FloatPoint, FloatPoint> > bestPrevCutInfo = thisBspPrevCuts[0];	for (int i = 1; i < thisBspPrevCuts.size(); i++)		if (thisBspPrevCuts[i].first->numInters < bestPrevCutInfo.first->numInters)			bestPrevCutInfo = thisBspPrevCuts[i];	if (bestPrevCutInfo.first->bsp1 == bsp)	{		cutOtherBsp = bestPrevCutInfo.first->bsp2;		cv1 = bestPrevCutInfo.first->cv1;		sg1 = bestPrevCutInfo.first->sg1;		cv2 = bestPrevCutInfo.first->cv2;		sg2 = bestPrevCutInfo.first->sg2;		lnPt1 = bestPrevCutInfo.second.first;		lnPt2 = bestPrevCutInfo.second.second;	}	else	{		cutOtherBsp = bestPrevCutInfo.first->bsp1;		cv1 = bestPrevCutInfo.first->cv2;		sg1 = bestPrevCutInfo.first->sg2;		cv2 = bestPrevCutInfo.first->cv1;		sg2 = bestPrevCutInfo.first->sg1;		lnPt1 = bestPrevCutInfo.second.second;		lnPt2 = bestPrevCutInfo.second.first;	}		//=============================================================================		alreadyCut = false;		//If the prev cut already exists, just take it	for (int i = 0; i < bsplinePairCuts.size(); i++)	{		if (bsplinePairCuts[i]->GetBsp1() == bsp && bsplinePairCuts[i]->GetBsp2() == cutOtherBsp &&			bsplinePairCuts[i]->GetCv1() == cv1 && bsplinePairCuts[i]->GetCv2() == cv2 &&			bsplinePairCuts[i]->GetSg1() == sg1 && bsplinePairCuts[i]->GetSg2() == sg2)		{			alreadyCut = true;			return NULL;		}		else if (bsplinePairCuts[i]->GetBsp1() == cutOtherBsp && bsplinePairCuts[i]->GetBsp2() == bsp &&			bsplinePairCuts[i]->GetCv1() == cv2 && bsplinePairCuts[i]->GetCv2() == cv1 &&			bsplinePairCuts[i]->GetSg1() == sg2 && bsplinePairCuts[i]->GetSg2() == sg1)		{			alreadyCut = true;			return NULL;		}	}		//Test the prev cut	//Working on finding the best cut out of all the prev cuts	//BSplineToBSplineCut* bestCut = NULL;	int initSectionDepth = bsp->GetArbitraryCurveSegCenterDepth(0, 0);	BSplineToBSplineCut* testCut = new BSplineToBSplineCut(this, bsp, cutOtherBsp, cv1, sg1, cv2, sg2, initSectionDepth);	bool goodCut = TestCut(testCut, cutEndingDepth);	if (goodCut)	{		//еее		if (gDebug3)		{			double lineSegAngle = (lnPt2.h != -1) ? LineSegmentAngle(lnPt1, lnPt2) : Pi;			FloatPoint projectedLnPt1 = ProjectPointAtAngle(lnPt1, lineSegAngle + Pi, 1);			FloatPoint projectedLnPt2 = (lnPt2.h != -1) ? ProjectPointAtAngle(lnPt2, lineSegAngle, 1) : projectedLnPt1;			if (lnPt2.h == -1)				projectedLnPt2.h = 0;						PenSize(7, 7);						ForeColor(magentaColor);			MoveTo(lnPt1.h - 4, lnPt1.v - 4);			Line(0, 0);						ForeColor(blackColor);			MoveTo(lnPt2.h - 4, lnPt2.v - 4);			Line(0, 0);						PenSize(3, 3);						ForeColor(magentaColor);			MoveTo(projectedLnPt1.h - 2, projectedLnPt1.v - 2);			LineTo(projectedLnPt2.h - 2, projectedLnPt2.v - 2);						PenSize(1, 1);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int dg3 = 1;		}				return testCut;		/*		Working on finding the best cut out of all the prev cuts, NOT IMPLEMENTED YET		if (!bestCut)	//No best cut yet, so take this cut			bestCut = bspBspCut;		else if (bestCut && bestCut->GetNumIntersections() > testCut->GetNumIntersections())	//New cut is better than the previous best cut		{			bestCut->NullAllBspsAndCuts();			DeleteBSplineToBSplineCut(bestCut);						bestCut = bspBspCut;		}		else goodCut = false;	//New cut isn't good enough		*/	}	/*	Working on finding the best cut out of all the prev cuts, NOT IMPLEMENTED YET	if (!goodCut)	{		//еее		if (gDebug3)		{			ForeColor(whiteColor);			MoveTo(testCut->GetStart().h, testCut->GetStart().v);			LineTo(testCut->GetEnd().h, testCut->GetEnd().v);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int dg3 = 1;		}				//Throw away the test cut		testCut->NullAllBspsAndCuts();		DeleteBSplineToBSplineCut(testCut);	}	*/	//Remove the cut from the prevCut list	bool foundIt = false;	for (vector<PrevCut*>::iterator iter = prevCuts.begin(); iter != prevCuts.end(); iter++)		if (((*iter)->bsp1 == bsp && (*iter)->bsp2 == cutOtherBsp) ||			((*iter)->bsp2 == bsp && (*iter)->bsp1 == cutOtherBsp))		{			prevCuts.erase(iter);			foundIt = true;			break;		}	MyAssert(foundIt);		//еее	if (gDebug3)	{		ForeColor(whiteColor);		MoveTo(testCut->GetStart().h, testCut->GetStart().v);		LineTo(testCut->GetEnd().h, testCut->GetEnd().v);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int dg3 = 1;	}		//Throw away the test cut	testCut->NullAllBspsAndCuts();	DeleteBSplineToBSplineCut(testCut);		return NULL;}BSplineToBSplineCut* Drawing::AttemptToFindBetterCut(BSpline* bsp, BSplineToBSplineCut* prevCut, int& cutEndingDepth, bool mouseTerminable){	MyAssert(gAttemptToImproveCutsWithManyInters || mouseTerminable);		int newCutEndingDepth;		BSplineToBSplineCut* newCut = NULL;		if (!mouseTerminable)	{		if (!prevCut->GetBsp2())	//Infinite cut			newCut = SearchForInfiniteCut(prevCut->GetBsp1(), newCutEndingDepth, mouseTerminable);		else	//Bsp to bsp cut			newCut = SearchForBSplineToBSplineCut(prevCut->GetBsp1(), mouseTerminable);	}	else	{		//With equal likelihood, sometimes try to find an infinite cut and sometimes try to find a bsp-to-bsp cut		if (RandZeroInt(2) == 0)			newCut = SearchForInfiniteCut(prevCut->GetBsp1(), newCutEndingDepth, mouseTerminable);		else newCut = SearchForBSplineToBSplineCut(prevCut->GetBsp1(), mouseTerminable);	}		if (newCut)	{		if (newCut->GetNumIntersections() < prevCut->GetNumIntersections())	//New cut is better		{			if (!prevCut->GetBsp2())	//Infinite cut				cutEndingDepth = newCutEndingDepth;			prevCut->NullAllBspsAndCuts();			DeleteBSplineToBSplineCut(prevCut);			return newCut;		}		else	//Old cut is better		{			newCut->NullAllBspsAndCuts();			DeleteBSplineToBSplineCut(newCut);			return prevCut;		}	}		return NULL;}BSplineToBSplineCut* Drawing::SearchForInfiniteCut(BSpline* bsp, int& infiniteCutEndingDepth, bool mouseTerminable){	int cv1 = -1, cv2 = -1, sg1 = -1, sg2 = -1;	FloatPoint lnPt1(-1, -1), lnPt2(-1, -1);	//For debug only	bool foundPrev = false;		//Calculate the number of cut attempts to make	vector<vector<FloatPoint>*>* curvePoints1 = bsp->GetCurvePoints();	int bsp1TotalCurveSegs = curvePoints1->size() * BSpline::sNumSegmentsPerCurve;	int maxNumCutAttempts = sqrt(bsp1TotalCurveSegs);	BSplineToBSplineCut* bestCut = NULL;		//Loop through the cut attempts	for (int numCutAttempts = 0; numCutAttempts < maxNumCutAttempts; numCutAttempts++)	{		if (mouseTerminable && (gMouseTerminated || !TestForMouseTermination()))			return NULL;				if (numCutAttempts == 0 && !mouseTerminable)			FindFurthestLeftInfiniteBSplineCut(bsp, cv1, sg1, lnPt1);		else FindRandomBSplineToBSplineCut(bsp, NULL, cv1, cv2, sg1, sg2, lnPt1, lnPt2);		MyAssert(cv2 == -1 && sg2 == -1 && lnPt2.h == -1 && lnPt2.v == -1);					int initSectionDepth = bsp->GetArbitraryCurveSegCenterDepth(0, 0);		BSplineToBSplineCut* infiniteCut = new BSplineToBSplineCut(this, bsp, NULL, cv1, sg1, -1, -1, initSectionDepth);		bool goodCut = TestCut(infiniteCut, infiniteCutEndingDepth);		if (goodCut)		{			//еее			if (gDebug3)			{				double lineSegAngle = Pi;				FloatPoint projectedLnPt1 = ProjectPointAtAngle(lnPt1, lineSegAngle + Pi, 1);				FloatPoint projectedLnPt2 = projectedLnPt1;				projectedLnPt2.h = 0;								PenSize(7, 7);								ForeColor(magentaColor);				MoveTo(lnPt1.h - 4, lnPt1.v - 4);				Line(0, 0);								ForeColor(blackColor);				MoveTo(lnPt2.h - 4, lnPt2.v - 4);				Line(0, 0);								PenSize(3, 3);								ForeColor(blueColor);				MoveTo(projectedLnPt1.h - 1, projectedLnPt1.v - 1);				LineTo(projectedLnPt2.h - 1, projectedLnPt2.v - 1);								PenSize(1, 1);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int dg3 = 1;			}						if (!bestCut)	//No best cut yet, so take this cut				bestCut = infiniteCut;			else if (bestCut && bestCut->GetNumIntersections() > infiniteCut->GetNumIntersections())	//New cut is better than the previous best cut			{				bestCut->NullAllBspsAndCuts();				DeleteBSplineToBSplineCut(bestCut);								bestCut = infiniteCut;			}			else goodCut = false;	//New cut isn't good enough		}				if (!goodCut)		{			//еее			if (gDebug3)			{				ForeColor(whiteColor);				MoveTo(infiniteCut->GetStart().h, infiniteCut->GetStart().v);				LineTo(infiniteCut->GetEnd().h, infiniteCut->GetEnd().v);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int dg3 = 1;			}						//Throw away the test infinite cut			infiniteCut->NullAllBspsAndCuts();			DeleteBSplineToBSplineCut(infiniteCut);		}				if (bestCut && (bestCut->GetNumIntersections() == 2 || (!gAttemptToImproveCutsWithManyInters && !mouseTerminable)))	//Cut is optimal, so break out			break;	}	//End loop over cut attempts		return bestCut;}vector<BSplineToBSplineCut*> Drawing::SearchForInfiniteCuts(BSpline* bsp, bool mouseTerminable){	int cv1 = -1, cv2 = -1, sg1 = -1, sg2 = -1;	FloatPoint lnPt1(-1, -1), lnPt2(-1, -1);	//For debug only	bool foundPrev = false;		//Calculate the number of cut attempts to make	vector<vector<FloatPoint>*>* curvePoints1 = bsp->GetCurvePoints();	int bsp1TotalCurveSegs = curvePoints1->size() * BSpline::sNumSegmentsPerCurve;	int maxNumCutAttempts = sqrt(bsp1TotalCurveSegs);	vector<BSplineToBSplineCut*> bestCuts;		//Loop through the cut attempts	for (int numCutAttempts = 0; numCutAttempts < maxNumCutAttempts; numCutAttempts++)	{		if (mouseTerminable && (gMouseTerminated || !TestForMouseTermination()))		{			bestCuts.clear();			return;		}				if (numCutAttempts == 0)			FindFurthestLeftInfiniteBSplineCut(bsp, cv1, sg1, lnPt1);		else FindRandomBSplineToBSplineCut(bsp, NULL, cv1, cv2, sg1, sg2, lnPt1, lnPt2);		MyAssert(cv2 == -1 && sg2 == -1 && lnPt2.h == -1 && lnPt2.v == -1);					int initSectionDepth = bsp->GetArbitraryCurveSegCenterDepth(0, 0);		BSplineToBSplineCut* infiniteCut = new BSplineToBSplineCut(this, bsp, NULL, cv1, sg1, -1, -1, initSectionDepth);		int infiniteCutEndingDepth;	//Not used		bool goodCut = TestCut(infiniteCut, infiniteCutEndingDepth);		if (goodCut)		{			//еее			if (gDebug3)			{				double lineSegAngle = Pi;				FloatPoint projectedLnPt1 = ProjectPointAtAngle(lnPt1, lineSegAngle + Pi, 1);				FloatPoint projectedLnPt2 = projectedLnPt1;				projectedLnPt2.h = 0;								PenSize(7, 7);								ForeColor(magentaColor);				MoveTo(lnPt1.h - 4, lnPt1.v - 4);				Line(0, 0);								ForeColor(blackColor);				MoveTo(lnPt2.h - 4, lnPt2.v - 4);				Line(0, 0);								PenSize(3, 3);								ForeColor(blueColor);				MoveTo(projectedLnPt1.h - 1, projectedLnPt1.v - 1);				LineTo(projectedLnPt2.h - 1, projectedLnPt2.v - 1);								PenSize(1, 1);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int dg3 = 1;			}						//if (bestCuts.size() == 0)	//No best cut yet, so take this cut			//	bestCuts.push_back(infiniteCut);						vector<int> infiniteCutSectionDepths = *infiniteCut->GetSectionDepths();			int infiniteCutEndDepth = infiniteCutSectionDepths[infiniteCutSectionDepths.size() - 1];			bool foundMatchingDepth = false;			for (int i = 0; i < bestCuts.size(); i++)			{				vector<int> sectionDepths = *bestCuts[i]->GetSectionDepths();				if (sectionDepths[sectionDepths.size() - 1] == infiniteCutEndDepth)				{					if (bestCuts[i]->GetNumIntersections() > infiniteCut->GetNumIntersections())	//New cut is better than the previous best cut					{						bestCuts[i]->NullAllBspsAndCuts();						DeleteBSplineToBSplineCut(bestCuts[i]);												bestCuts[i] = infiniteCut;					}					else goodCut = false;	//New cut isn't good enough										foundMatchingDepth = true;					break;				}			}			if (!foundMatchingDepth)	//No best cut yet, so take this cut			{				MyAssert(goodCut);				bestCuts.push_back(infiniteCut);			}		}				if (!goodCut)		{			//еее			if (gDebug3)			{				PenSize(3, 3);								ForeColor(whiteColor);				MoveTo(infiniteCut->GetStart().h - 1, infiniteCut->GetStart().v - 1);				LineTo(infiniteCut->GetEnd().h - 1, infiniteCut->GetEnd().v - 1);								PenSize(1, 1);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int dg3 = 1;			}						//Throw away the test infinite cut			infiniteCut->NullAllBspsAndCuts();			DeleteBSplineToBSplineCut(infiniteCut);		}				//if (bestCut && bestCut->GetNumIntersections() == 2)	//Cut is optimal, so break out		//	break;	}	//End loop over cut attempts		return bestCuts;}//return true if the bsp has a cut chain connection to an infinite cutbool Drawing::ConnectedHole(BSpline* bsp, vector<BSpline*> checkedBSplines, BSplineToBSplineCut* unusableCut){	if (gDebug3)	{		PenSize(2, 2);		Point scrollOffset = {0, 0};		bsp->DrawBSpline(MainWindow::KNOT_MODE, scrollOffset, false, false, false, false, true);		PenSize(1, 1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int dg3 = 1;	}		if (bsp->GetWindingNumber() >= 0)		return true;		checkedBSplines.push_back(bsp);	vector<GenericIntersection*> inters = bsp->GetIntersections();	for (int i = 0; i < inters.size(); i++)		if (inters[i]->GetType() == GenericIntersection::BSP_CUT_T)		{			BSplineToBSplineCut* cut = ((BspCutTIntersection*)inters[i])->GetCut();			if (cut == unusableCut)				continue;						if (gDebug3)			{				FloatPoint startPt = cut->GetStart(), endPt = cut->GetEnd();								PenSize(7, 7);								ForeColor(magentaColor);				MoveTo(startPt.h - 4, startPt.v - 4);				Line(0, 0);								ForeColor(blackColor);				MoveTo(endPt.h - 4, endPt.v - 4);				Line(0, 0);								PenSize(2, 2);								(!cut->GetBsp2()) ? ForeColor(greenColor) : ForeColor(redColor);				MoveTo(startPt.h - 1, startPt.v - 1);				LineTo(endPt.h - 1, endPt.v - 1);								PenSize(1, 1);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int dg3 = 1;			}						if (!cut->GetBsp2())				return true;	//This cut connects the hole bsp to an infinite solid						if (find(checkedBSplines.begin(), checkedBSplines.end(), cut->GetBsp2()) == checkedBSplines.end() &&				ConnectedHole(cut->GetBsp2(), checkedBSplines, unusableCut))				return true;	//This cut connects the hole bsp to a solid bsp		}		if (gDebug3)	{		PenSize(4, 4);		Point scrollOffset = {0, 0};		bsp->DrawBSpline(MainWindow::KNOT_MODE, scrollOffset, false, false, false, false, true);		PenSize(1, 1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int dg3 = 1;	}		return false;}BSplineToBSplineCut* Drawing::SearchForBSplineToBSplineCut(BSpline* bsp, bool mouseTerminable, WholeObject* cutToWholeObject, BSplineToBSplineCut* skipCut){	int cv1, cv2, sg1, sg2;	FloatPoint lnPt1, lnPt2;	//For debug only	bool foundPrev = false;		BSplineToBSplineCut* bestCut = NULL;	bool objectAlreadyGrouped = false;		//еее	debug only	WholeObject* wholeObject = NULL;	MyAssert(FindOrCreateWholeObjectForBSpline(bsp, wholeObject));		for (double maxNumCutAttemptsScaler = 1.0 / 32.0; maxNumCutAttemptsScaler <= 1.0; maxNumCutAttemptsScaler *= 2.0)	{		//Loop over the bsplines		for (int i = 0; i < bsplines.size(); i++)		{			if (mouseTerminable && (gMouseTerminated || !TestForMouseTermination()))				return NULL;						if (bsp == bsplines[i])	//Skip self-checks instantly, the test doesn't even make sense in such a case				continue;						//It is sometimes necessary to group ungrouped holes, but I am not sure if the correct solution is to comment out this code.			//It is possible that this code was doing something important and that commenting it out will cause bugs somewhere else.			//An alternative solution would be to leave this code uncommented and wrap the group search in a loop that doesn't end until			//all test bsplines have been grouped.						if (bsplines[i]->GetWindingNumber() < 0)	//Skip ungrouped holes			{				/*				WholeObject* testWholeObject = NULL;				for (int k = 0; k < wholeObjects.size(); k++)					if (find(wholeObjects[k]->bsplines.begin(), wholeObjects[k]->bsplines.end(), bsplines[i]) != wholeObjects[k]->bsplines.end())					{						testWholeObject = wholeObjects[k];						break;					}				MyAssert(testWholeObject && testWholeObject->bsplines.size() > 0);				if (testWholeObject->bgDepths.size() == 0)	//The hole is ungrouped, so skip it					continue;				*/								//gDebug3 = true;				vector<BSpline*> checkedBSplines;				if (!ConnectedHole(bsplines[i], checkedBSplines, NULL))				{					//gDebug3 = false;					continue;				}				//gDebug3 = false;			}						//Don't attempt to group solids to solids			if (bsp->GetWindingNumber() > 0 && bsplines[i]->GetWindingNumber() > 0)				continue;						if (!bsplines[i]->GetAllIntersectionsLegal())	//Don't check illegal BSplines				continue;						if (bsplines[i]->GetNumControlPoints() < 3)	//Skip incomplete BSplines				continue;						//Don't attempt to cut to a bspline that this bspline is already connected to by a cut			bool alreadyCut = false;			for (int j = 0; j < bsplinePairCuts.size(); j++)			{				if (bsplinePairCuts[j] == skipCut)					continue;								if ((bsplinePairCuts[j]->GetBsp1() == bsp && bsplinePairCuts[j]->GetBsp2() == bsplines[i]) ||					(bsplinePairCuts[j]->GetBsp1() == bsplines[i] && bsplinePairCuts[j]->GetBsp2() == bsp))				{					alreadyCut = true;					break;				}			}			if (alreadyCut)				continue;						//Get the other bspline's whole object			WholeObject* wholeObject2 = NULL;			MyAssert(FindOrCreateWholeObjectForBSpline(bsplines[i], wholeObject2));			if (!cutToWholeObject && wholeObject == wholeObject2)	//These two objects are already grouped, we can stop looking for a cut (there should already be one found by the other object)			{				objectAlreadyGrouped = true;				break;			}						//If there is a limiting wholeobject, limit the acceptable bsplines to that wholeobject			if (cutToWholeObject && wholeObject2 != cutToWholeObject)				continue;						//Calculate how many cut attempts to make			vector<vector<FloatPoint>*>* curvePoints1 = bsp->GetCurvePoints();			int bsp1TotalCurveSegs = curvePoints1->size() * BSpline::sNumSegmentsPerCurve;						vector<vector<FloatPoint>*>* curvePoints2 = bsplines[i]->GetCurvePoints();			int bsp2TotalCurveSegs = curvePoints2->size() * BSpline::sNumSegmentsPerCurve;						int maxNumCutAttempts = sqrt(bsp1TotalCurveSegs * bsp2TotalCurveSegs) * maxNumCutAttemptsScaler;	//Scales with the product						//Loop over the cut attempts			int numCutAttempts = 0;			for (numCutAttempts = 0; numCutAttempts < maxNumCutAttempts; numCutAttempts++)			{				if (mouseTerminable && (gMouseTerminated || !TestForMouseTermination()))					return NULL;								FindRandomBSplineToBSplineCut(bsp, bsplines[i], cv1, cv2, sg1, sg2, lnPt1, lnPt2);								int cutEndingDepthNotUsed;	//Not really used here, only used in the infinite boundary test								int initSectionDepth = bsp->GetArbitraryCurveSegCenterDepth(cv1, sg1);				BSplineToBSplineCut* bspBspCut = new BSplineToBSplineCut(this, bsp, bsplines[i], cv1, sg1, cv2, sg2, initSectionDepth);				bool goodCut = TestCut(bspBspCut, cutEndingDepthNotUsed);				if (goodCut)	//Cut is acceptable, but is it the best possible cut?  Check this here.				{					//еее					if (gDebug3)					{						double lineSegAngle = LineSegmentAngle(lnPt1, lnPt2);						FloatPoint projectedLnPt1 = ProjectPointAtAngle(lnPt1, lineSegAngle + Pi, 1);						FloatPoint projectedLnPt2 = ProjectPointAtAngle(lnPt2, lineSegAngle, 1);												PenSize(7, 7);												ForeColor(magentaColor);						MoveTo(lnPt1.h - 4, lnPt1.v - 4);						Line(0, 0);												ForeColor(blackColor);						MoveTo(lnPt2.h - 4, lnPt2.v - 4);						Line(0, 0);												PenSize(3, 3);												ForeColor(cyanColor);						MoveTo(projectedLnPt1.h - 2, projectedLnPt1.v - 2);						LineTo(projectedLnPt2.h - 2, projectedLnPt2.v - 2);												PenSize(1, 1);												QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int dg3 = 1;					}										//Make sure the ends of the new cut are legal					vector<int> cutDepths = *bspBspCut->GetSectionDepths();					int bsp1Depth = bsp->GetArbitraryCurveSegCenterDepth(cv1, sg1);					MyAssert(bsp1Depth == cutDepths[0]);					int bsp2Depth = bsplines[i]->GetArbitraryCurveSegCenterDepth(cv2, sg2);					MyAssert(bsp2Depth == cutDepths[cutDepths.size() - 1]);										if (!bestCut)	//No best cut yet, so take this cut						bestCut = bspBspCut;					else if (bestCut && bestCut->GetNumIntersections() > bspBspCut->GetNumIntersections())	//New cut is better than the previous best cut					{						bestCut->NullAllBspsAndCuts();						DeleteBSplineToBSplineCut(bestCut);												bestCut = bspBspCut;					}					else goodCut = false;	//New cut isn't good enough				}	//End processing of possibly good cut								if (!goodCut)	//Cut test failed or cut wasn't good enough				{					//еее					if (gDebug3)					{						ForeColor(whiteColor);						MoveTo(bspBspCut->GetStart().h, bspBspCut->GetStart().v);						LineTo(bspBspCut->GetEnd().h, bspBspCut->GetEnd().v);												QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);												int dg3 = 1;					}										bspBspCut->NullAllBspsAndCuts();					DeleteBSplineToBSplineCut(bspBspCut);				}	//End removal of bad cut								VerifyPrevCuts();								if (bestCut && (bestCut->GetNumIntersections() == 2 || (!gAttemptToImproveCutsWithManyInters && !mouseTerminable)))	//A better cut is impossible, so break out					break;			}	//End loop over cut attempts						if (bestCut && (bestCut->GetNumIntersections() == 2 || (!gAttemptToImproveCutsWithManyInters && !mouseTerminable)))	//A better cut is impossible, so break out				break;		}	//End loop over bsplines				if (objectAlreadyGrouped)			break;				if (bestCut && (bestCut->GetNumIntersections() == 2 || (!gAttemptToImproveCutsWithManyInters && !mouseTerminable)))	//A better cut is impossible, so break out			break;	}	//end loop over maxNumCutAttemptsScaler		//еее	This is just a bunch of MyAsserts	if (bestCut)	//A cut was found, so save it	{		//Make sure the ends of the new cut are legal		vector<int> cutDepths = *bestCut->GetSectionDepths();		MyAssert(bestCut->GetBsp1() == bsp);		int bsp1Depth = bsp->GetArbitraryCurveSegCenterDepth(bestCut->GetCv1(), bestCut->GetSg1());		MyAssert(bsp1Depth == cutDepths[0]);		int bsp2Depth = bestCut->GetBsp2()->GetArbitraryCurveSegCenterDepth(bestCut->GetCv2(), bestCut->GetSg2());		MyAssert(bsp2Depth == cutDepths[cutDepths.size() - 1]);				//The cut worked.  The hole and solid are part of the same surface.  Add the hole to the solid's object, if necessary.		//can't do this without first saving the cut                   bestCut->GetAllIntersectionsLegal(true);	}	//End condition on finding bestCut		return bestCut;}//Find one cut per holebool Drawing::FindWholeObjects2(vector<BSpline*> testBSplines, bool dontGroupIllegalBSplines, bool refindCompanionSets, Drawing* backup){	//еее	SetPort(GetWindowPort(gMainWindow->GetWindow()));		//gDebug3 = true;	if (gDebug3)	{		Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		gMainWindow->DrawGrid();				PenSize(1, 1);		Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);				PenSize(2, 2);		for (int i = 0; i < testBSplines.size(); i++)			testBSplines[i]->DrawBSpline(MainWindow::KNOT_MODE, scrollOffset, false, false, false, false, true);		PenSize(1, 1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int dg3 = 1;	}		PrepareToFindWholeObjects(testBSplines, dontGroupIllegalBSplines, (backup != NULL));		if (gDebug3)	{		Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		gMainWindow->DrawGrid();				PenSize(1, 1);		Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int dg3 = 1;	}		//Loop through the test bplines, finding a whole object for each one	int numCuts = 0;	do	{		numCuts = bsplinePairCuts.size();		for (int i = 0; i < testBSplines.size(); i++)		{			if (gMouseTerminated || !TestForMouseTermination())				return false;						if (gDebug3)			{				PenSize(1, 1);				Point scrollOffset = {0, 0};				vector<BSpline*> workingBSplines;				DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);								PenSize(2, 2);				testBSplines[i]->DrawBSpline(MainWindow::KNOT_MODE, scrollOffset, false, false, false, false, true);				PenSize(1, 1);								QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);								int dg3 = 1;			}						BSpline* testBSpline = testBSplines[i];	//еее						WholeObject* wholeObject = NULL;			MyAssert(FindOrCreateWholeObjectForBSpline(testBSplines[i], wholeObject));						if (dontGroupIllegalBSplines)				MyAssert(testBSplines[i]->GetNumControlPoints() >= 3 && testBSplines[i]->GetAllIntersectionsLegal());						//if (testBSplines[i]->GetWindingNumber() > 0)	//Skip solids			//	continue;						//First, retrieve a saved cut for this bspline if one exists.			//We'll try that one first before starting to search randomly for new potential cuts.			int cutEndingDepth;			bool alreadyCut = false;			BSplineToBSplineCut* prevCut = CreateCutFromPrevCut(testBSplines[i], cutEndingDepth, alreadyCut);			if (alreadyCut)				continue;			if (prevCut)			{				//MyAssert(prevCut->GetBsp2());				MyAssert(prevCut->GetNumIntersections() >= 2);								BSplineToBSplineCut* bestCut = prevCut;				if (prevCut->GetNumIntersections() > 2 && (gAttemptToImproveCutsWithManyInters || backup))					bestCut = AttemptToFindBetterCut(testBSplines[i], prevCut, cutEndingDepth, (backup != NULL));	//Try to improve on the prev cut since it isn't optimal								if (!bestCut)					bestCut = prevCut;								GroupBSplineAndSaveBSplineToBSplineCut(testBSplines[i], bestCut, cutEndingDepth);								if (!bestCut->GetBsp2())				{					BspCutTIntersection* infBspCutTInter = (BspCutTIntersection*)(bestCut->GetLastIntersection());					MyAssert(!infBspCutTInter->GetBsp());										WholeObject* oldWO = infBspCutTInter->GetInfiniteWholeObject();					if (oldWO)						RemoveWholeObjectBspCutTInter(oldWO, infBspCutTInter);										WholeObject* wholeObject2c = FindWholeObjectForBSpline(testBSplines[i]);					//MyAssert(wholeObject2c == wholeObject);	//This fails without causing trouble.  Is it a valid assert?					infBspCutTInter->SetInfiniteWholeObject(wholeObject2c);										for (int j = 0; j < wholeObject2c->bspCutTinters.size(); j++)						MyAssert(!wholeObject2c->bspCutTinters[j]->GetDtored());										if (find(wholeObject2c->bspCutTinters.begin(), wholeObject2c->bspCutTinters.end(), infBspCutTInter) == wholeObject2c->bspCutTinters.end())						wholeObject2c->bspCutTinters.push_back(infBspCutTInter);				}								FindOrCreateWholeObjectForBSpline(testBSplines[i], wholeObject);	//еее				bestCut->GetAllIntersectionsLegal(true);								if (backup)				{					*backup = *this;					//gMainWindow->Redraw();					//QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				}								continue;	//Whether or not the prev cut could be improved, don't bother looking for entirely new cuts to new objects that differ from the prev cut			}						//Getting here means there was no prev cut						//Second, look for an infinite cut and a bspBsp cut for this bspline			bool useMultipleInfiniteCuts = false;			BSplineToBSplineCut* infiniteCut = NULL;			vector<BSplineToBSplineCut*> infiniteCuts;			if (testBSplines[i]->GetWindingNumber() <= 0)	//Skip solids)			{				if (!useMultipleInfiniteCuts)					infiniteCut = SearchForInfiniteCut(testBSplines[i], cutEndingDepth, (backup != NULL));				else infiniteCuts = SearchForInfiniteCuts(testBSplines[i], (backup != NULL));			}						BSplineToBSplineCut* bspBspCut = NULL;			if (!useMultipleInfiniteCuts)				if (!infiniteCut || infiniteCut->GetNumIntersections() > 2)	//Check for a bspBsp cut					bspBspCut = SearchForBSplineToBSplineCut(testBSplines[i], (backup != NULL));			if (useMultipleInfiniteCuts)				if (infiniteCuts.size() == 0)// || infiniteCut->GetNumIntersections() > 2)	//Check for a bspBsp cut					bspBspCut = SearchForBSplineToBSplineCut(testBSplines[i], (backup != NULL));						//Take the best of the infinite or bspBsp cut			bool takeInfiniteCut = true;			if (!useMultipleInfiniteCuts)				if (!infiniteCut)					takeInfiniteCut = false;				else if (infiniteCut && bspBspCut && bspBspCut->GetNumIntersections() < infiniteCut->GetNumIntersections())					takeInfiniteCut = false;			if (useMultipleInfiniteCuts)				if (infiniteCuts.size() == 0)					takeInfiniteCut = false;						if (takeInfiniteCut)			{				if (bspBspCut)				{					bspBspCut->NullAllBspsAndCuts();					DeleteBSplineToBSplineCut(bspBspCut);	//delete bspBspCut;				}				/*				if (useMultipleInfiniteCuts)				{					MyAssert(!infiniteCut);					int minDepth = 999999;					for (int j = 0; j < infiniteCuts.size(); j++)					{						vector<int> sectionDepths = *infiniteCuts[j]->GetSectionDepths();						int endDepth = sectionDepths[sectionDepths.size() - 1];						if (endDepth < minDepth)						{							infiniteCut = infiniteCuts[j];							minDepth = endDepth;						}					}					MyAssert(infiniteCut);				}								GroupBSplineAndSaveBSplineToBSplineCut(testBSplines[i], infiniteCut, cutEndingDepth);								FindOrCreateWholeObjectForBSpline(testBSplines[i], wholeObject);	//еее				infiniteCut->GetAllIntersectionsLegal(true);				*/								if (!useMultipleInfiniteCuts)				{					GroupBSplineAndSaveBSplineToBSplineCut(testBSplines[i], infiniteCut, cutEndingDepth);										BspCutTIntersection* infBspCutTInter = (BspCutTIntersection*)(infiniteCut->GetLastIntersection());										WholeObject* oldWO = infBspCutTInter->GetInfiniteWholeObject();					if (oldWO)						RemoveWholeObjectBspCutTInter(oldWO, infBspCutTInter);										WholeObject* wholeObject2a = FindWholeObjectForBSpline(testBSplines[i]);					infBspCutTInter->SetInfiniteWholeObject(wholeObject2a);										for (int j = 0; j < wholeObject2a->bspCutTinters.size(); j++)						MyAssert(!wholeObject2a->bspCutTinters[j]->GetDtored());										if (find(wholeObject2a->bspCutTinters.begin(), wholeObject2a->bspCutTinters.end(), infBspCutTInter) == wholeObject2a->bspCutTinters.end())						wholeObject2a->bspCutTinters.push_back(infBspCutTInter);										//FindOrCreateWholeObjectForBSpline(testBSplines[i], wholeObject2a);	//еее					infiniteCut->GetAllIntersectionsLegal(true);										if (backup)					{						*backup = *this;						//gMainWindow->Redraw();						//QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);					}				}				if (useMultipleInfiniteCuts)				{					for (int j = 0; j < infiniteCuts.size(); j++)					{						vector<int> sectionDepths = *infiniteCuts[j]->GetSectionDepths();						cutEndingDepth = sectionDepths[sectionDepths.size() - 1];						GroupBSplineAndSaveBSplineToBSplineCut(testBSplines[i], infiniteCuts[j], cutEndingDepth);												BspCutTIntersection* infBspCutTInter = (BspCutTIntersection*)(infiniteCuts[j]->GetLastIntersection());												WholeObject* oldWO = infBspCutTInter->GetInfiniteWholeObject();						if (oldWO)							RemoveWholeObjectBspCutTInter(oldWO, infBspCutTInter);												WholeObject* wholeObject2b = FindWholeObjectForBSpline(testBSplines[i]);						infBspCutTInter->SetInfiniteWholeObject(wholeObject2b);												for (int j = 0; j < wholeObject2b->bspCutTinters.size(); j++)							MyAssert(!wholeObject2b->bspCutTinters[j]->GetDtored());												if (find(wholeObject2b->bspCutTinters.begin(), wholeObject2b->bspCutTinters.end(), infBspCutTInter) == wholeObject2b->bspCutTinters.end())							wholeObject2b->bspCutTinters.push_back(infBspCutTInter);												//FindOrCreateWholeObjectForBSpline(testBSplines[i], wholeObject2b);	//еее						infiniteCuts[j]->GetAllIntersectionsLegal(true);												if (backup)						{							*backup = *this;							//gMainWindow->Redraw();							//QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						}					}				}							}			else if (!takeInfiniteCut && bspBspCut)			{				if (!useMultipleInfiniteCuts)					if (infiniteCut)					{						infiniteCut->NullAllBspsAndCuts();						DeleteBSplineToBSplineCut(infiniteCut);	//delete infiniteCut;					}				if (useMultipleInfiniteCuts)					for (int j = 0; j < infiniteCuts.size(); j++)					{						infiniteCuts[j]->NullAllBspsAndCuts();						DeleteBSplineToBSplineCut(infiniteCuts[j]);	//delete infiniteCuts[j];					}								GroupBSplineAndSaveBSplineToBSplineCut(testBSplines[i], bspBspCut, -1);				bspBspCut->GetAllIntersectionsLegal(true);							//FindOrCreateWholeObjectForBSpline(testBSplines[i], wholeObject);	//еее			}		}	} while (numCuts != bsplinePairCuts.size());		VerifyWholeObjects();	for (int i = 0; i < bsplinePairCuts.size(); i++)		bsplinePairCuts[i]->VerifyBackupsMatchPresent();		//Sort the infinite whole object bspTinters	SortWholeObjectInfiniteInters();		//еее	//ConnectDisconnectedComponents();		//============================================================================================================		//Make a list of every intersection associated with a newly formed group, then find companion sets for those intersections		//I keep waffling on whether or not to find companion sets on the labeled, whole objected drawing.	//Comp sets should already have been found on the unlabeled drawing prior to labeling, so it doesn't	//seem necessary.  The catch is that after labeling and whole objecting, the whole object relationships	//might have changed.  As a result, comp sets might change.  Therefore, it would seem necessary to find	//comp sets all over again each time the whole object relationships change.	//	//Even if this is done, there are two algorithms for doing it.  The algorithm for finding comp sets on	//unlabeled drawings should work perfectly well on labeled drawings.  So in effect, the algorithm for	//finding comp sets on labeled drawings seems superfluous.  However, it is older, more thoroughly	//tested, and possibly more stable than the algorithm for unlabeled drawings.  In addition, it is	//localized to touched intersections, whereas the algorithm for unlabeled drawings is global at the 	//present time (060219).  This would argue in favor of using the older algorithm instead.	//	//But I keep commenting and uncommenting the entire approach, regardless of which method is used.	//Sometimes it seems necessary, but other times it seems slow, and possibly even subject to error,	//thus I comment it out.	//	//I haven't made a final decision about this yet.		if (gDebug3)		for (int i = 0; i < interCompanionSets.size(); i++)			if (interCompanionSets[i]->size() > 0)			{				SetPort(GetWindowPort(gMainWindow->GetWindow()));								Rect r;				GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);				EraseRect(&r);				gMainWindow->DrawGrid();								Point scrollOffset = {0, 0};				vector<BSpline*> workingBSplines;				DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);								PenSize(2, 2);				ForeColor(blueColor);				for (int j = 0; j < interCompanionSets[i]->size(); j++)				{					FloatPoint loc = (*interCompanionSets[i])[j]->GetLocation();					SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);					FrameOval(&r);				}				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int dg3 = 1;								ForeColor(whiteColor);				for (int j = 0; j < interCompanionSets[i]->size(); j++)				{					FloatPoint loc = (*interCompanionSets[i])[j]->GetLocation();					SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);					FrameOval(&r);				}				PenSize(1, 1);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			}		if (gCompanionSetMethod != 0 && refindCompanionSets)	{		vector<GenericIntersection*> intersToComp;		bool legalLabeling = true;		bool useMethodOne = false;				if (useMethodOne)		{			//I can't figure out why this method is coded so complicatedly.  The "method two" in the "else" clause seems better			for (int i = 0; i < testBSplines.size(); i++)			{				if (gDebug3)				{					Point scrollOffset = {0, 0};					vector<BSpline*> workingBSplines;					DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);					QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int dg3 = 1;				}								//Get the intersections on bsplines in the group				vector<BSpline*> groupBSplines;				GetBSplinesInGroupFromBSpline(testBSplines[i], groupBSplines);								for (int j = 0; j < groupBSplines.size(); j++)					MyAssert(groupBSplines[j]->GetAllIntersectionsLegal(true));								for (int j = 0; j < groupBSplines.size(); j++)				{					vector<GenericIntersection*> bspInters = groupBSplines[j]->GetIntersections();					for (int k = 0; k < bspInters.size(); k++)						if (bspInters[k]->GetType() == GenericIntersection::BSP_BSP)						{							if (!((BspBspIntersection*)bspInters[k])->GetBsp1()->GetAllIntersectionsLegal(false))								legalLabeling = false;							if (!((BspBspIntersection*)bspInters[k])->GetBsp2()->GetAllIntersectionsLegal(false))								legalLabeling = false;							if (find(intersToComp.begin(), intersToComp.end(), bspInters[k]) == intersToComp.end())								intersToComp.push_back(bspInters[k]);						}						else if (bspInters[k]->GetType() == GenericIntersection::BSP_CUT)						{							if (!((BspCutIntersection*)bspInters[k])->GetBsp()->GetAllIntersectionsLegal(false))								legalLabeling = false;							if (!((BspCutIntersection*)bspInters[k])->GetCut()->GetAllIntersectionsLegal(false))								legalLabeling = false;							if (find(intersToComp.begin(), intersToComp.end(), bspInters[k]) == intersToComp.end())								intersToComp.push_back(bspInters[k]);						}				}								//Get the intersections on cuts in the group				for (int j = 0; j < bsplinePairCuts.size(); j++)					if (find(groupBSplines.begin(), groupBSplines.end(), bsplinePairCuts[j]->GetBsp1()) != groupBSplines.end() ||						find(groupBSplines.begin(), groupBSplines.end(), bsplinePairCuts[j]->GetBsp2()) != groupBSplines.end())					{						MyAssert(bsplinePairCuts[j]->GetAllIntersectionsLegal(true));												vector<GenericIntersection*> cutInters = bsplinePairCuts[j]->GetIntersections();						for (int k = 0; k < cutInters.size(); k++)							if (cutInters[k]->GetType() == GenericIntersection::BSP_CUT)							{								if (!((BspCutIntersection*)cutInters[k])->GetBsp()->GetAllIntersectionsLegal(false))									legalLabeling = false;								if (!((BspCutIntersection*)cutInters[k])->GetCut()->GetAllIntersectionsLegal(false))									legalLabeling = false;								if (find(intersToComp.begin(), intersToComp.end(), cutInters[k]) == intersToComp.end())									intersToComp.push_back(cutInters[k]);							}					}			}		}		else	//!useMethodOne		{			for (int i = 0; i < testBSplines.size(); i++)				if (!testBSplines[i]->GetAllIntersectionsLegal(false))				{					legalLabeling = false;					break;				}				else				{					//This is going to comp every intersection on the bsplines.					//Actually, we might need to only recomp the intersections that were just flipped.					//Actually, if we just did a flip, and everything went well and stayed legal, we shouldn't have to recomp at all!!!  Dammit!					//The problem is, recomping (recompanion setting) can take a while, and this slows down the response time to simple interactions like flips.					vector<GenericIntersection*> bspInters = testBSplines[i]->GetIntersections();					for (int j = 0; j < bspInters.size(); j++)						if (find(intersToComp.begin(), intersToComp.end(), bspInters[j]) == intersToComp.end())							intersToComp.push_back(bspInters[j]);				}		}				if (legalLabeling)		{			if (gDebug3)			{				SetPort(GetWindowPort(gMainWindow->GetWindow()));								Rect r;				GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);				EraseRect(&r);				//gMainWindow->DrawGrid();								Point scrollOffset = {0, 0};				vector<BSpline*> workingBSplines;				DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);								ForeColor(redColor);				PenSize(2, 2);				for (int i = 0; i < intersToComp.size(); i++)				{					FloatPoint loc = intersToComp[i]->GetLocation();					SetRect(&r, loc.h - 8, loc.v - 8, loc.h + 8, loc.v + 8);					FrameRect(&r);				}				PenSize(1, 1);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int dg3 = 1;								GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);				EraseRect(&r);				//gMainWindow->DrawGrid();								DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);			}						FindInterCompSetsForInters(intersToComp);	//We want to use this method.  HOWEVER, it has a bug, it doesn't turn into cuts.  This needs to be fixed.			//FindInterCompSetsForUnlabeledDrawing();	//We really don't want to use this, but the other comp set method has a bug.  It only traverses bsplines, where as it needs to traverse surfaces, turning in and out of cuts.		}	}		//Ugh, I think this is necessary to get the cuts to reestablish their maximum possible section depths	FindBSplineSectionMaxPossibleDepthsV4();		VerifyWholeObjects();	for (int i = 0; i < bsplinePairCuts.size(); i++)		bsplinePairCuts[i]->VerifyBackupsMatchPresent();		if (gDebug3)		for (int i = 0; i < interCompanionSets.size(); i++)			if (interCompanionSets[i]->size() > 0)			{				SetPort(GetWindowPort(gMainWindow->GetWindow()));								Rect r;				GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);				EraseRect(&r);				//gMainWindow->DrawGrid();								Point scrollOffset = {0, 0};				vector<BSpline*> workingBSplines;				DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);								PenSize(2, 2);				ForeColor(greenColor);				for (int j = 0; j < interCompanionSets[i]->size(); j++)				{					FloatPoint loc = (*interCompanionSets[i])[j]->GetLocation();					SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);					FrameOval(&r);				}				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int dg3 = 1;								ForeColor(whiteColor);				for (int j = 0; j < interCompanionSets[i]->size(); j++)				{					FloatPoint loc = (*interCompanionSets[i])[j]->GetLocation();					SetRect(&r, loc.h - 10, loc.v - 10, loc.h + 10, loc.v + 10);					FrameOval(&r);				}				PenSize(1, 1);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);			}	//gDebug3 = false;}void Drawing::AttemptToFindBetterCuts(){	if (gDebug5)	{		WriteSearchParameters();		InitAnalysisWindow();				IncrementTextV();		MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pSeeking better cuts");				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);		SetPort(GetWindowPort(gMainWindow->GetWindow()));	}	clock_t startTime = clock();		//gDebug3 = true;	if (gDebug3)	{		Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		gMainWindow->DrawGrid();				PenSize(1, 1);		Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);				int dg3 = 1;	}		gMouseTerminated = false;	while (Button());	mouseDownAtStartOfAttempt = Button();	SetPort(GetWindowPort(gMainWindow->GetWindow()));	GetMouse(&mouseLocAtStartOfAttempt);	mouseSensitive = false;		VerifyWholeObjects();	for (int i = 0; i < bsplinePairCuts.size(); i++)		bsplinePairCuts[i]->VerifyBackupsMatchPresent();		//Drawing* backup = new Drawing(*this);		//Make a list of hole bsplines connected by suboptimal cuts (cuts with intersections on them)	//At the same time, make a list of troublesome cuts	vector<pair<BSpline*, BSplineToBSplineCut*> > fixBSplines;	vector<BSpline*> dontFixBSplines;	for (int i = 0; i < bsplinePairCuts.size(); i++)	{		BSplineToBSplineCut* cut = bsplinePairCuts[i];	//debug		cut->VerifyBackupsMatchPresent();				MyAssert(bsplinePairCuts[i]->GetNumIntersections() >= 2);				BSpline* bsp1 = bsplinePairCuts[i]->GetBsp1();		BSpline* bsp2 = bsplinePairCuts[i]->GetBsp2();				vector<BSpline*> checkedBSplines;		bool bsp1connected = ConnectedHole(bsp1, checkedBSplines, bsplinePairCuts[i]);		bool bsp2connected = bsp2 ? ConnectedHole(bsp2, checkedBSplines, bsplinePairCuts[i]) : true;		//MyAssert((bsp1connected && !bsp2connected) || (bsp2connected && !bsp1connected));	//In the case of two zero winding numbers (figure-eight), both will be connected.				if (bsp2)	//Not an infinite cut		{			//Holes connected by clean (2 inters) cuts to a solid don't get fixed			if (bsplinePairCuts[i]->GetNumIntersections() == 2)	//Optimal cut, mark its hole to not be fixed if it is a hole-solid cut			{/*				if (bsp1->GetWindingNumber() <= 0 && bsp2->GetWindingNumber() > 0)				{					if (find(dontFixBSplines.begin(), dontFixBSplines.end(), bsp1) == dontFixBSplines.end())						dontFixBSplines.push_back(bsp1);				}				else if (bsp2->GetWindingNumber() <= 0 && bsp1->GetWindingNumber() > 0)				{					if (find(dontFixBSplines.begin(), dontFixBSplines.end(), bsp2) == dontFixBSplines.end())						dontFixBSplines.push_back(bsp2);				}			*/}			else	//Suboptimal cut, so add its hole to the fix list			{				int cnt = 0;	//debug				if ((bsp1->GetWindingNumber() < 0 && !bsp1connected) || bsp1->GetWindingNumber() == 0)				{					bool foundIt = false;					for (int j = 0; j < fixBSplines.size(); j++)						if (fixBSplines[j].first == bsp1)						{							foundIt = true;							break;						}					if (!foundIt)					{						fixBSplines.push_back(pair<BSpline*, BSplineToBSplineCut*>(bsp1, bsplinePairCuts[i]));						cnt++;					}				}								if ((bsp2->GetWindingNumber() < 0 && !bsp2connected))//Only accept zeros at the start end of the cut || bsp2->GetWindingNumber() == 0)				{					bool foundIt = false;					for (int j = 0; j < fixBSplines.size(); j++)						if (fixBSplines[j].first == bsp2)						{							foundIt = true;							break;						}					if (!foundIt)					{						if (cnt == 0)							fixBSplines.push_back(pair<BSpline*, BSplineToBSplineCut*>(bsp2, bsplinePairCuts[i]));						else fixBSplines.push_back(pair<BSpline*, BSplineToBSplineCut*>(bsp2, NULL));						cnt++;					}				}			}		}		else	//Infinite cut		{			MyAssert(bsp1->GetWindingNumber() <= 0);						//Holes connected by clean (2 inters) cuts to a solid don't get fixed			if (bsplinePairCuts[i]->GetNumIntersections() == 2)	//Optimal cut, mark its hole to not be fixed			{				if (find(dontFixBSplines.begin(), dontFixBSplines.end(), bsp1) == dontFixBSplines.end())					dontFixBSplines.push_back(bsp1);			}			else	//Suboptimal cut, so add its hole to the fix list			{				bool foundIt = false;				//if (!bsp1connected)				{					for (int j = 0; j < fixBSplines.size(); j++)						if (fixBSplines[j].first == bsp1)						{							foundIt = true;							break;						}					if (!foundIt)						fixBSplines.push_back(pair<BSpline*, BSplineToBSplineCut*>(bsp1, bsplinePairCuts[i]));				}			}		}	}		//Remove dontFixBSplines from fixBSplines	for (int i = 0; i < dontFixBSplines.size(); i++)	{		vector<pair<BSpline*, BSplineToBSplineCut*> >::iterator iter;		for (iter = fixBSplines.begin(); iter != fixBSplines.end(); iter++)			if ((*iter).first == dontFixBSplines[i])			{				fixBSplines.erase(iter);				break;			}	}		if (gDebug3)	{		Rect r;		GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &r);		EraseRect(&r);		gMainWindow->DrawGrid();				PenSize(1, 1);		Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);				PenSize(2, 2);		for (int i = 0; i < fixBSplines.size(); i++)			fixBSplines[i].first->DrawBSpline(MainWindow::KNOT_MODE, scrollOffset, false, false, false, false, true);		PenSize(1, 1);				for (int i = 0; i < fixBSplines.size(); i++)		{			FloatPoint startPt = fixBSplines[i].second->GetStart(), endPt = fixBSplines[i].second->GetEnd();						PenSize(7, 7);						ForeColor(magentaColor);			MoveTo(startPt.h - 4, startPt.v - 4);			Line(0, 0);						ForeColor(blackColor);			MoveTo(endPt.h - 4, endPt.v - 4);			Line(0, 0);						PenSize(3, 3);						ForeColor(redColor);			MoveTo(startPt.h - 2, startPt.v - 2);			LineTo(endPt.h - 2, endPt.v - 2);						PenSize(1, 1);		}				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int dg3 = 1;	}		//Delete the cuts	/*	for (int i = 0; i < deleteCuts.size(); i++)	{		BSpline *bsp1 = deleteCuts[i]->GetBsp1(), *bsp2 = deleteCuts[i]->GetBsp2();		WholeObject* wholeObject1 = FindWholeObjectForBSpline(bsp1);		WholeObject* wholeObject2 = FindWholeObjectForBSpline(bsp2);		MyAssert(wholeObject2 == wholeObject1 || !wholeObject2);				RemoveCut(deleteCuts[i], false);				WholeObject* wholeObject1a = FindWholeObjectForBSpline(bsp1);		WholeObject* wholeObject2a = FindWholeObjectForBSpline(bsp2);		MyAssert(wholeObject1 == wholeObject1a && wholeObject2 == wholeObject2a);	}	*/	if (fixBSplines.size() == 0)		SysBeep(1);		vector<BSplineToBSplineCut*> newCuts;	for (int ii = 0; ii < fixBSplines.size(); ii++)	{		MyAssert(!fixBSplines[ii].first->dtored);		MyAssert(!fixBSplines[ii].second || !fixBSplines[ii].second->dtored);				//==================================================================================================================		//vector<BSpline*> fixOneBSplines;		//fixOneBSplines.push_back(fixBSplines[ii].first);		//if (!FindWholeObjects2(fixOneBSplines, true, false, backup))		//	*this = *backup;		//==================================================================================================================				//With equal likelihood, sometimes try to find an infinite cut and sometimes try to find a bsp-to-bsp cut		if (RandZeroInt(2) == 0)		{			int cutEndingDepth;			BSplineToBSplineCut* infiniteCut = SearchForInfiniteCut(fixBSplines[ii].first, cutEndingDepth, true);			if (infiniteCut)			{				if (gDebug3)				{					switch (ii % 7)					{						case 0:	ForeColor(redColor);	break;						case 1:	ForeColor(greenColor);	break;						case 2:	ForeColor(blueColor);	break;						case 3:	ForeColor(yellowColor);	break;						case 4:	ForeColor(magentaColor);	break;						case 5:	ForeColor(cyanColor);	break;						case 6:	ForeColor(blackColor);	break;					}										FloatPoint startPt, endPt;					if (fixBSplines[ii].second)					{						startPt = fixBSplines[ii].second->GetStart(), endPt = fixBSplines[ii].second->GetEnd();						PenSize(4, 4);						MoveTo(startPt.h - 1, startPt.v - 1);						LineTo(endPt.h - 1, endPt.v - 1);					}										startPt = infiniteCut->GetStart();					endPt = infiniteCut->GetEnd();					PenSize(2, 2);					MoveTo(startPt.h - 1, startPt.v - 1);					LineTo(endPt.h - 1, endPt.v - 1);										PenSize(1, 1);										QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int dg3 = 1;				}								//Remove the cut from the prevCut list				if (fixBSplines[ii].second)				{					bool foundIt = false;					for (vector<PrevCut*>::iterator iter = prevCuts.begin(); iter != prevCuts.end(); iter++)						if (((*iter)->bsp1 == fixBSplines[ii].second->GetBsp1() && (*iter)->bsp2 == fixBSplines[ii].second->GetBsp2()) ||							((*iter)->bsp2 == fixBSplines[ii].second->GetBsp2() && (*iter)->bsp1 == fixBSplines[ii].second->GetBsp1()))						{							prevCuts.erase(iter);							foundIt = true;							break;						}					MyAssert(foundIt);										RemoveCut(fixBSplines[ii].second, false);				}								GroupBSplineAndSaveBSplineToBSplineCut(fixBSplines[ii].first, infiniteCut, cutEndingDepth);								BspCutTIntersection* infBspCutTInter = (BspCutTIntersection*)(infiniteCut->GetLastIntersection());								WholeObject* oldWO = infBspCutTInter->GetInfiniteWholeObject();				if (oldWO)					RemoveWholeObjectBspCutTInter(oldWO, infBspCutTInter);								WholeObject* wholeObject2a = FindWholeObjectForBSpline(fixBSplines[ii].first);				infBspCutTInter->SetInfiniteWholeObject(wholeObject2a);								for (int j = 0; j < wholeObject2a->bspCutTinters.size(); j++)					MyAssert(!wholeObject2a->bspCutTinters[j]->GetDtored());								if (find(wholeObject2a->bspCutTinters.begin(), wholeObject2a->bspCutTinters.end(), infBspCutTInter) == wholeObject2a->bspCutTinters.end())					wholeObject2a->bspCutTinters.push_back(infBspCutTInter);								infiniteCut->GetAllIntersectionsLegal(true);								//*backup = *this;								newCuts.push_back(infiniteCut);			}		}		else	//Try to find a bsp-to-bsp cut (as opposed to an infinite cut)		{			BSplineToBSplineCut* newCut = SearchForBSplineToBSplineCut(fixBSplines[ii].first, true, FindWholeObjectForBSpline(fixBSplines[ii].first), fixBSplines[ii].second);			if (newCut)			{				if (gDebug3)				{					switch (ii % 7)					{						case 0:	ForeColor(redColor);	break;						case 1:	ForeColor(greenColor);	break;						case 2:	ForeColor(blueColor);	break;						case 3:	ForeColor(yellowColor);	break;						case 4:	ForeColor(magentaColor);	break;						case 5:	ForeColor(cyanColor);	break;						case 6:	ForeColor(blackColor);	break;					}										FloatPoint startPt, endPt;					if (fixBSplines[ii].second)					{						startPt = fixBSplines[ii].second->GetStart(), endPt = fixBSplines[ii].second->GetEnd();						PenSize(4, 4);						MoveTo(startPt.h - 1, startPt.v - 1);						LineTo(endPt.h - 1, endPt.v - 1);					}										startPt = newCut->GetStart();					endPt = newCut->GetEnd();					PenSize(2, 2);					MoveTo(startPt.h - 1, startPt.v - 1);					LineTo(endPt.h - 1, endPt.v - 1);										PenSize(1, 1);										QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);										int dg3 = 1;				}								//Remove the cut from the prevCut list				if (fixBSplines[ii].second)				{					bool foundIt = false;					for (vector<PrevCut*>::iterator iter = prevCuts.begin(); iter != prevCuts.end(); iter++)						if (((*iter)->bsp1 == fixBSplines[ii].second->GetBsp1() && (*iter)->bsp2 == fixBSplines[ii].second->GetBsp2()) ||							((*iter)->bsp2 == fixBSplines[ii].second->GetBsp2() && (*iter)->bsp1 == fixBSplines[ii].second->GetBsp1()))						{							prevCuts.erase(iter);							foundIt = true;							break;						}					MyAssert(foundIt);										RemoveCut(fixBSplines[ii].second, false);				}								GroupBSplineAndSaveBSplineToBSplineCut(fixBSplines[ii].first, newCut, -1);				newCut->GetAllIntersectionsLegal(true);								//*backup = *this;								newCuts.push_back(newCut);			}			VerifyWholeObjects();			for (int i = 0; i < bsplinePairCuts.size(); i++)				bsplinePairCuts[i]->VerifyBackupsMatchPresent();		}				if (gMouseTerminated || !TestForMouseTermination())			break;	}		VerifyPrevCuts();		if (gDebug3)	{		for (int i = 0; i < newCuts.size(); i++)		{			FloatPoint startPt = newCuts[i]->GetStart(), endPt = newCuts[i]->GetEnd();						PenSize(7, 7);						ForeColor(magentaColor);			MoveTo(startPt.h - 4, startPt.v - 4);			Line(0, 0);						ForeColor(blackColor);			MoveTo(endPt.h - 4, endPt.v - 4);			Line(0, 0);						PenSize(3, 3);						ForeColor(greenColor);			MoveTo(startPt.h - 1, startPt.v - 1);			LineTo(endPt.h - 1, endPt.v - 1);						PenSize(1, 1);		}				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int dg3 = 1;	}		//delete backup;		FindInterCompSetsForBrandNewInters();	ClearBrandNewIntersections();	VerifyWholeObjects();	for (int i = 0; i < bsplinePairCuts.size(); i++)		bsplinePairCuts[i]->VerifyBackupsMatchPresent();		clock_t timeUsed = clock() - startTime;	if (gDebug5)	{		InitAnalysisWindow();				Str255 str1;				IncrementTextV();		MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pCuts suboptimal , fixed: ");		NumToString(fixBSplines.size(), str1);		DrawString(str1);		DrawString("\p , ");		NumToString(newCuts.size(), str1);		DrawString(str1);				MoveTo(5, IncrementTextV() * 10 + 5);		DrawString("\pSeconds used: ");				long double timeUsedSecs = timeUsed / CLOCKS_PER_SEC;		FloatToPascal(timeUsedSecs, 3, str1);		DrawString(str1);				QDFlushPortBuffer(GetWindowPort(gAnalysisWindow), NULL);				int dg3 = 1;	}}void Drawing::SortWholeObjectInfiniteInters(WholeObject* wholeObject){	if (!wholeObject)	//Sort all whole objects' infinite inters	{		for (int i = 0; i < wholeObjects.size(); i++)		{			wholeObject = wholeObjects[i];						for (int j = 0; j < wholeObject->bspCutTinters.size(); j++)			{				MyAssert(!wholeObject->bspCutTinters[j]->GetDtored());				MyAssert(wholeObject->bspCutTinters[j]->GetInfiniteWholeObject() == wholeObject);			}							sort(wholeObject->bspCutTinters.begin(), wholeObject->bspCutTinters.end(), less<BspCutTIntersection*>());						for (int j = 0; j < wholeObject->bspCutTinters.size(); j++)			{				MyAssert(!wholeObject->bspCutTinters[j]->GetDtored());				wholeObject->bspCutTinters[j]->SetInfiniteWOsection(j);			}		}	}	else	//Only sort the infinite inters for the whole object passed into this function	{		for (int j = 0; j < wholeObject->bspCutTinters.size(); j++)		{			MyAssert(!wholeObject->bspCutTinters[j]->GetDtored());			MyAssert(wholeObject->bspCutTinters[j]->GetInfiniteWholeObject() == wholeObject);		}					sort(wholeObject->bspCutTinters.begin(), wholeObject->bspCutTinters.end(), less<BspCutTIntersection*>());				for (int j = 0; j < wholeObject->bspCutTinters.size(); j++)		{			MyAssert(!wholeObject->bspCutTinters[j]->GetDtored());			wholeObject->bspCutTinters[j]->SetInfiniteWOsection(j);		}	}}#pragma mark -BSplineToBSplineCut* Drawing::CreateCutFromPrevCut(BSpline* bsp1, BSpline* bsp2, int& cutEndingDepth){	int cv1, cv2, sg1, sg2;	FloatPoint lnPt1, lnPt2;	//For debug only	bool foundPrev = false;		double lineSegAngle = LineSegmentAngle(lnPt1, lnPt2);	//Extend the ends a tad bit	FloatPoint projectedLnPt1 = ProjectPointAtAngle(lnPt1, lineSegAngle + Pi, lineSegmentProjectSlop);	FloatPoint projectedLnPt2 = ProjectPointAtAngle(lnPt2, lineSegAngle, lineSegmentProjectSlop);		BSpline* cutOtherBsp = NULL;	if (!FindPreviousBSplineToSpecificBSplineCut(bsp1, bsp2, cv1, cv2, sg1, sg2, lnPt1, lnPt2))		return NULL;	//Prev cut was not found		//Test the prev cut	int initSectionDepth = bsp1->GetArbitraryCurveSegCenterDepth(cv1, sg1);	BSplineToBSplineCut* testCut = new BSplineToBSplineCut(this, bsp1, bsp2, cv1, sg1, cv2, sg2, initSectionDepth);	vector<CutIntersection> cutDistInters;	bool success;	cutDistInters = FindCutIntersections(testCut, lineSegAngle, projectedLnPt1, projectedLnPt2, success);	MyAssert(success);	if (cutDistInters.size() == 2)	//A pseudocut can only have the two end intersections	{		//еее		if (gDebug11)		{			double lineSegAngle = (lnPt2.h != -1) ? LineSegmentAngle(lnPt1, lnPt2) : Pi;			FloatPoint projectedLnPt1 = ProjectPointAtAngle(lnPt1, lineSegAngle + Pi, 1);			FloatPoint projectedLnPt2 = (lnPt2.h != -1) ? ProjectPointAtAngle(lnPt2, lineSegAngle, 1) : projectedLnPt1;			if (lnPt2.h == -1)				projectedLnPt2.h = 0;						PenSize(7, 7);						ForeColor(magentaColor);			MoveTo(lnPt1.h - 4, lnPt1.v - 4);			Line(0, 0);						ForeColor(blackColor);			MoveTo(lnPt2.h - 4, lnPt2.v - 4);			Line(0, 0);						PenSize(3, 3);						ForeColor(yellowColor);			MoveTo(projectedLnPt1.h - 2, projectedLnPt1.v - 2);			LineTo(projectedLnPt2.h - 2, projectedLnPt2.v - 2);						PenSize(1, 1);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int dg11 = 1;		}				return testCut;	}		//еее	if (gDebug11)	{		ForeColor(whiteColor);		MoveTo(testCut->GetStart().h, testCut->GetStart().v);		LineTo(testCut->GetEnd().h, testCut->GetEnd().v);				QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int dg11 = 1;	}		//Throw away the test cut	testCut->NullAllBspsAndCuts();	DeleteBSplineToBSplineCut(testCut);		return NULL;}bool Drawing::AttemptToConnectComponents(vector<BSpline*>& component1, vector<BSpline*>& component2, double maxNumCutAttemptsScaler){	MyAssert(&component1 != &component2);		BSpline *bsp1, *bsp2;	int cv1, cv2, sg1, sg2;	FloatPoint lnPt1, lnPt2;		//First, retrieve a saved cut if one exists.	//We'll try that one first before starting to search randomly for new potential cuts.	for (int i = 0; i < component1.size(); i++)		for (int j = 0; j < component2.size(); j++)		{			bsp1 = component1[i];			bsp2 = component2[j];						int cutEndingDepth;			BSplineToBSplineCut* prevCut = CreateCutFromPrevCut(bsp1, bsp2, cutEndingDepth);						if (prevCut)	//A pseudocut can only have the two end intersections				MyAssert(prevCut->GetNumIntersections() == 2);						if (prevCut)			{				SaveBSplineToBSplineCut(prevCut);								for (int i = 0; i < component2.size(); i++)					component1.push_back(component2[i]);								return true;			}		}			//Randomly pick pairs of bplines, one from each component, and pairs of segments, one from each bspline,	//and test them for a pseudocut with no intersections.  Do this several times in an attempt to connect the components.		//Calculate how many cut attempts to make	int component1TotalCurveSegs = 0;	for (int i = 0; i < component1.size(); i++)	{		vector<vector<FloatPoint>*>* curvePoints = component1[i]->GetCurvePoints();		component1TotalCurveSegs += curvePoints->size() * BSpline::sNumSegmentsPerCurve;	}		int component2TotalCurveSegs = 0;	for (int i = 0; i < component2.size(); i++)	{		vector<vector<FloatPoint>*>* curvePoints = component2[i]->GetCurvePoints();		component2TotalCurveSegs += curvePoints->size() * BSpline::sNumSegmentsPerCurve;	}		int maxNumCutAttempts = sqrt(component1TotalCurveSegs * component2TotalCurveSegs) * maxNumCutAttemptsScaler;	//Scales with the product		//Loop over the cut attempts	int numCutAttempts = 0;	for (numCutAttempts = 0; numCutAttempts < maxNumCutAttempts; numCutAttempts++)	{		bsp1 = component1[RandZeroInt(component1.size())];		bsp2 = component2[RandZeroInt(component2.size())];				FindRandomBSplineToBSplineCut(bsp1, bsp2, cv1, cv2, sg1, sg2, lnPt1, lnPt2);				double lineSegAngle = LineSegmentAngle(lnPt1, lnPt2);		//Extend the ends a tad bit		FloatPoint projectedLnPt1 = ProjectPointAtAngle(lnPt1, lineSegAngle + Pi, lineSegmentProjectSlop);		FloatPoint projectedLnPt2 = ProjectPointAtAngle(lnPt2, lineSegAngle, lineSegmentProjectSlop);				//еее		if (gDebug11)		{			PenSize(7, 7);						ForeColor(magentaColor);			MoveTo(lnPt1.h - 4, lnPt1.v - 4);			Line(0, 0);						ForeColor(blackColor);			MoveTo(lnPt2.h - 4, lnPt2.v - 4);			Line(0, 0);						PenSize(3, 3);						ForeColor(yellowColor);			MoveTo(projectedLnPt1.h - 2, projectedLnPt1.v - 2);			LineTo(projectedLnPt2.h - 2, projectedLnPt2.v - 2);						PenSize(1, 1);						QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);						int dg11 = 1;		}				//Make a list of all the intersections along the line segment and then sort them in order along the segment		int initSectionDepth = bsp1->GetArbitraryCurveSegCenterDepth(cv1, sg1);		BSplineToBSplineCut* testCut = new BSplineToBSplineCut(this, bsp1, bsp2, cv1, sg1, cv2, sg2, initSectionDepth);		bool success;		vector<CutIntersection> cutDistInters;		cutDistInters = FindCutIntersections(testCut, lineSegAngle, projectedLnPt1, projectedLnPt2, success);		if (success && testCut->GetNumIntersections() == 2)	//A pseudocut can only have the two end intersections		{			SaveBSplineToBSplineCut(testCut);						for (int i = 0; i < component2.size(); i++)				component1.push_back(component2[i]);						return true;		}	}		return false;}void Drawing::IdentifyConnectedComponents(list<vector<BSpline*> >& connectedComponents){	for (int i = 0; i < bsplines.size(); i++)	{		BSpline* bsp = bsplines[i];				//Determine if the bspline is already in a connected component		bool alreadyInAComponent = false;		for (list<vector<BSpline*> >::iterator j = connectedComponents.begin(); j != connectedComponents.end(); j++)		{			if (find((*j).begin(), (*j).end(), bsp) != (*j).end())			{				alreadyInAComponent = true;				break;			}						if (alreadyInAComponent)				break;		}		if (alreadyInAComponent)			continue;				//Getting here means the bspline isn't part of a connected component yet				//Start a new connected component		vector<BSpline*> connectedComponent;				//Start by adding the bspline's entire whole object to the next connected component		WholeObject* wholeObject = FindWholeObjectForBSpline(bsp);		for (int j = 0; j < wholeObject->bsplines.size(); j++)			connectedComponent.push_back(wholeObject->bsplines[j]);				//Next, start cycling through the connected component adding all intersecting bsplines until the cycle ends		bool foundANewOne = true;		while (foundANewOne)		{			foundANewOne = false;			for (int j = 0; j < connectedComponent.size(); j++)			{				bsp = connectedComponent[j];								//Get every bspline that intersects this bspline and add it to the connected component				vector<GenericIntersection*> bspInters = bsp->GetIntersections();				for (int k = 0; k < bspInters.size(); k++)				{					switch (bspInters[k]->GetType())					{						case GenericIntersection::BSP_BSP:							BSpline* crossBsp = ((BspBspIntersection*)bspInters[k])->GetOtherBsp(bsp);							if (find(connectedComponent.begin(), connectedComponent.end(), crossBsp) == connectedComponent.end())							{								connectedComponent.push_back(crossBsp);								foundANewOne = true;							}							break;						case GenericIntersection::BSP_CUT:							//Don't do anything here, these don't count...I guess.  Should these count?							break;						case GenericIntersection::BSP_CUT_T:							//By definition, the BSpline at the other end of the cut is in the same wholeobject anyway, so it was already added							BSplineToBSplineCut* cut = ((BspCutTIntersection*)bspInters[k])->GetCut();							BSpline* otherEndBsp = (cut->GetBsp1() == bsp) ? cut->GetBsp2() : cut->GetBsp1();							MyAssert(find(connectedComponent.begin(), connectedComponent.end(), otherEndBsp) != connectedComponent.end());							break;						case GenericIntersection::CUT_CUT:							MyAssert(false);							//Should these count?  I kinda doubt it.							break;					}				}			}		}				//Add the new connected component		connectedComponents.push_back(connectedComponent);	}}void Drawing::ConnectDisconnectedComponents(){	if (gDebug11)	{		PenSize(1, 1);		Point scrollOffset = {0, 0};		vector<BSpline*> workingBSplines;		DrawDrawing(MainWindow::KNOT_MODE, scrollOffset, scrollOffset, workingBSplines, NULL, -1);		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);				int dg11 = 1;	}		//Identify the distinct connected components	list<vector<BSpline*> > connectedComponents;	IdentifyConnectedComponents(connectedComponents);	MyAssert(connectedComponents.size() >= 1);		//Won't do anything if there is only one connected component to begin with	while (connectedComponents.size() > 1)	{		//Steadily increase the number of attempts to make between each pair of components		for (double maxNumCutAttemptsScaler = 1.0 / 32.0; maxNumCutAttemptsScaler <= 1.0; maxNumCutAttemptsScaler *= 2.0)		{			//Find a component that can be connected to the first component with a pseudocut with no intersections on the pseudocut						//Init the iterator to the second item in the list			list<vector<BSpline*> >::iterator connectedComponentsIter = connectedComponents.begin();			connectedComponentsIter++;			for (; connectedComponentsIter != connectedComponents.end(); connectedComponentsIter++)				if (AttemptToConnectComponents(*(connectedComponents.begin()), *connectedComponentsIter, maxNumCutAttemptsScaler))				{					connectedComponents.erase(connectedComponentsIter);					break;				}						if (connectedComponentsIter != connectedComponents.end())				break;	//This pair of components just became connected, so start over with the next pair		}	}}/*void Drawing::CreateConnectedComponentDAG(){	//Identify the distinct connected components	list<vector<BSpline*> > connectedComponents;	IdentifyConnectedComponents(connectedComponents);	MyAssert(connectedComponents.size() >= 1);		//Compare every component to every other component and determine an inside/outside relationship between them	for (int i = 0; i < connectedComponents.size(); i++)		for (int j = 0; j < connectedComponents.size(); j++)			if (i != j)			{			}}*/