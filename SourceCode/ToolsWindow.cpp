#include "ToolsWindow.h"#include "MainWindow.h"#include "BSpline.h"#include "GenericIntersection.h"#include "BspCutTIntersection.h"#include "Drawing.h"#include "TextGenerator.h"#include "PascalStringUtil.h"#include <vector.h>//******************************************************************************//Extern Globalsextern WindowPtr gHelpTagWindow, gToolHelpWindow;extern MainWindow *gMainWindow;extern Drawing *gDrawing;extern TextGenerator *gTextGenerator;//******************************************************************************//Global Declarations//******************************************************************************//Function Prototypes	//	In external files		//	main.cppvoid MyAssert(bool condition);void RedrawToolHelpWindow();#pragma mark -ToolsWindow::ToolsWindow(int windowRsrcId) : window(NULL), toolType(SUPER_SPLINE), lastToolType(SUPER_SPLINE), toolHelpVisible(false){	for (int i = 0; i < 24; i++)	{		int picResourceId = i + 128;		PicHandle picH = GetPicture(picResourceId);		MyAssert(picH);		picHs.push_back(picH);	}		//window = GetNewCWindow(windowRsrcId, NULL, NULL);	IBNibRef theNib;	OSStatus err = CreateNibReference(CFSTR("main"), &theNib);	CreateWindowFromNib(theNib, CFSTR("ToolPaletteWindow"), &window);		//Keep things on the screen as much as possible	CGrafPtr presentPort; 	GDHandle presentDevice;	GetGWorld(&presentPort, &presentDevice);	Rect screenBounds;	GetAvailableWindowPositioningBounds(presentDevice, &screenBounds);		Rect windowBounds;	GetPortBounds(GetWindowPort(window), &windowBounds);	SetPort(GetWindowPort(window));	Point pt;	pt.h = 0;	pt.v = 0;	LocalToGlobal(&pt);	if (pt.h > screenBounds.right - windowBounds.right)		pt.h = screenBounds.right - windowBounds.right;	if (pt.v > screenBounds.bottom - windowBounds.bottom)		pt.v = screenBounds.bottom - windowBounds.bottom;	if (pt.h < screenBounds.left)		pt.h = screenBounds.left;	if (pt.v < screenBounds.top)		pt.v = screenBounds.top;	MoveWindow(window, pt.h, pt.v, false);		ShowWindow(window);}ToolsWindow::~ToolsWindow(){	for (int i = 0; i < picHs.size(); i++)		KillPicture(picHs[i]);		DisposeWindow(window);}#pragma mark -WindowRef ToolsWindow::GetWindow(){	return window;}ToolsWindow::ToolType ToolsWindow::GetToolType(){	return toolType;}#pragma mark -void ToolsWindow::Redraw(){	int w = 25, h = 23;	SizeWindow(window, w * 2 + 1, h * 6 + 1, true);		SetPort(GetWindowPort(window));	Rect r;	GetPortBounds(GetWindowPort(window), &r);		RGBColor gray;	gray.red = gray.green = gray.blue = 65535 * .86;	RGBForeColor(&gray);	//PaintRect(&r);		DrawControls(window);		PicHandle picH;	SetRect(&r, 0, 0, 24, 22);		//I think the following would be used to read image files in the Resources directory of the bundle.  However, I don't know how to draw quartz images in a window.	/*	CGImageRef CreateImageFromPNG(CFStringRef inFileName) 	{ 		CGImageRef theRef = NULL; 		CFBundleRef theBundle = ::CFBundleGetMainBundle(); 		if (theBundle != NULL)		{ 			 CFURLRef theURL = ::CFBundleCopyResourceURL(theBundle, inFileName, CFSTR("png"), NULL); 			 if (theURL != NULL)			 { 					CGDataProviderRef theProvider = ::CGDataProviderCreateWithURL(theURL); 					if (theProvider != NULL)					{ 						 theRef = ::CGImageCreateWithPNGDataProvider(theProvider, NULL, true, kCGRenderingIntentDefault); 						 ::CFRelease(theProvider); 					} 					::CFRelease(theURL); 			 } 		} 		return theRef; 	}	*/	if (toolType == SUPER_SPLINE)		picH = picHs[129 - 128];//GetPicture(129);	else picH = picHs[128 - 128];//GetPicture(128);	OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 0 + 1, h * 0 + 1);	DrawPicture(picH, &r);		if (toolType == NEW_SPLINE)		picH = picHs[131 - 128];//GetPicture(131);	else picH = picHs[130 - 128];//GetPicture(130);	OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 1 + 1, h * 0 + 1);	DrawPicture(picH, &r);		if (toolType == CHANGE_CONTROL_POINT)		picH = picHs[133 - 128];//GetPicture(133);	else picH = picHs[132 - 128];//GetPicture(132);	OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 0 + 1, h * 1 + 1);	DrawPicture(picH, &r);		if (toolType == ADD_CONTROL_POINT)		picH = picHs[135 - 128];//GetPicture(135);	else picH = picHs[134 - 128];//GetPicture(134);	OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 1 + 1, h * 1 + 1);	DrawPicture(picH, &r);		if (toolType == REMOVE_CONTROL_POINT)		picH = picHs[137 - 128];//GetPicture(137);	else picH = picHs[136 - 128];//GetPicture(136);	OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 0 + 1, h * 2 + 1);	DrawPicture(picH, &r);		if (toolType == CHANGE_DEGREE)		picH = picHs[139 - 128];//GetPicture(139);	else picH = picHs[138 - 128];//GetPicture(138);	OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 1 + 1, h * 2 + 1);	DrawPicture(picH, &r);		if (toolType == SURFACE_SELECT)		picH = picHs[149 - 128];//GetPicture(149);	else picH = picHs[148 - 128];//GetPicture(148);	OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 0 + 1, h * 3 + 1);	DrawPicture(picH, &r);		if (toolType == HAND)		picH = picHs[141 - 128];//GetPicture(141);	else picH = picHs[140 - 128];//GetPicture(140);	OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 1 + 1, h * 3 + 1);	DrawPicture(picH, &r);		if (toolType == TEXT)		picH = picHs[151 - 128];//GetPicture(151);	else picH = picHs[150 - 128];//GetPicture(150);	OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 0 + 1, h * 4 + 1);	DrawPicture(picH, &r);		if (toolType == INCREASE_SEG_NUM)		picH = picHs[145 - 128];//GetPicture(145);	else picH = picHs[144 - 128];//GetPicture(144);	OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 0 + 1, h * 5 + 1);	DrawPicture(picH, &r);		if (toolType == DECREASE_SEG_NUM)		picH = picHs[147 - 128];//GetPicture(147);	else picH = picHs[146 - 128];//GetPicture(146);	OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 1 + 1, h * 5 + 1);	DrawPicture(picH, &r);}#pragma mark -void ToolsWindow::HandleToolSelection(Point where, bool mouseDown){	if (!mouseDown)	{		if (toolType == INCREASE_SEG_NUM || toolType == DECREASE_SEG_NUM)		{			toolType = lastToolType;						Redraw();			RedrawToolHelpWindow();		}		return;	}		lastToolType = toolType;		SetThemeCursor(kThemeArrowCursor);		SetPort(GetWindowPort(window));		GlobalToLocal(&where);		Rect r;	SetRect(&r, 0, 0, 24, 22);	int w = 25, h = 23;		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 0 + 1, h * 0 + 1);	if (PtInRect(where, &r))		toolType = SUPER_SPLINE;		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 1 + 1, h * 0 + 1);	if (PtInRect(where, &r))		toolType = NEW_SPLINE;		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 0 + 1, h * 1 + 1);	if (PtInRect(where, &r))		toolType = CHANGE_CONTROL_POINT;		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 1 + 1, h * 1 + 1);	if (PtInRect(where, &r))		toolType = ADD_CONTROL_POINT;		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 0 + 1, h * 2 + 1);	if (PtInRect(where, &r))		toolType = REMOVE_CONTROL_POINT;		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 1 + 1, h * 2 + 1);	if (PtInRect(where, &r))		toolType = CHANGE_DEGREE;		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 0 + 1, h * 3 + 1);	if (PtInRect(where, &r))		toolType = SURFACE_SELECT;		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 1 + 1, h * 3 + 1);	if (PtInRect(where, &r))	{		toolType = HAND;		SetThemeCursor(kThemeOpenHandCursor);	}		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 0 + 1, h * 4 + 1);	if (PtInRect(where, &r))	{		ToolType oldTool = toolType;		toolType = TEXT;				Redraw();		QDFlushPortBuffer(GetWindowPort(window), NULL);		RedrawToolHelpWindow();		QDFlushPortBuffer(GetWindowPort(gToolHelpWindow), NULL);				gTextGenerator->RunDialog();				toolType = oldTool;	}		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 0 + 1, h * 5 + 1);	if (PtInRect(where, &r))	{		if (BSpline::sNumSegmentsPerCurve < 64)		{			toolType = INCREASE_SEG_NUM;			BSpline::sNumSegmentsPerCurve *= 2;			HandleNumSegsChange(true);		}		else SysBeep(1);	}		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 1 + 1, h * 5 + 1);	if (PtInRect(where, &r))	{		if (BSpline::sNumSegmentsPerCurve > 1)		{			toolType = DECREASE_SEG_NUM;			BSpline::sNumSegmentsPerCurve /= 2;			HandleNumSegsChange(false);		}		else SysBeep(1);	}		gMainWindow->DeselectAll();		Redraw();	RedrawToolHelpWindow();}void ToolsWindow::HandleSpaceBarDown(){	lastToolType = toolType;	toolType = HAND;	SetThemeCursor(kThemeOpenHandCursor);	Redraw();	RedrawToolHelpWindow();}void ToolsWindow::HandleSpaceBarUp(){	toolType = lastToolType;	SetThemeCursor(kThemeArrowCursor);	Redraw();	RedrawToolHelpWindow();}void ToolsWindow::HandleNumSegsChange(bool numIncreased){	gMainWindow->SetWorkingSplineNULL();		//gDrawing->DeleteAllIntersections();		gDrawing->ReallocateCurvePoints();		// Is this true?	gDrawing->VerifyBackupsMatchPresent();		//gDrawing->CleanUpIntersections();		if (numIncreased)		gDrawing->DoubleAllBspCutTInterSegs();	else gDrawing->HalveAllBspCutTInterSegs();		vector<BSpline*> bsplines = gDrawing->GetBSplines();	for (int i = 0; i < bsplines.size(); i++)		gDrawing->RemoveAndRefindIntersections(bsplines[i]);		vector<GenericIntersection*> intersections = gDrawing->GetIntersections();	for (int i = 0; i < intersections.size(); i++)		if (intersections[i]->GetType() == GenericIntersection::BSP_CUT_T)		{			((BspCutTIntersection*)intersections[i])->RecalcStartEndLocs();			((BspCutTIntersection*)intersections[i])->SetLocToCutStartOrEndLoc();			((BspCutTIntersection*)intersections[i])->RecalcEdgeDirection();		}		// Is this true?	gDrawing->VerifyBackupsMatchPresent();		gDrawing->CreateLegalLabeling(bsplines, false);		gMainWindow->Redraw();}		void ToolsWindow::SetToolType(ToolType tt){	toolType = tt;		if (toolType == HAND)		SetThemeCursor(kThemeOpenHandCursor);	else SetThemeCursor(kThemeArrowCursor);		Redraw();	RedrawToolHelpWindow();}void ToolsWindow::HandleMouseMoved(Point where){	if (!IsWindowVisible(window))		return;		SetPort(GetWindowPort(window));	GlobalToLocal(&where);		Point helpTagLoc = { -1, -1 };	Str255 helpTagStr;		Rect r;	SetRect(&r, 0, 0, 24, 22);	int w = 25, h = 23;		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 0 + 1, h * 0 + 1);	if (PtInRect(where, &r))	{		helpTagLoc.h = r.left;		helpTagLoc.v = r.top;		CtoPascal("Super Spline", helpTagStr);	}		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 1 + 1, h * 0 + 1);	if (PtInRect(where, &r))	{		helpTagLoc.h = r.left;		helpTagLoc.v = r.top;		CtoPascal("New Spline", helpTagStr);	}		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 0 + 1, h * 1 + 1);	if (PtInRect(where, &r))	{		helpTagLoc.h = r.left;		helpTagLoc.v = r.top;		CtoPascal("Move Control Point", helpTagStr);	}		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 1 + 1, h * 1 + 1);	if (PtInRect(where, &r))	{		helpTagLoc.h = r.left;		helpTagLoc.v = r.top;		CtoPascal("Add Control Point", helpTagStr);	}		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 0 + 1, h * 2 + 1);	if (PtInRect(where, &r))	{		helpTagLoc.h = r.left;		helpTagLoc.v = r.top;		CtoPascal("Delete Control Point", helpTagStr);	}		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 1 + 1, h * 2 + 1);	if (PtInRect(where, &r))	{		helpTagLoc.h = r.left;		helpTagLoc.v = r.top;		CtoPascal("Change Spline Degree", helpTagStr);	}		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 0 + 1, h * 3 + 1);	if (PtInRect(where, &r))	{		helpTagLoc.h = r.left;		helpTagLoc.v = r.top;		CtoPascal("Surface Selector", helpTagStr);	}		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 1 + 1, h * 3 + 1);	if (PtInRect(where, &r))	{		helpTagLoc.h = r.left;		helpTagLoc.v = r.top;		CtoPascal("Hand", helpTagStr);	}		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 0 + 1, h * 4 + 1);	if (PtInRect(where, &r))	{		helpTagLoc.h = r.left;		helpTagLoc.v = r.top;		CtoPascal("Text", helpTagStr);	}		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 0 + 1, h * 5 + 1);	if (PtInRect(where, &r))	{		helpTagLoc.h = r.left;		helpTagLoc.v = r.top;		CtoPascal("Increase Spline Segmentation", helpTagStr);	}		OffsetRect(&r, -r.left, -r.top);	OffsetRect(&r, w * 1 + 1, h * 5 + 1);	if (PtInRect(where, &r))	{		helpTagLoc.h = r.left;		helpTagLoc.v = r.top;		CtoPascal("Decrease Spline Segmentation", helpTagStr);	}		if (helpTagLoc.h != -1)	{		helpTagLoc.h += 10;		helpTagLoc.v += 25;		LocalToGlobal(&helpTagLoc);		SetPort(GetWindowPort(gHelpTagWindow));				SizeWindow(gHelpTagWindow, StringWidth(helpTagStr) + 10, 20, true);				Rect bounds;		GetPortBounds(GetWindowPort(gHelpTagWindow), &bounds);		RGBColor lightYellow;		lightYellow.red = lightYellow.green = 65535;		lightYellow.blue = 37000;		RGBForeColor(&lightYellow);				PaintRect(&bounds);				ForeColor(blackColor);		TextSize(9);		MoveTo(5, 15);		DrawString(helpTagStr);				MoveWindow(gHelpTagWindow, helpTagLoc.h, helpTagLoc.v, false);		ShowWindow(gHelpTagWindow);				toolHelpVisible = true;	}	else if (toolHelpVisible)	{		HideWindow(gHelpTagWindow);		toolHelpVisible = false;	}}