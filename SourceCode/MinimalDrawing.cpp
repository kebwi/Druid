#include "MinimalDrawing.h"#include "Drawing.h"#include "BSpline.h"#include "BSplineToBSplineCut.h"#include "GenericIntersection.h"#include "BspBspIntersection.h"#include "BspCutIntersection.h"#include "BspCutTIntersection.h"#include <iostream.h>//******************************************************************************//Extern Globalsextern bool gDebug;//******************************************************************************//Global Declarations//******************************************************************************//Function Prototypes	//	In external files		//	main.cppvoid MyAssert(bool condition);MinimalDrawing::MinimalDrawing(Drawing* drawing) :	numBSplinesAndCuts(0), intersections(NULL), sections(NULL){	TransferFromDrawing(drawing);}MinimalDrawing::~MinimalDrawing(){	if (numBSplinesAndCuts > 0)	{		MyAssert(intersections && sections);		for (int i = 0; i < numBSplinesAndCuts; i++)		{			delete [] intersections[i];			delete [] sections[i];		}				delete [] intersections;		delete [] sections;	}}		void MinimalDrawing::TransferFromDrawing(Drawing* drawing){	//Get the total number of BSplines and Cuts	numBSplines = drawing->GetNumBSplines();	numBSplinesAndCuts = drawing->GetNumBSplines() + drawing->GetNumCuts();	if (numBSplinesAndCuts == 0)		return;	MyAssert(numBSplinesAndCuts < 256);	//Needs to fit into a byte.  This can easily be expanded in the future.		//Make the first level arrays	intersections = new unsigned long*[numBSplinesAndCuts];	sections = new unsigned char*[numBSplinesAndCuts];		intersectionsV.resize(numBSplinesAndCuts);	sectionsV.resize(numBSplinesAndCuts);		vector<BSpline*> bsplines = drawing->GetBSplines();	vector<BSplineToBSplineCut*> cuts = drawing->GetCuts();	MyAssert(bsplines.size() + cuts.size() == numBSplinesAndCuts);		//Copy the drawing into the minimal drawing		//Loop through the bsplines, collecting their intersection info	for (int i = 0; i < bsplines.size(); i++)	{		//Get the BSpline's number of intersections		int numBspInters = bsplines[i]->GetNumIntersections();				//Make the arrays to store the intersections and sections		intersections[i] = new unsigned long(numBspInters);		sections[i] = new unsigned char(numBspInters);				intersectionsV[i].resize(numBspInters);		sectionsV[i].resize(numBspInters);				//Init things, just to start out clean		for (int j = 0; j < numBspInters; j++)		{			intersections[i][j] = 0;			sections[i][j] = 0;						intersectionsV[i][j] = 0;			sectionsV[i][j] = 0;		}				//Copy the intersection info, one intersection at a time		vector<GenericIntersection*> bspInters = bsplines[i]->GetIntersections();		vector<BspBspIntersection*> selfIntersAlreadyVisited;		vector<GenericIntersection*> otherInters;		BSplineToBSplineCut* cut;		unsigned char* bytePtr;	//The intersection is a long, so four bytes.  Walk through the four bytes one at a time.		unsigned char* bytePtrV;	//The intersection is a long, so four bytes.  Walk through the four bytes one at a time.		for (int j = 0; j < bspInters.size(); j++)		{			bytePtr = (unsigned char*)&(intersections[i][j]);	//Point the byte pointer at the beginning of the long for this intersection			bytePtrV = (unsigned char*)&(intersectionsV[i][j]);	//Point the byte pointer at the beginning of the long for this intersection						switch (bspInters[j]->GetType())	//Different kinds of intersections are stored uniquely in their long.  See MinimalDrawing.h for details.			{				case GenericIntersection::BSP_BSP:					BspBspIntersection* bspBspInter = (BspBspIntersection*)bspInters[j];					if (!bspBspInter->SelfIntersection())					{						BSpline* otherBsp = bspBspInter->GetOtherBsp(bsplines[i]);												int otherBspIndex = drawing->GetBSplineIndex(otherBsp);						*bytePtr++ = *bytePtrV++ = otherBspIndex;												vector<GenericIntersection*> otherBspInters = otherBsp->GetIntersections();						int otherBspInterIndex = 0;						while (otherBspInterIndex < otherBspInters.size() && otherBspInters[otherBspInterIndex] != bspBspInter)							otherBspInterIndex++;						MyAssert(otherBspInterIndex < otherBspInters.size() && otherBspInterIndex < 256);						*bytePtr++ = *bytePtrV++ = otherBspInterIndex;												*bytePtr++ = *bytePtrV++ = (bspBspInter->GetBsp1() == bsplines[i]) ? 1 : 0;												*bytePtr = bspBspInter->GetHardConstraint() ? 1 : 0;					}					else	//Self intersection					{						*bytePtr++ = *bytePtrV++ = i;												int otherInterIndex = 0;						while (otherInterIndex < bspInters.size() && bspInters[otherInterIndex] != bspBspInter)							otherInterIndex++;						MyAssert(otherInterIndex < bspInters.size() && otherInterIndex < 256);						*bytePtr++ = *bytePtrV++ = otherInterIndex;												if (find(selfIntersAlreadyVisited.begin(), selfIntersAlreadyVisited.end(), bspBspInter) == selfIntersAlreadyVisited.end())						{							if (bspBspInter->GetCv1() < bspBspInter->GetCv2())								*bytePtr++ = *bytePtrV++ = 1;							else if (bspBspInter->GetCv2() < bspBspInter->GetCv1())								*bytePtr++ = *bytePtrV++ = 0;							else if (bspBspInter->GetSg1() < bspBspInter->GetSg2())								*bytePtr++ = *bytePtrV++ = 1;							else if (bspBspInter->GetSg2() < bspBspInter->GetSg1())								*bytePtr++ = *bytePtrV++ = 0;														selfIntersAlreadyVisited.push_back(bspBspInter);						}						else	//Second time visiting this self intersection						{							if (bspBspInter->GetCv1() < bspBspInter->GetCv2())								*bytePtr++ = *bytePtrV++ = 0;							else if (bspBspInter->GetCv2() < bspBspInter->GetCv1())								*bytePtr++ = *bytePtrV++ = 1;							else if (bspBspInter->GetSg1() < bspBspInter->GetSg2())								*bytePtr++ = *bytePtrV++ = 0;							else if (bspBspInter->GetSg2() < bspBspInter->GetSg1())								*bytePtr++ = *bytePtrV++ = 1;						}												*bytePtr = bspBspInter->GetHardConstraint() ? 1 : 0;					}					break;				case GenericIntersection::BSP_CUT:					BspCutIntersection* bspCutInter = (BspCutIntersection*)bspInters[j];										cut = bspCutInter->GetCut();										*bytePtr++ = *bytePtrV++ = bsplines.size() + drawing->GetCutIndex(bspCutInter->GetCut());										otherInters = cut->GetIntersections();					int cutInterIndex = 0;					while (cutInterIndex < otherInters.size() && otherInters[cutInterIndex] != bspCutInter)						cutInterIndex++;					MyAssert(cutInterIndex < otherInters.size() && cutInterIndex < 256);					*bytePtr++ = *bytePtrV++ = cutInterIndex;										*bytePtr++ = *bytePtrV++ = bspCutInter->GetBspOnTop() ? 1 : 0;										*bytePtr = bspCutInter->GetHardConstraint() ? 1 : 0;					break;				case GenericIntersection::BSP_CUT_T:					BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)bspInters[j];										*bytePtr++ = *bytePtrV++ = i;										*bytePtr++ = *bytePtrV++ = j;										*bytePtr++ = *bytePtrV++ = bsplines.size() + drawing->GetCutIndex(bspCutTInter->GetCut());										*bytePtr = bspCutTInter->GetAtStart() ? 1 : 0;					break;				case GenericIntersection::CUT_CUT:					MyAssert(false);					break;			}		}	//End loop over one bspline's intersections				//Copy the section depths		vector<int> sectionDepths = *bsplines[i]->GetSectionDepths();		for (int j = 0; j < sectionDepths.size(); j++)			sections[i][j] = sectionsV[i][j] = sectionDepths[j];	}		//Loop through the cuts, collecting their intersection info	for (int i = 0; i < cuts.size(); i++)	{		int cutArrayIndex = bsplines.size() + i;				//Get the Cut's number of intersections		int numCutInters = cuts[i]->GetNumIntersections();				//Make the arrays to store the intersections and sections		intersections[cutArrayIndex] = new unsigned long(numCutInters);		sections[cutArrayIndex] = new unsigned char(numCutInters);				//Init things, just to start out clean		for (int j = 0; j < numCutInters; j++)		{			intersections[cutArrayIndex][j] = 0;			sections[cutArrayIndex][j] = 0;		}				//Copy the intersection info, one intersection at a time		vector<GenericIntersection*> cutInters = cuts[i]->GetIntersections();		vector<BspBspIntersection*> selfIntersAlreadyVisited;		vector<GenericIntersection*> bspInters;		BSpline* bsp;		int bspInterIndex;		unsigned char* bytePtr;	//The intersection is a long, so four bytes.  Walk through the four bytes one at a time.		unsigned char* bytePtrV;	//The intersection is a long, so four bytes.  Walk through the four bytes one at a time.		for (int j = 0; j < cutInters.size(); j++)		{			bytePtr = (unsigned char*)&(intersections[cutArrayIndex][j]);	//Point the byte pointer at the beginning of the long for this intersection			bytePtrV = (unsigned char*)&(intersectionsV[cutArrayIndex][j]);	//Point the byte pointer at the beginning of the long for this intersection						switch (cutInters[j]->GetType())	//Different kinds of intersections are stored uniquely in their long.  See MinimalDrawing.h for details.			{				case GenericIntersection::BSP_BSP:					MyAssert(false);					break;				case GenericIntersection::BSP_CUT:					BspCutIntersection* bspCutInter = (BspCutIntersection*)cutInters[j];										bsp = bspCutInter->GetBsp();										*bytePtr++ = *bytePtrV++ = drawing->GetBSplineIndex(bsp);										bspInters = bsp->GetIntersections();					bspInterIndex = 0;					while (bspInterIndex < bspInters.size() && bspInters[bspInterIndex] != bspCutInter)						bspInterIndex++;					MyAssert(bspInterIndex < bspInters.size() && bspInterIndex < 256);					*bytePtr++ = *bytePtrV++ = bspInterIndex;										*bytePtr++ = *bytePtrV++ = bspCutInter->GetBspOnTop() ? 0 : 1;										*bytePtr = bspCutInter->GetHardConstraint() ? 1 : 0;					break;				case GenericIntersection::BSP_CUT_T:					BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)bspInters[j];										BSplineToBSplineCut* cut = bspCutTInter->GetCut();					bsp = bspCutTInter->GetAtStart() ? cut->GetBsp1() : cut->GetBsp2();										*bytePtr++ = *bytePtrV++ = drawing->GetBSplineIndex(bsp);										bspInters = bsp->GetIntersections();					bspInterIndex = 0;					while (bspInterIndex < bspInters.size() && bspInters[bspInterIndex] != bspCutTInter)						bspInterIndex++;					MyAssert(bspInterIndex < bspInters.size() && bspInterIndex < 256);					*bytePtr++ = *bytePtrV++ = bspInterIndex;										*bytePtr++ = *bytePtrV++ = cutArrayIndex;										*bytePtr = bspCutTInter->GetAtStart() ? 1 : 0;					break;				case GenericIntersection::CUT_CUT:					//Don't store CutCut intersections.  There's no point.					break;			}		}	//End loop over one bspline's intersections				//Copy the section depths		vector<int> sectionDepths = *cuts[i]->GetSectionDepths();		for (int j = 0; j < sectionDepths.size(); j++)			sections[cutArrayIndex][j] = sectionsV[cutArrayIndex][j] = sectionDepths[j];	}}void MinimalDrawing::WriteMinimalDrawing(){	MyAssert(intersectionsV.size() == numBSplinesAndCuts);	MyAssert(sectionsV.size() == numBSplinesAndCuts);	int numCuts = numBSplinesAndCuts - numBSplines;		cout << "========================================" << endl;	cout << "MINIMAL DRAWING ========================" << endl;	cout << "========================================" << endl << endl;		cout << "Bsplines" << endl << endl;		for (int i = 0; i < numBSplines; i++)	{		for (int j = 0; j < intersectionsV[i].size(); j++)			cout << intersectionsV[i][j] << " ";		cout << endl;	}		cout << endl << "Cuts" << endl << endl;		for (int i = numBSplines; i < numBSplinesAndCuts; i++)	{		for (int j = 0; j < intersectionsV[i].size(); j++)			cout << intersectionsV[i][j] << " ";		cout << endl;	}		cout << endl << "Sections" << endl << endl;		for (int i = 0; i < numBSplines; i++)	{		for (int j = 0; j < sectionsV[i].size(); j++)			cout << sectionsV[i][j] << " ";		cout << endl;	}		cout << endl;}void MinimalDrawing::TransferToDrawing(Drawing* drawing){	//Get the total number of BSplines and Cuts	int dNumBSplinesPlusCuts = drawing->GetNumBSplines() + drawing->GetNumCuts();	MyAssert(dNumBSplinesPlusCuts == numBSplinesAndCuts);		vector<BSpline*> bsplines = drawing->GetBSplines();	vector<BSplineToBSplineCut*> cuts = drawing->GetCuts();		//Copy the minimal drawing into the drawing	for (int i = 0; i < bsplines.size(); i++)	{		//Get the BSpline's number of intersections		int numBspInters = bsplines[i]->GetNumIntersections();				//Copy the intersection info		vector<GenericIntersection*> bspInters = bsplines[i]->GetIntersections();		vector<BspBspIntersection*> selfIntersAlreadyVisited;		char* bytePtr;		for (int j = 0; j < bspInters.size(); j++)		{			//bytePtr = (char*)&(intersections[i][j]);			bytePtr = (char*)&(intersectionsV[i][j]);			bytePtr++;			bytePtr++;			switch (bspInters[j]->GetType())			{				case GenericIntersection::BSP_BSP:					BspBspIntersection* bspBspInter = (BspBspIntersection*)bspInters[j];					if (!bspBspInter->SelfIntersection())					{						if ((bspBspInter->GetBsp1() == bsplines[i] && *bytePtr == 0) || (bspBspInter->GetBsp2() == bsplines[i] && *bytePtr == 1))							bspBspInter->FlipTopBottom();					}					else	//Self intersection					{						if (find(selfIntersAlreadyVisited.begin(), selfIntersAlreadyVisited.end(), bspBspInter) == selfIntersAlreadyVisited.end())						{							if (bspBspInter->GetCv1() < bspBspInter->GetCv2() && *bytePtr == 1)								bspBspInter->FlipTopBottom();							else if (bspBspInter->GetCv2() < bspBspInter->GetCv1() && *bytePtr == 0)								bspBspInter->FlipTopBottom();							else if (bspBspInter->GetSg1() < bspBspInter->GetSg2() && *bytePtr == 1)								bspBspInter->FlipTopBottom();							else if (bspBspInter->GetSg2() < bspBspInter->GetSg1() && *bytePtr == 0)								bspBspInter->FlipTopBottom();														selfIntersAlreadyVisited.push_back(bspBspInter);						}						else	//Second time visiting this self intersection						{							if (bspBspInter->GetCv1() < bspBspInter->GetCv2() && *bytePtr == 0)								bspBspInter->FlipTopBottom();							else if (bspBspInter->GetCv2() < bspBspInter->GetCv1() && *bytePtr == 1)								bspBspInter->FlipTopBottom();							else if (bspBspInter->GetSg1() < bspBspInter->GetSg2() && *bytePtr == 0)								bspBspInter->FlipTopBottom();							else if (bspBspInter->GetSg2() < bspBspInter->GetSg1() && *bytePtr == 1)								bspBspInter->FlipTopBottom();						}					}					break;				case GenericIntersection::BSP_CUT:					BspCutIntersection* bspCutInter = (BspCutIntersection*)bspInters[j];					if ((bspCutInter->GetBspOnTop() && *bytePtr == 1) || (!bspCutInter->GetBspOnTop() && *bytePtr == 0))						bspCutInter->FlipTopBottom();					break;				case GenericIntersection::BSP_CUT_T:					//Don't store T junctions.  There's no point.					break;				case GenericIntersection::CUT_CUT:					MyAssert(false);					break;			}		}	//End loop over one bspline's intersections				//Copy the section depths		vector<int> sectionDepths = *bsplines[i]->GetSectionDepths();		for (int j = 0; j < sectionDepths.size(); j++)			//sectionDepths[j] = sections[i][j];			sectionDepths[j] = sectionsV[i][j];	}		for (int i = 0; i < cuts.size(); i++)	{		int cutArrayIndex = bsplines.size() + i;				//Get the Cut's number of intersections		int numCutInters = cuts[i]->GetNumIntersections();				//Make the arrays to store the intersections and sections		intersections[cutArrayIndex] = new unsigned long(numCutInters);		sections[cutArrayIndex] = new unsigned char(numCutInters);				//Copy the intersection info		vector<GenericIntersection*> cutInters = cuts[i]->GetIntersections();		vector<BspBspIntersection*> selfIntersAlreadyVisited;		char* bytePtr;		for (int j = 0; j < cutInters.size(); j++)		{			//bytePtr = (char*)&(intersections[cutArrayIndex][j]);			bytePtr = (char*)&(intersectionsV[cutArrayIndex][j]);			switch (cutInters[j]->GetType())			{				case GenericIntersection::BSP_BSP:					MyAssert(false);					break;				case GenericIntersection::BSP_CUT:					BspCutIntersection* bspCutInter = (BspCutIntersection*)cutInters[j];					if ((bspCutInter->GetBspOnTop() && *bytePtr == 1) || (!bspCutInter->GetBspOnTop() && *bytePtr == 0))						bspCutInter->FlipTopBottom();					break;				case GenericIntersection::BSP_CUT_T:					//Don't store T junctions.  There's no point.					break;				case GenericIntersection::CUT_CUT:					//Don't store CutCut intersections.  There's no point.					break;			}		}	//End loop over one bspline's intersections				//Copy the section depths		vector<int> sectionDepths = *cuts[i]->GetSectionDepths();		for (int j = 0; j < sectionDepths.size(); j++)			//sectionDepths[j] = sections[cutArrayIndex][j];			sectionDepths[j] = sectionsV[cutArrayIndex][j];	}}