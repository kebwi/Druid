//#include "BSpline.h"//#include "Intersection.h"#include "Drawing.h"#include "Colors.h"#include "GWorldWrapper.h"#include "MainWindow.h"#include "BSpline.h"#include "ToolsWindow.h"#include "TextGenerator.h"#include "GenericIntersection.h"#include "BspBspIntersection.h"#include "BspCutIntersection.h"#include "BspCutTIntersection.h"#include "CutCutIntersection.h"#include "Random.h"#include "PascalStringUtil.h"#include <ColorPicker.h>#include <math.h>#include <vector.h>#include <assert.h>//******************************************************************************//Extern Globals//******************************************************************************//Global DeclarationsWindowRef gHelpTagWindow = NULL, gColorsWindow = NULL, gInfoWindow = NULL, gToolHelpWindow = NULL, gAnalysisWindow = NULL,	gReflectanceSliderWindow = NULL, gSurfaceTraitsWindow = NULL, gDataLogWindow = NULL;bool gQuit = false;MainWindow *gMainWindow = NULL;ToolsWindow *gToolsWindow = NULL;Drawing *gDrawing = NULL;TextGenerator *gTextGenerator = NULL;int gPointRadius = 2;Colors gColors;SurfaceTraits gSurfaceTraits;vector<BSpline*> gAffectedBSplines;bool gColorsHelpVisible = false;UserEventUPP gEventProcUPP = NULL;ColorChangedUPP gColorChangedUPP = NULL;NColorChangedUPP gColorNChangedUPP = NULL;ColorChangedUPP gSurfaceTraitsColorChangedUPP = NULL;NColorChangedUPP gSurfaceTraitsColorNChangedUPP = NULL;//******************************************************************************//Function Prototypes	//	In this filevoid InitColors();void DoAboutBox();pascal OSStatus AboutBoxHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData);void HandleFill(Point where);void HandleColorChange(Point where);void RedrawColorsWindow();void RedrawInfoWindow();void RedrawToolHelpWindow();void RedrawSurfaceTraitsWindow();pascal OSStatus SimpleModalErrorDialogHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData);	//	In external files		//	toolbox.cppvoid MenuBarInit();void WindowInit();void EventHandlersInit();void ToolBoxInit();pascal void WindowBoundaryDragEventHandler(EventLoopTimerRef theTimer, void* userData);#pragma mark -int main(){	SeedRandom();		ToolBoxInit();	WindowInit();		InitColors();		gSurfaceTraits.interiorColor.red = gSurfaceTraits.interiorColor.green = gSurfaceTraits.interiorColor.blue = 1;	//0 is reserved as a "flag" for an illegal boundary	gSurfaceTraits.interiorReflectance = 1.0;	gSurfaceTraits.borderColor.red = gSurfaceTraits.interiorColor.red;	gSurfaceTraits.borderColor.green = gSurfaceTraits.interiorColor.green;	gSurfaceTraits.borderColor.blue = gSurfaceTraits.interiorColor.blue;	gSurfaceTraits.borderReflectance = gSurfaceTraits.interiorReflectance;	gSurfaceTraits.borderThickness = 1.0;		gDrawing = new Drawing();	//It is important to create the Drawing before creating the MainWindow	gMainWindow = new MainWindow(128);	gToolsWindow = new ToolsWindow(129);		MenuBarInit();	gTextGenerator = new TextGenerator();	EventHandlersInit();		//DoAboutBox();		//Just for some tests, hide most of the windows	/*	HideWindow(gToolsWindow->GetWindow());	HideWindow(gColorsWindow);	HideWindow(gInfoWindow);	HideWindow(gToolHelpWindow);	HideWindow(gAnalysisWindow);	HideWindow(gSurfaceTraitsWindow);	*/	RunApplicationEventLoop();		delete gDrawing;	delete gToolsWindow;	delete gMainWindow;		return 0;}void InitColors(){	gColors.canvas.red = 65535;	gColors.canvas.green = 65535;	gColors.canvas.blue = 65535;		gColors.controlPoint.red = 65535;	gColors.controlPoint.green = 32768;	gColors.controlPoint.blue = 32768;		gColors.boundary.red = 65535;	gColors.boundary.green = 65535;	gColors.boundary.blue = 45192;		gColors.curvePoint.red = 16384;	gColors.curvePoint.green = 32768;	gColors.curvePoint.blue = 16384;		gColors.segmentA.red = 45192;	gColors.segmentA.green = 45192;	gColors.segmentA.blue = 45192;		gColors.segmentB.red = 0;	gColors.segmentB.green = 0;	gColors.segmentB.blue = 0;		gColors.intersection.red = 16384;	gColors.intersection.green = 16384;	gColors.intersection.blue = 65535;	}void DoAboutBox(){	IBNibRef theNib;	OSStatus err = CreateNibReference(CFSTR("main"), &theNib);  	if (!err) 	{		//Create the window		WindowRef theWindow;		CreateWindowFromNib(theNib, CFSTR("AboutBox"), &theWindow);				ShowWindow(theWindow);				InstallStandardEventHandler(GetWindowEventTarget(theWindow));				//EventTypeSpec dlogEventList[] = {{kEventClassControl, kEventControlHit}};				//We shouldn't have to pass the window in through the userdata,		//but there is a problem otherwise so we are forced to until we solve the problem.		//See AboutBoxHandler() for more on this.		//InstallWindowEventHandler(theWindow, NewEventHandlerUPP(SimpleModalErrorDialogHandler), 1, dlogEventList, (void*)theWindow, NULL);				//RunAppModalLoopForWindow(theWindow);				//DisposeWindow(theWindow);	}}void MyAssert(bool condition){	if (!condition)	{		//SysBeep(1);		int k = 1;	}		//assert(condition);}#pragma mark -void HandleFill(Point where){	if (gMainWindow->GetWorkingObjects().size() != 1)		return;		Rect bounds;	GetPortBounds(GetWindowPort(gMainWindow->GetWindow()), &bounds);	GWorldWrapper src(32, bounds, -1);	GWorldWrapper dest(1, bounds, -1);		src.StartUsingGWorld();	gMainWindow->Redraw();	src.FinishUsingGWorld();		LockPixels(GetGWorldPixMap(src.GetGWorldPtr()));	LockPixels(GetGWorldPixMap(dest.GetGWorldPtr()));		BitMapHandle srcBM = src.GetSrcBitMap(), destBM = dest.GetSrcBitMap();		SeedCFill(*srcBM, *destBM, &bounds, &bounds, where.h, where.v, 0, 0);		UnlockPixels(GetGWorldPixMap(src.GetGWorldPtr()));	UnlockPixels(GetGWorldPixMap(src.GetGWorldPtr()));		SetPort(GetWindowPort(gMainWindow->GetWindow()));	ForeColor(blackColor);	BackColor(whiteColor);	dest.CopyWorldBits(bounds, bounds, GetWindowPort(gMainWindow->GetWindow()));		QDFlushPortBuffer(GetWindowPort(gMainWindow->GetWindow()), NULL);}#pragma mark -pascal Boolean ColorPickerEventProc(EventRecord *event){	if (event->what == updateEvt)		return true;	return false;	//Return true if my function handles the event, false if I want the system to handle it}pascal void ColorPickerColorChanged(SInt32 userData, PMColor *newColor){}pascal void NColorPickerColorChanged(SInt32 userData, NPMColor *newColor){	RGBColor newRGBcolor;	newRGBcolor.red = newColor->color.rgb.red;	newRGBcolor.green = newColor->color.rgb.green;	newRGBcolor.blue = newColor->color.rgb.blue;		switch (userData)	{		case 0:	gColors.canvas = newRGBcolor;	break;		case 1:	gColors.controlPoint = newRGBcolor;	break;		case 2:	gColors.boundary = newRGBcolor;	break;		case 3:	gColors.curvePoint = newRGBcolor;	break;		case 4:	gColors.segmentA = newRGBcolor;	break;		case 5:	gColors.segmentB = newRGBcolor;	break;		case 6:	gColors.intersection = newRGBcolor;	break;	}		RedrawColorsWindow();	if (userData == 0)		gMainWindow->GenerateGrid();	gMainWindow->Redraw();}void HandleColorChange(Point where){	SetPort(GetWindowPort(gColorsWindow));	GlobalToLocal(&where);		OSErr err;		Rect r;	for (int i = 0; i < 7; i++)	{		SetRect(&r, 5, i * 15 + 5, 15, i * 15 + 15);		if (PtInRect(where, &r))		{			RGBColor currentColor, newColor;			switch (i)			{				case 0:	currentColor = gColors.canvas;	break;				case 1:	currentColor = gColors.controlPoint;	break;				case 2:	currentColor = gColors.boundary;	break;				case 3:	currentColor = gColors.curvePoint;	break;				case 4:	currentColor = gColors.segmentA;	break;				case 5:	currentColor = gColors.segmentB;	break;				case 6:	currentColor = gColors.intersection;	break;			}						//Freeze mouse-moved events in the main window while the color picker dialog is up			gMainWindow->FreezeMouseMovedEvents();						int colorMethod = 2;			if (colorMethod == 0)			{				if (GetColor(where, "\pSelect a new color.", &currentColor, &newColor))				{					switch (i)					{						case 0:	gColors.canvas = newColor;	break;						case 1:	gColors.controlPoint = newColor;	break;						case 2:	gColors.boundary = newColor;	break;						case 3:	gColors.curvePoint = newColor;	break;						case 4:	gColors.segmentA = newColor;	break;						case 5:	gColors.segmentB = newColor;	break;						case 6:	gColors.intersection = newColor;	break;					}										RedrawColorsWindow();					if (i == 0)						gMainWindow->GenerateGrid();					gMainWindow->Redraw();				}			}			else if (colorMethod == 1)			{				ColorPickerInfo cpi;				cpi.theColor.color.rgb.red = currentColor.red;				cpi.theColor.color.rgb.green = currentColor.green;				cpi.theColor.color.rgb.blue = currentColor.blue;				cpi.theColor.profile = NULL;				cpi.dstProfile = NULL;	//Use default profile				cpi.placeWhere = kAtSpecifiedOrigin;	//Doesn't seem to work, but oh well!				cpi.dialogOrigin = where;	//Doesn't seem to work, but oh well!				cpi.pickerType = 0;	//Use last used type				if (!gEventProcUPP)					gEventProcUPP = NewUserEventUPP(ColorPickerEventProc);				cpi.eventProc = gEventProcUPP;				if (!gColorChangedUPP)					gColorChangedUPP = NewColorChangedUPP(ColorPickerColorChanged);				cpi.colorProc = gColorChangedUPP;				cpi.colorProcData = i;	//user data passed to color changed callback				cpi.prompt[0] = 0;	//This dialog has no text prompt				cpi.mInfo.editMenuID = 130;				cpi.mInfo.cutItem = 4;				cpi.mInfo.copyItem = 5;				cpi.mInfo.pasteItem = 6;				cpi.mInfo.clearItem = 7;				cpi.mInfo.undoItem = 1;								err = PickColor(&cpi);				if (err == noErr && cpi.newColorChosen)				{					newColor.red = cpi.theColor.color.rgb.red;					newColor.green = cpi.theColor.color.rgb.green;					newColor.blue = cpi.theColor.color.rgb.blue;										switch (i)					{						case 0:	gColors.canvas = newColor;	break;						case 1:	gColors.controlPoint = newColor;	break;						case 2:	gColors.boundary = newColor;	break;						case 3:	gColors.curvePoint = newColor;	break;						case 4:	gColors.segmentA = newColor;	break;						case 5:	gColors.segmentB = newColor;	break;						case 6:	gColors.intersection = newColor;	break;					}										RedrawColorsWindow();					if (i == 0)						gMainWindow->GenerateGrid();					gMainWindow->Redraw();				}				else				{					switch (i)					{						case 0:	gColors.canvas = currentColor;	break;						case 1:	gColors.controlPoint = currentColor;	break;						case 2:	gColors.boundary = currentColor;	break;						case 3:	gColors.curvePoint = currentColor;	break;						case 4:	gColors.segmentA = currentColor;	break;						case 5:	gColors.segmentB = currentColor;	break;						case 6:	gColors.intersection = currentColor;	break;					}										RedrawColorsWindow();					if (i == 0)						gMainWindow->GenerateGrid();					gMainWindow->Redraw();				}								//DisposeUserEventUPP(gEventProcUPP);				//DisposeColorChangedUPP(gColorChangedUPP);			}			else if (colorMethod == 2)			{				NColorPickerInfo ncpi;				ncpi.theColor.color.rgb.red = currentColor.red;				ncpi.theColor.color.rgb.green = currentColor.green;				ncpi.theColor.color.rgb.blue = currentColor.blue;				ncpi.theColor.profile = NULL;				ncpi.dstProfile = NULL;	//Use default profile				ncpi.placeWhere = kCenterOnMainScreen;	//Doesn't seem to work, but oh well!				ncpi.dialogOrigin = where;	//Doesn't seem to work, but oh well!				ncpi.pickerType = 0;	//Use last used type				if (!gEventProcUPP)					gEventProcUPP = NewUserEventUPP(ColorPickerEventProc);				ncpi.eventProc = gEventProcUPP;				if (!gColorNChangedUPP)					gColorNChangedUPP = NewNColorChangedUPP(NColorPickerColorChanged);				ncpi.colorProc = gColorNChangedUPP;				ncpi.colorProcData = i;	//user data passed to color changed callback				ncpi.prompt[0] = 0;	//This dialog has no text prompt				ncpi.mInfo.editMenuID = 130;				ncpi.mInfo.cutItem = 4;				ncpi.mInfo.copyItem = 5;				ncpi.mInfo.pasteItem = 6;				ncpi.mInfo.clearItem = 7;				ncpi.mInfo.undoItem = 1;								err = NPickColor(&ncpi);				if (err == noErr && ncpi.newColorChosen)				{					newColor.red = ncpi.theColor.color.rgb.red;					newColor.green = ncpi.theColor.color.rgb.green;					newColor.blue = ncpi.theColor.color.rgb.blue;										switch (i)					{						case 0:	gColors.canvas = newColor;	break;						case 1:	gColors.controlPoint = newColor;	break;						case 2:	gColors.boundary = newColor;	break;						case 3:	gColors.curvePoint = newColor;	break;						case 4:	gColors.segmentA = newColor;	break;						case 5:	gColors.segmentB = newColor;	break;						case 6:	gColors.intersection = newColor;	break;					}										RedrawColorsWindow();					if (i == 0)						gMainWindow->GenerateGrid();					gMainWindow->Redraw();				}				else				{					switch (i)					{						case 0:	gColors.canvas = currentColor;	break;						case 1:	gColors.controlPoint = currentColor;	break;						case 2:	gColors.boundary = currentColor;	break;						case 3:	gColors.curvePoint = currentColor;	break;						case 4:	gColors.segmentA = currentColor;	break;						case 5:	gColors.segmentB = currentColor;	break;						case 6:	gColors.intersection = currentColor;	break;					}										RedrawColorsWindow();					if (i == 0)						gMainWindow->GenerateGrid();					gMainWindow->Redraw();				}								//DisposeUserEventUPP(gEventProcUPP);				//DisposeNColorChangedUPP(gColorNChangedUPP);			}						gMainWindow->ResumeMouseMovedEvents();						break;		}	}}void HandleColorWindowMouseMoved(Point where){	if (!IsWindowVisible(gColorsWindow))		return;		SetPort(GetWindowPort(gColorsWindow));	GlobalToLocal(&where);		Point helpTagLoc = { -1, -1 };	Str255 helpTagStr;		Rect r;	for (int i = 0; i < 7; i++)	{		SetRect(&r, 5, i * 15 + 5, 15, i * 15 + 15);		if (PtInRect(where, &r))		{			helpTagLoc.h = r.left;			helpTagLoc.v = r.top;			switch (i)			{				case 0:	CtoPascal("Underlying canvas color", helpTagStr);	break;				case 1:	CtoPascal("Control point color", helpTagStr);	break;				case 2:	CtoPascal("Boundary color (inverted when hilighted)", helpTagStr);	break;				case 3:	CtoPascal("Curve point color (only shown in spline view mode)", helpTagStr);	break;				case 4:	CtoPascal("Even curve segment color (only shown in spline view mode)", helpTagStr);	break;				case 5:	CtoPascal("Odd curve segment color (only shown in spline view mode)", helpTagStr);	break;				case 6:	CtoPascal("Intersection color (only shown in spline view mode, or when pointer is over an intersection with Super Spline tool)", helpTagStr);	break;			}		}	}		if (helpTagLoc.h != -1)	{		helpTagLoc.h += 5;		helpTagLoc.v += 25;		LocalToGlobal(&helpTagLoc);		SetPort(GetWindowPort(gHelpTagWindow));				SizeWindow(gHelpTagWindow, StringWidth(helpTagStr) + 10, 20, true);				Rect bounds;		GetPortBounds(GetWindowPort(gHelpTagWindow), &bounds);		RGBColor lightYellow;		lightYellow.red = lightYellow.green = 65535;		lightYellow.blue = 37000;		RGBForeColor(&lightYellow);				PaintRect(&bounds);				ForeColor(blackColor);		TextSize(9);		MoveTo(5, 15);		DrawString(helpTagStr);				MoveWindow(gHelpTagWindow, helpTagLoc.h, helpTagLoc.v, false);		ShowWindow(gHelpTagWindow);				gColorsHelpVisible = true;	}	else if (gColorsHelpVisible)	{		HideWindow(gHelpTagWindow);		gColorsHelpVisible = false;	}}pascal void ColorPickerSurfaceTraitsColorChanged(SInt32 userData, PMColor *newColor){}pascal void NColorPickerSurfaceTraitsColorChanged(SInt32 userData, NPMColor *newColor){	RGBColor newRGBcolor;	newRGBcolor.red = newColor->color.rgb.red;	newRGBcolor.green = newColor->color.rgb.green;	newRGBcolor.blue = newColor->color.rgb.blue;		switch (userData)	{		case 0:	gSurfaceTraits.interiorColor = newRGBcolor;	break;		case 1:	gSurfaceTraits.borderColor = newRGBcolor;	break;	}		//Set the color for all the BSplines in the group	for (int i = 0; i < gAffectedBSplines.size(); i++)		gAffectedBSplines[i]->SetSurfaceTraits(gSurfaceTraits);		gMainWindow->Redraw();}void DoErrorMessage(vector<const char*> errLines){	IBNibRef theNib;	OSStatus err = CreateNibReference(CFSTR("main"), &theNib);  	if (!err) 	{		//Create the window		WindowRef theWindow;		CreateWindowFromNib(theNib, CFSTR("ErrorMessage"), &theWindow);				ShowWindow(theWindow);				SetPort(GetWindowPort(theWindow));		TextFont(FMGetFontFamilyFromName("\pLucida Grande"));	//System font, I think		TextFace(0);		TextSize(12);		Str255 str;		int vSpace = 20;		if (errLines.size() > 4)			vSpace = 90 / errLines.size();		for (int i = 0; i < errLines.size(); i++)		{			CtoPascal(errLines[i], str);			MoveTo(20, i * vSpace + vSpace);			DrawString(str);		}		QDFlushPortBuffer(GetWindowPort(theWindow), NULL);				InstallStandardEventHandler(GetWindowEventTarget(theWindow));				EventTypeSpec dlogEventList[] = {{kEventClassControl, kEventControlHit}};				//We shouldn't have to pass the window in through the userdata,		//but there is a problem otherwise so we are forced to until we solve the problem.		//See AboutBoxHandler() for more on this.		InstallWindowEventHandler(theWindow, NewEventHandlerUPP(SimpleModalErrorDialogHandler), 1, dlogEventList, (void*)theWindow, NULL);				RunAppModalLoopForWindow(theWindow);				DisposeWindow(theWindow);	}}void DoEmptySelectionSurfaceTraitsClickError(){	vector<const char*> errLines;	errLines.push_back("You have clicked in the Surface Traits window.");	errLines.push_back("Are you trying to alter a surface's traits?");	errLines.push_back("If so, please make a selection with the Spline Selector tool first.");	DoErrorMessage(errLines);}pascal OSStatus SimpleModalErrorDialogHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){	WindowRef           window = (WindowRef)userData;//NULL;	UInt32              whatHappened;	//OSStatus err = GetEventParameter(theEvent, kEventParamWindowRef, typeWindowRef,	//					NULL, sizeof(WindowRef), NULL, &window);	//err = GetEventParameter(theEvent, kEventParamDirectObject, typeWindowRef,	//					NULL, sizeof(WindowRef), NULL, &window);    								whatHappened = GetEventKind(theEvent);		//http://developer.apple.com/documentation/Carbon/Conceptual/carbon_porting_guide/cpg_newtechstruct/chapter_5_section_6.html		switch (whatHappened)	{		case kEventControlHit:			ControlRef controlRef;			GetEventParameter(theEvent, kEventParamDirectObject, typeControlRef,								NULL, sizeof(ControlRef), NULL, &controlRef);						ControlID itemID;			GetControlID(controlRef, &itemID);						switch (itemID.id)			{				case 1:					QuitAppModalLoopForWindow(window);					break;			}			break;	}		//This makes dialog items "work", like highlight buttons while the mouse is pressed over a button and hilighting text fields when they are clicked in, etc.	CallNextEventHandler(nextHandler, theEvent);		return noErr;}void HandleSurfaceTraitsColorChange(Point where){	ControlID inID = { 'sftr', 1 };	ControlRef controlRef;	GetControlByID(gSurfaceTraitsWindow, &inID, &controlRef);	if (!IsControlActive(controlRef))	{		DoEmptySelectionSurfaceTraitsClickError();		return;	}		//===================================================================================		vector<BSpline*> workingBSplines = gMainWindow->GetWorkingObjects();	vector<WholeObject*> wholeObjects = gDrawing->GetWholeObjects();		//Build a vector  of all affected BSplines	gAffectedBSplines.clear();	for (vector<BSpline*>::iterator i = workingBSplines.begin(); i != workingBSplines.end(); i++)	{		if (find(gAffectedBSplines.begin(), gAffectedBSplines.end(), *i) == gAffectedBSplines.end())			gAffectedBSplines.push_back(*i);				vector<BSpline*> groupBSplines;		gDrawing->GetBSplinesInGroupFromBSpline(*i, groupBSplines);				for (vector<BSpline*>::iterator j = groupBSplines.begin(); j != groupBSplines.end(); j++)			if (find(gAffectedBSplines.begin(), gAffectedBSplines.end(), *j) == gAffectedBSplines.end())				gAffectedBSplines.push_back(*j);	}		//===================================================================================		SetPort(GetWindowPort(gSurfaceTraitsWindow));	GlobalToLocal(&where);		OSErr err;		Rect r;		for (int i = 0; i < 2; i++)	{		switch (i)		{			case 0:	SetRect(&r, 130, 5, 145, 20);	break;			case 1:	SetRect(&r, 130, 55, 145, 70);	break;		}				if (PtInRect(where, &r))		{			RGBColor currentColor, newColor;			switch (i)			{				case 0:	currentColor = gSurfaceTraits.interiorColor;	break;				case 1:	currentColor = gSurfaceTraits.borderColor;	break;			}						//Freeze mouse-moved events in the main window while the color picker dialog is up			gMainWindow->FreezeMouseMovedEvents();						int colorMethod = 2;			if (colorMethod == 0)			{				if (GetColor(where, "\pSelect a new color.", &currentColor, &newColor))				{					switch (i)					{						case 0:	gSurfaceTraits.interiorColor = newColor;	break;						case 1:	gSurfaceTraits.borderColor = newColor;	break;					}										gMainWindow->Redraw();										gMainWindow->IncrementUndoStack();				}			}			else if (colorMethod == 1)			{				ColorPickerInfo cpi;				cpi.theColor.color.rgb.red = currentColor.red;				cpi.theColor.color.rgb.green = currentColor.green;				cpi.theColor.color.rgb.blue = currentColor.blue;				cpi.theColor.profile = NULL;				cpi.dstProfile = NULL;	//Use default profile				cpi.placeWhere = kAtSpecifiedOrigin;	//Doesn't seem to work, but oh well!				cpi.dialogOrigin = where;	//Doesn't seem to work, but oh well!				cpi.pickerType = 0;	//Use last used type				if (!gEventProcUPP)					gEventProcUPP = NewUserEventUPP(ColorPickerEventProc);				cpi.eventProc = gEventProcUPP;				if (!gSurfaceTraitsColorChangedUPP)					gSurfaceTraitsColorChangedUPP = NewColorChangedUPP(ColorPickerSurfaceTraitsColorChanged);				cpi.colorProc = gSurfaceTraitsColorChangedUPP;				cpi.colorProcData = i;	//user data passed to color changed callback				cpi.prompt[0] = 0;	//This dialog has no text prompt				cpi.mInfo.editMenuID = 130;				cpi.mInfo.cutItem = 4;				cpi.mInfo.copyItem = 5;				cpi.mInfo.pasteItem = 6;				cpi.mInfo.clearItem = 7;				cpi.mInfo.undoItem = 1;								err = PickColor(&cpi);				if (err == noErr && cpi.newColorChosen)				{					newColor.red = cpi.theColor.color.rgb.red;					newColor.green = cpi.theColor.color.rgb.green;					newColor.blue = cpi.theColor.color.rgb.blue;										switch (i)					{						case 0:	gSurfaceTraits.interiorColor = newColor;	break;						case 1:	gSurfaceTraits.borderColor = newColor;	break;					}										//Set the color for all the BSplines in the group					for (int i = 0; i < gAffectedBSplines.size(); i++)						gAffectedBSplines[i]->SetSurfaceTraits(gSurfaceTraits);										gMainWindow->Redraw();										gMainWindow->IncrementUndoStack();				}				else				{					switch (i)					{						case 0:	gSurfaceTraits.interiorColor = currentColor;	break;						case 1:	gSurfaceTraits.borderColor = currentColor;	break;					}										//Set the color for all the BSplines in the group					for (int i = 0; i < gAffectedBSplines.size(); i++)						gAffectedBSplines[i]->SetSurfaceTraits(gSurfaceTraits);										gMainWindow->Redraw();				}								//DisposeUserEventUPP(gEventProcUPP);				//DisposeColorChangedUPP(gSurfaceTraitsColorChangedUPP);			}			else if (colorMethod == 2)			{				NColorPickerInfo ncpi;				ncpi.theColor.color.rgb.red = currentColor.red;				ncpi.theColor.color.rgb.green = currentColor.green;				ncpi.theColor.color.rgb.blue = currentColor.blue;				ncpi.theColor.profile = NULL;				ncpi.dstProfile = NULL;	//Use default profile				ncpi.placeWhere = kCenterOnMainScreen;	//Doesn't seem to work, but oh well!				ncpi.dialogOrigin = where;	//Doesn't seem to work, but oh well!				ncpi.pickerType = 0;	//Use last used type				if (!gEventProcUPP)					gEventProcUPP = NewUserEventUPP(ColorPickerEventProc);				ncpi.eventProc = gEventProcUPP;				if (!gSurfaceTraitsColorNChangedUPP)					gSurfaceTraitsColorNChangedUPP = NewNColorChangedUPP(NColorPickerSurfaceTraitsColorChanged);				ncpi.colorProc = gSurfaceTraitsColorNChangedUPP;				ncpi.colorProcData = i;	//user data passed to color changed callback				ncpi.prompt[0] = 0;	//This dialog has no text prompt				ncpi.mInfo.editMenuID = 130;				ncpi.mInfo.cutItem = 4;				ncpi.mInfo.copyItem = 5;				ncpi.mInfo.pasteItem = 6;				ncpi.mInfo.clearItem = 7;				ncpi.mInfo.undoItem = 1;								err = NPickColor(&ncpi);				if (err == noErr && ncpi.newColorChosen)				{					newColor.red = ncpi.theColor.color.rgb.red;					newColor.green = ncpi.theColor.color.rgb.green;					newColor.blue = ncpi.theColor.color.rgb.blue;										switch (i)					{						case 0:	gSurfaceTraits.interiorColor = newColor;	break;						case 1:	gSurfaceTraits.borderColor = newColor;	break;					}										//Set the color for all the BSplines in the group					for (int i = 0; i < gAffectedBSplines.size(); i++)						gAffectedBSplines[i]->SetSurfaceTraits(gSurfaceTraits);										gMainWindow->Redraw();										gMainWindow->IncrementUndoStack();				}				else				{					switch (i)					{						case 0:	gSurfaceTraits.interiorColor = currentColor;	break;						case 1:	gSurfaceTraits.borderColor = currentColor;	break;					}										//Set the color for all the BSplines in the group					for (int i = 0; i < gAffectedBSplines.size(); i++)						gAffectedBSplines[i]->SetSurfaceTraits(gSurfaceTraits);										gMainWindow->Redraw();				}								//DisposeUserEventUPP(gEventProcUPP);				//DisposeNColorChangedUPP(gSurfaceTraitsColorNChangedUPP);			}						gMainWindow->ResumeMouseMovedEvents();						break;		}	}		gAffectedBSplines.clear();}#pragma mark -void RedrawColorsWindow(){	SetPort(GetWindowPort(gColorsWindow));		TextFont(FMGetFontFamilyFromName("\pHelvetica"));	TextSize(9);		Rect r;		SetRect(&r, 5, 5, 15, 15);	RGBForeColor(&gColors.canvas);	PaintRect(&r);	ForeColor(blackColor);	FrameRect(&r);	MoveTo(20, 15);	DrawString("\pCanvas");		OffsetRect(&r, 0, 15);	RGBForeColor(&gColors.controlPoint);	PaintRect(&r);	ForeColor(blackColor);	FrameRect(&r);	MoveTo(20, 30);	DrawString("\pControl Point");		OffsetRect(&r, 0, 15);	RGBForeColor(&gColors.boundary);	PaintRect(&r);	ForeColor(blackColor);	FrameRect(&r);	MoveTo(20, 45);	DrawString("\pBoundary");		OffsetRect(&r, 0, 15);	RGBForeColor(&gColors.curvePoint);	PaintRect(&r);	ForeColor(blackColor);	FrameRect(&r);	MoveTo(20, 60);	DrawString("\pCurve Point");		OffsetRect(&r, 0, 15);	RGBForeColor(&gColors.segmentA);	PaintRect(&r);	ForeColor(blackColor);	FrameRect(&r);	MoveTo(20, 75);	DrawString("\pEven Segments");		OffsetRect(&r, 0, 15);	RGBForeColor(&gColors.segmentB);	PaintRect(&r);	ForeColor(blackColor);	FrameRect(&r);	MoveTo(20, 90);	DrawString("\pOdd Segments");		OffsetRect(&r, 0, 15);	RGBForeColor(&gColors.intersection);	PaintRect(&r);	ForeColor(blackColor);	FrameRect(&r);	MoveTo(20, 105);	DrawString("\pIntersection");}void RedrawInfoWindow(){	SetPort(GetWindowPort(gInfoWindow));		Rect r;	GetPortBounds(GetWindowPort(gInfoWindow), &r);	EraseRect(&r);		ForeColor(blackColor);	Str255 s;	TextFont(FMGetFontFamilyFromName("\pHelvetica"));	TextSize(9);		int tab = 100;	int v = 10;		NumToString(gDrawing->GetNumBSplines(), s);	MoveTo(5, v);	DrawString("\pPointer position:");	MoveTo(tab, v);	Point pointerPos = gMainWindow->GetPointerPos();	NumToString(pointerPos.h, s);	DrawString(s);	DrawString("\p , ");	NumToString(pointerPos.v, s);	DrawString(s);		v += 10;		NumToString(gDrawing->GetNumBSplines(), s);	MoveTo(5, v);	DrawString("\pNum BSplines:");	MoveTo(tab, v);	DrawString(s);		v += 10;	NumToString(gDrawing->GetNumCuts(), s);	MoveTo(5, v);	DrawString("\pNum Cuts:");	MoveTo(tab, v);	DrawString(s);		v += 10;	NumToString(gDrawing->GetNumIntersections(), s);	MoveTo(5, v);	DrawString("\pNum Intersections:");	MoveTo(tab, v);	DrawString(s);		v += 10;	NumToString(gDrawing->GetNumInterCompanionSets(), s);	MoveTo(5, v);	DrawString("\pNum Inter Comp Sets:");	MoveTo(tab, v);	DrawString(s);		v += 20;	MoveTo(5, v);	DrawString("\pWorking BSpline:");	MoveTo(tab, v);	vector<BSpline*> workingBSplines = gMainWindow->GetWorkingObjects();	if (workingBSplines.size() != 0)	{		for (vector<BSpline*>::iterator i = workingBSplines.begin(); i != workingBSplines.end(); i++)		{			int j = gDrawing->GetBSplineIndex(*i);			NumToString(j, s);			if (i != workingBSplines.begin())				DrawString("\p, ");			DrawString(s);		}	}	else DrawString("\pn/a");		v += 10;	MoveTo(5, v);	DrawString("\pHilighted BSpline:");	MoveTo(tab, v);	if (gMainWindow->GetHilightedObject())	{		MyAssert(!gMainWindow->GetHilightedObject()->dtored);		int i = gDrawing->GetBSplineIndex(gMainWindow->GetHilightedObject());		NumToString(i, s);		DrawString(s);	}	else DrawString("\pn/a");		v += 10;	MoveTo(5, v);	DrawString("\pHilighted Intersection:");	MoveTo(tab, v);		if (gMainWindow->GetHilightedIntersection())	{		GenericIntersection* intersection = gMainWindow->GetHilightedIntersection();				int interIndex = gDrawing->GetIntersectionIndex(intersection);		NumToString(interIndex, s);		DrawString(s);				int bspIndex;		int cutIndex;		int woIndex;		int curve;		int seg;		int woSection;		switch (intersection->GetType())		{			case GenericIntersection::BSP_BSP:				BspBspIntersection* bspBspInter = (BspBspIntersection*)intersection;								DrawString("\p BB");								MoveTo(15, v + 10);				DrawString("\pbspA:  ");				bspIndex = bspBspInter->GetBsp1Index();				NumToString(bspIndex, s);				DrawString(s);				DrawString("\p            bspB:  ");				bspIndex = bspBspInter->GetBsp2Index();				NumToString(bspIndex, s);				DrawString(s);								MoveTo(15, v + 20);				DrawString("\pcurves: ");				curve = bspBspInter->GetCv1();				NumToString(curve, s);				DrawString(s);				DrawString("\p   ");				curve = bspBspInter->GetCv2();				NumToString(curve, s);				DrawString(s);				DrawString("\p            segs:   ");				seg = bspBspInter->GetSg1();				NumToString(seg, s);				DrawString(s);				DrawString("\p   ");				seg = bspBspInter->GetSg2();				NumToString(seg, s);				DrawString(s);				break;			case GenericIntersection::BSP_CUT:				BspCutIntersection* bspCutInter = (BspCutIntersection*)intersection;								DrawString("\p BC");								MoveTo(15, v + 10);				DrawString("\pbsp:  ");				bspIndex = bspCutInter->GetBspIndex();				NumToString(bspIndex, s);				DrawString(s);				DrawString("\p    cut:  ");				cutIndex = bspCutInter->GetCutIndex();				NumToString(cutIndex, s);				DrawString(s);								MoveTo(15, v + 20);				DrawString("\pcurve: ");				curve = bspCutInter->GetCv();				NumToString(curve, s);				DrawString(s);				DrawString("\p      seg:   ");				seg = bspCutInter->GetSg();				NumToString(seg, s);				DrawString(s);								MoveTo(15, v + 30);				if (bspCutInter->GetBspOnTop())					DrawString("\pBsp on top");				else DrawString("\pCut on top");				break;			case GenericIntersection::BSP_CUT_T:				BspCutTIntersection* bspCutTInter = (BspCutTIntersection*)intersection;								DrawString("\p BCT");								MoveTo(15, v + 10);				DrawString("\pbsp:  ");				bspIndex = bspCutTInter->GetBspIndex();				NumToString(bspIndex, s);				DrawString(s);				DrawString("\p    cut:  ");				cutIndex = bspCutTInter->GetCutIndex();				NumToString(cutIndex, s);				DrawString(s);				DrawString("\p    wo:  ");				woIndex = bspCutTInter->GetWOIndex();				NumToString(woIndex, s);				DrawString(s);								MoveTo(15, v + 20);				DrawString("\pcurve: ");				curve = bspCutTInter->GetCv();				NumToString(curve, s);				DrawString(s);				DrawString("\p      seg:   ");				seg = bspCutTInter->GetSg();				NumToString(seg, s);				DrawString(s);				DrawString("\p      woSection:   ");				woSection = bspCutTInter->GetInfiniteWOsection();				NumToString(woSection, s);				DrawString(s);								MoveTo(15, v + 30);				if (bspCutTInter->GetAtStart())					DrawString("\pintersection is at cut start");				else DrawString("\pintersection is at cut end");				break;			case GenericIntersection::CUT_CUT:				CutCutIntersection* cutCutInter = (CutCutIntersection*)intersection;								DrawString("\p CC");								MoveTo(15, v + 10);				DrawString("\pcutA:  ");				cutIndex = cutCutInter->GetCut1Index();				NumToString(cutIndex, s);				DrawString(s);				DrawString("\p    cutB:  ");				cutIndex = cutCutInter->GetCut2Index();				NumToString(cutIndex, s);				DrawString(s);				break;		}	}	else DrawString("\pn/a");		v += 50;	MoveTo(5, v);	DrawString("\pWorking control point:");	MoveTo(tab, v);	if (gMainWindow->GetWorkingControlPoint() != -1)	{		NumToString(gMainWindow->GetWorkingControlPoint(), s);		DrawString(s);	}	else DrawString("\pn/a");		v += 20;	MoveTo(5, v);	DrawString("\pNum Whole Objects:");	int objectNum = 0;	vector<WholeObject*> wholeObjects = gDrawing->GetWholeObjects();	NumToString(wholeObjects.size(), s);	MoveTo(tab, v);	DrawString(s);	v += 10;	MoveTo(15, v);	DrawString("\pDepth");	MoveTo(50, v);	DrawString("\pSplines");	for (vector<WholeObject*>::iterator i = wholeObjects.begin(); i != wholeObjects.end(); i++)	{		MoveTo(15, v + 10 + objectNum * 10);		if ((*i)->bgDepths.size() > 0)		{			for (int j = 0; j < (*i)->bgDepths.size(); j++)			{				if (j > 0)					DrawString("\p,");				NumToString((*i)->bgDepths[j], s);				DrawString(s);			}		}		else DrawString("\pX");				MoveTo(50, v + 10 + objectNum * 10);		for (vector<BSpline*>::iterator j = (*i)->bsplines.begin(); j != (*i)->bsplines.end(); j++)		{			int bsplineIndex = gDrawing->GetBSplineIndex(*j);			NumToString(bsplineIndex, s);			if (j != (*i)->bsplines.begin())				DrawString("\p, ");			DrawString(s);		}				objectNum++;	}		//еее	//Write the section depths for each BSpline	/*	InitAnalysisWindow();		GetPortBounds(GetWindowPort(gAnalysisWindow), &r);	EraseRect(&r);		Str255 str;	vector<BSpline*> bsplines = gDrawing->GetBSplines();	for (int i = 0; i < bsplines.size(); i++)	{		vector<int> sectionDepths = *bsplines[i]->GetSectionDepths();		for (int j = 0; j < sectionDepths.size(); j++)		{			NumToString(sectionDepths[j], str);			MoveTo(10 + j * 10, 20 + i * 10);			DrawString(str);		}	}	SetPort(GetWindowPort(gMainWindow->GetWindow()));	*/}void RedrawToolHelpWindow(){	SetPort(GetWindowPort(gToolHelpWindow));		Rect r;	GetPortBounds(GetWindowPort(gToolHelpWindow), &r);	EraseRect(&r);		ForeColor(blackColor);	TextFont(FMGetFontFamilyFromName("\pHelvetica"));	TextSize(9);		TextFace(bold);	MoveTo(5, 10);	switch (gToolsWindow->GetToolType())	{		case ToolsWindow::SUPER_SPLINE:			SizeWindow(gToolHelpWindow, 200, 205, true);			DrawString("\pSuper Spline");			TextFace(0);			MoveTo(5, 20);			DrawString("\pClick open space to make new control points");			MoveTo(15, 30);			DrawString("\pDouble-click to end spline");			MoveTo(5, 40);			DrawString("\pClick-drag control point to move control point");			MoveTo(5, 50);			DrawString("\pCmd-click-drag control point to move spline");			MoveTo(5, 60);			DrawString("\pOption-click control point to delete control point");			MoveTo(5, 70);			DrawString("\pClick boundary to add control point to spline");			MoveTo(5, 80);			DrawString("\pClick curve to reverse sign of occlusion or");			MoveTo(15, 90);			DrawString("\pto end a cut");			MoveTo(5, 100);			DrawString("\pCtrl-click curve to start a cut");			MoveTo(5, 110);			DrawString("\pCmd-option-click control point or boundary");			MoveTo(15, 120);			DrawString("\por curve to delete entire spline");			MoveTo(5, 130);			DrawString("\pCtrl-click control point to");			MoveTo(15, 140);			DrawString("\pincrease degree");			MoveTo(5, 150);			DrawString("\pOption-ctrl-click control point to");			MoveTo(15, 160);			DrawString("\pdecrease degree");			MoveTo(5, 170);			DrawString("\pShift-click curve to change color");			MoveTo(5, 180);			DrawString("\pShift-ctrl click curve to change reflectance");			MoveTo(5, 190);			DrawString("\pClick intersection to flip layer ordering");			MoveTo(5, 200);			DrawString("\pOption-click intersection to constrain");			break;		case ToolsWindow::NEW_SPLINE:			SizeWindow(gToolHelpWindow, 200, 35, true);			DrawString("\pNew Spline");			TextFace(0);			MoveTo(5, 20);			DrawString("\pClick open space to make new spline,");			MoveTo(15, 30);			DrawString("\pDouble-click to end spline");			break;		case ToolsWindow::CHANGE_CONTROL_POINT:			SizeWindow(gToolHelpWindow, 200, 45, true);			DrawString("\pMove Control Point");			TextFace(0);			MoveTo(5, 20);			DrawString("\pClick-drag control point to move control point");			MoveTo(5, 30);			DrawString("\pCmd-click-drag control point to move entire");			MoveTo(15, 40);			DrawString("\pspline");			break;		case ToolsWindow::ADD_CONTROL_POINT:			SizeWindow(gToolHelpWindow, 200, 45, true);			DrawString("\pAdd Control Point");			TextFace(0);			MoveTo(5, 20);			DrawString("\pClick boundary to make new control point");			MoveTo(5, 30);			DrawString("\pClick-drag boundary to make new");			MoveTo(15, 40);			DrawString("\pcontrol point and move");			break;		case ToolsWindow::REMOVE_CONTROL_POINT:			SizeWindow(gToolHelpWindow, 200, 35, true);			DrawString("\pDelete Control Point");			TextFace(0);			MoveTo(5, 20);			DrawString("\pClick control point to delete");			MoveTo(5, 30);			DrawString("\pCmd-click control point to delete entire spline");			break;		case ToolsWindow::CHANGE_DEGREE:			SizeWindow(gToolHelpWindow, 200, 55, true);			DrawString("\pChange Spline Degree");			TextFace(0);			MoveTo(5, 20);			DrawString("\pClick control point, boundary, or curve");			MoveTo(15, 30);			DrawString("\pto increase degree");			MoveTo(5, 40);			DrawString("\pOption-click control point, boundary, or curve");			MoveTo(15, 50);			DrawString("\pto decrease degree");			break;		case ToolsWindow::HAND:			SizeWindow(gToolHelpWindow, 200, 25, true);			DrawString("\pHand");			TextFace(0);			MoveTo(5, 20);			DrawString("\pClick-drag anywhere to move canvas");			break;		case ToolsWindow::TEXT:			SizeWindow(gToolHelpWindow, 200, 25, true);			DrawString("\pText");			TextFace(0);			MoveTo(5, 20);			DrawString("\pCreate the desired text using the dialog box");			break;		case ToolsWindow::SURFACE_SELECT:			SizeWindow(gToolHelpWindow, 200, 85, true);			DrawString("\pSurface Select");			TextFace(0);			MoveTo(5, 20);			DrawString("\pClick control point, boundary, or curve");			MoveTo(15, 30);			DrawString("\pto select surface");			MoveTo(5, 40);			DrawString("\pCtrl-click control point, boundary, or curve");			MoveTo(15, 50);			DrawString("\pto add/remove surface from selection");			MoveTo(5, 60);			DrawString("\pSelection can be dragged or selection's color");			MoveTo(15, 70);			DrawString("\pand border traits can be edited in the");			MoveTo(15, 80);			DrawString("\pSurface Traits window");			break;		case ToolsWindow::INCREASE_SEG_NUM:			SizeWindow(gToolHelpWindow, 200, 15, true);			DrawString("\pIncrease Spline Segmentation");			break;		case ToolsWindow::DECREASE_SEG_NUM:			SizeWindow(gToolHelpWindow, 200, 15, true);			DrawString("\pDecrease Spline Segmentation");			break;	}}void RedrawSurfaceTraitsWindow(){	SetPort(GetWindowPort(gSurfaceTraitsWindow));		Rect r;	GetPortBounds(GetWindowPort(gSurfaceTraitsWindow), &r);	//EraseRect(&r);		BSpline* hilightedObject = gMainWindow->GetHilightedObject();	vector<BSpline*> workingBSplines = gMainWindow->GetWorkingObjects();	vector<WholeObject*> wholeObjects = gDrawing->GetWholeObjects();		if (hilightedObject || (workingBSplines.size() > 0 && wholeObjects.size() > 0))	{		if (hilightedObject)			gSurfaceTraits = hilightedObject->GetSurfaceTraits();		else		{			MyAssert(workingBSplines.size() > 0 && wholeObjects.size() > 0);			WholeObject* wholeObject = NULL;			bool foundIt = false;			for (int i = 0; i < wholeObjects.size(); i++)			{				for (int j = 0; j < wholeObjects[i]->bsplines.size(); j++)				{					if (wholeObjects[i]->bsplines[j] == workingBSplines[0])					{						wholeObject = wholeObjects[i];						foundIt = true;						break;					}				}				if (foundIt)					break;			}			if (!foundIt)				return;			MyAssert(foundIt);						foundIt = false;			for (int j = 0; j < wholeObject->bsplines.size(); j++)				if (wholeObject->bsplines[j]->GetWindingNumber() > 0)				{					gSurfaceTraits = wholeObject->bsplines[j]->GetSurfaceTraits();					foundIt = true;					break;				}			if (!foundIt)			{				for (int j = 0; j < wholeObject->bsplines.size(); j++)					if (wholeObject->bsplines[j]->GetWindingNumber() == 0)					{						gSurfaceTraits = wholeObject->bsplines[j]->GetSurfaceTraits();						foundIt = true;						break;					}			}			if (!foundIt)			{				for (int j = 0; j < wholeObject->bsplines.size(); j++)					if (wholeObject->bsplines[j]->GetWindingNumber() < 0)					{						gSurfaceTraits = wholeObject->bsplines[j]->GetSurfaceTraits();						foundIt = true;						break;					}			}			MyAssert(foundIt);		}				//Paint a rect with the surface's interior color		SetRect(&r, 130, 5, 145, 20);				RGBForeColor(&gSurfaceTraits.interiorColor);		PaintRect(&r);		ForeColor(blackColor);		FrameRect(&r);				//Enable and set the surface's interor reflectance slider		ControlID inID = { 'sftr', 1 };		ControlRef controlRef;		GetControlByID(gSurfaceTraitsWindow, &inID, &controlRef);		ActivateControl(controlRef);		SetControl32BitValue(controlRef, gSurfaceTraits.interiorReflectance * 100.0);				//Paint a rect with the surface's border color		SetRect(&r, 130, 55, 145, 70);				RGBForeColor(&gSurfaceTraits.borderColor);		PaintRect(&r);		ForeColor(blackColor);		FrameRect(&r);				//Enable and set the surface's border reflectance slider		inID.id = 2;		GetControlByID(gSurfaceTraitsWindow, &inID, &controlRef);		//ActivateControl(controlRef);		SetControl32BitValue(controlRef, gSurfaceTraits.borderReflectance * 100.0);				//Enable and set the surface's border thickness		inID.id = 3;		GetControlByID(gSurfaceTraitsWindow, &inID, &controlRef);		ActivateControl(controlRef);		SetControl32BitValue(controlRef, gSurfaceTraits.borderThickness * 10.0);	}	else	{		ControlID inID = { 'sftr', 1 };		ControlRef controlRef;		GetControlByID(gSurfaceTraitsWindow, &inID, &controlRef);		DeactivateControl(controlRef);				inID.id = 2;		GetControlByID(gSurfaceTraitsWindow, &inID, &controlRef);		DeactivateControl(controlRef);				inID.id = 3;		GetControlByID(gSurfaceTraitsWindow, &inID, &controlRef);		DeactivateControl(controlRef);	}		DrawControls(gSurfaceTraitsWindow);}